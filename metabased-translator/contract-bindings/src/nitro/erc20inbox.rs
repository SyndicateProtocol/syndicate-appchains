/**

Generated by the following Solidity interface...
```solidity
interface ERC20Inbox {
    error AmountTooLarge(uint256 amount);
    error DataTooLarge(uint256 dataLength, uint256 maxDataLength);
    error GasLimitTooLarge();
    error InsufficientSubmissionCost(uint256 expected, uint256 actual);
    error InsufficientValue(uint256 expected, uint256 actual);
    error L1Forked();
    error NotAllowedOrigin(address origin);
    error NotCodelessOrigin();
    error NotRollupOrOwner(address sender, address rollup, address owner);
    error RetryableData(address from, address to, uint256 l2CallValue, uint256 deposit, uint256 maxSubmissionCost, address excessFeeRefundAddress, address callValueRefundAddress, uint256 gasLimit, uint256 maxFeePerGas, bytes data);

    event AllowListAddressSet(address indexed user, bool val);
    event AllowListEnabledUpdated(bool isEnabled);
    event InboxMessageDelivered(uint256 indexed messageNum, bytes data);
    event InboxMessageDeliveredFromOrigin(uint256 indexed messageNum);
    event Initialized(uint8 version);
    event Paused(address account);
    event Unpaused(address account);

    constructor(uint256 _maxDataSize);

    function allowListEnabled() external view returns (bool);
    function bridge() external view returns (address);
    function calculateRetryableSubmissionFee(uint256, uint256) external pure returns (uint256);
    function createRetryableTicket(address to, uint256 l2CallValue, uint256 maxSubmissionCost, address excessFeeRefundAddress, address callValueRefundAddress, uint256 gasLimit, uint256 maxFeePerGas, uint256 tokenTotalFeeAmount, bytes memory data) external returns (uint256);
    function depositERC20(uint256 amount) external returns (uint256);
    function getProxyAdmin() external view returns (address);
    function initialize(address _bridge, address _sequencerInbox) external;
    function isAllowed(address) external view returns (bool);
    function maxDataSize() external view returns (uint256);
    function pause() external;
    function paused() external view returns (bool);
    function sendContractTransaction(uint256 gasLimit, uint256 maxFeePerGas, address to, uint256 value, bytes memory data) external returns (uint256);
    function sendL2Message(bytes memory messageData) external returns (uint256);
    function sendL2MessageFromOrigin(bytes memory messageData) external returns (uint256);
    function sendUnsignedTransaction(uint256 gasLimit, uint256 maxFeePerGas, uint256 nonce, address to, uint256 value, bytes memory data) external returns (uint256);
    function sequencerInbox() external view returns (address);
    function setAllowList(address[] memory user, bool[] memory val) external;
    function setAllowListEnabled(bool _allowListEnabled) external;
    function unpause() external;
    function unsafeCreateRetryableTicket(address to, uint256 l2CallValue, uint256 maxSubmissionCost, address excessFeeRefundAddress, address callValueRefundAddress, uint256 gasLimit, uint256 maxFeePerGas, uint256 tokenTotalFeeAmount, bytes memory data) external returns (uint256);
}
```

...which was generated by the following JSON ABI:
```json
[
  {
    "type": "constructor",
    "inputs": [
      {
        "name": "_maxDataSize",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "allowListEnabled",
    "inputs": [],
    "outputs": [
      {
        "name": "",
        "type": "bool",
        "internalType": "bool"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "bridge",
    "inputs": [],
    "outputs": [
      {
        "name": "",
        "type": "address",
        "internalType": "contract IBridge"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "calculateRetryableSubmissionFee",
    "inputs": [
      {
        "name": "",
        "type": "uint256",
        "internalType": "uint256"
      },
      {
        "name": "",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "stateMutability": "pure"
  },
  {
    "type": "function",
    "name": "createRetryableTicket",
    "inputs": [
      {
        "name": "to",
        "type": "address",
        "internalType": "address"
      },
      {
        "name": "l2CallValue",
        "type": "uint256",
        "internalType": "uint256"
      },
      {
        "name": "maxSubmissionCost",
        "type": "uint256",
        "internalType": "uint256"
      },
      {
        "name": "excessFeeRefundAddress",
        "type": "address",
        "internalType": "address"
      },
      {
        "name": "callValueRefundAddress",
        "type": "address",
        "internalType": "address"
      },
      {
        "name": "gasLimit",
        "type": "uint256",
        "internalType": "uint256"
      },
      {
        "name": "maxFeePerGas",
        "type": "uint256",
        "internalType": "uint256"
      },
      {
        "name": "tokenTotalFeeAmount",
        "type": "uint256",
        "internalType": "uint256"
      },
      {
        "name": "data",
        "type": "bytes",
        "internalType": "bytes"
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "depositERC20",
    "inputs": [
      {
        "name": "amount",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "getProxyAdmin",
    "inputs": [],
    "outputs": [
      {
        "name": "",
        "type": "address",
        "internalType": "address"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "initialize",
    "inputs": [
      {
        "name": "_bridge",
        "type": "address",
        "internalType": "contract IBridge"
      },
      {
        "name": "_sequencerInbox",
        "type": "address",
        "internalType": "contract ISequencerInbox"
      }
    ],
    "outputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "isAllowed",
    "inputs": [
      {
        "name": "",
        "type": "address",
        "internalType": "address"
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "bool",
        "internalType": "bool"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "maxDataSize",
    "inputs": [],
    "outputs": [
      {
        "name": "",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "pause",
    "inputs": [],
    "outputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "paused",
    "inputs": [],
    "outputs": [
      {
        "name": "",
        "type": "bool",
        "internalType": "bool"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "sendContractTransaction",
    "inputs": [
      {
        "name": "gasLimit",
        "type": "uint256",
        "internalType": "uint256"
      },
      {
        "name": "maxFeePerGas",
        "type": "uint256",
        "internalType": "uint256"
      },
      {
        "name": "to",
        "type": "address",
        "internalType": "address"
      },
      {
        "name": "value",
        "type": "uint256",
        "internalType": "uint256"
      },
      {
        "name": "data",
        "type": "bytes",
        "internalType": "bytes"
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "sendL2Message",
    "inputs": [
      {
        "name": "messageData",
        "type": "bytes",
        "internalType": "bytes"
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "sendL2MessageFromOrigin",
    "inputs": [
      {
        "name": "messageData",
        "type": "bytes",
        "internalType": "bytes"
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "sendUnsignedTransaction",
    "inputs": [
      {
        "name": "gasLimit",
        "type": "uint256",
        "internalType": "uint256"
      },
      {
        "name": "maxFeePerGas",
        "type": "uint256",
        "internalType": "uint256"
      },
      {
        "name": "nonce",
        "type": "uint256",
        "internalType": "uint256"
      },
      {
        "name": "to",
        "type": "address",
        "internalType": "address"
      },
      {
        "name": "value",
        "type": "uint256",
        "internalType": "uint256"
      },
      {
        "name": "data",
        "type": "bytes",
        "internalType": "bytes"
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "sequencerInbox",
    "inputs": [],
    "outputs": [
      {
        "name": "",
        "type": "address",
        "internalType": "contract ISequencerInbox"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "setAllowList",
    "inputs": [
      {
        "name": "user",
        "type": "address[]",
        "internalType": "address[]"
      },
      {
        "name": "val",
        "type": "bool[]",
        "internalType": "bool[]"
      }
    ],
    "outputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "setAllowListEnabled",
    "inputs": [
      {
        "name": "_allowListEnabled",
        "type": "bool",
        "internalType": "bool"
      }
    ],
    "outputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "unpause",
    "inputs": [],
    "outputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "unsafeCreateRetryableTicket",
    "inputs": [
      {
        "name": "to",
        "type": "address",
        "internalType": "address"
      },
      {
        "name": "l2CallValue",
        "type": "uint256",
        "internalType": "uint256"
      },
      {
        "name": "maxSubmissionCost",
        "type": "uint256",
        "internalType": "uint256"
      },
      {
        "name": "excessFeeRefundAddress",
        "type": "address",
        "internalType": "address"
      },
      {
        "name": "callValueRefundAddress",
        "type": "address",
        "internalType": "address"
      },
      {
        "name": "gasLimit",
        "type": "uint256",
        "internalType": "uint256"
      },
      {
        "name": "maxFeePerGas",
        "type": "uint256",
        "internalType": "uint256"
      },
      {
        "name": "tokenTotalFeeAmount",
        "type": "uint256",
        "internalType": "uint256"
      },
      {
        "name": "data",
        "type": "bytes",
        "internalType": "bytes"
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "stateMutability": "nonpayable"
  },
  {
    "type": "event",
    "name": "AllowListAddressSet",
    "inputs": [
      {
        "name": "user",
        "type": "address",
        "indexed": true,
        "internalType": "address"
      },
      {
        "name": "val",
        "type": "bool",
        "indexed": false,
        "internalType": "bool"
      }
    ],
    "anonymous": false
  },
  {
    "type": "event",
    "name": "AllowListEnabledUpdated",
    "inputs": [
      {
        "name": "isEnabled",
        "type": "bool",
        "indexed": false,
        "internalType": "bool"
      }
    ],
    "anonymous": false
  },
  {
    "type": "event",
    "name": "InboxMessageDelivered",
    "inputs": [
      {
        "name": "messageNum",
        "type": "uint256",
        "indexed": true,
        "internalType": "uint256"
      },
      {
        "name": "data",
        "type": "bytes",
        "indexed": false,
        "internalType": "bytes"
      }
    ],
    "anonymous": false
  },
  {
    "type": "event",
    "name": "InboxMessageDeliveredFromOrigin",
    "inputs": [
      {
        "name": "messageNum",
        "type": "uint256",
        "indexed": true,
        "internalType": "uint256"
      }
    ],
    "anonymous": false
  },
  {
    "type": "event",
    "name": "Initialized",
    "inputs": [
      {
        "name": "version",
        "type": "uint8",
        "indexed": false,
        "internalType": "uint8"
      }
    ],
    "anonymous": false
  },
  {
    "type": "event",
    "name": "Paused",
    "inputs": [
      {
        "name": "account",
        "type": "address",
        "indexed": false,
        "internalType": "address"
      }
    ],
    "anonymous": false
  },
  {
    "type": "event",
    "name": "Unpaused",
    "inputs": [
      {
        "name": "account",
        "type": "address",
        "indexed": false,
        "internalType": "address"
      }
    ],
    "anonymous": false
  },
  {
    "type": "error",
    "name": "AmountTooLarge",
    "inputs": [
      {
        "name": "amount",
        "type": "uint256",
        "internalType": "uint256"
      }
    ]
  },
  {
    "type": "error",
    "name": "DataTooLarge",
    "inputs": [
      {
        "name": "dataLength",
        "type": "uint256",
        "internalType": "uint256"
      },
      {
        "name": "maxDataLength",
        "type": "uint256",
        "internalType": "uint256"
      }
    ]
  },
  {
    "type": "error",
    "name": "GasLimitTooLarge",
    "inputs": []
  },
  {
    "type": "error",
    "name": "InsufficientSubmissionCost",
    "inputs": [
      {
        "name": "expected",
        "type": "uint256",
        "internalType": "uint256"
      },
      {
        "name": "actual",
        "type": "uint256",
        "internalType": "uint256"
      }
    ]
  },
  {
    "type": "error",
    "name": "InsufficientValue",
    "inputs": [
      {
        "name": "expected",
        "type": "uint256",
        "internalType": "uint256"
      },
      {
        "name": "actual",
        "type": "uint256",
        "internalType": "uint256"
      }
    ]
  },
  {
    "type": "error",
    "name": "L1Forked",
    "inputs": []
  },
  {
    "type": "error",
    "name": "NotAllowedOrigin",
    "inputs": [
      {
        "name": "origin",
        "type": "address",
        "internalType": "address"
      }
    ]
  },
  {
    "type": "error",
    "name": "NotCodelessOrigin",
    "inputs": []
  },
  {
    "type": "error",
    "name": "NotRollupOrOwner",
    "inputs": [
      {
        "name": "sender",
        "type": "address",
        "internalType": "address"
      },
      {
        "name": "rollup",
        "type": "address",
        "internalType": "address"
      },
      {
        "name": "owner",
        "type": "address",
        "internalType": "address"
      }
    ]
  },
  {
    "type": "error",
    "name": "RetryableData",
    "inputs": [
      {
        "name": "from",
        "type": "address",
        "internalType": "address"
      },
      {
        "name": "to",
        "type": "address",
        "internalType": "address"
      },
      {
        "name": "l2CallValue",
        "type": "uint256",
        "internalType": "uint256"
      },
      {
        "name": "deposit",
        "type": "uint256",
        "internalType": "uint256"
      },
      {
        "name": "maxSubmissionCost",
        "type": "uint256",
        "internalType": "uint256"
      },
      {
        "name": "excessFeeRefundAddress",
        "type": "address",
        "internalType": "address"
      },
      {
        "name": "callValueRefundAddress",
        "type": "address",
        "internalType": "address"
      },
      {
        "name": "gasLimit",
        "type": "uint256",
        "internalType": "uint256"
      },
      {
        "name": "maxFeePerGas",
        "type": "uint256",
        "internalType": "uint256"
      },
      {
        "name": "data",
        "type": "bytes",
        "internalType": "bytes"
      }
    ]
  }
]
```*/
#[allow(
    non_camel_case_types,
    non_snake_case,
    clippy::pub_underscore_fields,
    clippy::style,
    clippy::empty_structs_with_brackets
)]
pub mod ERC20Inbox {
    use super::*;
    use alloy::sol_types as alloy_sol_types;
    /// The creation / init bytecode of the contract.
    ///
    /// ```text
    ///0x60e0604052306080524660c052348015610017575f5ffd5b506040516128d93803806128d98339810160408190526100369161003e565b60a052610055565b5f6020828403121561004e575f5ffd5b5051919050565b60805160a05160c0516128376100a25f395f818161039a0152610c0701525f81816102f901528181610430015281816104850152818161179c01526117f501525f61070f01526128375ff3fe608060405234801561000f575f5ffd5b5060043610610163575f3560e01c8063a66b327d116100c7578063e3de72a51161007d578063e8eb1dc311610063578063e8eb1dc3146102f4578063ee35f3271461031b578063efeadb6d1461032e575f5ffd5b8063e3de72a5146102ce578063e78cea92146102e1575f5ffd5b8063b79092fd116100ad578063b79092fd14610286578063b9b9a68814610299578063babcc539146102ac575f5ffd5b8063a66b327d1461025e578063b75436bb14610273575f5ffd5b8063549e84261161011c5780638456cb59116101025780638456cb59146101ff5780638a631aa6146102075780638b3240a01461021a575f5ffd5b8063549e8426146101e15780635c975abb146101f4575f5ffd5b80633f4ba83a1161014c5780633f4ba83a146101b1578063485cc955146101bb5780635075788b146101ce575f5ffd5b80631fe927cf1461016757806322bd5c1c1461018d575b5f5ffd5b61017a610175366004611fc9565b610341565b6040519081526020015b60405180910390f35b6066546101a190600160a01b900460ff1681565b6040519015158152602001610184565b6101b961050c565b005b6101b96101c936600461201c565b61063b565b61017a6101dc366004612053565b61089a565b61017a6101ef3660046120ca565b610963565b60335460ff166101a1565b6101b96109d5565b61017a610215366004612173565b610b01565b7fb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103546001600160a01b03165b6040516001600160a01b039091168152602001610184565b61017a61026c3660046121e1565b5f92915050565b61017a610281366004611fc9565b610bb3565b61017a610294366004612201565b610ca5565b61017a6102a73660046120ca565b610d90565b6101a16102ba366004612218565b60676020525f908152604090205460ff1681565b6101b96102dc36600461231b565b610df3565b606554610246906001600160a01b031681565b61017a7f000000000000000000000000000000000000000000000000000000000000000081565b606654610246906001600160a01b031681565b6101b961033c3660046123e0565b611064565b5f61034a61125b565b606654600160a01b900460ff1680156103725750325f9081526067602052604090205460ff16155b1561039757604051630f51ed7160e41b81523260048201526024015b60405180910390fd5b467f0000000000000000000000000000000000000000000000000000000000000000146103f0576040517fc6ea680300000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b6103f86112b0565b61042e576040517fc8958ead00000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b7f00000000000000000000000000000000000000000000000000000000000000008211156104b1576040517f4634691b000000000000000000000000000000000000000000000000000000008152600481018390527f0000000000000000000000000000000000000000000000000000000000000000602482015260440161038e565b5f6104d660033386866040516104c89291906123fb565b60405180910390205f6112c4565b60405190915081907fab532385be8f1005a4b6ba8fa20a2245facb346134ac739fe9a5198dc1580b9c905f90a290505b92915050565b6065546040805163cb23bcb560e01b815290515f926001600160a01b03169163cb23bcb59160048083019260209291908290030181865afa158015610553573d5f5f3e3d5ffd5b505050506040513d601f19601f82011682018060405250810190610577919061240a565b9050336001600160a01b03821614610630575f816001600160a01b0316638da5cb5b6040518163ffffffff1660e01b8152600401602060405180830381865afa1580156105c6573d5f5f3e3d5ffd5b505050506040513d601f19601f820116820180604052508101906105ea919061240a565b9050336001600160a01b0382161461062e57604051630739600760e01b81523360048201526001600160a01b0380841660248301528216604482015260640161038e565b505b6106386114aa565b50565b5f54610100900460ff161580801561065957505f54600160ff909116105b806106725750303b15801561067257505f5460ff166001145b6106e45760405162461bcd60e51b815260206004820152602e60248201527f496e697469616c697a61626c653a20636f6e747261637420697320616c72656160448201527f647920696e697469616c697a6564000000000000000000000000000000000000606482015260840161038e565b5f805460ff191660011790558015610705575f805461ff0019166101001790555b6001600160a01b037f00000000000000000000000000000000000000000000000000000000000000001630036107a35760405162461bcd60e51b815260206004820152602c60248201527f46756e6374696f6e206d7573742062652063616c6c6564207468726f7567682060448201527f64656c656761746563616c6c0000000000000000000000000000000000000000606482015260840161038e565b6107ad83836114fc565b606554604080517fe1758bd800000000000000000000000000000000000000000000000000000000815290515f926001600160a01b03169163e1758bd89160048083019260209291908290030181865afa15801561080d573d5f5f3e3d5ffd5b505050506040513d601f19601f82011682018060405250810190610831919061240a565b60655490915061084f906001600160a01b0380841691165f196115ed565b508015610895575f805461ff0019169055604051600181527f7f26b83ff96e1f2b6a682f133852f6798a09c465da95921460cefb38474024989060200160405180910390a15b505050565b5f6108a361125b565b606654600160a01b900460ff1680156108cb5750325f9081526067602052604090205460ff16155b156108eb57604051630f51ed7160e41b815232600482015260240161038e565b67ffffffffffffffff8811156109145760405163107c527b60e01b815260040160405180910390fd5b6109576003335f8b8b8b8b6001600160a01b03168b8b8b604051602001610942989796959493929190612425565b6040516020818303038152906040525f611799565b98975050505050505050565b5f61096c61125b565b606654600160a01b900460ff1680156109945750325f9081526067602052604090205460ff16155b156109b457604051630f51ed7160e41b815232600482015260240161038e565b6109c68b8b8b8b8b8b8b8b8b8b611878565b9b9a5050505050505050505050565b6065546040805163cb23bcb560e01b815290515f926001600160a01b03169163cb23bcb59160048083019260209291908290030181865afa158015610a1c573d5f5f3e3d5ffd5b505050506040513d601f19601f82011682018060405250810190610a40919061240a565b9050336001600160a01b03821614610af9575f816001600160a01b0316638da5cb5b6040518163ffffffff1660e01b8152600401602060405180830381865afa158015610a8f573d5f5f3e3d5ffd5b505050506040513d601f19601f82011682018060405250810190610ab3919061240a565b9050336001600160a01b03821614610af757604051630739600760e01b81523360048201526001600160a01b0380841660248301528216604482015260640161038e565b505b61063861197b565b5f610b0a61125b565b606654600160a01b900460ff168015610b325750325f9081526067602052604090205460ff16155b15610b5257604051630f51ed7160e41b815232600482015260240161038e565b67ffffffffffffffff871115610b7b5760405163107c527b60e01b815260040160405180910390fd5b610ba860033360018a8a8a6001600160a01b03168a8a8a6040516020016109429796959493929190612486565b979650505050505050565b5f610bbc61125b565b606654600160a01b900460ff168015610be45750325f9081526067602052604090205460ff16155b15610c0457604051630f51ed7160e41b815232600482015260240161038e565b467f000000000000000000000000000000000000000000000000000000000000000014610c5d576040517fc6ea680300000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b610c9e60033385858080601f0160208091040260200160405190810160405280939291908181526020018383808284375f9201829052509250611799915050565b9392505050565b5f610cae61125b565b606654600160a01b900460ff168015610cd65750325f9081526067602052604090205460ff16155b15610cf657604051630f51ed7160e41b815232600482015260240161038e565b33803b151580610d065750323314155b15610d24575033731111000000000000000000000000000000001111015b5f610d2e846119b8565b6040517fffffffffffffffffffffffffffffffffffffffff000000000000000000000000606085901b16602082015260348101829052909150610d8890600c90339060540160405160208183030381529060405287611799565b949350505050565b5f610d9961125b565b606654600160a01b900460ff168015610dc15750325f9081526067602052604090205460ff16155b15610de157604051630f51ed7160e41b815232600482015260240161038e565b6109c68b8b8b8b8b8b8b8b8b8b611a9d565b6065546040805163cb23bcb560e01b815290515f926001600160a01b03169163cb23bcb59160048083019260209291908290030181865afa158015610e3a573d5f5f3e3d5ffd5b505050506040513d601f19601f82011682018060405250810190610e5e919061240a565b9050336001600160a01b03821614610f17575f816001600160a01b0316638da5cb5b6040518163ffffffff1660e01b8152600401602060405180830381865afa158015610ead573d5f5f3e3d5ffd5b505050506040513d601f19601f82011682018060405250810190610ed1919061240a565b9050336001600160a01b03821614610f1557604051630739600760e01b81523360048201526001600160a01b0380841660248301528216604482015260640161038e565b505b8151835114610f685760405162461bcd60e51b815260206004820152600d60248201527f494e56414c49445f494e50555400000000000000000000000000000000000000604482015260640161038e565b5f5b835181101561105e57828181518110610f8557610f856124e0565b602002602001015160675f868481518110610fa257610fa26124e0565b60200260200101516001600160a01b03166001600160a01b031681526020019081526020015f205f6101000a81548160ff021916908315150217905550838181518110610ff157610ff16124e0565b60200260200101516001600160a01b03167fd9739f45a01ce092c5cdb3d68f63d63d21676b1c6c0b4f9cbc6be4cf5449595a848381518110611035576110356124e0565b602002602001015160405161104e911515815260200190565b60405180910390a2600101610f6a565b50505050565b6065546040805163cb23bcb560e01b815290515f926001600160a01b03169163cb23bcb59160048083019260209291908290030181865afa1580156110ab573d5f5f3e3d5ffd5b505050506040513d601f19601f820116820180604052508101906110cf919061240a565b9050336001600160a01b03821614611188575f816001600160a01b0316638da5cb5b6040518163ffffffff1660e01b8152600401602060405180830381865afa15801561111e573d5f5f3e3d5ffd5b505050506040513d601f19601f82011682018060405250810190611142919061240a565b9050336001600160a01b0382161461118657604051630739600760e01b81523360048201526001600160a01b0380841660248301528216604482015260640161038e565b505b606654600160a01b900460ff161515821515036111e75760405162461bcd60e51b815260206004820152600b60248201527f414c52454144595f534554000000000000000000000000000000000000000000604482015260640161038e565b60668054831515600160a01b027fffffffffffffffffffffff00ffffffffffffffffffffffffffffffffffffffff9091161790556040517f16435b45f7482047f839a6a19d291442627200f52cad2803c595150d0d440eb39061124f90841515815260200190565b60405180910390a15050565b60335460ff16156112ae5760405162461bcd60e51b815260206004820152601060248201527f5061757361626c653a2070617573656400000000000000000000000000000000604482015260640161038e565b565b5f33321480156112bf5750333b155b905090565b5f5f60655f9054906101000a90046001600160a01b03166001600160a01b031663e1758bd86040518163ffffffff1660e01b8152600401602060405180830381865afa158015611316573d5f5f3e3d5ffd5b505050506040513d601f19601f8201168201806040525081019061133a919061240a565b6040517f70a082310000000000000000000000000000000000000000000000000000000081523060048201529091505f906001600160a01b038316906370a0823190602401602060405180830381865afa15801561139a573d5f5f3e3d5ffd5b505050506040513d601f19601f820116820180604052508101906113be91906124f4565b9050838110156113ec575f6113d3828661251f565b90506113ea6001600160a01b038416333084611b8a565b505b6065546001600160a01b03166375d81e258873111100000000000000000000000000000000111189016040517fffffffff0000000000000000000000000000000000000000000000000000000060e085901b16815260ff90921660048301526001600160a01b0316602482015260448101889052606481018790526084016020604051808303815f875af1158015611486573d5f5f3e3d5ffd5b505050506040513d601f19601f82011682018060405250810190610ba891906124f4565b6114b2611bdb565b6033805460ff191690557f5db9ee0a495bf2e6ff9c91a7834c1ba4fdd244a5e8aa4e537bd38aeae4b073aa335b6040516001600160a01b03909116815260200160405180910390a1565b5f54610100900460ff166115785760405162461bcd60e51b815260206004820152602b60248201527f496e697469616c697a61626c653a20636f6e7472616374206973206e6f74206960448201527f6e697469616c697a696e67000000000000000000000000000000000000000000606482015260840161038e565b606580546001600160a01b038085167fffffffffffffffffffffffff000000000000000000000000000000000000000090921691909117909155606680547fffffffffffffffffffffff000000000000000000000000000000000000000000169183169190911790556115e9611c2d565b5050565b80158061167e57506040517fdd62ed3e0000000000000000000000000000000000000000000000000000000081523060048201526001600160a01b03838116602483015284169063dd62ed3e90604401602060405180830381865afa158015611658573d5f5f3e3d5ffd5b505050506040513d601f19601f8201168201806040525081019061167c91906124f4565b155b6116f05760405162461bcd60e51b815260206004820152603660248201527f5361666545524332303a20617070726f76652066726f6d206e6f6e2d7a65726f60448201527f20746f206e6f6e2d7a65726f20616c6c6f77616e636500000000000000000000606482015260840161038e565b6040516001600160a01b0383166024820152604481018290526108959084907f095ea7b300000000000000000000000000000000000000000000000000000000906064015b60408051601f198184030181529190526020810180517bffffffffffffffffffffffffffffffffffffffffffffffffffffffff167fffffffff0000000000000000000000000000000000000000000000000000000090931692909217909152611cb1565b5f7f0000000000000000000000000000000000000000000000000000000000000000835111156118215782516040517f4634691b00000000000000000000000000000000000000000000000000000000815260048101919091527f0000000000000000000000000000000000000000000000000000000000000000602482015260440161038e565b5f61183586868680519060200120866112c4565b9050807fff64905f73a67fb594e0f940a8075a860db489ad991e032f48c81123eb52d60b856040516118679190612560565b60405180910390a295945050505050565b5f5f611883856119b8565b905061188f8688612572565b6118998c8c612589565b6118a39190612589565b811015611905576118b48688612572565b6118be8c8c612589565b6118c89190612589565b6040517f7040b58c00000000000000000000000000000000000000000000000000000000815260048101919091526024810182905260440161038e565b6001600160a01b0389163b1561192f57731111000000000000000000000000000000001111890198505b6001600160a01b0388163b1561195957731111000000000000000000000000000000001111880197505b61196b8c8c8c8c8c8c8c8c8c8c611a9d565b9c9b505050505050505050505050565b61198361125b565b6033805460ff191660011790557f62e78cea01bee320cd4e420270b5ea74000d11b0c9f74754ebdbfc544b05a2586114df3390565b5f5f60655f9054906101000a90046001600160a01b03166001600160a01b031663ad48cb5e6040518163ffffffff1660e01b8152600401602060405180830381865afa158015611a0a573d5f5f3e3d5ffd5b505050506040513d601f19601f82011682018060405250810190611a2e919061259c565b905060128160ff161015611a915777ffffffffffffffffffffffffffffffffffffffffffffffff831115611a91576040517f08083b2a0000000000000000000000000000000000000000000000000000000081526004810184905260240161038e565b610c9e83826012611d95565b5f8560011480611aad5750846001145b15611afa57338b8b868c8c8c8c8c8b8b6040517f07c266e300000000000000000000000000000000000000000000000000000000815260040161038e9b9a999897969594939291906125bc565b67ffffffffffffffff861115611b235760405163107c527b60e01b815260040160405180910390fd5b5f61196b6009338e6001600160a01b03168e611b3e8a6119b8565b8f8f6001600160a01b03168f6001600160a01b03168f8f8e8e90508f8f604051602001611b759b9a99989796959493929190612653565b60405160208183030381529060405288611799565b6040516001600160a01b038085166024830152831660448201526064810182905261105e9085907f23b872dd0000000000000000000000000000000000000000000000000000000090608401611735565b60335460ff166112ae5760405162461bcd60e51b815260206004820152601460248201527f5061757361626c653a206e6f7420706175736564000000000000000000000000604482015260640161038e565b5f54610100900460ff16611ca95760405162461bcd60e51b815260206004820152602b60248201527f496e697469616c697a61626c653a20636f6e7472616374206973206e6f74206960448201527f6e697469616c697a696e67000000000000000000000000000000000000000000606482015260840161038e565b6112ae611dfd565b5f611d05826040518060400160405280602081526020017f5361666545524332303a206c6f772d6c6576656c2063616c6c206661696c6564815250856001600160a01b0316611e859092919063ffffffff16565b8051909150156108955780806020019051810190611d2391906126a7565b6108955760405162461bcd60e51b815260206004820152602a60248201527f5361666545524332303a204552433230206f7065726174696f6e20646964206e60448201527f6f74207375636365656400000000000000000000000000000000000000000000606482015260840161038e565b5f8160ff168360ff1603611daa575082610c9e565b8160ff168360ff161015611dde57611dc283836126c2565b611dcd90600a6127be565b611dd79085612572565b9050610c9e565b611de882846126c2565b611df390600a6127be565b611dd790856127cc565b5f54610100900460ff16611e795760405162461bcd60e51b815260206004820152602b60248201527f496e697469616c697a61626c653a20636f6e7472616374206973206e6f74206960448201527f6e697469616c697a696e67000000000000000000000000000000000000000000606482015260840161038e565b6033805460ff19169055565b6060610d8884845f85856001600160a01b0385163b611ee65760405162461bcd60e51b815260206004820152601d60248201527f416464726573733a2063616c6c20746f206e6f6e2d636f6e7472616374000000604482015260640161038e565b5f5f866001600160a01b03168587604051611f0191906127eb565b5f6040518083038185875af1925050503d805f8114611f3b576040519150601f19603f3d011682016040523d82523d5f602084013e611f40565b606091505b5091509150610ba882828660608315611f5a575081610c9e565b825115611f6a5782518084602001fd5b8160405162461bcd60e51b815260040161038e9190612560565b5f5f83601f840112611f94575f5ffd5b50813567ffffffffffffffff811115611fab575f5ffd5b602083019150836020828501011115611fc2575f5ffd5b9250929050565b5f5f60208385031215611fda575f5ffd5b823567ffffffffffffffff811115611ff0575f5ffd5b611ffc85828601611f84565b90969095509350505050565b6001600160a01b0381168114610638575f5ffd5b5f5f6040838503121561202d575f5ffd5b823561203881612008565b9150602083013561204881612008565b809150509250929050565b5f5f5f5f5f5f5f60c0888a031215612069575f5ffd5b873596506020880135955060408801359450606088013561208981612008565b93506080880135925060a088013567ffffffffffffffff8111156120ab575f5ffd5b6120b78a828b01611f84565b989b979a50959850939692959293505050565b5f5f5f5f5f5f5f5f5f5f6101208b8d0312156120e4575f5ffd5b8a356120ef81612008565b995060208b0135985060408b0135975060608b013561210d81612008565b965060808b013561211d81612008565b955060a08b0135945060c08b0135935060e08b013592506101008b013567ffffffffffffffff81111561214e575f5ffd5b61215a8d828e01611f84565b915080935050809150509295989b9194979a5092959850565b5f5f5f5f5f5f60a08789031215612188575f5ffd5b863595506020870135945060408701356121a181612008565b935060608701359250608087013567ffffffffffffffff8111156121c3575f5ffd5b6121cf89828a01611f84565b979a9699509497509295939492505050565b5f5f604083850312156121f2575f5ffd5b50508035926020909101359150565b5f60208284031215612211575f5ffd5b5035919050565b5f60208284031215612228575f5ffd5b8135610c9e81612008565b634e487b7160e01b5f52604160045260245ffd5b604051601f8201601f1916810167ffffffffffffffff8111828210171561227057612270612233565b604052919050565b5f67ffffffffffffffff82111561229157612291612233565b5060051b60200190565b8015158114610638575f5ffd5b5f82601f8301126122b7575f5ffd5b81356122ca6122c582612278565b612247565b8082825260208201915060208360051b8601019250858311156122eb575f5ffd5b602085015b838110156123115780356123038161229b565b8352602092830192016122f0565b5095945050505050565b5f5f6040838503121561232c575f5ffd5b823567ffffffffffffffff811115612342575f5ffd5b8301601f81018513612352575f5ffd5b80356123606122c582612278565b8082825260208201915060208360051b850101925087831115612381575f5ffd5b6020840193505b828410156123ac57833561239b81612008565b825260209384019390910190612388565b9450505050602083013567ffffffffffffffff8111156123ca575f5ffd5b6123d6858286016122a8565b9150509250929050565b5f602082840312156123f0575f5ffd5b8135610c9e8161229b565b818382375f9101908152919050565b5f6020828403121561241a575f5ffd5b8151610c9e81612008565b7fff000000000000000000000000000000000000000000000000000000000000008960f81b168152876001820152866021820152856041820152846061820152836081820152818360a18301375f910160a101908152979650505050505050565b7fff000000000000000000000000000000000000000000000000000000000000008860f81b168152866001820152856021820152846041820152836061820152818360818301375f91016081019081529695505050505050565b634e487b7160e01b5f52603260045260245ffd5b5f60208284031215612504575f5ffd5b5051919050565b634e487b7160e01b5f52601160045260245ffd5b818103818111156105065761050661250b565b5f81518084528060208401602086015e5f602082860101526020601f19601f83011685010191505092915050565b602081525f610c9e6020830184612532565b80820281158282048414176105065761050661250b565b808201808211156105065761050661250b565b5f602082840312156125ac575f5ffd5b815160ff81168114610c9e575f5ffd5b6001600160a01b038c1681526001600160a01b038b1660208201528960408201528860608201528760808201526001600160a01b03871660a08201526001600160a01b03861660c08201528460e0820152836101008201526101406101208201528161014082015281836101608301375f81830161016090810191909152601f909201601f191601019a9950505050505050505050565b8b81528a60208201528960408201528860608201528760808201528660a08201528560c08201528460e08201528361010082015281836101208301375f9101610120019081529a9950505050505050505050565b5f602082840312156126b7575f5ffd5b8151610c9e8161229b565b60ff82811682821603908111156105065761050661250b565b6001815b6001841115612716578085048111156126fa576126fa61250b565b600184161561270857908102905b60019390931c9280026126df565b935093915050565b5f8261272c57506001610506565b8161273857505f610506565b816001811461274e576002811461275857612774565b6001915050610506565b60ff8411156127695761276961250b565b50506001821b610506565b5060208310610133831016604e8410600b8410161715612797575081810a610506565b6127a35f1984846126db565b805f19048211156127b6576127b661250b565b029392505050565b5f610c9e60ff84168361271e565b5f826127e657634e487b7160e01b5f52601260045260245ffd5b500490565b5f82518060208501845e5f92019182525091905056fea2646970667358221220265f869376b6c520445ee90b23fc3e870282a128759593a36018a4b154b4b55264736f6c634300081c0033
    /// ```
    #[rustfmt::skip]
    #[allow(clippy::all)]
    pub static BYTECODE: alloy_sol_types::private::Bytes = alloy_sol_types::private::Bytes::from_static(
        b"`\xE0`@R0`\x80RF`\xC0R4\x80\x15a\0\x17W__\xFD[P`@Qa(\xD98\x03\x80a(\xD9\x839\x81\x01`@\x81\x90Ra\x006\x91a\0>V[`\xA0Ra\0UV[_` \x82\x84\x03\x12\x15a\0NW__\xFD[PQ\x91\x90PV[`\x80Q`\xA0Q`\xC0Qa(7a\0\xA2_9_\x81\x81a\x03\x9A\x01Ra\x0C\x07\x01R_\x81\x81a\x02\xF9\x01R\x81\x81a\x040\x01R\x81\x81a\x04\x85\x01R\x81\x81a\x17\x9C\x01Ra\x17\xF5\x01R_a\x07\x0F\x01Ra(7_\xF3\xFE`\x80`@R4\x80\x15a\0\x0FW__\xFD[P`\x046\x10a\x01cW_5`\xE0\x1C\x80c\xA6k2}\x11a\0\xC7W\x80c\xE3\xDEr\xA5\x11a\0}W\x80c\xE8\xEB\x1D\xC3\x11a\0cW\x80c\xE8\xEB\x1D\xC3\x14a\x02\xF4W\x80c\xEE5\xF3'\x14a\x03\x1BW\x80c\xEF\xEA\xDBm\x14a\x03.W__\xFD[\x80c\xE3\xDEr\xA5\x14a\x02\xCEW\x80c\xE7\x8C\xEA\x92\x14a\x02\xE1W__\xFD[\x80c\xB7\x90\x92\xFD\x11a\0\xADW\x80c\xB7\x90\x92\xFD\x14a\x02\x86W\x80c\xB9\xB9\xA6\x88\x14a\x02\x99W\x80c\xBA\xBC\xC59\x14a\x02\xACW__\xFD[\x80c\xA6k2}\x14a\x02^W\x80c\xB7T6\xBB\x14a\x02sW__\xFD[\x80cT\x9E\x84&\x11a\x01\x1CW\x80c\x84V\xCBY\x11a\x01\x02W\x80c\x84V\xCBY\x14a\x01\xFFW\x80c\x8Ac\x1A\xA6\x14a\x02\x07W\x80c\x8B2@\xA0\x14a\x02\x1AW__\xFD[\x80cT\x9E\x84&\x14a\x01\xE1W\x80c\\\x97Z\xBB\x14a\x01\xF4W__\xFD[\x80c?K\xA8:\x11a\x01LW\x80c?K\xA8:\x14a\x01\xB1W\x80cH\\\xC9U\x14a\x01\xBBW\x80cPux\x8B\x14a\x01\xCEW__\xFD[\x80c\x1F\xE9'\xCF\x14a\x01gW\x80c\"\xBD\\\x1C\x14a\x01\x8DW[__\xFD[a\x01za\x01u6`\x04a\x1F\xC9V[a\x03AV[`@Q\x90\x81R` \x01[`@Q\x80\x91\x03\x90\xF3[`fTa\x01\xA1\x90`\x01`\xA0\x1B\x90\x04`\xFF\x16\x81V[`@Q\x90\x15\x15\x81R` \x01a\x01\x84V[a\x01\xB9a\x05\x0CV[\0[a\x01\xB9a\x01\xC96`\x04a \x1CV[a\x06;V[a\x01za\x01\xDC6`\x04a SV[a\x08\x9AV[a\x01za\x01\xEF6`\x04a \xCAV[a\tcV[`3T`\xFF\x16a\x01\xA1V[a\x01\xB9a\t\xD5V[a\x01za\x02\x156`\x04a!sV[a\x0B\x01V[\x7F\xB51'hJV\x8B1s\xAE\x13\xB9\xF8\xA6\x01n$>c\xB6\xE8\xEE\x11x\xD6\xA7\x17\x85\x0B]a\x03T`\x01`\x01`\xA0\x1B\x03\x16[`@Q`\x01`\x01`\xA0\x1B\x03\x90\x91\x16\x81R` \x01a\x01\x84V[a\x01za\x02l6`\x04a!\xE1V[_\x92\x91PPV[a\x01za\x02\x816`\x04a\x1F\xC9V[a\x0B\xB3V[a\x01za\x02\x946`\x04a\"\x01V[a\x0C\xA5V[a\x01za\x02\xA76`\x04a \xCAV[a\r\x90V[a\x01\xA1a\x02\xBA6`\x04a\"\x18V[`g` R_\x90\x81R`@\x90 T`\xFF\x16\x81V[a\x01\xB9a\x02\xDC6`\x04a#\x1BV[a\r\xF3V[`eTa\x02F\x90`\x01`\x01`\xA0\x1B\x03\x16\x81V[a\x01z\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81V[`fTa\x02F\x90`\x01`\x01`\xA0\x1B\x03\x16\x81V[a\x01\xB9a\x03<6`\x04a#\xE0V[a\x10dV[_a\x03Ja\x12[V[`fT`\x01`\xA0\x1B\x90\x04`\xFF\x16\x80\x15a\x03rWP2_\x90\x81R`g` R`@\x90 T`\xFF\x16\x15[\x15a\x03\x97W`@Qc\x0FQ\xEDq`\xE4\x1B\x81R2`\x04\x82\x01R`$\x01[`@Q\x80\x91\x03\x90\xFD[F\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x14a\x03\xF0W`@Q\x7F\xC6\xEAh\x03\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[a\x03\xF8a\x12\xB0V[a\x04.W`@Q\x7F\xC8\x95\x8E\xAD\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x82\x11\x15a\x04\xB1W`@Q\x7FF4i\x1B\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x81\x01\x83\x90R\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0`$\x82\x01R`D\x01a\x03\x8EV[_a\x04\xD6`\x033\x86\x86`@Qa\x04\xC8\x92\x91\x90a#\xFBV[`@Q\x80\x91\x03\x90 _a\x12\xC4V[`@Q\x90\x91P\x81\x90\x7F\xABS#\x85\xBE\x8F\x10\x05\xA4\xB6\xBA\x8F\xA2\n\"E\xFA\xCB4a4\xACs\x9F\xE9\xA5\x19\x8D\xC1X\x0B\x9C\x90_\x90\xA2\x90P[\x92\x91PPV[`eT`@\x80Qc\xCB#\xBC\xB5`\xE0\x1B\x81R\x90Q_\x92`\x01`\x01`\xA0\x1B\x03\x16\x91c\xCB#\xBC\xB5\x91`\x04\x80\x83\x01\x92` \x92\x91\x90\x82\x90\x03\x01\x81\x86Z\xFA\x15\x80\x15a\x05SW=__>=_\xFD[PPPP`@Q=`\x1F\x19`\x1F\x82\x01\x16\x82\x01\x80`@RP\x81\x01\x90a\x05w\x91\x90a$\nV[\x90P3`\x01`\x01`\xA0\x1B\x03\x82\x16\x14a\x060W_\x81`\x01`\x01`\xA0\x1B\x03\x16c\x8D\xA5\xCB[`@Q\x81c\xFF\xFF\xFF\xFF\x16`\xE0\x1B\x81R`\x04\x01` `@Q\x80\x83\x03\x81\x86Z\xFA\x15\x80\x15a\x05\xC6W=__>=_\xFD[PPPP`@Q=`\x1F\x19`\x1F\x82\x01\x16\x82\x01\x80`@RP\x81\x01\x90a\x05\xEA\x91\x90a$\nV[\x90P3`\x01`\x01`\xA0\x1B\x03\x82\x16\x14a\x06.W`@Qc\x079`\x07`\xE0\x1B\x81R3`\x04\x82\x01R`\x01`\x01`\xA0\x1B\x03\x80\x84\x16`$\x83\x01R\x82\x16`D\x82\x01R`d\x01a\x03\x8EV[P[a\x068a\x14\xAAV[PV[_Ta\x01\0\x90\x04`\xFF\x16\x15\x80\x80\x15a\x06YWP_T`\x01`\xFF\x90\x91\x16\x10[\x80a\x06rWP0;\x15\x80\x15a\x06rWP_T`\xFF\x16`\x01\x14[a\x06\xE4W`@QbF\x1B\xCD`\xE5\x1B\x81R` `\x04\x82\x01R`.`$\x82\x01R\x7FInitializable: contract is alrea`D\x82\x01R\x7Fdy initialized\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0`d\x82\x01R`\x84\x01a\x03\x8EV[_\x80T`\xFF\x19\x16`\x01\x17\x90U\x80\x15a\x07\x05W_\x80Ta\xFF\0\x19\x16a\x01\0\x17\x90U[`\x01`\x01`\xA0\x1B\x03\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x160\x03a\x07\xA3W`@QbF\x1B\xCD`\xE5\x1B\x81R` `\x04\x82\x01R`,`$\x82\x01R\x7FFunction must be called through `D\x82\x01R\x7Fdelegatecall\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0`d\x82\x01R`\x84\x01a\x03\x8EV[a\x07\xAD\x83\x83a\x14\xFCV[`eT`@\x80Q\x7F\xE1u\x8B\xD8\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R\x90Q_\x92`\x01`\x01`\xA0\x1B\x03\x16\x91c\xE1u\x8B\xD8\x91`\x04\x80\x83\x01\x92` \x92\x91\x90\x82\x90\x03\x01\x81\x86Z\xFA\x15\x80\x15a\x08\rW=__>=_\xFD[PPPP`@Q=`\x1F\x19`\x1F\x82\x01\x16\x82\x01\x80`@RP\x81\x01\x90a\x081\x91\x90a$\nV[`eT\x90\x91Pa\x08O\x90`\x01`\x01`\xA0\x1B\x03\x80\x84\x16\x91\x16_\x19a\x15\xEDV[P\x80\x15a\x08\x95W_\x80Ta\xFF\0\x19\x16\x90U`@Q`\x01\x81R\x7F\x7F&\xB8?\xF9n\x1F+jh/\x138R\xF6y\x8A\t\xC4e\xDA\x95\x92\x14`\xCE\xFB8G@$\x98\x90` \x01`@Q\x80\x91\x03\x90\xA1[PPPV[_a\x08\xA3a\x12[V[`fT`\x01`\xA0\x1B\x90\x04`\xFF\x16\x80\x15a\x08\xCBWP2_\x90\x81R`g` R`@\x90 T`\xFF\x16\x15[\x15a\x08\xEBW`@Qc\x0FQ\xEDq`\xE4\x1B\x81R2`\x04\x82\x01R`$\x01a\x03\x8EV[g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x88\x11\x15a\t\x14W`@Qc\x10|R{`\xE0\x1B\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[a\tW`\x033_\x8B\x8B\x8B\x8B`\x01`\x01`\xA0\x1B\x03\x16\x8B\x8B\x8B`@Q` \x01a\tB\x98\x97\x96\x95\x94\x93\x92\x91\x90a$%V[`@Q` \x81\x83\x03\x03\x81R\x90`@R_a\x17\x99V[\x98\x97PPPPPPPPV[_a\tla\x12[V[`fT`\x01`\xA0\x1B\x90\x04`\xFF\x16\x80\x15a\t\x94WP2_\x90\x81R`g` R`@\x90 T`\xFF\x16\x15[\x15a\t\xB4W`@Qc\x0FQ\xEDq`\xE4\x1B\x81R2`\x04\x82\x01R`$\x01a\x03\x8EV[a\t\xC6\x8B\x8B\x8B\x8B\x8B\x8B\x8B\x8B\x8B\x8Ba\x18xV[\x9B\x9APPPPPPPPPPPV[`eT`@\x80Qc\xCB#\xBC\xB5`\xE0\x1B\x81R\x90Q_\x92`\x01`\x01`\xA0\x1B\x03\x16\x91c\xCB#\xBC\xB5\x91`\x04\x80\x83\x01\x92` \x92\x91\x90\x82\x90\x03\x01\x81\x86Z\xFA\x15\x80\x15a\n\x1CW=__>=_\xFD[PPPP`@Q=`\x1F\x19`\x1F\x82\x01\x16\x82\x01\x80`@RP\x81\x01\x90a\n@\x91\x90a$\nV[\x90P3`\x01`\x01`\xA0\x1B\x03\x82\x16\x14a\n\xF9W_\x81`\x01`\x01`\xA0\x1B\x03\x16c\x8D\xA5\xCB[`@Q\x81c\xFF\xFF\xFF\xFF\x16`\xE0\x1B\x81R`\x04\x01` `@Q\x80\x83\x03\x81\x86Z\xFA\x15\x80\x15a\n\x8FW=__>=_\xFD[PPPP`@Q=`\x1F\x19`\x1F\x82\x01\x16\x82\x01\x80`@RP\x81\x01\x90a\n\xB3\x91\x90a$\nV[\x90P3`\x01`\x01`\xA0\x1B\x03\x82\x16\x14a\n\xF7W`@Qc\x079`\x07`\xE0\x1B\x81R3`\x04\x82\x01R`\x01`\x01`\xA0\x1B\x03\x80\x84\x16`$\x83\x01R\x82\x16`D\x82\x01R`d\x01a\x03\x8EV[P[a\x068a\x19{V[_a\x0B\na\x12[V[`fT`\x01`\xA0\x1B\x90\x04`\xFF\x16\x80\x15a\x0B2WP2_\x90\x81R`g` R`@\x90 T`\xFF\x16\x15[\x15a\x0BRW`@Qc\x0FQ\xEDq`\xE4\x1B\x81R2`\x04\x82\x01R`$\x01a\x03\x8EV[g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x87\x11\x15a\x0B{W`@Qc\x10|R{`\xE0\x1B\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[a\x0B\xA8`\x033`\x01\x8A\x8A\x8A`\x01`\x01`\xA0\x1B\x03\x16\x8A\x8A\x8A`@Q` \x01a\tB\x97\x96\x95\x94\x93\x92\x91\x90a$\x86V[\x97\x96PPPPPPPV[_a\x0B\xBCa\x12[V[`fT`\x01`\xA0\x1B\x90\x04`\xFF\x16\x80\x15a\x0B\xE4WP2_\x90\x81R`g` R`@\x90 T`\xFF\x16\x15[\x15a\x0C\x04W`@Qc\x0FQ\xEDq`\xE4\x1B\x81R2`\x04\x82\x01R`$\x01a\x03\x8EV[F\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x14a\x0C]W`@Q\x7F\xC6\xEAh\x03\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[a\x0C\x9E`\x033\x85\x85\x80\x80`\x1F\x01` \x80\x91\x04\x02` \x01`@Q\x90\x81\x01`@R\x80\x93\x92\x91\x90\x81\x81R` \x01\x83\x83\x80\x82\x847_\x92\x01\x82\x90RP\x92Pa\x17\x99\x91PPV[\x93\x92PPPV[_a\x0C\xAEa\x12[V[`fT`\x01`\xA0\x1B\x90\x04`\xFF\x16\x80\x15a\x0C\xD6WP2_\x90\x81R`g` R`@\x90 T`\xFF\x16\x15[\x15a\x0C\xF6W`@Qc\x0FQ\xEDq`\xE4\x1B\x81R2`\x04\x82\x01R`$\x01a\x03\x8EV[3\x80;\x15\x15\x80a\r\x06WP23\x14\x15[\x15a\r$WP3s\x11\x11\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x11\x11\x01[_a\r.\x84a\x19\xB8V[`@Q\x7F\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\0\0\0\0\0\0\0\0\0\0\0\0``\x85\x90\x1B\x16` \x82\x01R`4\x81\x01\x82\x90R\x90\x91Pa\r\x88\x90`\x0C\x903\x90`T\x01`@Q` \x81\x83\x03\x03\x81R\x90`@R\x87a\x17\x99V[\x94\x93PPPPV[_a\r\x99a\x12[V[`fT`\x01`\xA0\x1B\x90\x04`\xFF\x16\x80\x15a\r\xC1WP2_\x90\x81R`g` R`@\x90 T`\xFF\x16\x15[\x15a\r\xE1W`@Qc\x0FQ\xEDq`\xE4\x1B\x81R2`\x04\x82\x01R`$\x01a\x03\x8EV[a\t\xC6\x8B\x8B\x8B\x8B\x8B\x8B\x8B\x8B\x8B\x8Ba\x1A\x9DV[`eT`@\x80Qc\xCB#\xBC\xB5`\xE0\x1B\x81R\x90Q_\x92`\x01`\x01`\xA0\x1B\x03\x16\x91c\xCB#\xBC\xB5\x91`\x04\x80\x83\x01\x92` \x92\x91\x90\x82\x90\x03\x01\x81\x86Z\xFA\x15\x80\x15a\x0E:W=__>=_\xFD[PPPP`@Q=`\x1F\x19`\x1F\x82\x01\x16\x82\x01\x80`@RP\x81\x01\x90a\x0E^\x91\x90a$\nV[\x90P3`\x01`\x01`\xA0\x1B\x03\x82\x16\x14a\x0F\x17W_\x81`\x01`\x01`\xA0\x1B\x03\x16c\x8D\xA5\xCB[`@Q\x81c\xFF\xFF\xFF\xFF\x16`\xE0\x1B\x81R`\x04\x01` `@Q\x80\x83\x03\x81\x86Z\xFA\x15\x80\x15a\x0E\xADW=__>=_\xFD[PPPP`@Q=`\x1F\x19`\x1F\x82\x01\x16\x82\x01\x80`@RP\x81\x01\x90a\x0E\xD1\x91\x90a$\nV[\x90P3`\x01`\x01`\xA0\x1B\x03\x82\x16\x14a\x0F\x15W`@Qc\x079`\x07`\xE0\x1B\x81R3`\x04\x82\x01R`\x01`\x01`\xA0\x1B\x03\x80\x84\x16`$\x83\x01R\x82\x16`D\x82\x01R`d\x01a\x03\x8EV[P[\x81Q\x83Q\x14a\x0FhW`@QbF\x1B\xCD`\xE5\x1B\x81R` `\x04\x82\x01R`\r`$\x82\x01R\x7FINVALID_INPUT\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0`D\x82\x01R`d\x01a\x03\x8EV[_[\x83Q\x81\x10\x15a\x10^W\x82\x81\x81Q\x81\x10a\x0F\x85Wa\x0F\x85a$\xE0V[` \x02` \x01\x01Q`g_\x86\x84\x81Q\x81\x10a\x0F\xA2Wa\x0F\xA2a$\xE0V[` \x02` \x01\x01Q`\x01`\x01`\xA0\x1B\x03\x16`\x01`\x01`\xA0\x1B\x03\x16\x81R` \x01\x90\x81R` \x01_ _a\x01\0\n\x81T\x81`\xFF\x02\x19\x16\x90\x83\x15\x15\x02\x17\x90UP\x83\x81\x81Q\x81\x10a\x0F\xF1Wa\x0F\xF1a$\xE0V[` \x02` \x01\x01Q`\x01`\x01`\xA0\x1B\x03\x16\x7F\xD9s\x9FE\xA0\x1C\xE0\x92\xC5\xCD\xB3\xD6\x8Fc\xD6=!gk\x1Cl\x0BO\x9C\xBCk\xE4\xCFTIYZ\x84\x83\x81Q\x81\x10a\x105Wa\x105a$\xE0V[` \x02` \x01\x01Q`@Qa\x10N\x91\x15\x15\x81R` \x01\x90V[`@Q\x80\x91\x03\x90\xA2`\x01\x01a\x0FjV[PPPPV[`eT`@\x80Qc\xCB#\xBC\xB5`\xE0\x1B\x81R\x90Q_\x92`\x01`\x01`\xA0\x1B\x03\x16\x91c\xCB#\xBC\xB5\x91`\x04\x80\x83\x01\x92` \x92\x91\x90\x82\x90\x03\x01\x81\x86Z\xFA\x15\x80\x15a\x10\xABW=__>=_\xFD[PPPP`@Q=`\x1F\x19`\x1F\x82\x01\x16\x82\x01\x80`@RP\x81\x01\x90a\x10\xCF\x91\x90a$\nV[\x90P3`\x01`\x01`\xA0\x1B\x03\x82\x16\x14a\x11\x88W_\x81`\x01`\x01`\xA0\x1B\x03\x16c\x8D\xA5\xCB[`@Q\x81c\xFF\xFF\xFF\xFF\x16`\xE0\x1B\x81R`\x04\x01` `@Q\x80\x83\x03\x81\x86Z\xFA\x15\x80\x15a\x11\x1EW=__>=_\xFD[PPPP`@Q=`\x1F\x19`\x1F\x82\x01\x16\x82\x01\x80`@RP\x81\x01\x90a\x11B\x91\x90a$\nV[\x90P3`\x01`\x01`\xA0\x1B\x03\x82\x16\x14a\x11\x86W`@Qc\x079`\x07`\xE0\x1B\x81R3`\x04\x82\x01R`\x01`\x01`\xA0\x1B\x03\x80\x84\x16`$\x83\x01R\x82\x16`D\x82\x01R`d\x01a\x03\x8EV[P[`fT`\x01`\xA0\x1B\x90\x04`\xFF\x16\x15\x15\x82\x15\x15\x03a\x11\xE7W`@QbF\x1B\xCD`\xE5\x1B\x81R` `\x04\x82\x01R`\x0B`$\x82\x01R\x7FALREADY_SET\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0`D\x82\x01R`d\x01a\x03\x8EV[`f\x80T\x83\x15\x15`\x01`\xA0\x1B\x02\x7F\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\0\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x90\x91\x16\x17\x90U`@Q\x7F\x16C[E\xF7H G\xF89\xA6\xA1\x9D)\x14Bbr\0\xF5,\xAD(\x03\xC5\x95\x15\r\rD\x0E\xB3\x90a\x12O\x90\x84\x15\x15\x81R` \x01\x90V[`@Q\x80\x91\x03\x90\xA1PPV[`3T`\xFF\x16\x15a\x12\xAEW`@QbF\x1B\xCD`\xE5\x1B\x81R` `\x04\x82\x01R`\x10`$\x82\x01R\x7FPausable: paused\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0`D\x82\x01R`d\x01a\x03\x8EV[V[_32\x14\x80\x15a\x12\xBFWP3;\x15[\x90P\x90V[__`e_\x90T\x90a\x01\0\n\x90\x04`\x01`\x01`\xA0\x1B\x03\x16`\x01`\x01`\xA0\x1B\x03\x16c\xE1u\x8B\xD8`@Q\x81c\xFF\xFF\xFF\xFF\x16`\xE0\x1B\x81R`\x04\x01` `@Q\x80\x83\x03\x81\x86Z\xFA\x15\x80\x15a\x13\x16W=__>=_\xFD[PPPP`@Q=`\x1F\x19`\x1F\x82\x01\x16\x82\x01\x80`@RP\x81\x01\x90a\x13:\x91\x90a$\nV[`@Q\x7Fp\xA0\x821\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R0`\x04\x82\x01R\x90\x91P_\x90`\x01`\x01`\xA0\x1B\x03\x83\x16\x90cp\xA0\x821\x90`$\x01` `@Q\x80\x83\x03\x81\x86Z\xFA\x15\x80\x15a\x13\x9AW=__>=_\xFD[PPPP`@Q=`\x1F\x19`\x1F\x82\x01\x16\x82\x01\x80`@RP\x81\x01\x90a\x13\xBE\x91\x90a$\xF4V[\x90P\x83\x81\x10\x15a\x13\xECW_a\x13\xD3\x82\x86a%\x1FV[\x90Pa\x13\xEA`\x01`\x01`\xA0\x1B\x03\x84\x1630\x84a\x1B\x8AV[P[`eT`\x01`\x01`\xA0\x1B\x03\x16cu\xD8\x1E%\x88s\x11\x11\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x11\x11\x89\x01`@Q\x7F\xFF\xFF\xFF\xFF\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0`\xE0\x85\x90\x1B\x16\x81R`\xFF\x90\x92\x16`\x04\x83\x01R`\x01`\x01`\xA0\x1B\x03\x16`$\x82\x01R`D\x81\x01\x88\x90R`d\x81\x01\x87\x90R`\x84\x01` `@Q\x80\x83\x03\x81_\x87Z\xF1\x15\x80\x15a\x14\x86W=__>=_\xFD[PPPP`@Q=`\x1F\x19`\x1F\x82\x01\x16\x82\x01\x80`@RP\x81\x01\x90a\x0B\xA8\x91\x90a$\xF4V[a\x14\xB2a\x1B\xDBV[`3\x80T`\xFF\x19\x16\x90U\x7F]\xB9\xEE\nI[\xF2\xE6\xFF\x9C\x91\xA7\x83L\x1B\xA4\xFD\xD2D\xA5\xE8\xAANS{\xD3\x8A\xEA\xE4\xB0s\xAA3[`@Q`\x01`\x01`\xA0\x1B\x03\x90\x91\x16\x81R` \x01`@Q\x80\x91\x03\x90\xA1V[_Ta\x01\0\x90\x04`\xFF\x16a\x15xW`@QbF\x1B\xCD`\xE5\x1B\x81R` `\x04\x82\x01R`+`$\x82\x01R\x7FInitializable: contract is not i`D\x82\x01R\x7Fnitializing\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0`d\x82\x01R`\x84\x01a\x03\x8EV[`e\x80T`\x01`\x01`\xA0\x1B\x03\x80\x85\x16\x7F\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x90\x92\x16\x91\x90\x91\x17\x90\x91U`f\x80T\x7F\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x16\x91\x83\x16\x91\x90\x91\x17\x90Ua\x15\xE9a\x1C-V[PPV[\x80\x15\x80a\x16~WP`@Q\x7F\xDDb\xED>\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R0`\x04\x82\x01R`\x01`\x01`\xA0\x1B\x03\x83\x81\x16`$\x83\x01R\x84\x16\x90c\xDDb\xED>\x90`D\x01` `@Q\x80\x83\x03\x81\x86Z\xFA\x15\x80\x15a\x16XW=__>=_\xFD[PPPP`@Q=`\x1F\x19`\x1F\x82\x01\x16\x82\x01\x80`@RP\x81\x01\x90a\x16|\x91\x90a$\xF4V[\x15[a\x16\xF0W`@QbF\x1B\xCD`\xE5\x1B\x81R` `\x04\x82\x01R`6`$\x82\x01R\x7FSafeERC20: approve from non-zero`D\x82\x01R\x7F to non-zero allowance\0\0\0\0\0\0\0\0\0\0`d\x82\x01R`\x84\x01a\x03\x8EV[`@Q`\x01`\x01`\xA0\x1B\x03\x83\x16`$\x82\x01R`D\x81\x01\x82\x90Ra\x08\x95\x90\x84\x90\x7F\t^\xA7\xB3\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x90`d\x01[`@\x80Q`\x1F\x19\x81\x84\x03\x01\x81R\x91\x90R` \x81\x01\x80Q{\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x7F\xFF\xFF\xFF\xFF\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x90\x93\x16\x92\x90\x92\x17\x90\x91Ra\x1C\xB1V[_\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x83Q\x11\x15a\x18!W\x82Q`@Q\x7FF4i\x1B\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x81\x01\x91\x90\x91R\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0`$\x82\x01R`D\x01a\x03\x8EV[_a\x185\x86\x86\x86\x80Q\x90` \x01 \x86a\x12\xC4V[\x90P\x80\x7F\xFFd\x90_s\xA6\x7F\xB5\x94\xE0\xF9@\xA8\x07Z\x86\r\xB4\x89\xAD\x99\x1E\x03/H\xC8\x11#\xEBR\xD6\x0B\x85`@Qa\x18g\x91\x90a%`V[`@Q\x80\x91\x03\x90\xA2\x95\x94PPPPPV[__a\x18\x83\x85a\x19\xB8V[\x90Pa\x18\x8F\x86\x88a%rV[a\x18\x99\x8C\x8Ca%\x89V[a\x18\xA3\x91\x90a%\x89V[\x81\x10\x15a\x19\x05Wa\x18\xB4\x86\x88a%rV[a\x18\xBE\x8C\x8Ca%\x89V[a\x18\xC8\x91\x90a%\x89V[`@Q\x7Fp@\xB5\x8C\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x81\x01\x91\x90\x91R`$\x81\x01\x82\x90R`D\x01a\x03\x8EV[`\x01`\x01`\xA0\x1B\x03\x89\x16;\x15a\x19/Ws\x11\x11\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x11\x11\x89\x01\x98P[`\x01`\x01`\xA0\x1B\x03\x88\x16;\x15a\x19YWs\x11\x11\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x11\x11\x88\x01\x97P[a\x19k\x8C\x8C\x8C\x8C\x8C\x8C\x8C\x8C\x8C\x8Ca\x1A\x9DV[\x9C\x9BPPPPPPPPPPPPV[a\x19\x83a\x12[V[`3\x80T`\xFF\x19\x16`\x01\x17\x90U\x7Fb\xE7\x8C\xEA\x01\xBE\xE3 \xCDNB\x02p\xB5\xEAt\0\r\x11\xB0\xC9\xF7GT\xEB\xDB\xFCTK\x05\xA2Xa\x14\xDF3\x90V[__`e_\x90T\x90a\x01\0\n\x90\x04`\x01`\x01`\xA0\x1B\x03\x16`\x01`\x01`\xA0\x1B\x03\x16c\xADH\xCB^`@Q\x81c\xFF\xFF\xFF\xFF\x16`\xE0\x1B\x81R`\x04\x01` `@Q\x80\x83\x03\x81\x86Z\xFA\x15\x80\x15a\x1A\nW=__>=_\xFD[PPPP`@Q=`\x1F\x19`\x1F\x82\x01\x16\x82\x01\x80`@RP\x81\x01\x90a\x1A.\x91\x90a%\x9CV[\x90P`\x12\x81`\xFF\x16\x10\x15a\x1A\x91Ww\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x83\x11\x15a\x1A\x91W`@Q\x7F\x08\x08;*\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x81\x01\x84\x90R`$\x01a\x03\x8EV[a\x0C\x9E\x83\x82`\x12a\x1D\x95V[_\x85`\x01\x14\x80a\x1A\xADWP\x84`\x01\x14[\x15a\x1A\xFAW3\x8B\x8B\x86\x8C\x8C\x8C\x8C\x8C\x8B\x8B`@Q\x7F\x07\xC2f\xE3\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01a\x03\x8E\x9B\x9A\x99\x98\x97\x96\x95\x94\x93\x92\x91\x90a%\xBCV[g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x86\x11\x15a\x1B#W`@Qc\x10|R{`\xE0\x1B\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[_a\x19k`\t3\x8E`\x01`\x01`\xA0\x1B\x03\x16\x8Ea\x1B>\x8Aa\x19\xB8V[\x8F\x8F`\x01`\x01`\xA0\x1B\x03\x16\x8F`\x01`\x01`\xA0\x1B\x03\x16\x8F\x8F\x8E\x8E\x90P\x8F\x8F`@Q` \x01a\x1Bu\x9B\x9A\x99\x98\x97\x96\x95\x94\x93\x92\x91\x90a&SV[`@Q` \x81\x83\x03\x03\x81R\x90`@R\x88a\x17\x99V[`@Q`\x01`\x01`\xA0\x1B\x03\x80\x85\x16`$\x83\x01R\x83\x16`D\x82\x01R`d\x81\x01\x82\x90Ra\x10^\x90\x85\x90\x7F#\xB8r\xDD\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x90`\x84\x01a\x175V[`3T`\xFF\x16a\x12\xAEW`@QbF\x1B\xCD`\xE5\x1B\x81R` `\x04\x82\x01R`\x14`$\x82\x01R\x7FPausable: not paused\0\0\0\0\0\0\0\0\0\0\0\0`D\x82\x01R`d\x01a\x03\x8EV[_Ta\x01\0\x90\x04`\xFF\x16a\x1C\xA9W`@QbF\x1B\xCD`\xE5\x1B\x81R` `\x04\x82\x01R`+`$\x82\x01R\x7FInitializable: contract is not i`D\x82\x01R\x7Fnitializing\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0`d\x82\x01R`\x84\x01a\x03\x8EV[a\x12\xAEa\x1D\xFDV[_a\x1D\x05\x82`@Q\x80`@\x01`@R\x80` \x81R` \x01\x7FSafeERC20: low-level call failed\x81RP\x85`\x01`\x01`\xA0\x1B\x03\x16a\x1E\x85\x90\x92\x91\x90c\xFF\xFF\xFF\xFF\x16V[\x80Q\x90\x91P\x15a\x08\x95W\x80\x80` \x01\x90Q\x81\x01\x90a\x1D#\x91\x90a&\xA7V[a\x08\x95W`@QbF\x1B\xCD`\xE5\x1B\x81R` `\x04\x82\x01R`*`$\x82\x01R\x7FSafeERC20: ERC20 operation did n`D\x82\x01R\x7Fot succeed\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0`d\x82\x01R`\x84\x01a\x03\x8EV[_\x81`\xFF\x16\x83`\xFF\x16\x03a\x1D\xAAWP\x82a\x0C\x9EV[\x81`\xFF\x16\x83`\xFF\x16\x10\x15a\x1D\xDEWa\x1D\xC2\x83\x83a&\xC2V[a\x1D\xCD\x90`\na'\xBEV[a\x1D\xD7\x90\x85a%rV[\x90Pa\x0C\x9EV[a\x1D\xE8\x82\x84a&\xC2V[a\x1D\xF3\x90`\na'\xBEV[a\x1D\xD7\x90\x85a'\xCCV[_Ta\x01\0\x90\x04`\xFF\x16a\x1EyW`@QbF\x1B\xCD`\xE5\x1B\x81R` `\x04\x82\x01R`+`$\x82\x01R\x7FInitializable: contract is not i`D\x82\x01R\x7Fnitializing\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0`d\x82\x01R`\x84\x01a\x03\x8EV[`3\x80T`\xFF\x19\x16\x90UV[``a\r\x88\x84\x84_\x85\x85`\x01`\x01`\xA0\x1B\x03\x85\x16;a\x1E\xE6W`@QbF\x1B\xCD`\xE5\x1B\x81R` `\x04\x82\x01R`\x1D`$\x82\x01R\x7FAddress: call to non-contract\0\0\0`D\x82\x01R`d\x01a\x03\x8EV[__\x86`\x01`\x01`\xA0\x1B\x03\x16\x85\x87`@Qa\x1F\x01\x91\x90a'\xEBV[_`@Q\x80\x83\x03\x81\x85\x87Z\xF1\x92PPP=\x80_\x81\x14a\x1F;W`@Q\x91P`\x1F\x19`?=\x01\x16\x82\x01`@R=\x82R=_` \x84\x01>a\x1F@V[``\x91P[P\x91P\x91Pa\x0B\xA8\x82\x82\x86``\x83\x15a\x1FZWP\x81a\x0C\x9EV[\x82Q\x15a\x1FjW\x82Q\x80\x84` \x01\xFD[\x81`@QbF\x1B\xCD`\xE5\x1B\x81R`\x04\x01a\x03\x8E\x91\x90a%`V[__\x83`\x1F\x84\x01\x12a\x1F\x94W__\xFD[P\x815g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x11\x15a\x1F\xABW__\xFD[` \x83\x01\x91P\x83` \x82\x85\x01\x01\x11\x15a\x1F\xC2W__\xFD[\x92P\x92\x90PV[__` \x83\x85\x03\x12\x15a\x1F\xDAW__\xFD[\x825g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x11\x15a\x1F\xF0W__\xFD[a\x1F\xFC\x85\x82\x86\x01a\x1F\x84V[\x90\x96\x90\x95P\x93PPPPV[`\x01`\x01`\xA0\x1B\x03\x81\x16\x81\x14a\x068W__\xFD[__`@\x83\x85\x03\x12\x15a -W__\xFD[\x825a 8\x81a \x08V[\x91P` \x83\x015a H\x81a \x08V[\x80\x91PP\x92P\x92\x90PV[_______`\xC0\x88\x8A\x03\x12\x15a iW__\xFD[\x875\x96P` \x88\x015\x95P`@\x88\x015\x94P``\x88\x015a \x89\x81a \x08V[\x93P`\x80\x88\x015\x92P`\xA0\x88\x015g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x11\x15a \xABW__\xFD[a \xB7\x8A\x82\x8B\x01a\x1F\x84V[\x98\x9B\x97\x9AP\x95\x98P\x93\x96\x92\x95\x92\x93PPPV[__________a\x01 \x8B\x8D\x03\x12\x15a \xE4W__\xFD[\x8A5a \xEF\x81a \x08V[\x99P` \x8B\x015\x98P`@\x8B\x015\x97P``\x8B\x015a!\r\x81a \x08V[\x96P`\x80\x8B\x015a!\x1D\x81a \x08V[\x95P`\xA0\x8B\x015\x94P`\xC0\x8B\x015\x93P`\xE0\x8B\x015\x92Pa\x01\0\x8B\x015g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x11\x15a!NW__\xFD[a!Z\x8D\x82\x8E\x01a\x1F\x84V[\x91P\x80\x93PP\x80\x91PP\x92\x95\x98\x9B\x91\x94\x97\x9AP\x92\x95\x98PV[______`\xA0\x87\x89\x03\x12\x15a!\x88W__\xFD[\x865\x95P` \x87\x015\x94P`@\x87\x015a!\xA1\x81a \x08V[\x93P``\x87\x015\x92P`\x80\x87\x015g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x11\x15a!\xC3W__\xFD[a!\xCF\x89\x82\x8A\x01a\x1F\x84V[\x97\x9A\x96\x99P\x94\x97P\x92\x95\x93\x94\x92PPPV[__`@\x83\x85\x03\x12\x15a!\xF2W__\xFD[PP\x805\x92` \x90\x91\x015\x91PV[_` \x82\x84\x03\x12\x15a\"\x11W__\xFD[P5\x91\x90PV[_` \x82\x84\x03\x12\x15a\"(W__\xFD[\x815a\x0C\x9E\x81a \x08V[cNH{q`\xE0\x1B_R`A`\x04R`$_\xFD[`@Q`\x1F\x82\x01`\x1F\x19\x16\x81\x01g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x11\x82\x82\x10\x17\x15a\"pWa\"pa\"3V[`@R\x91\x90PV[_g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x82\x11\x15a\"\x91Wa\"\x91a\"3V[P`\x05\x1B` \x01\x90V[\x80\x15\x15\x81\x14a\x068W__\xFD[_\x82`\x1F\x83\x01\x12a\"\xB7W__\xFD[\x815a\"\xCAa\"\xC5\x82a\"xV[a\"GV[\x80\x82\x82R` \x82\x01\x91P` \x83`\x05\x1B\x86\x01\x01\x92P\x85\x83\x11\x15a\"\xEBW__\xFD[` \x85\x01[\x83\x81\x10\x15a#\x11W\x805a#\x03\x81a\"\x9BV[\x83R` \x92\x83\x01\x92\x01a\"\xF0V[P\x95\x94PPPPPV[__`@\x83\x85\x03\x12\x15a#,W__\xFD[\x825g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x11\x15a#BW__\xFD[\x83\x01`\x1F\x81\x01\x85\x13a#RW__\xFD[\x805a#`a\"\xC5\x82a\"xV[\x80\x82\x82R` \x82\x01\x91P` \x83`\x05\x1B\x85\x01\x01\x92P\x87\x83\x11\x15a#\x81W__\xFD[` \x84\x01\x93P[\x82\x84\x10\x15a#\xACW\x835a#\x9B\x81a \x08V[\x82R` \x93\x84\x01\x93\x90\x91\x01\x90a#\x88V[\x94PPPP` \x83\x015g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x11\x15a#\xCAW__\xFD[a#\xD6\x85\x82\x86\x01a\"\xA8V[\x91PP\x92P\x92\x90PV[_` \x82\x84\x03\x12\x15a#\xF0W__\xFD[\x815a\x0C\x9E\x81a\"\x9BV[\x81\x83\x827_\x91\x01\x90\x81R\x91\x90PV[_` \x82\x84\x03\x12\x15a$\x1AW__\xFD[\x81Qa\x0C\x9E\x81a \x08V[\x7F\xFF\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x89`\xF8\x1B\x16\x81R\x87`\x01\x82\x01R\x86`!\x82\x01R\x85`A\x82\x01R\x84`a\x82\x01R\x83`\x81\x82\x01R\x81\x83`\xA1\x83\x017_\x91\x01`\xA1\x01\x90\x81R\x97\x96PPPPPPPV[\x7F\xFF\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x88`\xF8\x1B\x16\x81R\x86`\x01\x82\x01R\x85`!\x82\x01R\x84`A\x82\x01R\x83`a\x82\x01R\x81\x83`\x81\x83\x017_\x91\x01`\x81\x01\x90\x81R\x96\x95PPPPPPV[cNH{q`\xE0\x1B_R`2`\x04R`$_\xFD[_` \x82\x84\x03\x12\x15a%\x04W__\xFD[PQ\x91\x90PV[cNH{q`\xE0\x1B_R`\x11`\x04R`$_\xFD[\x81\x81\x03\x81\x81\x11\x15a\x05\x06Wa\x05\x06a%\x0BV[_\x81Q\x80\x84R\x80` \x84\x01` \x86\x01^_` \x82\x86\x01\x01R` `\x1F\x19`\x1F\x83\x01\x16\x85\x01\x01\x91PP\x92\x91PPV[` \x81R_a\x0C\x9E` \x83\x01\x84a%2V[\x80\x82\x02\x81\x15\x82\x82\x04\x84\x14\x17a\x05\x06Wa\x05\x06a%\x0BV[\x80\x82\x01\x80\x82\x11\x15a\x05\x06Wa\x05\x06a%\x0BV[_` \x82\x84\x03\x12\x15a%\xACW__\xFD[\x81Q`\xFF\x81\x16\x81\x14a\x0C\x9EW__\xFD[`\x01`\x01`\xA0\x1B\x03\x8C\x16\x81R`\x01`\x01`\xA0\x1B\x03\x8B\x16` \x82\x01R\x89`@\x82\x01R\x88``\x82\x01R\x87`\x80\x82\x01R`\x01`\x01`\xA0\x1B\x03\x87\x16`\xA0\x82\x01R`\x01`\x01`\xA0\x1B\x03\x86\x16`\xC0\x82\x01R\x84`\xE0\x82\x01R\x83a\x01\0\x82\x01Ra\x01@a\x01 \x82\x01R\x81a\x01@\x82\x01R\x81\x83a\x01`\x83\x017_\x81\x83\x01a\x01`\x90\x81\x01\x91\x90\x91R`\x1F\x90\x92\x01`\x1F\x19\x16\x01\x01\x9A\x99PPPPPPPPPPV[\x8B\x81R\x8A` \x82\x01R\x89`@\x82\x01R\x88``\x82\x01R\x87`\x80\x82\x01R\x86`\xA0\x82\x01R\x85`\xC0\x82\x01R\x84`\xE0\x82\x01R\x83a\x01\0\x82\x01R\x81\x83a\x01 \x83\x017_\x91\x01a\x01 \x01\x90\x81R\x9A\x99PPPPPPPPPPV[_` \x82\x84\x03\x12\x15a&\xB7W__\xFD[\x81Qa\x0C\x9E\x81a\"\x9BV[`\xFF\x82\x81\x16\x82\x82\x16\x03\x90\x81\x11\x15a\x05\x06Wa\x05\x06a%\x0BV[`\x01\x81[`\x01\x84\x11\x15a'\x16W\x80\x85\x04\x81\x11\x15a&\xFAWa&\xFAa%\x0BV[`\x01\x84\x16\x15a'\x08W\x90\x81\x02\x90[`\x01\x93\x90\x93\x1C\x92\x80\x02a&\xDFV[\x93P\x93\x91PPV[_\x82a',WP`\x01a\x05\x06V[\x81a'8WP_a\x05\x06V[\x81`\x01\x81\x14a'NW`\x02\x81\x14a'XWa'tV[`\x01\x91PPa\x05\x06V[`\xFF\x84\x11\x15a'iWa'ia%\x0BV[PP`\x01\x82\x1Ba\x05\x06V[P` \x83\x10a\x013\x83\x10\x16`N\x84\x10`\x0B\x84\x10\x16\x17\x15a'\x97WP\x81\x81\na\x05\x06V[a'\xA3_\x19\x84\x84a&\xDBV[\x80_\x19\x04\x82\x11\x15a'\xB6Wa'\xB6a%\x0BV[\x02\x93\x92PPPV[_a\x0C\x9E`\xFF\x84\x16\x83a'\x1EV[_\x82a'\xE6WcNH{q`\xE0\x1B_R`\x12`\x04R`$_\xFD[P\x04\x90V[_\x82Q\x80` \x85\x01\x84^_\x92\x01\x91\x82RP\x91\x90PV\xFE\xA2dipfsX\"\x12 &_\x86\x93v\xB6\xC5 D^\xE9\x0B#\xFC>\x87\x02\x82\xA1(u\x95\x93\xA3`\x18\xA4\xB1T\xB4\xB5RdsolcC\0\x08\x1C\x003",
    );
    /// The runtime bytecode of the contract, as deployed on the network.
    ///
    /// ```text
    ///0x608060405234801561000f575f5ffd5b5060043610610163575f3560e01c8063a66b327d116100c7578063e3de72a51161007d578063e8eb1dc311610063578063e8eb1dc3146102f4578063ee35f3271461031b578063efeadb6d1461032e575f5ffd5b8063e3de72a5146102ce578063e78cea92146102e1575f5ffd5b8063b79092fd116100ad578063b79092fd14610286578063b9b9a68814610299578063babcc539146102ac575f5ffd5b8063a66b327d1461025e578063b75436bb14610273575f5ffd5b8063549e84261161011c5780638456cb59116101025780638456cb59146101ff5780638a631aa6146102075780638b3240a01461021a575f5ffd5b8063549e8426146101e15780635c975abb146101f4575f5ffd5b80633f4ba83a1161014c5780633f4ba83a146101b1578063485cc955146101bb5780635075788b146101ce575f5ffd5b80631fe927cf1461016757806322bd5c1c1461018d575b5f5ffd5b61017a610175366004611fc9565b610341565b6040519081526020015b60405180910390f35b6066546101a190600160a01b900460ff1681565b6040519015158152602001610184565b6101b961050c565b005b6101b96101c936600461201c565b61063b565b61017a6101dc366004612053565b61089a565b61017a6101ef3660046120ca565b610963565b60335460ff166101a1565b6101b96109d5565b61017a610215366004612173565b610b01565b7fb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103546001600160a01b03165b6040516001600160a01b039091168152602001610184565b61017a61026c3660046121e1565b5f92915050565b61017a610281366004611fc9565b610bb3565b61017a610294366004612201565b610ca5565b61017a6102a73660046120ca565b610d90565b6101a16102ba366004612218565b60676020525f908152604090205460ff1681565b6101b96102dc36600461231b565b610df3565b606554610246906001600160a01b031681565b61017a7f000000000000000000000000000000000000000000000000000000000000000081565b606654610246906001600160a01b031681565b6101b961033c3660046123e0565b611064565b5f61034a61125b565b606654600160a01b900460ff1680156103725750325f9081526067602052604090205460ff16155b1561039757604051630f51ed7160e41b81523260048201526024015b60405180910390fd5b467f0000000000000000000000000000000000000000000000000000000000000000146103f0576040517fc6ea680300000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b6103f86112b0565b61042e576040517fc8958ead00000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b7f00000000000000000000000000000000000000000000000000000000000000008211156104b1576040517f4634691b000000000000000000000000000000000000000000000000000000008152600481018390527f0000000000000000000000000000000000000000000000000000000000000000602482015260440161038e565b5f6104d660033386866040516104c89291906123fb565b60405180910390205f6112c4565b60405190915081907fab532385be8f1005a4b6ba8fa20a2245facb346134ac739fe9a5198dc1580b9c905f90a290505b92915050565b6065546040805163cb23bcb560e01b815290515f926001600160a01b03169163cb23bcb59160048083019260209291908290030181865afa158015610553573d5f5f3e3d5ffd5b505050506040513d601f19601f82011682018060405250810190610577919061240a565b9050336001600160a01b03821614610630575f816001600160a01b0316638da5cb5b6040518163ffffffff1660e01b8152600401602060405180830381865afa1580156105c6573d5f5f3e3d5ffd5b505050506040513d601f19601f820116820180604052508101906105ea919061240a565b9050336001600160a01b0382161461062e57604051630739600760e01b81523360048201526001600160a01b0380841660248301528216604482015260640161038e565b505b6106386114aa565b50565b5f54610100900460ff161580801561065957505f54600160ff909116105b806106725750303b15801561067257505f5460ff166001145b6106e45760405162461bcd60e51b815260206004820152602e60248201527f496e697469616c697a61626c653a20636f6e747261637420697320616c72656160448201527f647920696e697469616c697a6564000000000000000000000000000000000000606482015260840161038e565b5f805460ff191660011790558015610705575f805461ff0019166101001790555b6001600160a01b037f00000000000000000000000000000000000000000000000000000000000000001630036107a35760405162461bcd60e51b815260206004820152602c60248201527f46756e6374696f6e206d7573742062652063616c6c6564207468726f7567682060448201527f64656c656761746563616c6c0000000000000000000000000000000000000000606482015260840161038e565b6107ad83836114fc565b606554604080517fe1758bd800000000000000000000000000000000000000000000000000000000815290515f926001600160a01b03169163e1758bd89160048083019260209291908290030181865afa15801561080d573d5f5f3e3d5ffd5b505050506040513d601f19601f82011682018060405250810190610831919061240a565b60655490915061084f906001600160a01b0380841691165f196115ed565b508015610895575f805461ff0019169055604051600181527f7f26b83ff96e1f2b6a682f133852f6798a09c465da95921460cefb38474024989060200160405180910390a15b505050565b5f6108a361125b565b606654600160a01b900460ff1680156108cb5750325f9081526067602052604090205460ff16155b156108eb57604051630f51ed7160e41b815232600482015260240161038e565b67ffffffffffffffff8811156109145760405163107c527b60e01b815260040160405180910390fd5b6109576003335f8b8b8b8b6001600160a01b03168b8b8b604051602001610942989796959493929190612425565b6040516020818303038152906040525f611799565b98975050505050505050565b5f61096c61125b565b606654600160a01b900460ff1680156109945750325f9081526067602052604090205460ff16155b156109b457604051630f51ed7160e41b815232600482015260240161038e565b6109c68b8b8b8b8b8b8b8b8b8b611878565b9b9a5050505050505050505050565b6065546040805163cb23bcb560e01b815290515f926001600160a01b03169163cb23bcb59160048083019260209291908290030181865afa158015610a1c573d5f5f3e3d5ffd5b505050506040513d601f19601f82011682018060405250810190610a40919061240a565b9050336001600160a01b03821614610af9575f816001600160a01b0316638da5cb5b6040518163ffffffff1660e01b8152600401602060405180830381865afa158015610a8f573d5f5f3e3d5ffd5b505050506040513d601f19601f82011682018060405250810190610ab3919061240a565b9050336001600160a01b03821614610af757604051630739600760e01b81523360048201526001600160a01b0380841660248301528216604482015260640161038e565b505b61063861197b565b5f610b0a61125b565b606654600160a01b900460ff168015610b325750325f9081526067602052604090205460ff16155b15610b5257604051630f51ed7160e41b815232600482015260240161038e565b67ffffffffffffffff871115610b7b5760405163107c527b60e01b815260040160405180910390fd5b610ba860033360018a8a8a6001600160a01b03168a8a8a6040516020016109429796959493929190612486565b979650505050505050565b5f610bbc61125b565b606654600160a01b900460ff168015610be45750325f9081526067602052604090205460ff16155b15610c0457604051630f51ed7160e41b815232600482015260240161038e565b467f000000000000000000000000000000000000000000000000000000000000000014610c5d576040517fc6ea680300000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b610c9e60033385858080601f0160208091040260200160405190810160405280939291908181526020018383808284375f9201829052509250611799915050565b9392505050565b5f610cae61125b565b606654600160a01b900460ff168015610cd65750325f9081526067602052604090205460ff16155b15610cf657604051630f51ed7160e41b815232600482015260240161038e565b33803b151580610d065750323314155b15610d24575033731111000000000000000000000000000000001111015b5f610d2e846119b8565b6040517fffffffffffffffffffffffffffffffffffffffff000000000000000000000000606085901b16602082015260348101829052909150610d8890600c90339060540160405160208183030381529060405287611799565b949350505050565b5f610d9961125b565b606654600160a01b900460ff168015610dc15750325f9081526067602052604090205460ff16155b15610de157604051630f51ed7160e41b815232600482015260240161038e565b6109c68b8b8b8b8b8b8b8b8b8b611a9d565b6065546040805163cb23bcb560e01b815290515f926001600160a01b03169163cb23bcb59160048083019260209291908290030181865afa158015610e3a573d5f5f3e3d5ffd5b505050506040513d601f19601f82011682018060405250810190610e5e919061240a565b9050336001600160a01b03821614610f17575f816001600160a01b0316638da5cb5b6040518163ffffffff1660e01b8152600401602060405180830381865afa158015610ead573d5f5f3e3d5ffd5b505050506040513d601f19601f82011682018060405250810190610ed1919061240a565b9050336001600160a01b03821614610f1557604051630739600760e01b81523360048201526001600160a01b0380841660248301528216604482015260640161038e565b505b8151835114610f685760405162461bcd60e51b815260206004820152600d60248201527f494e56414c49445f494e50555400000000000000000000000000000000000000604482015260640161038e565b5f5b835181101561105e57828181518110610f8557610f856124e0565b602002602001015160675f868481518110610fa257610fa26124e0565b60200260200101516001600160a01b03166001600160a01b031681526020019081526020015f205f6101000a81548160ff021916908315150217905550838181518110610ff157610ff16124e0565b60200260200101516001600160a01b03167fd9739f45a01ce092c5cdb3d68f63d63d21676b1c6c0b4f9cbc6be4cf5449595a848381518110611035576110356124e0565b602002602001015160405161104e911515815260200190565b60405180910390a2600101610f6a565b50505050565b6065546040805163cb23bcb560e01b815290515f926001600160a01b03169163cb23bcb59160048083019260209291908290030181865afa1580156110ab573d5f5f3e3d5ffd5b505050506040513d601f19601f820116820180604052508101906110cf919061240a565b9050336001600160a01b03821614611188575f816001600160a01b0316638da5cb5b6040518163ffffffff1660e01b8152600401602060405180830381865afa15801561111e573d5f5f3e3d5ffd5b505050506040513d601f19601f82011682018060405250810190611142919061240a565b9050336001600160a01b0382161461118657604051630739600760e01b81523360048201526001600160a01b0380841660248301528216604482015260640161038e565b505b606654600160a01b900460ff161515821515036111e75760405162461bcd60e51b815260206004820152600b60248201527f414c52454144595f534554000000000000000000000000000000000000000000604482015260640161038e565b60668054831515600160a01b027fffffffffffffffffffffff00ffffffffffffffffffffffffffffffffffffffff9091161790556040517f16435b45f7482047f839a6a19d291442627200f52cad2803c595150d0d440eb39061124f90841515815260200190565b60405180910390a15050565b60335460ff16156112ae5760405162461bcd60e51b815260206004820152601060248201527f5061757361626c653a2070617573656400000000000000000000000000000000604482015260640161038e565b565b5f33321480156112bf5750333b155b905090565b5f5f60655f9054906101000a90046001600160a01b03166001600160a01b031663e1758bd86040518163ffffffff1660e01b8152600401602060405180830381865afa158015611316573d5f5f3e3d5ffd5b505050506040513d601f19601f8201168201806040525081019061133a919061240a565b6040517f70a082310000000000000000000000000000000000000000000000000000000081523060048201529091505f906001600160a01b038316906370a0823190602401602060405180830381865afa15801561139a573d5f5f3e3d5ffd5b505050506040513d601f19601f820116820180604052508101906113be91906124f4565b9050838110156113ec575f6113d3828661251f565b90506113ea6001600160a01b038416333084611b8a565b505b6065546001600160a01b03166375d81e258873111100000000000000000000000000000000111189016040517fffffffff0000000000000000000000000000000000000000000000000000000060e085901b16815260ff90921660048301526001600160a01b0316602482015260448101889052606481018790526084016020604051808303815f875af1158015611486573d5f5f3e3d5ffd5b505050506040513d601f19601f82011682018060405250810190610ba891906124f4565b6114b2611bdb565b6033805460ff191690557f5db9ee0a495bf2e6ff9c91a7834c1ba4fdd244a5e8aa4e537bd38aeae4b073aa335b6040516001600160a01b03909116815260200160405180910390a1565b5f54610100900460ff166115785760405162461bcd60e51b815260206004820152602b60248201527f496e697469616c697a61626c653a20636f6e7472616374206973206e6f74206960448201527f6e697469616c697a696e67000000000000000000000000000000000000000000606482015260840161038e565b606580546001600160a01b038085167fffffffffffffffffffffffff000000000000000000000000000000000000000090921691909117909155606680547fffffffffffffffffffffff000000000000000000000000000000000000000000169183169190911790556115e9611c2d565b5050565b80158061167e57506040517fdd62ed3e0000000000000000000000000000000000000000000000000000000081523060048201526001600160a01b03838116602483015284169063dd62ed3e90604401602060405180830381865afa158015611658573d5f5f3e3d5ffd5b505050506040513d601f19601f8201168201806040525081019061167c91906124f4565b155b6116f05760405162461bcd60e51b815260206004820152603660248201527f5361666545524332303a20617070726f76652066726f6d206e6f6e2d7a65726f60448201527f20746f206e6f6e2d7a65726f20616c6c6f77616e636500000000000000000000606482015260840161038e565b6040516001600160a01b0383166024820152604481018290526108959084907f095ea7b300000000000000000000000000000000000000000000000000000000906064015b60408051601f198184030181529190526020810180517bffffffffffffffffffffffffffffffffffffffffffffffffffffffff167fffffffff0000000000000000000000000000000000000000000000000000000090931692909217909152611cb1565b5f7f0000000000000000000000000000000000000000000000000000000000000000835111156118215782516040517f4634691b00000000000000000000000000000000000000000000000000000000815260048101919091527f0000000000000000000000000000000000000000000000000000000000000000602482015260440161038e565b5f61183586868680519060200120866112c4565b9050807fff64905f73a67fb594e0f940a8075a860db489ad991e032f48c81123eb52d60b856040516118679190612560565b60405180910390a295945050505050565b5f5f611883856119b8565b905061188f8688612572565b6118998c8c612589565b6118a39190612589565b811015611905576118b48688612572565b6118be8c8c612589565b6118c89190612589565b6040517f7040b58c00000000000000000000000000000000000000000000000000000000815260048101919091526024810182905260440161038e565b6001600160a01b0389163b1561192f57731111000000000000000000000000000000001111890198505b6001600160a01b0388163b1561195957731111000000000000000000000000000000001111880197505b61196b8c8c8c8c8c8c8c8c8c8c611a9d565b9c9b505050505050505050505050565b61198361125b565b6033805460ff191660011790557f62e78cea01bee320cd4e420270b5ea74000d11b0c9f74754ebdbfc544b05a2586114df3390565b5f5f60655f9054906101000a90046001600160a01b03166001600160a01b031663ad48cb5e6040518163ffffffff1660e01b8152600401602060405180830381865afa158015611a0a573d5f5f3e3d5ffd5b505050506040513d601f19601f82011682018060405250810190611a2e919061259c565b905060128160ff161015611a915777ffffffffffffffffffffffffffffffffffffffffffffffff831115611a91576040517f08083b2a0000000000000000000000000000000000000000000000000000000081526004810184905260240161038e565b610c9e83826012611d95565b5f8560011480611aad5750846001145b15611afa57338b8b868c8c8c8c8c8b8b6040517f07c266e300000000000000000000000000000000000000000000000000000000815260040161038e9b9a999897969594939291906125bc565b67ffffffffffffffff861115611b235760405163107c527b60e01b815260040160405180910390fd5b5f61196b6009338e6001600160a01b03168e611b3e8a6119b8565b8f8f6001600160a01b03168f6001600160a01b03168f8f8e8e90508f8f604051602001611b759b9a99989796959493929190612653565b60405160208183030381529060405288611799565b6040516001600160a01b038085166024830152831660448201526064810182905261105e9085907f23b872dd0000000000000000000000000000000000000000000000000000000090608401611735565b60335460ff166112ae5760405162461bcd60e51b815260206004820152601460248201527f5061757361626c653a206e6f7420706175736564000000000000000000000000604482015260640161038e565b5f54610100900460ff16611ca95760405162461bcd60e51b815260206004820152602b60248201527f496e697469616c697a61626c653a20636f6e7472616374206973206e6f74206960448201527f6e697469616c697a696e67000000000000000000000000000000000000000000606482015260840161038e565b6112ae611dfd565b5f611d05826040518060400160405280602081526020017f5361666545524332303a206c6f772d6c6576656c2063616c6c206661696c6564815250856001600160a01b0316611e859092919063ffffffff16565b8051909150156108955780806020019051810190611d2391906126a7565b6108955760405162461bcd60e51b815260206004820152602a60248201527f5361666545524332303a204552433230206f7065726174696f6e20646964206e60448201527f6f74207375636365656400000000000000000000000000000000000000000000606482015260840161038e565b5f8160ff168360ff1603611daa575082610c9e565b8160ff168360ff161015611dde57611dc283836126c2565b611dcd90600a6127be565b611dd79085612572565b9050610c9e565b611de882846126c2565b611df390600a6127be565b611dd790856127cc565b5f54610100900460ff16611e795760405162461bcd60e51b815260206004820152602b60248201527f496e697469616c697a61626c653a20636f6e7472616374206973206e6f74206960448201527f6e697469616c697a696e67000000000000000000000000000000000000000000606482015260840161038e565b6033805460ff19169055565b6060610d8884845f85856001600160a01b0385163b611ee65760405162461bcd60e51b815260206004820152601d60248201527f416464726573733a2063616c6c20746f206e6f6e2d636f6e7472616374000000604482015260640161038e565b5f5f866001600160a01b03168587604051611f0191906127eb565b5f6040518083038185875af1925050503d805f8114611f3b576040519150601f19603f3d011682016040523d82523d5f602084013e611f40565b606091505b5091509150610ba882828660608315611f5a575081610c9e565b825115611f6a5782518084602001fd5b8160405162461bcd60e51b815260040161038e9190612560565b5f5f83601f840112611f94575f5ffd5b50813567ffffffffffffffff811115611fab575f5ffd5b602083019150836020828501011115611fc2575f5ffd5b9250929050565b5f5f60208385031215611fda575f5ffd5b823567ffffffffffffffff811115611ff0575f5ffd5b611ffc85828601611f84565b90969095509350505050565b6001600160a01b0381168114610638575f5ffd5b5f5f6040838503121561202d575f5ffd5b823561203881612008565b9150602083013561204881612008565b809150509250929050565b5f5f5f5f5f5f5f60c0888a031215612069575f5ffd5b873596506020880135955060408801359450606088013561208981612008565b93506080880135925060a088013567ffffffffffffffff8111156120ab575f5ffd5b6120b78a828b01611f84565b989b979a50959850939692959293505050565b5f5f5f5f5f5f5f5f5f5f6101208b8d0312156120e4575f5ffd5b8a356120ef81612008565b995060208b0135985060408b0135975060608b013561210d81612008565b965060808b013561211d81612008565b955060a08b0135945060c08b0135935060e08b013592506101008b013567ffffffffffffffff81111561214e575f5ffd5b61215a8d828e01611f84565b915080935050809150509295989b9194979a5092959850565b5f5f5f5f5f5f60a08789031215612188575f5ffd5b863595506020870135945060408701356121a181612008565b935060608701359250608087013567ffffffffffffffff8111156121c3575f5ffd5b6121cf89828a01611f84565b979a9699509497509295939492505050565b5f5f604083850312156121f2575f5ffd5b50508035926020909101359150565b5f60208284031215612211575f5ffd5b5035919050565b5f60208284031215612228575f5ffd5b8135610c9e81612008565b634e487b7160e01b5f52604160045260245ffd5b604051601f8201601f1916810167ffffffffffffffff8111828210171561227057612270612233565b604052919050565b5f67ffffffffffffffff82111561229157612291612233565b5060051b60200190565b8015158114610638575f5ffd5b5f82601f8301126122b7575f5ffd5b81356122ca6122c582612278565b612247565b8082825260208201915060208360051b8601019250858311156122eb575f5ffd5b602085015b838110156123115780356123038161229b565b8352602092830192016122f0565b5095945050505050565b5f5f6040838503121561232c575f5ffd5b823567ffffffffffffffff811115612342575f5ffd5b8301601f81018513612352575f5ffd5b80356123606122c582612278565b8082825260208201915060208360051b850101925087831115612381575f5ffd5b6020840193505b828410156123ac57833561239b81612008565b825260209384019390910190612388565b9450505050602083013567ffffffffffffffff8111156123ca575f5ffd5b6123d6858286016122a8565b9150509250929050565b5f602082840312156123f0575f5ffd5b8135610c9e8161229b565b818382375f9101908152919050565b5f6020828403121561241a575f5ffd5b8151610c9e81612008565b7fff000000000000000000000000000000000000000000000000000000000000008960f81b168152876001820152866021820152856041820152846061820152836081820152818360a18301375f910160a101908152979650505050505050565b7fff000000000000000000000000000000000000000000000000000000000000008860f81b168152866001820152856021820152846041820152836061820152818360818301375f91016081019081529695505050505050565b634e487b7160e01b5f52603260045260245ffd5b5f60208284031215612504575f5ffd5b5051919050565b634e487b7160e01b5f52601160045260245ffd5b818103818111156105065761050661250b565b5f81518084528060208401602086015e5f602082860101526020601f19601f83011685010191505092915050565b602081525f610c9e6020830184612532565b80820281158282048414176105065761050661250b565b808201808211156105065761050661250b565b5f602082840312156125ac575f5ffd5b815160ff81168114610c9e575f5ffd5b6001600160a01b038c1681526001600160a01b038b1660208201528960408201528860608201528760808201526001600160a01b03871660a08201526001600160a01b03861660c08201528460e0820152836101008201526101406101208201528161014082015281836101608301375f81830161016090810191909152601f909201601f191601019a9950505050505050505050565b8b81528a60208201528960408201528860608201528760808201528660a08201528560c08201528460e08201528361010082015281836101208301375f9101610120019081529a9950505050505050505050565b5f602082840312156126b7575f5ffd5b8151610c9e8161229b565b60ff82811682821603908111156105065761050661250b565b6001815b6001841115612716578085048111156126fa576126fa61250b565b600184161561270857908102905b60019390931c9280026126df565b935093915050565b5f8261272c57506001610506565b8161273857505f610506565b816001811461274e576002811461275857612774565b6001915050610506565b60ff8411156127695761276961250b565b50506001821b610506565b5060208310610133831016604e8410600b8410161715612797575081810a610506565b6127a35f1984846126db565b805f19048211156127b6576127b661250b565b029392505050565b5f610c9e60ff84168361271e565b5f826127e657634e487b7160e01b5f52601260045260245ffd5b500490565b5f82518060208501845e5f92019182525091905056fea2646970667358221220265f869376b6c520445ee90b23fc3e870282a128759593a36018a4b154b4b55264736f6c634300081c0033
    /// ```
    #[rustfmt::skip]
    #[allow(clippy::all)]
    pub static DEPLOYED_BYTECODE: alloy_sol_types::private::Bytes = alloy_sol_types::private::Bytes::from_static(
        b"`\x80`@R4\x80\x15a\0\x0FW__\xFD[P`\x046\x10a\x01cW_5`\xE0\x1C\x80c\xA6k2}\x11a\0\xC7W\x80c\xE3\xDEr\xA5\x11a\0}W\x80c\xE8\xEB\x1D\xC3\x11a\0cW\x80c\xE8\xEB\x1D\xC3\x14a\x02\xF4W\x80c\xEE5\xF3'\x14a\x03\x1BW\x80c\xEF\xEA\xDBm\x14a\x03.W__\xFD[\x80c\xE3\xDEr\xA5\x14a\x02\xCEW\x80c\xE7\x8C\xEA\x92\x14a\x02\xE1W__\xFD[\x80c\xB7\x90\x92\xFD\x11a\0\xADW\x80c\xB7\x90\x92\xFD\x14a\x02\x86W\x80c\xB9\xB9\xA6\x88\x14a\x02\x99W\x80c\xBA\xBC\xC59\x14a\x02\xACW__\xFD[\x80c\xA6k2}\x14a\x02^W\x80c\xB7T6\xBB\x14a\x02sW__\xFD[\x80cT\x9E\x84&\x11a\x01\x1CW\x80c\x84V\xCBY\x11a\x01\x02W\x80c\x84V\xCBY\x14a\x01\xFFW\x80c\x8Ac\x1A\xA6\x14a\x02\x07W\x80c\x8B2@\xA0\x14a\x02\x1AW__\xFD[\x80cT\x9E\x84&\x14a\x01\xE1W\x80c\\\x97Z\xBB\x14a\x01\xF4W__\xFD[\x80c?K\xA8:\x11a\x01LW\x80c?K\xA8:\x14a\x01\xB1W\x80cH\\\xC9U\x14a\x01\xBBW\x80cPux\x8B\x14a\x01\xCEW__\xFD[\x80c\x1F\xE9'\xCF\x14a\x01gW\x80c\"\xBD\\\x1C\x14a\x01\x8DW[__\xFD[a\x01za\x01u6`\x04a\x1F\xC9V[a\x03AV[`@Q\x90\x81R` \x01[`@Q\x80\x91\x03\x90\xF3[`fTa\x01\xA1\x90`\x01`\xA0\x1B\x90\x04`\xFF\x16\x81V[`@Q\x90\x15\x15\x81R` \x01a\x01\x84V[a\x01\xB9a\x05\x0CV[\0[a\x01\xB9a\x01\xC96`\x04a \x1CV[a\x06;V[a\x01za\x01\xDC6`\x04a SV[a\x08\x9AV[a\x01za\x01\xEF6`\x04a \xCAV[a\tcV[`3T`\xFF\x16a\x01\xA1V[a\x01\xB9a\t\xD5V[a\x01za\x02\x156`\x04a!sV[a\x0B\x01V[\x7F\xB51'hJV\x8B1s\xAE\x13\xB9\xF8\xA6\x01n$>c\xB6\xE8\xEE\x11x\xD6\xA7\x17\x85\x0B]a\x03T`\x01`\x01`\xA0\x1B\x03\x16[`@Q`\x01`\x01`\xA0\x1B\x03\x90\x91\x16\x81R` \x01a\x01\x84V[a\x01za\x02l6`\x04a!\xE1V[_\x92\x91PPV[a\x01za\x02\x816`\x04a\x1F\xC9V[a\x0B\xB3V[a\x01za\x02\x946`\x04a\"\x01V[a\x0C\xA5V[a\x01za\x02\xA76`\x04a \xCAV[a\r\x90V[a\x01\xA1a\x02\xBA6`\x04a\"\x18V[`g` R_\x90\x81R`@\x90 T`\xFF\x16\x81V[a\x01\xB9a\x02\xDC6`\x04a#\x1BV[a\r\xF3V[`eTa\x02F\x90`\x01`\x01`\xA0\x1B\x03\x16\x81V[a\x01z\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81V[`fTa\x02F\x90`\x01`\x01`\xA0\x1B\x03\x16\x81V[a\x01\xB9a\x03<6`\x04a#\xE0V[a\x10dV[_a\x03Ja\x12[V[`fT`\x01`\xA0\x1B\x90\x04`\xFF\x16\x80\x15a\x03rWP2_\x90\x81R`g` R`@\x90 T`\xFF\x16\x15[\x15a\x03\x97W`@Qc\x0FQ\xEDq`\xE4\x1B\x81R2`\x04\x82\x01R`$\x01[`@Q\x80\x91\x03\x90\xFD[F\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x14a\x03\xF0W`@Q\x7F\xC6\xEAh\x03\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[a\x03\xF8a\x12\xB0V[a\x04.W`@Q\x7F\xC8\x95\x8E\xAD\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x82\x11\x15a\x04\xB1W`@Q\x7FF4i\x1B\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x81\x01\x83\x90R\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0`$\x82\x01R`D\x01a\x03\x8EV[_a\x04\xD6`\x033\x86\x86`@Qa\x04\xC8\x92\x91\x90a#\xFBV[`@Q\x80\x91\x03\x90 _a\x12\xC4V[`@Q\x90\x91P\x81\x90\x7F\xABS#\x85\xBE\x8F\x10\x05\xA4\xB6\xBA\x8F\xA2\n\"E\xFA\xCB4a4\xACs\x9F\xE9\xA5\x19\x8D\xC1X\x0B\x9C\x90_\x90\xA2\x90P[\x92\x91PPV[`eT`@\x80Qc\xCB#\xBC\xB5`\xE0\x1B\x81R\x90Q_\x92`\x01`\x01`\xA0\x1B\x03\x16\x91c\xCB#\xBC\xB5\x91`\x04\x80\x83\x01\x92` \x92\x91\x90\x82\x90\x03\x01\x81\x86Z\xFA\x15\x80\x15a\x05SW=__>=_\xFD[PPPP`@Q=`\x1F\x19`\x1F\x82\x01\x16\x82\x01\x80`@RP\x81\x01\x90a\x05w\x91\x90a$\nV[\x90P3`\x01`\x01`\xA0\x1B\x03\x82\x16\x14a\x060W_\x81`\x01`\x01`\xA0\x1B\x03\x16c\x8D\xA5\xCB[`@Q\x81c\xFF\xFF\xFF\xFF\x16`\xE0\x1B\x81R`\x04\x01` `@Q\x80\x83\x03\x81\x86Z\xFA\x15\x80\x15a\x05\xC6W=__>=_\xFD[PPPP`@Q=`\x1F\x19`\x1F\x82\x01\x16\x82\x01\x80`@RP\x81\x01\x90a\x05\xEA\x91\x90a$\nV[\x90P3`\x01`\x01`\xA0\x1B\x03\x82\x16\x14a\x06.W`@Qc\x079`\x07`\xE0\x1B\x81R3`\x04\x82\x01R`\x01`\x01`\xA0\x1B\x03\x80\x84\x16`$\x83\x01R\x82\x16`D\x82\x01R`d\x01a\x03\x8EV[P[a\x068a\x14\xAAV[PV[_Ta\x01\0\x90\x04`\xFF\x16\x15\x80\x80\x15a\x06YWP_T`\x01`\xFF\x90\x91\x16\x10[\x80a\x06rWP0;\x15\x80\x15a\x06rWP_T`\xFF\x16`\x01\x14[a\x06\xE4W`@QbF\x1B\xCD`\xE5\x1B\x81R` `\x04\x82\x01R`.`$\x82\x01R\x7FInitializable: contract is alrea`D\x82\x01R\x7Fdy initialized\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0`d\x82\x01R`\x84\x01a\x03\x8EV[_\x80T`\xFF\x19\x16`\x01\x17\x90U\x80\x15a\x07\x05W_\x80Ta\xFF\0\x19\x16a\x01\0\x17\x90U[`\x01`\x01`\xA0\x1B\x03\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x160\x03a\x07\xA3W`@QbF\x1B\xCD`\xE5\x1B\x81R` `\x04\x82\x01R`,`$\x82\x01R\x7FFunction must be called through `D\x82\x01R\x7Fdelegatecall\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0`d\x82\x01R`\x84\x01a\x03\x8EV[a\x07\xAD\x83\x83a\x14\xFCV[`eT`@\x80Q\x7F\xE1u\x8B\xD8\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R\x90Q_\x92`\x01`\x01`\xA0\x1B\x03\x16\x91c\xE1u\x8B\xD8\x91`\x04\x80\x83\x01\x92` \x92\x91\x90\x82\x90\x03\x01\x81\x86Z\xFA\x15\x80\x15a\x08\rW=__>=_\xFD[PPPP`@Q=`\x1F\x19`\x1F\x82\x01\x16\x82\x01\x80`@RP\x81\x01\x90a\x081\x91\x90a$\nV[`eT\x90\x91Pa\x08O\x90`\x01`\x01`\xA0\x1B\x03\x80\x84\x16\x91\x16_\x19a\x15\xEDV[P\x80\x15a\x08\x95W_\x80Ta\xFF\0\x19\x16\x90U`@Q`\x01\x81R\x7F\x7F&\xB8?\xF9n\x1F+jh/\x138R\xF6y\x8A\t\xC4e\xDA\x95\x92\x14`\xCE\xFB8G@$\x98\x90` \x01`@Q\x80\x91\x03\x90\xA1[PPPV[_a\x08\xA3a\x12[V[`fT`\x01`\xA0\x1B\x90\x04`\xFF\x16\x80\x15a\x08\xCBWP2_\x90\x81R`g` R`@\x90 T`\xFF\x16\x15[\x15a\x08\xEBW`@Qc\x0FQ\xEDq`\xE4\x1B\x81R2`\x04\x82\x01R`$\x01a\x03\x8EV[g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x88\x11\x15a\t\x14W`@Qc\x10|R{`\xE0\x1B\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[a\tW`\x033_\x8B\x8B\x8B\x8B`\x01`\x01`\xA0\x1B\x03\x16\x8B\x8B\x8B`@Q` \x01a\tB\x98\x97\x96\x95\x94\x93\x92\x91\x90a$%V[`@Q` \x81\x83\x03\x03\x81R\x90`@R_a\x17\x99V[\x98\x97PPPPPPPPV[_a\tla\x12[V[`fT`\x01`\xA0\x1B\x90\x04`\xFF\x16\x80\x15a\t\x94WP2_\x90\x81R`g` R`@\x90 T`\xFF\x16\x15[\x15a\t\xB4W`@Qc\x0FQ\xEDq`\xE4\x1B\x81R2`\x04\x82\x01R`$\x01a\x03\x8EV[a\t\xC6\x8B\x8B\x8B\x8B\x8B\x8B\x8B\x8B\x8B\x8Ba\x18xV[\x9B\x9APPPPPPPPPPPV[`eT`@\x80Qc\xCB#\xBC\xB5`\xE0\x1B\x81R\x90Q_\x92`\x01`\x01`\xA0\x1B\x03\x16\x91c\xCB#\xBC\xB5\x91`\x04\x80\x83\x01\x92` \x92\x91\x90\x82\x90\x03\x01\x81\x86Z\xFA\x15\x80\x15a\n\x1CW=__>=_\xFD[PPPP`@Q=`\x1F\x19`\x1F\x82\x01\x16\x82\x01\x80`@RP\x81\x01\x90a\n@\x91\x90a$\nV[\x90P3`\x01`\x01`\xA0\x1B\x03\x82\x16\x14a\n\xF9W_\x81`\x01`\x01`\xA0\x1B\x03\x16c\x8D\xA5\xCB[`@Q\x81c\xFF\xFF\xFF\xFF\x16`\xE0\x1B\x81R`\x04\x01` `@Q\x80\x83\x03\x81\x86Z\xFA\x15\x80\x15a\n\x8FW=__>=_\xFD[PPPP`@Q=`\x1F\x19`\x1F\x82\x01\x16\x82\x01\x80`@RP\x81\x01\x90a\n\xB3\x91\x90a$\nV[\x90P3`\x01`\x01`\xA0\x1B\x03\x82\x16\x14a\n\xF7W`@Qc\x079`\x07`\xE0\x1B\x81R3`\x04\x82\x01R`\x01`\x01`\xA0\x1B\x03\x80\x84\x16`$\x83\x01R\x82\x16`D\x82\x01R`d\x01a\x03\x8EV[P[a\x068a\x19{V[_a\x0B\na\x12[V[`fT`\x01`\xA0\x1B\x90\x04`\xFF\x16\x80\x15a\x0B2WP2_\x90\x81R`g` R`@\x90 T`\xFF\x16\x15[\x15a\x0BRW`@Qc\x0FQ\xEDq`\xE4\x1B\x81R2`\x04\x82\x01R`$\x01a\x03\x8EV[g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x87\x11\x15a\x0B{W`@Qc\x10|R{`\xE0\x1B\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[a\x0B\xA8`\x033`\x01\x8A\x8A\x8A`\x01`\x01`\xA0\x1B\x03\x16\x8A\x8A\x8A`@Q` \x01a\tB\x97\x96\x95\x94\x93\x92\x91\x90a$\x86V[\x97\x96PPPPPPPV[_a\x0B\xBCa\x12[V[`fT`\x01`\xA0\x1B\x90\x04`\xFF\x16\x80\x15a\x0B\xE4WP2_\x90\x81R`g` R`@\x90 T`\xFF\x16\x15[\x15a\x0C\x04W`@Qc\x0FQ\xEDq`\xE4\x1B\x81R2`\x04\x82\x01R`$\x01a\x03\x8EV[F\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x14a\x0C]W`@Q\x7F\xC6\xEAh\x03\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[a\x0C\x9E`\x033\x85\x85\x80\x80`\x1F\x01` \x80\x91\x04\x02` \x01`@Q\x90\x81\x01`@R\x80\x93\x92\x91\x90\x81\x81R` \x01\x83\x83\x80\x82\x847_\x92\x01\x82\x90RP\x92Pa\x17\x99\x91PPV[\x93\x92PPPV[_a\x0C\xAEa\x12[V[`fT`\x01`\xA0\x1B\x90\x04`\xFF\x16\x80\x15a\x0C\xD6WP2_\x90\x81R`g` R`@\x90 T`\xFF\x16\x15[\x15a\x0C\xF6W`@Qc\x0FQ\xEDq`\xE4\x1B\x81R2`\x04\x82\x01R`$\x01a\x03\x8EV[3\x80;\x15\x15\x80a\r\x06WP23\x14\x15[\x15a\r$WP3s\x11\x11\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x11\x11\x01[_a\r.\x84a\x19\xB8V[`@Q\x7F\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\0\0\0\0\0\0\0\0\0\0\0\0``\x85\x90\x1B\x16` \x82\x01R`4\x81\x01\x82\x90R\x90\x91Pa\r\x88\x90`\x0C\x903\x90`T\x01`@Q` \x81\x83\x03\x03\x81R\x90`@R\x87a\x17\x99V[\x94\x93PPPPV[_a\r\x99a\x12[V[`fT`\x01`\xA0\x1B\x90\x04`\xFF\x16\x80\x15a\r\xC1WP2_\x90\x81R`g` R`@\x90 T`\xFF\x16\x15[\x15a\r\xE1W`@Qc\x0FQ\xEDq`\xE4\x1B\x81R2`\x04\x82\x01R`$\x01a\x03\x8EV[a\t\xC6\x8B\x8B\x8B\x8B\x8B\x8B\x8B\x8B\x8B\x8Ba\x1A\x9DV[`eT`@\x80Qc\xCB#\xBC\xB5`\xE0\x1B\x81R\x90Q_\x92`\x01`\x01`\xA0\x1B\x03\x16\x91c\xCB#\xBC\xB5\x91`\x04\x80\x83\x01\x92` \x92\x91\x90\x82\x90\x03\x01\x81\x86Z\xFA\x15\x80\x15a\x0E:W=__>=_\xFD[PPPP`@Q=`\x1F\x19`\x1F\x82\x01\x16\x82\x01\x80`@RP\x81\x01\x90a\x0E^\x91\x90a$\nV[\x90P3`\x01`\x01`\xA0\x1B\x03\x82\x16\x14a\x0F\x17W_\x81`\x01`\x01`\xA0\x1B\x03\x16c\x8D\xA5\xCB[`@Q\x81c\xFF\xFF\xFF\xFF\x16`\xE0\x1B\x81R`\x04\x01` `@Q\x80\x83\x03\x81\x86Z\xFA\x15\x80\x15a\x0E\xADW=__>=_\xFD[PPPP`@Q=`\x1F\x19`\x1F\x82\x01\x16\x82\x01\x80`@RP\x81\x01\x90a\x0E\xD1\x91\x90a$\nV[\x90P3`\x01`\x01`\xA0\x1B\x03\x82\x16\x14a\x0F\x15W`@Qc\x079`\x07`\xE0\x1B\x81R3`\x04\x82\x01R`\x01`\x01`\xA0\x1B\x03\x80\x84\x16`$\x83\x01R\x82\x16`D\x82\x01R`d\x01a\x03\x8EV[P[\x81Q\x83Q\x14a\x0FhW`@QbF\x1B\xCD`\xE5\x1B\x81R` `\x04\x82\x01R`\r`$\x82\x01R\x7FINVALID_INPUT\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0`D\x82\x01R`d\x01a\x03\x8EV[_[\x83Q\x81\x10\x15a\x10^W\x82\x81\x81Q\x81\x10a\x0F\x85Wa\x0F\x85a$\xE0V[` \x02` \x01\x01Q`g_\x86\x84\x81Q\x81\x10a\x0F\xA2Wa\x0F\xA2a$\xE0V[` \x02` \x01\x01Q`\x01`\x01`\xA0\x1B\x03\x16`\x01`\x01`\xA0\x1B\x03\x16\x81R` \x01\x90\x81R` \x01_ _a\x01\0\n\x81T\x81`\xFF\x02\x19\x16\x90\x83\x15\x15\x02\x17\x90UP\x83\x81\x81Q\x81\x10a\x0F\xF1Wa\x0F\xF1a$\xE0V[` \x02` \x01\x01Q`\x01`\x01`\xA0\x1B\x03\x16\x7F\xD9s\x9FE\xA0\x1C\xE0\x92\xC5\xCD\xB3\xD6\x8Fc\xD6=!gk\x1Cl\x0BO\x9C\xBCk\xE4\xCFTIYZ\x84\x83\x81Q\x81\x10a\x105Wa\x105a$\xE0V[` \x02` \x01\x01Q`@Qa\x10N\x91\x15\x15\x81R` \x01\x90V[`@Q\x80\x91\x03\x90\xA2`\x01\x01a\x0FjV[PPPPV[`eT`@\x80Qc\xCB#\xBC\xB5`\xE0\x1B\x81R\x90Q_\x92`\x01`\x01`\xA0\x1B\x03\x16\x91c\xCB#\xBC\xB5\x91`\x04\x80\x83\x01\x92` \x92\x91\x90\x82\x90\x03\x01\x81\x86Z\xFA\x15\x80\x15a\x10\xABW=__>=_\xFD[PPPP`@Q=`\x1F\x19`\x1F\x82\x01\x16\x82\x01\x80`@RP\x81\x01\x90a\x10\xCF\x91\x90a$\nV[\x90P3`\x01`\x01`\xA0\x1B\x03\x82\x16\x14a\x11\x88W_\x81`\x01`\x01`\xA0\x1B\x03\x16c\x8D\xA5\xCB[`@Q\x81c\xFF\xFF\xFF\xFF\x16`\xE0\x1B\x81R`\x04\x01` `@Q\x80\x83\x03\x81\x86Z\xFA\x15\x80\x15a\x11\x1EW=__>=_\xFD[PPPP`@Q=`\x1F\x19`\x1F\x82\x01\x16\x82\x01\x80`@RP\x81\x01\x90a\x11B\x91\x90a$\nV[\x90P3`\x01`\x01`\xA0\x1B\x03\x82\x16\x14a\x11\x86W`@Qc\x079`\x07`\xE0\x1B\x81R3`\x04\x82\x01R`\x01`\x01`\xA0\x1B\x03\x80\x84\x16`$\x83\x01R\x82\x16`D\x82\x01R`d\x01a\x03\x8EV[P[`fT`\x01`\xA0\x1B\x90\x04`\xFF\x16\x15\x15\x82\x15\x15\x03a\x11\xE7W`@QbF\x1B\xCD`\xE5\x1B\x81R` `\x04\x82\x01R`\x0B`$\x82\x01R\x7FALREADY_SET\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0`D\x82\x01R`d\x01a\x03\x8EV[`f\x80T\x83\x15\x15`\x01`\xA0\x1B\x02\x7F\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\0\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x90\x91\x16\x17\x90U`@Q\x7F\x16C[E\xF7H G\xF89\xA6\xA1\x9D)\x14Bbr\0\xF5,\xAD(\x03\xC5\x95\x15\r\rD\x0E\xB3\x90a\x12O\x90\x84\x15\x15\x81R` \x01\x90V[`@Q\x80\x91\x03\x90\xA1PPV[`3T`\xFF\x16\x15a\x12\xAEW`@QbF\x1B\xCD`\xE5\x1B\x81R` `\x04\x82\x01R`\x10`$\x82\x01R\x7FPausable: paused\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0`D\x82\x01R`d\x01a\x03\x8EV[V[_32\x14\x80\x15a\x12\xBFWP3;\x15[\x90P\x90V[__`e_\x90T\x90a\x01\0\n\x90\x04`\x01`\x01`\xA0\x1B\x03\x16`\x01`\x01`\xA0\x1B\x03\x16c\xE1u\x8B\xD8`@Q\x81c\xFF\xFF\xFF\xFF\x16`\xE0\x1B\x81R`\x04\x01` `@Q\x80\x83\x03\x81\x86Z\xFA\x15\x80\x15a\x13\x16W=__>=_\xFD[PPPP`@Q=`\x1F\x19`\x1F\x82\x01\x16\x82\x01\x80`@RP\x81\x01\x90a\x13:\x91\x90a$\nV[`@Q\x7Fp\xA0\x821\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R0`\x04\x82\x01R\x90\x91P_\x90`\x01`\x01`\xA0\x1B\x03\x83\x16\x90cp\xA0\x821\x90`$\x01` `@Q\x80\x83\x03\x81\x86Z\xFA\x15\x80\x15a\x13\x9AW=__>=_\xFD[PPPP`@Q=`\x1F\x19`\x1F\x82\x01\x16\x82\x01\x80`@RP\x81\x01\x90a\x13\xBE\x91\x90a$\xF4V[\x90P\x83\x81\x10\x15a\x13\xECW_a\x13\xD3\x82\x86a%\x1FV[\x90Pa\x13\xEA`\x01`\x01`\xA0\x1B\x03\x84\x1630\x84a\x1B\x8AV[P[`eT`\x01`\x01`\xA0\x1B\x03\x16cu\xD8\x1E%\x88s\x11\x11\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x11\x11\x89\x01`@Q\x7F\xFF\xFF\xFF\xFF\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0`\xE0\x85\x90\x1B\x16\x81R`\xFF\x90\x92\x16`\x04\x83\x01R`\x01`\x01`\xA0\x1B\x03\x16`$\x82\x01R`D\x81\x01\x88\x90R`d\x81\x01\x87\x90R`\x84\x01` `@Q\x80\x83\x03\x81_\x87Z\xF1\x15\x80\x15a\x14\x86W=__>=_\xFD[PPPP`@Q=`\x1F\x19`\x1F\x82\x01\x16\x82\x01\x80`@RP\x81\x01\x90a\x0B\xA8\x91\x90a$\xF4V[a\x14\xB2a\x1B\xDBV[`3\x80T`\xFF\x19\x16\x90U\x7F]\xB9\xEE\nI[\xF2\xE6\xFF\x9C\x91\xA7\x83L\x1B\xA4\xFD\xD2D\xA5\xE8\xAANS{\xD3\x8A\xEA\xE4\xB0s\xAA3[`@Q`\x01`\x01`\xA0\x1B\x03\x90\x91\x16\x81R` \x01`@Q\x80\x91\x03\x90\xA1V[_Ta\x01\0\x90\x04`\xFF\x16a\x15xW`@QbF\x1B\xCD`\xE5\x1B\x81R` `\x04\x82\x01R`+`$\x82\x01R\x7FInitializable: contract is not i`D\x82\x01R\x7Fnitializing\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0`d\x82\x01R`\x84\x01a\x03\x8EV[`e\x80T`\x01`\x01`\xA0\x1B\x03\x80\x85\x16\x7F\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x90\x92\x16\x91\x90\x91\x17\x90\x91U`f\x80T\x7F\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x16\x91\x83\x16\x91\x90\x91\x17\x90Ua\x15\xE9a\x1C-V[PPV[\x80\x15\x80a\x16~WP`@Q\x7F\xDDb\xED>\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R0`\x04\x82\x01R`\x01`\x01`\xA0\x1B\x03\x83\x81\x16`$\x83\x01R\x84\x16\x90c\xDDb\xED>\x90`D\x01` `@Q\x80\x83\x03\x81\x86Z\xFA\x15\x80\x15a\x16XW=__>=_\xFD[PPPP`@Q=`\x1F\x19`\x1F\x82\x01\x16\x82\x01\x80`@RP\x81\x01\x90a\x16|\x91\x90a$\xF4V[\x15[a\x16\xF0W`@QbF\x1B\xCD`\xE5\x1B\x81R` `\x04\x82\x01R`6`$\x82\x01R\x7FSafeERC20: approve from non-zero`D\x82\x01R\x7F to non-zero allowance\0\0\0\0\0\0\0\0\0\0`d\x82\x01R`\x84\x01a\x03\x8EV[`@Q`\x01`\x01`\xA0\x1B\x03\x83\x16`$\x82\x01R`D\x81\x01\x82\x90Ra\x08\x95\x90\x84\x90\x7F\t^\xA7\xB3\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x90`d\x01[`@\x80Q`\x1F\x19\x81\x84\x03\x01\x81R\x91\x90R` \x81\x01\x80Q{\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x7F\xFF\xFF\xFF\xFF\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x90\x93\x16\x92\x90\x92\x17\x90\x91Ra\x1C\xB1V[_\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x83Q\x11\x15a\x18!W\x82Q`@Q\x7FF4i\x1B\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x81\x01\x91\x90\x91R\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0`$\x82\x01R`D\x01a\x03\x8EV[_a\x185\x86\x86\x86\x80Q\x90` \x01 \x86a\x12\xC4V[\x90P\x80\x7F\xFFd\x90_s\xA6\x7F\xB5\x94\xE0\xF9@\xA8\x07Z\x86\r\xB4\x89\xAD\x99\x1E\x03/H\xC8\x11#\xEBR\xD6\x0B\x85`@Qa\x18g\x91\x90a%`V[`@Q\x80\x91\x03\x90\xA2\x95\x94PPPPPV[__a\x18\x83\x85a\x19\xB8V[\x90Pa\x18\x8F\x86\x88a%rV[a\x18\x99\x8C\x8Ca%\x89V[a\x18\xA3\x91\x90a%\x89V[\x81\x10\x15a\x19\x05Wa\x18\xB4\x86\x88a%rV[a\x18\xBE\x8C\x8Ca%\x89V[a\x18\xC8\x91\x90a%\x89V[`@Q\x7Fp@\xB5\x8C\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x81\x01\x91\x90\x91R`$\x81\x01\x82\x90R`D\x01a\x03\x8EV[`\x01`\x01`\xA0\x1B\x03\x89\x16;\x15a\x19/Ws\x11\x11\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x11\x11\x89\x01\x98P[`\x01`\x01`\xA0\x1B\x03\x88\x16;\x15a\x19YWs\x11\x11\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x11\x11\x88\x01\x97P[a\x19k\x8C\x8C\x8C\x8C\x8C\x8C\x8C\x8C\x8C\x8Ca\x1A\x9DV[\x9C\x9BPPPPPPPPPPPPV[a\x19\x83a\x12[V[`3\x80T`\xFF\x19\x16`\x01\x17\x90U\x7Fb\xE7\x8C\xEA\x01\xBE\xE3 \xCDNB\x02p\xB5\xEAt\0\r\x11\xB0\xC9\xF7GT\xEB\xDB\xFCTK\x05\xA2Xa\x14\xDF3\x90V[__`e_\x90T\x90a\x01\0\n\x90\x04`\x01`\x01`\xA0\x1B\x03\x16`\x01`\x01`\xA0\x1B\x03\x16c\xADH\xCB^`@Q\x81c\xFF\xFF\xFF\xFF\x16`\xE0\x1B\x81R`\x04\x01` `@Q\x80\x83\x03\x81\x86Z\xFA\x15\x80\x15a\x1A\nW=__>=_\xFD[PPPP`@Q=`\x1F\x19`\x1F\x82\x01\x16\x82\x01\x80`@RP\x81\x01\x90a\x1A.\x91\x90a%\x9CV[\x90P`\x12\x81`\xFF\x16\x10\x15a\x1A\x91Ww\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x83\x11\x15a\x1A\x91W`@Q\x7F\x08\x08;*\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x81\x01\x84\x90R`$\x01a\x03\x8EV[a\x0C\x9E\x83\x82`\x12a\x1D\x95V[_\x85`\x01\x14\x80a\x1A\xADWP\x84`\x01\x14[\x15a\x1A\xFAW3\x8B\x8B\x86\x8C\x8C\x8C\x8C\x8C\x8B\x8B`@Q\x7F\x07\xC2f\xE3\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01a\x03\x8E\x9B\x9A\x99\x98\x97\x96\x95\x94\x93\x92\x91\x90a%\xBCV[g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x86\x11\x15a\x1B#W`@Qc\x10|R{`\xE0\x1B\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[_a\x19k`\t3\x8E`\x01`\x01`\xA0\x1B\x03\x16\x8Ea\x1B>\x8Aa\x19\xB8V[\x8F\x8F`\x01`\x01`\xA0\x1B\x03\x16\x8F`\x01`\x01`\xA0\x1B\x03\x16\x8F\x8F\x8E\x8E\x90P\x8F\x8F`@Q` \x01a\x1Bu\x9B\x9A\x99\x98\x97\x96\x95\x94\x93\x92\x91\x90a&SV[`@Q` \x81\x83\x03\x03\x81R\x90`@R\x88a\x17\x99V[`@Q`\x01`\x01`\xA0\x1B\x03\x80\x85\x16`$\x83\x01R\x83\x16`D\x82\x01R`d\x81\x01\x82\x90Ra\x10^\x90\x85\x90\x7F#\xB8r\xDD\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x90`\x84\x01a\x175V[`3T`\xFF\x16a\x12\xAEW`@QbF\x1B\xCD`\xE5\x1B\x81R` `\x04\x82\x01R`\x14`$\x82\x01R\x7FPausable: not paused\0\0\0\0\0\0\0\0\0\0\0\0`D\x82\x01R`d\x01a\x03\x8EV[_Ta\x01\0\x90\x04`\xFF\x16a\x1C\xA9W`@QbF\x1B\xCD`\xE5\x1B\x81R` `\x04\x82\x01R`+`$\x82\x01R\x7FInitializable: contract is not i`D\x82\x01R\x7Fnitializing\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0`d\x82\x01R`\x84\x01a\x03\x8EV[a\x12\xAEa\x1D\xFDV[_a\x1D\x05\x82`@Q\x80`@\x01`@R\x80` \x81R` \x01\x7FSafeERC20: low-level call failed\x81RP\x85`\x01`\x01`\xA0\x1B\x03\x16a\x1E\x85\x90\x92\x91\x90c\xFF\xFF\xFF\xFF\x16V[\x80Q\x90\x91P\x15a\x08\x95W\x80\x80` \x01\x90Q\x81\x01\x90a\x1D#\x91\x90a&\xA7V[a\x08\x95W`@QbF\x1B\xCD`\xE5\x1B\x81R` `\x04\x82\x01R`*`$\x82\x01R\x7FSafeERC20: ERC20 operation did n`D\x82\x01R\x7Fot succeed\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0`d\x82\x01R`\x84\x01a\x03\x8EV[_\x81`\xFF\x16\x83`\xFF\x16\x03a\x1D\xAAWP\x82a\x0C\x9EV[\x81`\xFF\x16\x83`\xFF\x16\x10\x15a\x1D\xDEWa\x1D\xC2\x83\x83a&\xC2V[a\x1D\xCD\x90`\na'\xBEV[a\x1D\xD7\x90\x85a%rV[\x90Pa\x0C\x9EV[a\x1D\xE8\x82\x84a&\xC2V[a\x1D\xF3\x90`\na'\xBEV[a\x1D\xD7\x90\x85a'\xCCV[_Ta\x01\0\x90\x04`\xFF\x16a\x1EyW`@QbF\x1B\xCD`\xE5\x1B\x81R` `\x04\x82\x01R`+`$\x82\x01R\x7FInitializable: contract is not i`D\x82\x01R\x7Fnitializing\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0`d\x82\x01R`\x84\x01a\x03\x8EV[`3\x80T`\xFF\x19\x16\x90UV[``a\r\x88\x84\x84_\x85\x85`\x01`\x01`\xA0\x1B\x03\x85\x16;a\x1E\xE6W`@QbF\x1B\xCD`\xE5\x1B\x81R` `\x04\x82\x01R`\x1D`$\x82\x01R\x7FAddress: call to non-contract\0\0\0`D\x82\x01R`d\x01a\x03\x8EV[__\x86`\x01`\x01`\xA0\x1B\x03\x16\x85\x87`@Qa\x1F\x01\x91\x90a'\xEBV[_`@Q\x80\x83\x03\x81\x85\x87Z\xF1\x92PPP=\x80_\x81\x14a\x1F;W`@Q\x91P`\x1F\x19`?=\x01\x16\x82\x01`@R=\x82R=_` \x84\x01>a\x1F@V[``\x91P[P\x91P\x91Pa\x0B\xA8\x82\x82\x86``\x83\x15a\x1FZWP\x81a\x0C\x9EV[\x82Q\x15a\x1FjW\x82Q\x80\x84` \x01\xFD[\x81`@QbF\x1B\xCD`\xE5\x1B\x81R`\x04\x01a\x03\x8E\x91\x90a%`V[__\x83`\x1F\x84\x01\x12a\x1F\x94W__\xFD[P\x815g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x11\x15a\x1F\xABW__\xFD[` \x83\x01\x91P\x83` \x82\x85\x01\x01\x11\x15a\x1F\xC2W__\xFD[\x92P\x92\x90PV[__` \x83\x85\x03\x12\x15a\x1F\xDAW__\xFD[\x825g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x11\x15a\x1F\xF0W__\xFD[a\x1F\xFC\x85\x82\x86\x01a\x1F\x84V[\x90\x96\x90\x95P\x93PPPPV[`\x01`\x01`\xA0\x1B\x03\x81\x16\x81\x14a\x068W__\xFD[__`@\x83\x85\x03\x12\x15a -W__\xFD[\x825a 8\x81a \x08V[\x91P` \x83\x015a H\x81a \x08V[\x80\x91PP\x92P\x92\x90PV[_______`\xC0\x88\x8A\x03\x12\x15a iW__\xFD[\x875\x96P` \x88\x015\x95P`@\x88\x015\x94P``\x88\x015a \x89\x81a \x08V[\x93P`\x80\x88\x015\x92P`\xA0\x88\x015g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x11\x15a \xABW__\xFD[a \xB7\x8A\x82\x8B\x01a\x1F\x84V[\x98\x9B\x97\x9AP\x95\x98P\x93\x96\x92\x95\x92\x93PPPV[__________a\x01 \x8B\x8D\x03\x12\x15a \xE4W__\xFD[\x8A5a \xEF\x81a \x08V[\x99P` \x8B\x015\x98P`@\x8B\x015\x97P``\x8B\x015a!\r\x81a \x08V[\x96P`\x80\x8B\x015a!\x1D\x81a \x08V[\x95P`\xA0\x8B\x015\x94P`\xC0\x8B\x015\x93P`\xE0\x8B\x015\x92Pa\x01\0\x8B\x015g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x11\x15a!NW__\xFD[a!Z\x8D\x82\x8E\x01a\x1F\x84V[\x91P\x80\x93PP\x80\x91PP\x92\x95\x98\x9B\x91\x94\x97\x9AP\x92\x95\x98PV[______`\xA0\x87\x89\x03\x12\x15a!\x88W__\xFD[\x865\x95P` \x87\x015\x94P`@\x87\x015a!\xA1\x81a \x08V[\x93P``\x87\x015\x92P`\x80\x87\x015g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x11\x15a!\xC3W__\xFD[a!\xCF\x89\x82\x8A\x01a\x1F\x84V[\x97\x9A\x96\x99P\x94\x97P\x92\x95\x93\x94\x92PPPV[__`@\x83\x85\x03\x12\x15a!\xF2W__\xFD[PP\x805\x92` \x90\x91\x015\x91PV[_` \x82\x84\x03\x12\x15a\"\x11W__\xFD[P5\x91\x90PV[_` \x82\x84\x03\x12\x15a\"(W__\xFD[\x815a\x0C\x9E\x81a \x08V[cNH{q`\xE0\x1B_R`A`\x04R`$_\xFD[`@Q`\x1F\x82\x01`\x1F\x19\x16\x81\x01g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x11\x82\x82\x10\x17\x15a\"pWa\"pa\"3V[`@R\x91\x90PV[_g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x82\x11\x15a\"\x91Wa\"\x91a\"3V[P`\x05\x1B` \x01\x90V[\x80\x15\x15\x81\x14a\x068W__\xFD[_\x82`\x1F\x83\x01\x12a\"\xB7W__\xFD[\x815a\"\xCAa\"\xC5\x82a\"xV[a\"GV[\x80\x82\x82R` \x82\x01\x91P` \x83`\x05\x1B\x86\x01\x01\x92P\x85\x83\x11\x15a\"\xEBW__\xFD[` \x85\x01[\x83\x81\x10\x15a#\x11W\x805a#\x03\x81a\"\x9BV[\x83R` \x92\x83\x01\x92\x01a\"\xF0V[P\x95\x94PPPPPV[__`@\x83\x85\x03\x12\x15a#,W__\xFD[\x825g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x11\x15a#BW__\xFD[\x83\x01`\x1F\x81\x01\x85\x13a#RW__\xFD[\x805a#`a\"\xC5\x82a\"xV[\x80\x82\x82R` \x82\x01\x91P` \x83`\x05\x1B\x85\x01\x01\x92P\x87\x83\x11\x15a#\x81W__\xFD[` \x84\x01\x93P[\x82\x84\x10\x15a#\xACW\x835a#\x9B\x81a \x08V[\x82R` \x93\x84\x01\x93\x90\x91\x01\x90a#\x88V[\x94PPPP` \x83\x015g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x11\x15a#\xCAW__\xFD[a#\xD6\x85\x82\x86\x01a\"\xA8V[\x91PP\x92P\x92\x90PV[_` \x82\x84\x03\x12\x15a#\xF0W__\xFD[\x815a\x0C\x9E\x81a\"\x9BV[\x81\x83\x827_\x91\x01\x90\x81R\x91\x90PV[_` \x82\x84\x03\x12\x15a$\x1AW__\xFD[\x81Qa\x0C\x9E\x81a \x08V[\x7F\xFF\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x89`\xF8\x1B\x16\x81R\x87`\x01\x82\x01R\x86`!\x82\x01R\x85`A\x82\x01R\x84`a\x82\x01R\x83`\x81\x82\x01R\x81\x83`\xA1\x83\x017_\x91\x01`\xA1\x01\x90\x81R\x97\x96PPPPPPPV[\x7F\xFF\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x88`\xF8\x1B\x16\x81R\x86`\x01\x82\x01R\x85`!\x82\x01R\x84`A\x82\x01R\x83`a\x82\x01R\x81\x83`\x81\x83\x017_\x91\x01`\x81\x01\x90\x81R\x96\x95PPPPPPV[cNH{q`\xE0\x1B_R`2`\x04R`$_\xFD[_` \x82\x84\x03\x12\x15a%\x04W__\xFD[PQ\x91\x90PV[cNH{q`\xE0\x1B_R`\x11`\x04R`$_\xFD[\x81\x81\x03\x81\x81\x11\x15a\x05\x06Wa\x05\x06a%\x0BV[_\x81Q\x80\x84R\x80` \x84\x01` \x86\x01^_` \x82\x86\x01\x01R` `\x1F\x19`\x1F\x83\x01\x16\x85\x01\x01\x91PP\x92\x91PPV[` \x81R_a\x0C\x9E` \x83\x01\x84a%2V[\x80\x82\x02\x81\x15\x82\x82\x04\x84\x14\x17a\x05\x06Wa\x05\x06a%\x0BV[\x80\x82\x01\x80\x82\x11\x15a\x05\x06Wa\x05\x06a%\x0BV[_` \x82\x84\x03\x12\x15a%\xACW__\xFD[\x81Q`\xFF\x81\x16\x81\x14a\x0C\x9EW__\xFD[`\x01`\x01`\xA0\x1B\x03\x8C\x16\x81R`\x01`\x01`\xA0\x1B\x03\x8B\x16` \x82\x01R\x89`@\x82\x01R\x88``\x82\x01R\x87`\x80\x82\x01R`\x01`\x01`\xA0\x1B\x03\x87\x16`\xA0\x82\x01R`\x01`\x01`\xA0\x1B\x03\x86\x16`\xC0\x82\x01R\x84`\xE0\x82\x01R\x83a\x01\0\x82\x01Ra\x01@a\x01 \x82\x01R\x81a\x01@\x82\x01R\x81\x83a\x01`\x83\x017_\x81\x83\x01a\x01`\x90\x81\x01\x91\x90\x91R`\x1F\x90\x92\x01`\x1F\x19\x16\x01\x01\x9A\x99PPPPPPPPPPV[\x8B\x81R\x8A` \x82\x01R\x89`@\x82\x01R\x88``\x82\x01R\x87`\x80\x82\x01R\x86`\xA0\x82\x01R\x85`\xC0\x82\x01R\x84`\xE0\x82\x01R\x83a\x01\0\x82\x01R\x81\x83a\x01 \x83\x017_\x91\x01a\x01 \x01\x90\x81R\x9A\x99PPPPPPPPPPV[_` \x82\x84\x03\x12\x15a&\xB7W__\xFD[\x81Qa\x0C\x9E\x81a\"\x9BV[`\xFF\x82\x81\x16\x82\x82\x16\x03\x90\x81\x11\x15a\x05\x06Wa\x05\x06a%\x0BV[`\x01\x81[`\x01\x84\x11\x15a'\x16W\x80\x85\x04\x81\x11\x15a&\xFAWa&\xFAa%\x0BV[`\x01\x84\x16\x15a'\x08W\x90\x81\x02\x90[`\x01\x93\x90\x93\x1C\x92\x80\x02a&\xDFV[\x93P\x93\x91PPV[_\x82a',WP`\x01a\x05\x06V[\x81a'8WP_a\x05\x06V[\x81`\x01\x81\x14a'NW`\x02\x81\x14a'XWa'tV[`\x01\x91PPa\x05\x06V[`\xFF\x84\x11\x15a'iWa'ia%\x0BV[PP`\x01\x82\x1Ba\x05\x06V[P` \x83\x10a\x013\x83\x10\x16`N\x84\x10`\x0B\x84\x10\x16\x17\x15a'\x97WP\x81\x81\na\x05\x06V[a'\xA3_\x19\x84\x84a&\xDBV[\x80_\x19\x04\x82\x11\x15a'\xB6Wa'\xB6a%\x0BV[\x02\x93\x92PPPV[_a\x0C\x9E`\xFF\x84\x16\x83a'\x1EV[_\x82a'\xE6WcNH{q`\xE0\x1B_R`\x12`\x04R`$_\xFD[P\x04\x90V[_\x82Q\x80` \x85\x01\x84^_\x92\x01\x91\x82RP\x91\x90PV\xFE\xA2dipfsX\"\x12 &_\x86\x93v\xB6\xC5 D^\xE9\x0B#\xFC>\x87\x02\x82\xA1(u\x95\x93\xA3`\x18\xA4\xB1T\xB4\xB5RdsolcC\0\x08\x1C\x003",
    );
    /**Custom error with signature `AmountTooLarge(uint256)` and selector `0x08083b2a`.
```solidity
error AmountTooLarge(uint256 amount);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct AmountTooLarge {
        #[allow(missing_docs)]
        pub amount: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = (
            alloy::sol_types::private::primitives::aliases::U256,
        );
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<AmountTooLarge> for UnderlyingRustTuple<'_> {
            fn from(value: AmountTooLarge) -> Self {
                (value.amount,)
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for AmountTooLarge {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self { amount: tuple.0 }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for AmountTooLarge {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "AmountTooLarge(uint256)";
            const SELECTOR: [u8; 4] = [8u8, 8u8, 59u8, 42u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.amount),
                )
            }
        }
    };
    /**Custom error with signature `DataTooLarge(uint256,uint256)` and selector `0x4634691b`.
```solidity
error DataTooLarge(uint256 dataLength, uint256 maxDataLength);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct DataTooLarge {
        #[allow(missing_docs)]
        pub dataLength: alloy::sol_types::private::primitives::aliases::U256,
        #[allow(missing_docs)]
        pub maxDataLength: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = (
            alloy::sol_types::sol_data::Uint<256>,
            alloy::sol_types::sol_data::Uint<256>,
        );
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = (
            alloy::sol_types::private::primitives::aliases::U256,
            alloy::sol_types::private::primitives::aliases::U256,
        );
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<DataTooLarge> for UnderlyingRustTuple<'_> {
            fn from(value: DataTooLarge) -> Self {
                (value.dataLength, value.maxDataLength)
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for DataTooLarge {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self {
                    dataLength: tuple.0,
                    maxDataLength: tuple.1,
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for DataTooLarge {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "DataTooLarge(uint256,uint256)";
            const SELECTOR: [u8; 4] = [70u8, 52u8, 105u8, 27u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.dataLength),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.maxDataLength),
                )
            }
        }
    };
    /**Custom error with signature `GasLimitTooLarge()` and selector `0x107c527b`.
```solidity
error GasLimitTooLarge();
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct GasLimitTooLarge {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = ();
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = ();
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<GasLimitTooLarge> for UnderlyingRustTuple<'_> {
            fn from(value: GasLimitTooLarge) -> Self {
                ()
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for GasLimitTooLarge {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self {}
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for GasLimitTooLarge {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "GasLimitTooLarge()";
            const SELECTOR: [u8; 4] = [16u8, 124u8, 82u8, 123u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
        }
    };
    /**Custom error with signature `InsufficientSubmissionCost(uint256,uint256)` and selector `0xfadf238a`.
```solidity
error InsufficientSubmissionCost(uint256 expected, uint256 actual);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct InsufficientSubmissionCost {
        #[allow(missing_docs)]
        pub expected: alloy::sol_types::private::primitives::aliases::U256,
        #[allow(missing_docs)]
        pub actual: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = (
            alloy::sol_types::sol_data::Uint<256>,
            alloy::sol_types::sol_data::Uint<256>,
        );
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = (
            alloy::sol_types::private::primitives::aliases::U256,
            alloy::sol_types::private::primitives::aliases::U256,
        );
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<InsufficientSubmissionCost>
        for UnderlyingRustTuple<'_> {
            fn from(value: InsufficientSubmissionCost) -> Self {
                (value.expected, value.actual)
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>>
        for InsufficientSubmissionCost {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self {
                    expected: tuple.0,
                    actual: tuple.1,
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for InsufficientSubmissionCost {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "InsufficientSubmissionCost(uint256,uint256)";
            const SELECTOR: [u8; 4] = [250u8, 223u8, 35u8, 138u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.expected),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.actual),
                )
            }
        }
    };
    /**Custom error with signature `InsufficientValue(uint256,uint256)` and selector `0x7040b58c`.
```solidity
error InsufficientValue(uint256 expected, uint256 actual);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct InsufficientValue {
        #[allow(missing_docs)]
        pub expected: alloy::sol_types::private::primitives::aliases::U256,
        #[allow(missing_docs)]
        pub actual: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = (
            alloy::sol_types::sol_data::Uint<256>,
            alloy::sol_types::sol_data::Uint<256>,
        );
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = (
            alloy::sol_types::private::primitives::aliases::U256,
            alloy::sol_types::private::primitives::aliases::U256,
        );
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<InsufficientValue> for UnderlyingRustTuple<'_> {
            fn from(value: InsufficientValue) -> Self {
                (value.expected, value.actual)
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for InsufficientValue {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self {
                    expected: tuple.0,
                    actual: tuple.1,
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for InsufficientValue {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "InsufficientValue(uint256,uint256)";
            const SELECTOR: [u8; 4] = [112u8, 64u8, 181u8, 140u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.expected),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.actual),
                )
            }
        }
    };
    /**Custom error with signature `L1Forked()` and selector `0xc6ea6803`.
```solidity
error L1Forked();
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct L1Forked {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = ();
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = ();
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<L1Forked> for UnderlyingRustTuple<'_> {
            fn from(value: L1Forked) -> Self {
                ()
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for L1Forked {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self {}
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for L1Forked {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "L1Forked()";
            const SELECTOR: [u8; 4] = [198u8, 234u8, 104u8, 3u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
        }
    };
    /**Custom error with signature `NotAllowedOrigin(address)` and selector `0xf51ed710`.
```solidity
error NotAllowedOrigin(address origin);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct NotAllowedOrigin {
        #[allow(missing_docs)]
        pub origin: alloy::sol_types::private::Address,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Address,);
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = (alloy::sol_types::private::Address,);
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<NotAllowedOrigin> for UnderlyingRustTuple<'_> {
            fn from(value: NotAllowedOrigin) -> Self {
                (value.origin,)
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for NotAllowedOrigin {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self { origin: tuple.0 }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for NotAllowedOrigin {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "NotAllowedOrigin(address)";
            const SELECTOR: [u8; 4] = [245u8, 30u8, 215u8, 16u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.origin,
                    ),
                )
            }
        }
    };
    /**Custom error with signature `NotCodelessOrigin()` and selector `0xc8958ead`.
```solidity
error NotCodelessOrigin();
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct NotCodelessOrigin {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = ();
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = ();
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<NotCodelessOrigin> for UnderlyingRustTuple<'_> {
            fn from(value: NotCodelessOrigin) -> Self {
                ()
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for NotCodelessOrigin {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self {}
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for NotCodelessOrigin {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "NotCodelessOrigin()";
            const SELECTOR: [u8; 4] = [200u8, 149u8, 142u8, 173u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
        }
    };
    /**Custom error with signature `NotRollupOrOwner(address,address,address)` and selector `0x07396007`.
```solidity
error NotRollupOrOwner(address sender, address rollup, address owner);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct NotRollupOrOwner {
        #[allow(missing_docs)]
        pub sender: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub rollup: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub owner: alloy::sol_types::private::Address,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = (
            alloy::sol_types::sol_data::Address,
            alloy::sol_types::sol_data::Address,
            alloy::sol_types::sol_data::Address,
        );
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = (
            alloy::sol_types::private::Address,
            alloy::sol_types::private::Address,
            alloy::sol_types::private::Address,
        );
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<NotRollupOrOwner> for UnderlyingRustTuple<'_> {
            fn from(value: NotRollupOrOwner) -> Self {
                (value.sender, value.rollup, value.owner)
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for NotRollupOrOwner {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self {
                    sender: tuple.0,
                    rollup: tuple.1,
                    owner: tuple.2,
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for NotRollupOrOwner {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "NotRollupOrOwner(address,address,address)";
            const SELECTOR: [u8; 4] = [7u8, 57u8, 96u8, 7u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.sender,
                    ),
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.rollup,
                    ),
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.owner,
                    ),
                )
            }
        }
    };
    /**Custom error with signature `RetryableData(address,address,uint256,uint256,uint256,address,address,uint256,uint256,bytes)` and selector `0x07c266e3`.
```solidity
error RetryableData(address from, address to, uint256 l2CallValue, uint256 deposit, uint256 maxSubmissionCost, address excessFeeRefundAddress, address callValueRefundAddress, uint256 gasLimit, uint256 maxFeePerGas, bytes data);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct RetryableData {
        #[allow(missing_docs)]
        pub from: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub to: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub l2CallValue: alloy::sol_types::private::primitives::aliases::U256,
        #[allow(missing_docs)]
        pub deposit: alloy::sol_types::private::primitives::aliases::U256,
        #[allow(missing_docs)]
        pub maxSubmissionCost: alloy::sol_types::private::primitives::aliases::U256,
        #[allow(missing_docs)]
        pub excessFeeRefundAddress: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub callValueRefundAddress: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub gasLimit: alloy::sol_types::private::primitives::aliases::U256,
        #[allow(missing_docs)]
        pub maxFeePerGas: alloy::sol_types::private::primitives::aliases::U256,
        #[allow(missing_docs)]
        pub data: alloy::sol_types::private::Bytes,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = (
            alloy::sol_types::sol_data::Address,
            alloy::sol_types::sol_data::Address,
            alloy::sol_types::sol_data::Uint<256>,
            alloy::sol_types::sol_data::Uint<256>,
            alloy::sol_types::sol_data::Uint<256>,
            alloy::sol_types::sol_data::Address,
            alloy::sol_types::sol_data::Address,
            alloy::sol_types::sol_data::Uint<256>,
            alloy::sol_types::sol_data::Uint<256>,
            alloy::sol_types::sol_data::Bytes,
        );
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = (
            alloy::sol_types::private::Address,
            alloy::sol_types::private::Address,
            alloy::sol_types::private::primitives::aliases::U256,
            alloy::sol_types::private::primitives::aliases::U256,
            alloy::sol_types::private::primitives::aliases::U256,
            alloy::sol_types::private::Address,
            alloy::sol_types::private::Address,
            alloy::sol_types::private::primitives::aliases::U256,
            alloy::sol_types::private::primitives::aliases::U256,
            alloy::sol_types::private::Bytes,
        );
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<RetryableData> for UnderlyingRustTuple<'_> {
            fn from(value: RetryableData) -> Self {
                (
                    value.from,
                    value.to,
                    value.l2CallValue,
                    value.deposit,
                    value.maxSubmissionCost,
                    value.excessFeeRefundAddress,
                    value.callValueRefundAddress,
                    value.gasLimit,
                    value.maxFeePerGas,
                    value.data,
                )
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for RetryableData {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self {
                    from: tuple.0,
                    to: tuple.1,
                    l2CallValue: tuple.2,
                    deposit: tuple.3,
                    maxSubmissionCost: tuple.4,
                    excessFeeRefundAddress: tuple.5,
                    callValueRefundAddress: tuple.6,
                    gasLimit: tuple.7,
                    maxFeePerGas: tuple.8,
                    data: tuple.9,
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for RetryableData {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "RetryableData(address,address,uint256,uint256,uint256,address,address,uint256,uint256,bytes)";
            const SELECTOR: [u8; 4] = [7u8, 194u8, 102u8, 227u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.from,
                    ),
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.to,
                    ),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.l2CallValue),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.deposit),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.maxSubmissionCost),
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.excessFeeRefundAddress,
                    ),
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.callValueRefundAddress,
                    ),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.gasLimit),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.maxFeePerGas),
                    <alloy::sol_types::sol_data::Bytes as alloy_sol_types::SolType>::tokenize(
                        &self.data,
                    ),
                )
            }
        }
    };
    /**Event with signature `AllowListAddressSet(address,bool)` and selector `0xd9739f45a01ce092c5cdb3d68f63d63d21676b1c6c0b4f9cbc6be4cf5449595a`.
```solidity
event AllowListAddressSet(address indexed user, bool val);
```*/
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    #[derive(Clone)]
    pub struct AllowListAddressSet {
        #[allow(missing_docs)]
        pub user: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub val: bool,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[automatically_derived]
        impl alloy_sol_types::SolEvent for AllowListAddressSet {
            type DataTuple<'a> = (alloy::sol_types::sol_data::Bool,);
            type DataToken<'a> = <Self::DataTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type TopicList = (
                alloy_sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Address,
            );
            const SIGNATURE: &'static str = "AllowListAddressSet(address,bool)";
            const SIGNATURE_HASH: alloy_sol_types::private::B256 = alloy_sol_types::private::B256::new([
                217u8,
                115u8,
                159u8,
                69u8,
                160u8,
                28u8,
                224u8,
                146u8,
                197u8,
                205u8,
                179u8,
                214u8,
                143u8,
                99u8,
                214u8,
                61u8,
                33u8,
                103u8,
                107u8,
                28u8,
                108u8,
                11u8,
                79u8,
                156u8,
                188u8,
                107u8,
                228u8,
                207u8,
                84u8,
                73u8,
                89u8,
                90u8,
            ]);
            const ANONYMOUS: bool = false;
            #[allow(unused_variables)]
            #[inline]
            fn new(
                topics: <Self::TopicList as alloy_sol_types::SolType>::RustType,
                data: <Self::DataTuple<'_> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                Self {
                    user: topics.1,
                    val: data.0,
                }
            }
            #[inline]
            fn check_signature(
                topics: &<Self::TopicList as alloy_sol_types::SolType>::RustType,
            ) -> alloy_sol_types::Result<()> {
                if topics.0 != Self::SIGNATURE_HASH {
                    return Err(
                        alloy_sol_types::Error::invalid_event_signature_hash(
                            Self::SIGNATURE,
                            topics.0,
                            Self::SIGNATURE_HASH,
                        ),
                    );
                }
                Ok(())
            }
            #[inline]
            fn tokenize_body(&self) -> Self::DataToken<'_> {
                (
                    <alloy::sol_types::sol_data::Bool as alloy_sol_types::SolType>::tokenize(
                        &self.val,
                    ),
                )
            }
            #[inline]
            fn topics(&self) -> <Self::TopicList as alloy_sol_types::SolType>::RustType {
                (Self::SIGNATURE_HASH.into(), self.user.clone())
            }
            #[inline]
            fn encode_topics_raw(
                &self,
                out: &mut [alloy_sol_types::abi::token::WordToken],
            ) -> alloy_sol_types::Result<()> {
                if out.len() < <Self::TopicList as alloy_sol_types::TopicList>::COUNT {
                    return Err(alloy_sol_types::Error::Overrun);
                }
                out[0usize] = alloy_sol_types::abi::token::WordToken(
                    Self::SIGNATURE_HASH,
                );
                out[1usize] = <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::encode_topic(
                    &self.user,
                );
                Ok(())
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::private::IntoLogData for AllowListAddressSet {
            fn to_log_data(&self) -> alloy_sol_types::private::LogData {
                From::from(self)
            }
            fn into_log_data(self) -> alloy_sol_types::private::LogData {
                From::from(&self)
            }
        }
        #[automatically_derived]
        impl From<&AllowListAddressSet> for alloy_sol_types::private::LogData {
            #[inline]
            fn from(this: &AllowListAddressSet) -> alloy_sol_types::private::LogData {
                alloy_sol_types::SolEvent::encode_log_data(this)
            }
        }
    };
    /**Event with signature `AllowListEnabledUpdated(bool)` and selector `0x16435b45f7482047f839a6a19d291442627200f52cad2803c595150d0d440eb3`.
```solidity
event AllowListEnabledUpdated(bool isEnabled);
```*/
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    #[derive(Clone)]
    pub struct AllowListEnabledUpdated {
        #[allow(missing_docs)]
        pub isEnabled: bool,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[automatically_derived]
        impl alloy_sol_types::SolEvent for AllowListEnabledUpdated {
            type DataTuple<'a> = (alloy::sol_types::sol_data::Bool,);
            type DataToken<'a> = <Self::DataTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type TopicList = (alloy_sol_types::sol_data::FixedBytes<32>,);
            const SIGNATURE: &'static str = "AllowListEnabledUpdated(bool)";
            const SIGNATURE_HASH: alloy_sol_types::private::B256 = alloy_sol_types::private::B256::new([
                22u8,
                67u8,
                91u8,
                69u8,
                247u8,
                72u8,
                32u8,
                71u8,
                248u8,
                57u8,
                166u8,
                161u8,
                157u8,
                41u8,
                20u8,
                66u8,
                98u8,
                114u8,
                0u8,
                245u8,
                44u8,
                173u8,
                40u8,
                3u8,
                197u8,
                149u8,
                21u8,
                13u8,
                13u8,
                68u8,
                14u8,
                179u8,
            ]);
            const ANONYMOUS: bool = false;
            #[allow(unused_variables)]
            #[inline]
            fn new(
                topics: <Self::TopicList as alloy_sol_types::SolType>::RustType,
                data: <Self::DataTuple<'_> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                Self { isEnabled: data.0 }
            }
            #[inline]
            fn check_signature(
                topics: &<Self::TopicList as alloy_sol_types::SolType>::RustType,
            ) -> alloy_sol_types::Result<()> {
                if topics.0 != Self::SIGNATURE_HASH {
                    return Err(
                        alloy_sol_types::Error::invalid_event_signature_hash(
                            Self::SIGNATURE,
                            topics.0,
                            Self::SIGNATURE_HASH,
                        ),
                    );
                }
                Ok(())
            }
            #[inline]
            fn tokenize_body(&self) -> Self::DataToken<'_> {
                (
                    <alloy::sol_types::sol_data::Bool as alloy_sol_types::SolType>::tokenize(
                        &self.isEnabled,
                    ),
                )
            }
            #[inline]
            fn topics(&self) -> <Self::TopicList as alloy_sol_types::SolType>::RustType {
                (Self::SIGNATURE_HASH.into(),)
            }
            #[inline]
            fn encode_topics_raw(
                &self,
                out: &mut [alloy_sol_types::abi::token::WordToken],
            ) -> alloy_sol_types::Result<()> {
                if out.len() < <Self::TopicList as alloy_sol_types::TopicList>::COUNT {
                    return Err(alloy_sol_types::Error::Overrun);
                }
                out[0usize] = alloy_sol_types::abi::token::WordToken(
                    Self::SIGNATURE_HASH,
                );
                Ok(())
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::private::IntoLogData for AllowListEnabledUpdated {
            fn to_log_data(&self) -> alloy_sol_types::private::LogData {
                From::from(self)
            }
            fn into_log_data(self) -> alloy_sol_types::private::LogData {
                From::from(&self)
            }
        }
        #[automatically_derived]
        impl From<&AllowListEnabledUpdated> for alloy_sol_types::private::LogData {
            #[inline]
            fn from(
                this: &AllowListEnabledUpdated,
            ) -> alloy_sol_types::private::LogData {
                alloy_sol_types::SolEvent::encode_log_data(this)
            }
        }
    };
    /**Event with signature `InboxMessageDelivered(uint256,bytes)` and selector `0xff64905f73a67fb594e0f940a8075a860db489ad991e032f48c81123eb52d60b`.
```solidity
event InboxMessageDelivered(uint256 indexed messageNum, bytes data);
```*/
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    #[derive(Clone)]
    pub struct InboxMessageDelivered {
        #[allow(missing_docs)]
        pub messageNum: alloy::sol_types::private::primitives::aliases::U256,
        #[allow(missing_docs)]
        pub data: alloy::sol_types::private::Bytes,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[automatically_derived]
        impl alloy_sol_types::SolEvent for InboxMessageDelivered {
            type DataTuple<'a> = (alloy::sol_types::sol_data::Bytes,);
            type DataToken<'a> = <Self::DataTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type TopicList = (
                alloy_sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Uint<256>,
            );
            const SIGNATURE: &'static str = "InboxMessageDelivered(uint256,bytes)";
            const SIGNATURE_HASH: alloy_sol_types::private::B256 = alloy_sol_types::private::B256::new([
                255u8,
                100u8,
                144u8,
                95u8,
                115u8,
                166u8,
                127u8,
                181u8,
                148u8,
                224u8,
                249u8,
                64u8,
                168u8,
                7u8,
                90u8,
                134u8,
                13u8,
                180u8,
                137u8,
                173u8,
                153u8,
                30u8,
                3u8,
                47u8,
                72u8,
                200u8,
                17u8,
                35u8,
                235u8,
                82u8,
                214u8,
                11u8,
            ]);
            const ANONYMOUS: bool = false;
            #[allow(unused_variables)]
            #[inline]
            fn new(
                topics: <Self::TopicList as alloy_sol_types::SolType>::RustType,
                data: <Self::DataTuple<'_> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                Self {
                    messageNum: topics.1,
                    data: data.0,
                }
            }
            #[inline]
            fn check_signature(
                topics: &<Self::TopicList as alloy_sol_types::SolType>::RustType,
            ) -> alloy_sol_types::Result<()> {
                if topics.0 != Self::SIGNATURE_HASH {
                    return Err(
                        alloy_sol_types::Error::invalid_event_signature_hash(
                            Self::SIGNATURE,
                            topics.0,
                            Self::SIGNATURE_HASH,
                        ),
                    );
                }
                Ok(())
            }
            #[inline]
            fn tokenize_body(&self) -> Self::DataToken<'_> {
                (
                    <alloy::sol_types::sol_data::Bytes as alloy_sol_types::SolType>::tokenize(
                        &self.data,
                    ),
                )
            }
            #[inline]
            fn topics(&self) -> <Self::TopicList as alloy_sol_types::SolType>::RustType {
                (Self::SIGNATURE_HASH.into(), self.messageNum.clone())
            }
            #[inline]
            fn encode_topics_raw(
                &self,
                out: &mut [alloy_sol_types::abi::token::WordToken],
            ) -> alloy_sol_types::Result<()> {
                if out.len() < <Self::TopicList as alloy_sol_types::TopicList>::COUNT {
                    return Err(alloy_sol_types::Error::Overrun);
                }
                out[0usize] = alloy_sol_types::abi::token::WordToken(
                    Self::SIGNATURE_HASH,
                );
                out[1usize] = <alloy::sol_types::sol_data::Uint<
                    256,
                > as alloy_sol_types::EventTopic>::encode_topic(&self.messageNum);
                Ok(())
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::private::IntoLogData for InboxMessageDelivered {
            fn to_log_data(&self) -> alloy_sol_types::private::LogData {
                From::from(self)
            }
            fn into_log_data(self) -> alloy_sol_types::private::LogData {
                From::from(&self)
            }
        }
        #[automatically_derived]
        impl From<&InboxMessageDelivered> for alloy_sol_types::private::LogData {
            #[inline]
            fn from(this: &InboxMessageDelivered) -> alloy_sol_types::private::LogData {
                alloy_sol_types::SolEvent::encode_log_data(this)
            }
        }
    };
    /**Event with signature `InboxMessageDeliveredFromOrigin(uint256)` and selector `0xab532385be8f1005a4b6ba8fa20a2245facb346134ac739fe9a5198dc1580b9c`.
```solidity
event InboxMessageDeliveredFromOrigin(uint256 indexed messageNum);
```*/
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    #[derive(Clone)]
    pub struct InboxMessageDeliveredFromOrigin {
        #[allow(missing_docs)]
        pub messageNum: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[automatically_derived]
        impl alloy_sol_types::SolEvent for InboxMessageDeliveredFromOrigin {
            type DataTuple<'a> = ();
            type DataToken<'a> = <Self::DataTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type TopicList = (
                alloy_sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Uint<256>,
            );
            const SIGNATURE: &'static str = "InboxMessageDeliveredFromOrigin(uint256)";
            const SIGNATURE_HASH: alloy_sol_types::private::B256 = alloy_sol_types::private::B256::new([
                171u8,
                83u8,
                35u8,
                133u8,
                190u8,
                143u8,
                16u8,
                5u8,
                164u8,
                182u8,
                186u8,
                143u8,
                162u8,
                10u8,
                34u8,
                69u8,
                250u8,
                203u8,
                52u8,
                97u8,
                52u8,
                172u8,
                115u8,
                159u8,
                233u8,
                165u8,
                25u8,
                141u8,
                193u8,
                88u8,
                11u8,
                156u8,
            ]);
            const ANONYMOUS: bool = false;
            #[allow(unused_variables)]
            #[inline]
            fn new(
                topics: <Self::TopicList as alloy_sol_types::SolType>::RustType,
                data: <Self::DataTuple<'_> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                Self { messageNum: topics.1 }
            }
            #[inline]
            fn check_signature(
                topics: &<Self::TopicList as alloy_sol_types::SolType>::RustType,
            ) -> alloy_sol_types::Result<()> {
                if topics.0 != Self::SIGNATURE_HASH {
                    return Err(
                        alloy_sol_types::Error::invalid_event_signature_hash(
                            Self::SIGNATURE,
                            topics.0,
                            Self::SIGNATURE_HASH,
                        ),
                    );
                }
                Ok(())
            }
            #[inline]
            fn tokenize_body(&self) -> Self::DataToken<'_> {
                ()
            }
            #[inline]
            fn topics(&self) -> <Self::TopicList as alloy_sol_types::SolType>::RustType {
                (Self::SIGNATURE_HASH.into(), self.messageNum.clone())
            }
            #[inline]
            fn encode_topics_raw(
                &self,
                out: &mut [alloy_sol_types::abi::token::WordToken],
            ) -> alloy_sol_types::Result<()> {
                if out.len() < <Self::TopicList as alloy_sol_types::TopicList>::COUNT {
                    return Err(alloy_sol_types::Error::Overrun);
                }
                out[0usize] = alloy_sol_types::abi::token::WordToken(
                    Self::SIGNATURE_HASH,
                );
                out[1usize] = <alloy::sol_types::sol_data::Uint<
                    256,
                > as alloy_sol_types::EventTopic>::encode_topic(&self.messageNum);
                Ok(())
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::private::IntoLogData for InboxMessageDeliveredFromOrigin {
            fn to_log_data(&self) -> alloy_sol_types::private::LogData {
                From::from(self)
            }
            fn into_log_data(self) -> alloy_sol_types::private::LogData {
                From::from(&self)
            }
        }
        #[automatically_derived]
        impl From<&InboxMessageDeliveredFromOrigin>
        for alloy_sol_types::private::LogData {
            #[inline]
            fn from(
                this: &InboxMessageDeliveredFromOrigin,
            ) -> alloy_sol_types::private::LogData {
                alloy_sol_types::SolEvent::encode_log_data(this)
            }
        }
    };
    /**Event with signature `Initialized(uint8)` and selector `0x7f26b83ff96e1f2b6a682f133852f6798a09c465da95921460cefb3847402498`.
```solidity
event Initialized(uint8 version);
```*/
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    #[derive(Clone)]
    pub struct Initialized {
        #[allow(missing_docs)]
        pub version: u8,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[automatically_derived]
        impl alloy_sol_types::SolEvent for Initialized {
            type DataTuple<'a> = (alloy::sol_types::sol_data::Uint<8>,);
            type DataToken<'a> = <Self::DataTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type TopicList = (alloy_sol_types::sol_data::FixedBytes<32>,);
            const SIGNATURE: &'static str = "Initialized(uint8)";
            const SIGNATURE_HASH: alloy_sol_types::private::B256 = alloy_sol_types::private::B256::new([
                127u8,
                38u8,
                184u8,
                63u8,
                249u8,
                110u8,
                31u8,
                43u8,
                106u8,
                104u8,
                47u8,
                19u8,
                56u8,
                82u8,
                246u8,
                121u8,
                138u8,
                9u8,
                196u8,
                101u8,
                218u8,
                149u8,
                146u8,
                20u8,
                96u8,
                206u8,
                251u8,
                56u8,
                71u8,
                64u8,
                36u8,
                152u8,
            ]);
            const ANONYMOUS: bool = false;
            #[allow(unused_variables)]
            #[inline]
            fn new(
                topics: <Self::TopicList as alloy_sol_types::SolType>::RustType,
                data: <Self::DataTuple<'_> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                Self { version: data.0 }
            }
            #[inline]
            fn check_signature(
                topics: &<Self::TopicList as alloy_sol_types::SolType>::RustType,
            ) -> alloy_sol_types::Result<()> {
                if topics.0 != Self::SIGNATURE_HASH {
                    return Err(
                        alloy_sol_types::Error::invalid_event_signature_hash(
                            Self::SIGNATURE,
                            topics.0,
                            Self::SIGNATURE_HASH,
                        ),
                    );
                }
                Ok(())
            }
            #[inline]
            fn tokenize_body(&self) -> Self::DataToken<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        8,
                    > as alloy_sol_types::SolType>::tokenize(&self.version),
                )
            }
            #[inline]
            fn topics(&self) -> <Self::TopicList as alloy_sol_types::SolType>::RustType {
                (Self::SIGNATURE_HASH.into(),)
            }
            #[inline]
            fn encode_topics_raw(
                &self,
                out: &mut [alloy_sol_types::abi::token::WordToken],
            ) -> alloy_sol_types::Result<()> {
                if out.len() < <Self::TopicList as alloy_sol_types::TopicList>::COUNT {
                    return Err(alloy_sol_types::Error::Overrun);
                }
                out[0usize] = alloy_sol_types::abi::token::WordToken(
                    Self::SIGNATURE_HASH,
                );
                Ok(())
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::private::IntoLogData for Initialized {
            fn to_log_data(&self) -> alloy_sol_types::private::LogData {
                From::from(self)
            }
            fn into_log_data(self) -> alloy_sol_types::private::LogData {
                From::from(&self)
            }
        }
        #[automatically_derived]
        impl From<&Initialized> for alloy_sol_types::private::LogData {
            #[inline]
            fn from(this: &Initialized) -> alloy_sol_types::private::LogData {
                alloy_sol_types::SolEvent::encode_log_data(this)
            }
        }
    };
    /**Event with signature `Paused(address)` and selector `0x62e78cea01bee320cd4e420270b5ea74000d11b0c9f74754ebdbfc544b05a258`.
```solidity
event Paused(address account);
```*/
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    #[derive(Clone)]
    pub struct Paused {
        #[allow(missing_docs)]
        pub account: alloy::sol_types::private::Address,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[automatically_derived]
        impl alloy_sol_types::SolEvent for Paused {
            type DataTuple<'a> = (alloy::sol_types::sol_data::Address,);
            type DataToken<'a> = <Self::DataTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type TopicList = (alloy_sol_types::sol_data::FixedBytes<32>,);
            const SIGNATURE: &'static str = "Paused(address)";
            const SIGNATURE_HASH: alloy_sol_types::private::B256 = alloy_sol_types::private::B256::new([
                98u8,
                231u8,
                140u8,
                234u8,
                1u8,
                190u8,
                227u8,
                32u8,
                205u8,
                78u8,
                66u8,
                2u8,
                112u8,
                181u8,
                234u8,
                116u8,
                0u8,
                13u8,
                17u8,
                176u8,
                201u8,
                247u8,
                71u8,
                84u8,
                235u8,
                219u8,
                252u8,
                84u8,
                75u8,
                5u8,
                162u8,
                88u8,
            ]);
            const ANONYMOUS: bool = false;
            #[allow(unused_variables)]
            #[inline]
            fn new(
                topics: <Self::TopicList as alloy_sol_types::SolType>::RustType,
                data: <Self::DataTuple<'_> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                Self { account: data.0 }
            }
            #[inline]
            fn check_signature(
                topics: &<Self::TopicList as alloy_sol_types::SolType>::RustType,
            ) -> alloy_sol_types::Result<()> {
                if topics.0 != Self::SIGNATURE_HASH {
                    return Err(
                        alloy_sol_types::Error::invalid_event_signature_hash(
                            Self::SIGNATURE,
                            topics.0,
                            Self::SIGNATURE_HASH,
                        ),
                    );
                }
                Ok(())
            }
            #[inline]
            fn tokenize_body(&self) -> Self::DataToken<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.account,
                    ),
                )
            }
            #[inline]
            fn topics(&self) -> <Self::TopicList as alloy_sol_types::SolType>::RustType {
                (Self::SIGNATURE_HASH.into(),)
            }
            #[inline]
            fn encode_topics_raw(
                &self,
                out: &mut [alloy_sol_types::abi::token::WordToken],
            ) -> alloy_sol_types::Result<()> {
                if out.len() < <Self::TopicList as alloy_sol_types::TopicList>::COUNT {
                    return Err(alloy_sol_types::Error::Overrun);
                }
                out[0usize] = alloy_sol_types::abi::token::WordToken(
                    Self::SIGNATURE_HASH,
                );
                Ok(())
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::private::IntoLogData for Paused {
            fn to_log_data(&self) -> alloy_sol_types::private::LogData {
                From::from(self)
            }
            fn into_log_data(self) -> alloy_sol_types::private::LogData {
                From::from(&self)
            }
        }
        #[automatically_derived]
        impl From<&Paused> for alloy_sol_types::private::LogData {
            #[inline]
            fn from(this: &Paused) -> alloy_sol_types::private::LogData {
                alloy_sol_types::SolEvent::encode_log_data(this)
            }
        }
    };
    /**Event with signature `Unpaused(address)` and selector `0x5db9ee0a495bf2e6ff9c91a7834c1ba4fdd244a5e8aa4e537bd38aeae4b073aa`.
```solidity
event Unpaused(address account);
```*/
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    #[derive(Clone)]
    pub struct Unpaused {
        #[allow(missing_docs)]
        pub account: alloy::sol_types::private::Address,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[automatically_derived]
        impl alloy_sol_types::SolEvent for Unpaused {
            type DataTuple<'a> = (alloy::sol_types::sol_data::Address,);
            type DataToken<'a> = <Self::DataTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type TopicList = (alloy_sol_types::sol_data::FixedBytes<32>,);
            const SIGNATURE: &'static str = "Unpaused(address)";
            const SIGNATURE_HASH: alloy_sol_types::private::B256 = alloy_sol_types::private::B256::new([
                93u8,
                185u8,
                238u8,
                10u8,
                73u8,
                91u8,
                242u8,
                230u8,
                255u8,
                156u8,
                145u8,
                167u8,
                131u8,
                76u8,
                27u8,
                164u8,
                253u8,
                210u8,
                68u8,
                165u8,
                232u8,
                170u8,
                78u8,
                83u8,
                123u8,
                211u8,
                138u8,
                234u8,
                228u8,
                176u8,
                115u8,
                170u8,
            ]);
            const ANONYMOUS: bool = false;
            #[allow(unused_variables)]
            #[inline]
            fn new(
                topics: <Self::TopicList as alloy_sol_types::SolType>::RustType,
                data: <Self::DataTuple<'_> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                Self { account: data.0 }
            }
            #[inline]
            fn check_signature(
                topics: &<Self::TopicList as alloy_sol_types::SolType>::RustType,
            ) -> alloy_sol_types::Result<()> {
                if topics.0 != Self::SIGNATURE_HASH {
                    return Err(
                        alloy_sol_types::Error::invalid_event_signature_hash(
                            Self::SIGNATURE,
                            topics.0,
                            Self::SIGNATURE_HASH,
                        ),
                    );
                }
                Ok(())
            }
            #[inline]
            fn tokenize_body(&self) -> Self::DataToken<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.account,
                    ),
                )
            }
            #[inline]
            fn topics(&self) -> <Self::TopicList as alloy_sol_types::SolType>::RustType {
                (Self::SIGNATURE_HASH.into(),)
            }
            #[inline]
            fn encode_topics_raw(
                &self,
                out: &mut [alloy_sol_types::abi::token::WordToken],
            ) -> alloy_sol_types::Result<()> {
                if out.len() < <Self::TopicList as alloy_sol_types::TopicList>::COUNT {
                    return Err(alloy_sol_types::Error::Overrun);
                }
                out[0usize] = alloy_sol_types::abi::token::WordToken(
                    Self::SIGNATURE_HASH,
                );
                Ok(())
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::private::IntoLogData for Unpaused {
            fn to_log_data(&self) -> alloy_sol_types::private::LogData {
                From::from(self)
            }
            fn into_log_data(self) -> alloy_sol_types::private::LogData {
                From::from(&self)
            }
        }
        #[automatically_derived]
        impl From<&Unpaused> for alloy_sol_types::private::LogData {
            #[inline]
            fn from(this: &Unpaused) -> alloy_sol_types::private::LogData {
                alloy_sol_types::SolEvent::encode_log_data(this)
            }
        }
    };
    /**Constructor`.
```solidity
constructor(uint256 _maxDataSize);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct constructorCall {
        #[allow(missing_docs)]
        pub _maxDataSize: alloy::sol_types::private::primitives::aliases::U256,
    }
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<constructorCall> for UnderlyingRustTuple<'_> {
                fn from(value: constructorCall) -> Self {
                    (value._maxDataSize,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for constructorCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _maxDataSize: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolConstructor for constructorCall {
            type Parameters<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self._maxDataSize),
                )
            }
        }
    };
    /**Function with signature `allowListEnabled()` and selector `0x22bd5c1c`.
```solidity
function allowListEnabled() external view returns (bool);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct allowListEnabledCall {}
    ///Container type for the return parameters of the [`allowListEnabled()`](allowListEnabledCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct allowListEnabledReturn {
        #[allow(missing_docs)]
        pub _0: bool,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<allowListEnabledCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: allowListEnabledCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for allowListEnabledCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Bool,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (bool,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<allowListEnabledReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: allowListEnabledReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for allowListEnabledReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for allowListEnabledCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = allowListEnabledReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Bool,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "allowListEnabled()";
            const SELECTOR: [u8; 4] = [34u8, 189u8, 92u8, 28u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `bridge()` and selector `0xe78cea92`.
```solidity
function bridge() external view returns (address);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct bridgeCall {}
    ///Container type for the return parameters of the [`bridge()`](bridgeCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct bridgeReturn {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::Address,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<bridgeCall> for UnderlyingRustTuple<'_> {
                fn from(value: bridgeCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for bridgeCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Address,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::Address,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<bridgeReturn> for UnderlyingRustTuple<'_> {
                fn from(value: bridgeReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for bridgeReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for bridgeCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = bridgeReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Address,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "bridge()";
            const SELECTOR: [u8; 4] = [231u8, 140u8, 234u8, 146u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `calculateRetryableSubmissionFee(uint256,uint256)` and selector `0xa66b327d`.
```solidity
function calculateRetryableSubmissionFee(uint256, uint256) external pure returns (uint256);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct calculateRetryableSubmissionFeeCall {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::primitives::aliases::U256,
        #[allow(missing_docs)]
        pub _1: alloy::sol_types::private::primitives::aliases::U256,
    }
    ///Container type for the return parameters of the [`calculateRetryableSubmissionFee(uint256,uint256)`](calculateRetryableSubmissionFeeCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct calculateRetryableSubmissionFeeReturn {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Uint<256>,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<calculateRetryableSubmissionFeeCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: calculateRetryableSubmissionFeeCall) -> Self {
                    (value._0, value._1)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for calculateRetryableSubmissionFeeCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0, _1: tuple.1 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<calculateRetryableSubmissionFeeReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: calculateRetryableSubmissionFeeReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for calculateRetryableSubmissionFeeReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for calculateRetryableSubmissionFeeCall {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Uint<256>,
            );
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = calculateRetryableSubmissionFeeReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "calculateRetryableSubmissionFee(uint256,uint256)";
            const SELECTOR: [u8; 4] = [166u8, 107u8, 50u8, 125u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self._0),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self._1),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `createRetryableTicket(address,uint256,uint256,address,address,uint256,uint256,uint256,bytes)` and selector `0x549e8426`.
```solidity
function createRetryableTicket(address to, uint256 l2CallValue, uint256 maxSubmissionCost, address excessFeeRefundAddress, address callValueRefundAddress, uint256 gasLimit, uint256 maxFeePerGas, uint256 tokenTotalFeeAmount, bytes memory data) external returns (uint256);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct createRetryableTicketCall {
        #[allow(missing_docs)]
        pub to: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub l2CallValue: alloy::sol_types::private::primitives::aliases::U256,
        #[allow(missing_docs)]
        pub maxSubmissionCost: alloy::sol_types::private::primitives::aliases::U256,
        #[allow(missing_docs)]
        pub excessFeeRefundAddress: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub callValueRefundAddress: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub gasLimit: alloy::sol_types::private::primitives::aliases::U256,
        #[allow(missing_docs)]
        pub maxFeePerGas: alloy::sol_types::private::primitives::aliases::U256,
        #[allow(missing_docs)]
        pub tokenTotalFeeAmount: alloy::sol_types::private::primitives::aliases::U256,
        #[allow(missing_docs)]
        pub data: alloy::sol_types::private::Bytes,
    }
    ///Container type for the return parameters of the [`createRetryableTicket(address,uint256,uint256,address,address,uint256,uint256,uint256,bytes)`](createRetryableTicketCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct createRetryableTicketReturn {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Bytes,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::Address,
                alloy::sol_types::private::primitives::aliases::U256,
                alloy::sol_types::private::primitives::aliases::U256,
                alloy::sol_types::private::Address,
                alloy::sol_types::private::Address,
                alloy::sol_types::private::primitives::aliases::U256,
                alloy::sol_types::private::primitives::aliases::U256,
                alloy::sol_types::private::primitives::aliases::U256,
                alloy::sol_types::private::Bytes,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<createRetryableTicketCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: createRetryableTicketCall) -> Self {
                    (
                        value.to,
                        value.l2CallValue,
                        value.maxSubmissionCost,
                        value.excessFeeRefundAddress,
                        value.callValueRefundAddress,
                        value.gasLimit,
                        value.maxFeePerGas,
                        value.tokenTotalFeeAmount,
                        value.data,
                    )
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for createRetryableTicketCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        to: tuple.0,
                        l2CallValue: tuple.1,
                        maxSubmissionCost: tuple.2,
                        excessFeeRefundAddress: tuple.3,
                        callValueRefundAddress: tuple.4,
                        gasLimit: tuple.5,
                        maxFeePerGas: tuple.6,
                        tokenTotalFeeAmount: tuple.7,
                        data: tuple.8,
                    }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<createRetryableTicketReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: createRetryableTicketReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for createRetryableTicketReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for createRetryableTicketCall {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Bytes,
            );
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = createRetryableTicketReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "createRetryableTicket(address,uint256,uint256,address,address,uint256,uint256,uint256,bytes)";
            const SELECTOR: [u8; 4] = [84u8, 158u8, 132u8, 38u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.to,
                    ),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.l2CallValue),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.maxSubmissionCost),
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.excessFeeRefundAddress,
                    ),
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.callValueRefundAddress,
                    ),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.gasLimit),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.maxFeePerGas),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.tokenTotalFeeAmount),
                    <alloy::sol_types::sol_data::Bytes as alloy_sol_types::SolType>::tokenize(
                        &self.data,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `depositERC20(uint256)` and selector `0xb79092fd`.
```solidity
function depositERC20(uint256 amount) external returns (uint256);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct depositERC20Call {
        #[allow(missing_docs)]
        pub amount: alloy::sol_types::private::primitives::aliases::U256,
    }
    ///Container type for the return parameters of the [`depositERC20(uint256)`](depositERC20Call) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct depositERC20Return {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<depositERC20Call> for UnderlyingRustTuple<'_> {
                fn from(value: depositERC20Call) -> Self {
                    (value.amount,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for depositERC20Call {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { amount: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<depositERC20Return> for UnderlyingRustTuple<'_> {
                fn from(value: depositERC20Return) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for depositERC20Return {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for depositERC20Call {
            type Parameters<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = depositERC20Return;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "depositERC20(uint256)";
            const SELECTOR: [u8; 4] = [183u8, 144u8, 146u8, 253u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.amount),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `getProxyAdmin()` and selector `0x8b3240a0`.
```solidity
function getProxyAdmin() external view returns (address);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct getProxyAdminCall {}
    ///Container type for the return parameters of the [`getProxyAdmin()`](getProxyAdminCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct getProxyAdminReturn {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::Address,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<getProxyAdminCall> for UnderlyingRustTuple<'_> {
                fn from(value: getProxyAdminCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for getProxyAdminCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Address,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::Address,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<getProxyAdminReturn> for UnderlyingRustTuple<'_> {
                fn from(value: getProxyAdminReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for getProxyAdminReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for getProxyAdminCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = getProxyAdminReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Address,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "getProxyAdmin()";
            const SELECTOR: [u8; 4] = [139u8, 50u8, 64u8, 160u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `initialize(address,address)` and selector `0x485cc955`.
```solidity
function initialize(address _bridge, address _sequencerInbox) external;
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct initializeCall {
        #[allow(missing_docs)]
        pub _bridge: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub _sequencerInbox: alloy::sol_types::private::Address,
    }
    ///Container type for the return parameters of the [`initialize(address,address)`](initializeCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct initializeReturn {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Address,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::Address,
                alloy::sol_types::private::Address,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<initializeCall> for UnderlyingRustTuple<'_> {
                fn from(value: initializeCall) -> Self {
                    (value._bridge, value._sequencerInbox)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for initializeCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        _bridge: tuple.0,
                        _sequencerInbox: tuple.1,
                    }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<initializeReturn> for UnderlyingRustTuple<'_> {
                fn from(value: initializeReturn) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for initializeReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for initializeCall {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Address,
            );
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = initializeReturn;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "initialize(address,address)";
            const SELECTOR: [u8; 4] = [72u8, 92u8, 201u8, 85u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self._bridge,
                    ),
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self._sequencerInbox,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `isAllowed(address)` and selector `0xbabcc539`.
```solidity
function isAllowed(address) external view returns (bool);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct isAllowedCall {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::Address,
    }
    ///Container type for the return parameters of the [`isAllowed(address)`](isAllowedCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct isAllowedReturn {
        #[allow(missing_docs)]
        pub _0: bool,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Address,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::Address,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<isAllowedCall> for UnderlyingRustTuple<'_> {
                fn from(value: isAllowedCall) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for isAllowedCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Bool,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (bool,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<isAllowedReturn> for UnderlyingRustTuple<'_> {
                fn from(value: isAllowedReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for isAllowedReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for isAllowedCall {
            type Parameters<'a> = (alloy::sol_types::sol_data::Address,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = isAllowedReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Bool,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "isAllowed(address)";
            const SELECTOR: [u8; 4] = [186u8, 188u8, 197u8, 57u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self._0,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `maxDataSize()` and selector `0xe8eb1dc3`.
```solidity
function maxDataSize() external view returns (uint256);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct maxDataSizeCall {}
    ///Container type for the return parameters of the [`maxDataSize()`](maxDataSizeCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct maxDataSizeReturn {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<maxDataSizeCall> for UnderlyingRustTuple<'_> {
                fn from(value: maxDataSizeCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for maxDataSizeCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<maxDataSizeReturn> for UnderlyingRustTuple<'_> {
                fn from(value: maxDataSizeReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for maxDataSizeReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for maxDataSizeCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = maxDataSizeReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "maxDataSize()";
            const SELECTOR: [u8; 4] = [232u8, 235u8, 29u8, 195u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `pause()` and selector `0x8456cb59`.
```solidity
function pause() external;
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct pauseCall {}
    ///Container type for the return parameters of the [`pause()`](pauseCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct pauseReturn {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<pauseCall> for UnderlyingRustTuple<'_> {
                fn from(value: pauseCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for pauseCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<pauseReturn> for UnderlyingRustTuple<'_> {
                fn from(value: pauseReturn) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for pauseReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for pauseCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = pauseReturn;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "pause()";
            const SELECTOR: [u8; 4] = [132u8, 86u8, 203u8, 89u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `paused()` and selector `0x5c975abb`.
```solidity
function paused() external view returns (bool);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct pausedCall {}
    ///Container type for the return parameters of the [`paused()`](pausedCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct pausedReturn {
        #[allow(missing_docs)]
        pub _0: bool,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<pausedCall> for UnderlyingRustTuple<'_> {
                fn from(value: pausedCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for pausedCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Bool,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (bool,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<pausedReturn> for UnderlyingRustTuple<'_> {
                fn from(value: pausedReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for pausedReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for pausedCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = pausedReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Bool,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "paused()";
            const SELECTOR: [u8; 4] = [92u8, 151u8, 90u8, 187u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `sendContractTransaction(uint256,uint256,address,uint256,bytes)` and selector `0x8a631aa6`.
```solidity
function sendContractTransaction(uint256 gasLimit, uint256 maxFeePerGas, address to, uint256 value, bytes memory data) external returns (uint256);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct sendContractTransactionCall {
        #[allow(missing_docs)]
        pub gasLimit: alloy::sol_types::private::primitives::aliases::U256,
        #[allow(missing_docs)]
        pub maxFeePerGas: alloy::sol_types::private::primitives::aliases::U256,
        #[allow(missing_docs)]
        pub to: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub value: alloy::sol_types::private::primitives::aliases::U256,
        #[allow(missing_docs)]
        pub data: alloy::sol_types::private::Bytes,
    }
    ///Container type for the return parameters of the [`sendContractTransaction(uint256,uint256,address,uint256,bytes)`](sendContractTransactionCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct sendContractTransactionReturn {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Bytes,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
                alloy::sol_types::private::primitives::aliases::U256,
                alloy::sol_types::private::Address,
                alloy::sol_types::private::primitives::aliases::U256,
                alloy::sol_types::private::Bytes,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<sendContractTransactionCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: sendContractTransactionCall) -> Self {
                    (
                        value.gasLimit,
                        value.maxFeePerGas,
                        value.to,
                        value.value,
                        value.data,
                    )
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for sendContractTransactionCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        gasLimit: tuple.0,
                        maxFeePerGas: tuple.1,
                        to: tuple.2,
                        value: tuple.3,
                        data: tuple.4,
                    }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<sendContractTransactionReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: sendContractTransactionReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for sendContractTransactionReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for sendContractTransactionCall {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Bytes,
            );
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = sendContractTransactionReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "sendContractTransaction(uint256,uint256,address,uint256,bytes)";
            const SELECTOR: [u8; 4] = [138u8, 99u8, 26u8, 166u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.gasLimit),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.maxFeePerGas),
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.to,
                    ),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.value),
                    <alloy::sol_types::sol_data::Bytes as alloy_sol_types::SolType>::tokenize(
                        &self.data,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `sendL2Message(bytes)` and selector `0xb75436bb`.
```solidity
function sendL2Message(bytes memory messageData) external returns (uint256);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct sendL2MessageCall {
        #[allow(missing_docs)]
        pub messageData: alloy::sol_types::private::Bytes,
    }
    ///Container type for the return parameters of the [`sendL2Message(bytes)`](sendL2MessageCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct sendL2MessageReturn {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Bytes,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::Bytes,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<sendL2MessageCall> for UnderlyingRustTuple<'_> {
                fn from(value: sendL2MessageCall) -> Self {
                    (value.messageData,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for sendL2MessageCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { messageData: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<sendL2MessageReturn> for UnderlyingRustTuple<'_> {
                fn from(value: sendL2MessageReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for sendL2MessageReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for sendL2MessageCall {
            type Parameters<'a> = (alloy::sol_types::sol_data::Bytes,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = sendL2MessageReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "sendL2Message(bytes)";
            const SELECTOR: [u8; 4] = [183u8, 84u8, 54u8, 187u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Bytes as alloy_sol_types::SolType>::tokenize(
                        &self.messageData,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `sendL2MessageFromOrigin(bytes)` and selector `0x1fe927cf`.
```solidity
function sendL2MessageFromOrigin(bytes memory messageData) external returns (uint256);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct sendL2MessageFromOriginCall {
        #[allow(missing_docs)]
        pub messageData: alloy::sol_types::private::Bytes,
    }
    ///Container type for the return parameters of the [`sendL2MessageFromOrigin(bytes)`](sendL2MessageFromOriginCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct sendL2MessageFromOriginReturn {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Bytes,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::Bytes,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<sendL2MessageFromOriginCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: sendL2MessageFromOriginCall) -> Self {
                    (value.messageData,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for sendL2MessageFromOriginCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { messageData: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<sendL2MessageFromOriginReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: sendL2MessageFromOriginReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for sendL2MessageFromOriginReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for sendL2MessageFromOriginCall {
            type Parameters<'a> = (alloy::sol_types::sol_data::Bytes,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = sendL2MessageFromOriginReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "sendL2MessageFromOrigin(bytes)";
            const SELECTOR: [u8; 4] = [31u8, 233u8, 39u8, 207u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Bytes as alloy_sol_types::SolType>::tokenize(
                        &self.messageData,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `sendUnsignedTransaction(uint256,uint256,uint256,address,uint256,bytes)` and selector `0x5075788b`.
```solidity
function sendUnsignedTransaction(uint256 gasLimit, uint256 maxFeePerGas, uint256 nonce, address to, uint256 value, bytes memory data) external returns (uint256);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct sendUnsignedTransactionCall {
        #[allow(missing_docs)]
        pub gasLimit: alloy::sol_types::private::primitives::aliases::U256,
        #[allow(missing_docs)]
        pub maxFeePerGas: alloy::sol_types::private::primitives::aliases::U256,
        #[allow(missing_docs)]
        pub nonce: alloy::sol_types::private::primitives::aliases::U256,
        #[allow(missing_docs)]
        pub to: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub value: alloy::sol_types::private::primitives::aliases::U256,
        #[allow(missing_docs)]
        pub data: alloy::sol_types::private::Bytes,
    }
    ///Container type for the return parameters of the [`sendUnsignedTransaction(uint256,uint256,uint256,address,uint256,bytes)`](sendUnsignedTransactionCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct sendUnsignedTransactionReturn {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Bytes,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
                alloy::sol_types::private::primitives::aliases::U256,
                alloy::sol_types::private::primitives::aliases::U256,
                alloy::sol_types::private::Address,
                alloy::sol_types::private::primitives::aliases::U256,
                alloy::sol_types::private::Bytes,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<sendUnsignedTransactionCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: sendUnsignedTransactionCall) -> Self {
                    (
                        value.gasLimit,
                        value.maxFeePerGas,
                        value.nonce,
                        value.to,
                        value.value,
                        value.data,
                    )
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for sendUnsignedTransactionCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        gasLimit: tuple.0,
                        maxFeePerGas: tuple.1,
                        nonce: tuple.2,
                        to: tuple.3,
                        value: tuple.4,
                        data: tuple.5,
                    }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<sendUnsignedTransactionReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: sendUnsignedTransactionReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for sendUnsignedTransactionReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for sendUnsignedTransactionCall {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Bytes,
            );
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = sendUnsignedTransactionReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "sendUnsignedTransaction(uint256,uint256,uint256,address,uint256,bytes)";
            const SELECTOR: [u8; 4] = [80u8, 117u8, 120u8, 139u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.gasLimit),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.maxFeePerGas),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.nonce),
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.to,
                    ),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.value),
                    <alloy::sol_types::sol_data::Bytes as alloy_sol_types::SolType>::tokenize(
                        &self.data,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `sequencerInbox()` and selector `0xee35f327`.
```solidity
function sequencerInbox() external view returns (address);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct sequencerInboxCall {}
    ///Container type for the return parameters of the [`sequencerInbox()`](sequencerInboxCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct sequencerInboxReturn {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::Address,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<sequencerInboxCall> for UnderlyingRustTuple<'_> {
                fn from(value: sequencerInboxCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for sequencerInboxCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Address,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::Address,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<sequencerInboxReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: sequencerInboxReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for sequencerInboxReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for sequencerInboxCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = sequencerInboxReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Address,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "sequencerInbox()";
            const SELECTOR: [u8; 4] = [238u8, 53u8, 243u8, 39u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `setAllowList(address[],bool[])` and selector `0xe3de72a5`.
```solidity
function setAllowList(address[] memory user, bool[] memory val) external;
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct setAllowListCall {
        #[allow(missing_docs)]
        pub user: alloy::sol_types::private::Vec<alloy::sol_types::private::Address>,
        #[allow(missing_docs)]
        pub val: alloy::sol_types::private::Vec<bool>,
    }
    ///Container type for the return parameters of the [`setAllowList(address[],bool[])`](setAllowListCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct setAllowListReturn {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::Array<alloy::sol_types::sol_data::Address>,
                alloy::sol_types::sol_data::Array<alloy::sol_types::sol_data::Bool>,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::Vec<alloy::sol_types::private::Address>,
                alloy::sol_types::private::Vec<bool>,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<setAllowListCall> for UnderlyingRustTuple<'_> {
                fn from(value: setAllowListCall) -> Self {
                    (value.user, value.val)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for setAllowListCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        user: tuple.0,
                        val: tuple.1,
                    }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<setAllowListReturn> for UnderlyingRustTuple<'_> {
                fn from(value: setAllowListReturn) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for setAllowListReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for setAllowListCall {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::Array<alloy::sol_types::sol_data::Address>,
                alloy::sol_types::sol_data::Array<alloy::sol_types::sol_data::Bool>,
            );
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = setAllowListReturn;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "setAllowList(address[],bool[])";
            const SELECTOR: [u8; 4] = [227u8, 222u8, 114u8, 165u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Array<
                        alloy::sol_types::sol_data::Address,
                    > as alloy_sol_types::SolType>::tokenize(&self.user),
                    <alloy::sol_types::sol_data::Array<
                        alloy::sol_types::sol_data::Bool,
                    > as alloy_sol_types::SolType>::tokenize(&self.val),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `setAllowListEnabled(bool)` and selector `0xefeadb6d`.
```solidity
function setAllowListEnabled(bool _allowListEnabled) external;
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct setAllowListEnabledCall {
        #[allow(missing_docs)]
        pub _allowListEnabled: bool,
    }
    ///Container type for the return parameters of the [`setAllowListEnabled(bool)`](setAllowListEnabledCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct setAllowListEnabledReturn {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Bool,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (bool,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<setAllowListEnabledCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: setAllowListEnabledCall) -> Self {
                    (value._allowListEnabled,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for setAllowListEnabledCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _allowListEnabled: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<setAllowListEnabledReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: setAllowListEnabledReturn) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for setAllowListEnabledReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for setAllowListEnabledCall {
            type Parameters<'a> = (alloy::sol_types::sol_data::Bool,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = setAllowListEnabledReturn;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "setAllowListEnabled(bool)";
            const SELECTOR: [u8; 4] = [239u8, 234u8, 219u8, 109u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Bool as alloy_sol_types::SolType>::tokenize(
                        &self._allowListEnabled,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `unpause()` and selector `0x3f4ba83a`.
```solidity
function unpause() external;
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct unpauseCall {}
    ///Container type for the return parameters of the [`unpause()`](unpauseCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct unpauseReturn {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<unpauseCall> for UnderlyingRustTuple<'_> {
                fn from(value: unpauseCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for unpauseCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<unpauseReturn> for UnderlyingRustTuple<'_> {
                fn from(value: unpauseReturn) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for unpauseReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for unpauseCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = unpauseReturn;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "unpause()";
            const SELECTOR: [u8; 4] = [63u8, 75u8, 168u8, 58u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `unsafeCreateRetryableTicket(address,uint256,uint256,address,address,uint256,uint256,uint256,bytes)` and selector `0xb9b9a688`.
```solidity
function unsafeCreateRetryableTicket(address to, uint256 l2CallValue, uint256 maxSubmissionCost, address excessFeeRefundAddress, address callValueRefundAddress, uint256 gasLimit, uint256 maxFeePerGas, uint256 tokenTotalFeeAmount, bytes memory data) external returns (uint256);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct unsafeCreateRetryableTicketCall {
        #[allow(missing_docs)]
        pub to: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub l2CallValue: alloy::sol_types::private::primitives::aliases::U256,
        #[allow(missing_docs)]
        pub maxSubmissionCost: alloy::sol_types::private::primitives::aliases::U256,
        #[allow(missing_docs)]
        pub excessFeeRefundAddress: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub callValueRefundAddress: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub gasLimit: alloy::sol_types::private::primitives::aliases::U256,
        #[allow(missing_docs)]
        pub maxFeePerGas: alloy::sol_types::private::primitives::aliases::U256,
        #[allow(missing_docs)]
        pub tokenTotalFeeAmount: alloy::sol_types::private::primitives::aliases::U256,
        #[allow(missing_docs)]
        pub data: alloy::sol_types::private::Bytes,
    }
    ///Container type for the return parameters of the [`unsafeCreateRetryableTicket(address,uint256,uint256,address,address,uint256,uint256,uint256,bytes)`](unsafeCreateRetryableTicketCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct unsafeCreateRetryableTicketReturn {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Bytes,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::Address,
                alloy::sol_types::private::primitives::aliases::U256,
                alloy::sol_types::private::primitives::aliases::U256,
                alloy::sol_types::private::Address,
                alloy::sol_types::private::Address,
                alloy::sol_types::private::primitives::aliases::U256,
                alloy::sol_types::private::primitives::aliases::U256,
                alloy::sol_types::private::primitives::aliases::U256,
                alloy::sol_types::private::Bytes,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<unsafeCreateRetryableTicketCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: unsafeCreateRetryableTicketCall) -> Self {
                    (
                        value.to,
                        value.l2CallValue,
                        value.maxSubmissionCost,
                        value.excessFeeRefundAddress,
                        value.callValueRefundAddress,
                        value.gasLimit,
                        value.maxFeePerGas,
                        value.tokenTotalFeeAmount,
                        value.data,
                    )
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for unsafeCreateRetryableTicketCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        to: tuple.0,
                        l2CallValue: tuple.1,
                        maxSubmissionCost: tuple.2,
                        excessFeeRefundAddress: tuple.3,
                        callValueRefundAddress: tuple.4,
                        gasLimit: tuple.5,
                        maxFeePerGas: tuple.6,
                        tokenTotalFeeAmount: tuple.7,
                        data: tuple.8,
                    }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<unsafeCreateRetryableTicketReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: unsafeCreateRetryableTicketReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for unsafeCreateRetryableTicketReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for unsafeCreateRetryableTicketCall {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Bytes,
            );
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = unsafeCreateRetryableTicketReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "unsafeCreateRetryableTicket(address,uint256,uint256,address,address,uint256,uint256,uint256,bytes)";
            const SELECTOR: [u8; 4] = [185u8, 185u8, 166u8, 136u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.to,
                    ),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.l2CallValue),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.maxSubmissionCost),
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.excessFeeRefundAddress,
                    ),
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.callValueRefundAddress,
                    ),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.gasLimit),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.maxFeePerGas),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.tokenTotalFeeAmount),
                    <alloy::sol_types::sol_data::Bytes as alloy_sol_types::SolType>::tokenize(
                        &self.data,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    ///Container for all the [`ERC20Inbox`](self) function calls.
    pub enum ERC20InboxCalls {
        #[allow(missing_docs)]
        allowListEnabled(allowListEnabledCall),
        #[allow(missing_docs)]
        bridge(bridgeCall),
        #[allow(missing_docs)]
        calculateRetryableSubmissionFee(calculateRetryableSubmissionFeeCall),
        #[allow(missing_docs)]
        createRetryableTicket(createRetryableTicketCall),
        #[allow(missing_docs)]
        depositERC20(depositERC20Call),
        #[allow(missing_docs)]
        getProxyAdmin(getProxyAdminCall),
        #[allow(missing_docs)]
        initialize(initializeCall),
        #[allow(missing_docs)]
        isAllowed(isAllowedCall),
        #[allow(missing_docs)]
        maxDataSize(maxDataSizeCall),
        #[allow(missing_docs)]
        pause(pauseCall),
        #[allow(missing_docs)]
        paused(pausedCall),
        #[allow(missing_docs)]
        sendContractTransaction(sendContractTransactionCall),
        #[allow(missing_docs)]
        sendL2Message(sendL2MessageCall),
        #[allow(missing_docs)]
        sendL2MessageFromOrigin(sendL2MessageFromOriginCall),
        #[allow(missing_docs)]
        sendUnsignedTransaction(sendUnsignedTransactionCall),
        #[allow(missing_docs)]
        sequencerInbox(sequencerInboxCall),
        #[allow(missing_docs)]
        setAllowList(setAllowListCall),
        #[allow(missing_docs)]
        setAllowListEnabled(setAllowListEnabledCall),
        #[allow(missing_docs)]
        unpause(unpauseCall),
        #[allow(missing_docs)]
        unsafeCreateRetryableTicket(unsafeCreateRetryableTicketCall),
    }
    #[automatically_derived]
    impl ERC20InboxCalls {
        /// All the selectors of this enum.
        ///
        /// Note that the selectors might not be in the same order as the variants.
        /// No guarantees are made about the order of the selectors.
        ///
        /// Prefer using `SolInterface` methods instead.
        pub const SELECTORS: &'static [[u8; 4usize]] = &[
            [31u8, 233u8, 39u8, 207u8],
            [34u8, 189u8, 92u8, 28u8],
            [63u8, 75u8, 168u8, 58u8],
            [72u8, 92u8, 201u8, 85u8],
            [80u8, 117u8, 120u8, 139u8],
            [84u8, 158u8, 132u8, 38u8],
            [92u8, 151u8, 90u8, 187u8],
            [132u8, 86u8, 203u8, 89u8],
            [138u8, 99u8, 26u8, 166u8],
            [139u8, 50u8, 64u8, 160u8],
            [166u8, 107u8, 50u8, 125u8],
            [183u8, 84u8, 54u8, 187u8],
            [183u8, 144u8, 146u8, 253u8],
            [185u8, 185u8, 166u8, 136u8],
            [186u8, 188u8, 197u8, 57u8],
            [227u8, 222u8, 114u8, 165u8],
            [231u8, 140u8, 234u8, 146u8],
            [232u8, 235u8, 29u8, 195u8],
            [238u8, 53u8, 243u8, 39u8],
            [239u8, 234u8, 219u8, 109u8],
        ];
    }
    #[automatically_derived]
    impl alloy_sol_types::SolInterface for ERC20InboxCalls {
        const NAME: &'static str = "ERC20InboxCalls";
        const MIN_DATA_LENGTH: usize = 0usize;
        const COUNT: usize = 20usize;
        #[inline]
        fn selector(&self) -> [u8; 4] {
            match self {
                Self::allowListEnabled(_) => {
                    <allowListEnabledCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::bridge(_) => <bridgeCall as alloy_sol_types::SolCall>::SELECTOR,
                Self::calculateRetryableSubmissionFee(_) => {
                    <calculateRetryableSubmissionFeeCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::createRetryableTicket(_) => {
                    <createRetryableTicketCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::depositERC20(_) => {
                    <depositERC20Call as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::getProxyAdmin(_) => {
                    <getProxyAdminCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::initialize(_) => {
                    <initializeCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::isAllowed(_) => {
                    <isAllowedCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::maxDataSize(_) => {
                    <maxDataSizeCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::pause(_) => <pauseCall as alloy_sol_types::SolCall>::SELECTOR,
                Self::paused(_) => <pausedCall as alloy_sol_types::SolCall>::SELECTOR,
                Self::sendContractTransaction(_) => {
                    <sendContractTransactionCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::sendL2Message(_) => {
                    <sendL2MessageCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::sendL2MessageFromOrigin(_) => {
                    <sendL2MessageFromOriginCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::sendUnsignedTransaction(_) => {
                    <sendUnsignedTransactionCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::sequencerInbox(_) => {
                    <sequencerInboxCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::setAllowList(_) => {
                    <setAllowListCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::setAllowListEnabled(_) => {
                    <setAllowListEnabledCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::unpause(_) => <unpauseCall as alloy_sol_types::SolCall>::SELECTOR,
                Self::unsafeCreateRetryableTicket(_) => {
                    <unsafeCreateRetryableTicketCall as alloy_sol_types::SolCall>::SELECTOR
                }
            }
        }
        #[inline]
        fn selector_at(i: usize) -> ::core::option::Option<[u8; 4]> {
            Self::SELECTORS.get(i).copied()
        }
        #[inline]
        fn valid_selector(selector: [u8; 4]) -> bool {
            Self::SELECTORS.binary_search(&selector).is_ok()
        }
        #[inline]
        #[allow(non_snake_case)]
        fn abi_decode_raw(
            selector: [u8; 4],
            data: &[u8],
            validate: bool,
        ) -> alloy_sol_types::Result<Self> {
            static DECODE_SHIMS: &[fn(
                &[u8],
                bool,
            ) -> alloy_sol_types::Result<ERC20InboxCalls>] = &[
                {
                    fn sendL2MessageFromOrigin(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<ERC20InboxCalls> {
                        <sendL2MessageFromOriginCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(ERC20InboxCalls::sendL2MessageFromOrigin)
                    }
                    sendL2MessageFromOrigin
                },
                {
                    fn allowListEnabled(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<ERC20InboxCalls> {
                        <allowListEnabledCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(ERC20InboxCalls::allowListEnabled)
                    }
                    allowListEnabled
                },
                {
                    fn unpause(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<ERC20InboxCalls> {
                        <unpauseCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(ERC20InboxCalls::unpause)
                    }
                    unpause
                },
                {
                    fn initialize(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<ERC20InboxCalls> {
                        <initializeCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(ERC20InboxCalls::initialize)
                    }
                    initialize
                },
                {
                    fn sendUnsignedTransaction(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<ERC20InboxCalls> {
                        <sendUnsignedTransactionCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(ERC20InboxCalls::sendUnsignedTransaction)
                    }
                    sendUnsignedTransaction
                },
                {
                    fn createRetryableTicket(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<ERC20InboxCalls> {
                        <createRetryableTicketCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(ERC20InboxCalls::createRetryableTicket)
                    }
                    createRetryableTicket
                },
                {
                    fn paused(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<ERC20InboxCalls> {
                        <pausedCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(ERC20InboxCalls::paused)
                    }
                    paused
                },
                {
                    fn pause(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<ERC20InboxCalls> {
                        <pauseCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(ERC20InboxCalls::pause)
                    }
                    pause
                },
                {
                    fn sendContractTransaction(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<ERC20InboxCalls> {
                        <sendContractTransactionCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(ERC20InboxCalls::sendContractTransaction)
                    }
                    sendContractTransaction
                },
                {
                    fn getProxyAdmin(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<ERC20InboxCalls> {
                        <getProxyAdminCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(ERC20InboxCalls::getProxyAdmin)
                    }
                    getProxyAdmin
                },
                {
                    fn calculateRetryableSubmissionFee(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<ERC20InboxCalls> {
                        <calculateRetryableSubmissionFeeCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(ERC20InboxCalls::calculateRetryableSubmissionFee)
                    }
                    calculateRetryableSubmissionFee
                },
                {
                    fn sendL2Message(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<ERC20InboxCalls> {
                        <sendL2MessageCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(ERC20InboxCalls::sendL2Message)
                    }
                    sendL2Message
                },
                {
                    fn depositERC20(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<ERC20InboxCalls> {
                        <depositERC20Call as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(ERC20InboxCalls::depositERC20)
                    }
                    depositERC20
                },
                {
                    fn unsafeCreateRetryableTicket(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<ERC20InboxCalls> {
                        <unsafeCreateRetryableTicketCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(ERC20InboxCalls::unsafeCreateRetryableTicket)
                    }
                    unsafeCreateRetryableTicket
                },
                {
                    fn isAllowed(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<ERC20InboxCalls> {
                        <isAllowedCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(ERC20InboxCalls::isAllowed)
                    }
                    isAllowed
                },
                {
                    fn setAllowList(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<ERC20InboxCalls> {
                        <setAllowListCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(ERC20InboxCalls::setAllowList)
                    }
                    setAllowList
                },
                {
                    fn bridge(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<ERC20InboxCalls> {
                        <bridgeCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(ERC20InboxCalls::bridge)
                    }
                    bridge
                },
                {
                    fn maxDataSize(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<ERC20InboxCalls> {
                        <maxDataSizeCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(ERC20InboxCalls::maxDataSize)
                    }
                    maxDataSize
                },
                {
                    fn sequencerInbox(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<ERC20InboxCalls> {
                        <sequencerInboxCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(ERC20InboxCalls::sequencerInbox)
                    }
                    sequencerInbox
                },
                {
                    fn setAllowListEnabled(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<ERC20InboxCalls> {
                        <setAllowListEnabledCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(ERC20InboxCalls::setAllowListEnabled)
                    }
                    setAllowListEnabled
                },
            ];
            let Ok(idx) = Self::SELECTORS.binary_search(&selector) else {
                return Err(
                    alloy_sol_types::Error::unknown_selector(
                        <Self as alloy_sol_types::SolInterface>::NAME,
                        selector,
                    ),
                );
            };
            DECODE_SHIMS[idx](data, validate)
        }
        #[inline]
        fn abi_encoded_size(&self) -> usize {
            match self {
                Self::allowListEnabled(inner) => {
                    <allowListEnabledCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::bridge(inner) => {
                    <bridgeCall as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::calculateRetryableSubmissionFee(inner) => {
                    <calculateRetryableSubmissionFeeCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::createRetryableTicket(inner) => {
                    <createRetryableTicketCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::depositERC20(inner) => {
                    <depositERC20Call as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::getProxyAdmin(inner) => {
                    <getProxyAdminCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::initialize(inner) => {
                    <initializeCall as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::isAllowed(inner) => {
                    <isAllowedCall as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::maxDataSize(inner) => {
                    <maxDataSizeCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::pause(inner) => {
                    <pauseCall as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::paused(inner) => {
                    <pausedCall as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::sendContractTransaction(inner) => {
                    <sendContractTransactionCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::sendL2Message(inner) => {
                    <sendL2MessageCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::sendL2MessageFromOrigin(inner) => {
                    <sendL2MessageFromOriginCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::sendUnsignedTransaction(inner) => {
                    <sendUnsignedTransactionCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::sequencerInbox(inner) => {
                    <sequencerInboxCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::setAllowList(inner) => {
                    <setAllowListCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::setAllowListEnabled(inner) => {
                    <setAllowListEnabledCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::unpause(inner) => {
                    <unpauseCall as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::unsafeCreateRetryableTicket(inner) => {
                    <unsafeCreateRetryableTicketCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
            }
        }
        #[inline]
        fn abi_encode_raw(&self, out: &mut alloy_sol_types::private::Vec<u8>) {
            match self {
                Self::allowListEnabled(inner) => {
                    <allowListEnabledCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::bridge(inner) => {
                    <bridgeCall as alloy_sol_types::SolCall>::abi_encode_raw(inner, out)
                }
                Self::calculateRetryableSubmissionFee(inner) => {
                    <calculateRetryableSubmissionFeeCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::createRetryableTicket(inner) => {
                    <createRetryableTicketCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::depositERC20(inner) => {
                    <depositERC20Call as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::getProxyAdmin(inner) => {
                    <getProxyAdminCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::initialize(inner) => {
                    <initializeCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::isAllowed(inner) => {
                    <isAllowedCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::maxDataSize(inner) => {
                    <maxDataSizeCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::pause(inner) => {
                    <pauseCall as alloy_sol_types::SolCall>::abi_encode_raw(inner, out)
                }
                Self::paused(inner) => {
                    <pausedCall as alloy_sol_types::SolCall>::abi_encode_raw(inner, out)
                }
                Self::sendContractTransaction(inner) => {
                    <sendContractTransactionCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::sendL2Message(inner) => {
                    <sendL2MessageCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::sendL2MessageFromOrigin(inner) => {
                    <sendL2MessageFromOriginCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::sendUnsignedTransaction(inner) => {
                    <sendUnsignedTransactionCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::sequencerInbox(inner) => {
                    <sequencerInboxCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::setAllowList(inner) => {
                    <setAllowListCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::setAllowListEnabled(inner) => {
                    <setAllowListEnabledCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::unpause(inner) => {
                    <unpauseCall as alloy_sol_types::SolCall>::abi_encode_raw(inner, out)
                }
                Self::unsafeCreateRetryableTicket(inner) => {
                    <unsafeCreateRetryableTicketCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
            }
        }
    }
    ///Container for all the [`ERC20Inbox`](self) custom errors.
    pub enum ERC20InboxErrors {
        #[allow(missing_docs)]
        AmountTooLarge(AmountTooLarge),
        #[allow(missing_docs)]
        DataTooLarge(DataTooLarge),
        #[allow(missing_docs)]
        GasLimitTooLarge(GasLimitTooLarge),
        #[allow(missing_docs)]
        InsufficientSubmissionCost(InsufficientSubmissionCost),
        #[allow(missing_docs)]
        InsufficientValue(InsufficientValue),
        #[allow(missing_docs)]
        L1Forked(L1Forked),
        #[allow(missing_docs)]
        NotAllowedOrigin(NotAllowedOrigin),
        #[allow(missing_docs)]
        NotCodelessOrigin(NotCodelessOrigin),
        #[allow(missing_docs)]
        NotRollupOrOwner(NotRollupOrOwner),
        #[allow(missing_docs)]
        RetryableData(RetryableData),
    }
    #[automatically_derived]
    impl ERC20InboxErrors {
        /// All the selectors of this enum.
        ///
        /// Note that the selectors might not be in the same order as the variants.
        /// No guarantees are made about the order of the selectors.
        ///
        /// Prefer using `SolInterface` methods instead.
        pub const SELECTORS: &'static [[u8; 4usize]] = &[
            [7u8, 57u8, 96u8, 7u8],
            [7u8, 194u8, 102u8, 227u8],
            [8u8, 8u8, 59u8, 42u8],
            [16u8, 124u8, 82u8, 123u8],
            [70u8, 52u8, 105u8, 27u8],
            [112u8, 64u8, 181u8, 140u8],
            [198u8, 234u8, 104u8, 3u8],
            [200u8, 149u8, 142u8, 173u8],
            [245u8, 30u8, 215u8, 16u8],
            [250u8, 223u8, 35u8, 138u8],
        ];
    }
    #[automatically_derived]
    impl alloy_sol_types::SolInterface for ERC20InboxErrors {
        const NAME: &'static str = "ERC20InboxErrors";
        const MIN_DATA_LENGTH: usize = 0usize;
        const COUNT: usize = 10usize;
        #[inline]
        fn selector(&self) -> [u8; 4] {
            match self {
                Self::AmountTooLarge(_) => {
                    <AmountTooLarge as alloy_sol_types::SolError>::SELECTOR
                }
                Self::DataTooLarge(_) => {
                    <DataTooLarge as alloy_sol_types::SolError>::SELECTOR
                }
                Self::GasLimitTooLarge(_) => {
                    <GasLimitTooLarge as alloy_sol_types::SolError>::SELECTOR
                }
                Self::InsufficientSubmissionCost(_) => {
                    <InsufficientSubmissionCost as alloy_sol_types::SolError>::SELECTOR
                }
                Self::InsufficientValue(_) => {
                    <InsufficientValue as alloy_sol_types::SolError>::SELECTOR
                }
                Self::L1Forked(_) => <L1Forked as alloy_sol_types::SolError>::SELECTOR,
                Self::NotAllowedOrigin(_) => {
                    <NotAllowedOrigin as alloy_sol_types::SolError>::SELECTOR
                }
                Self::NotCodelessOrigin(_) => {
                    <NotCodelessOrigin as alloy_sol_types::SolError>::SELECTOR
                }
                Self::NotRollupOrOwner(_) => {
                    <NotRollupOrOwner as alloy_sol_types::SolError>::SELECTOR
                }
                Self::RetryableData(_) => {
                    <RetryableData as alloy_sol_types::SolError>::SELECTOR
                }
            }
        }
        #[inline]
        fn selector_at(i: usize) -> ::core::option::Option<[u8; 4]> {
            Self::SELECTORS.get(i).copied()
        }
        #[inline]
        fn valid_selector(selector: [u8; 4]) -> bool {
            Self::SELECTORS.binary_search(&selector).is_ok()
        }
        #[inline]
        #[allow(non_snake_case)]
        fn abi_decode_raw(
            selector: [u8; 4],
            data: &[u8],
            validate: bool,
        ) -> alloy_sol_types::Result<Self> {
            static DECODE_SHIMS: &[fn(
                &[u8],
                bool,
            ) -> alloy_sol_types::Result<ERC20InboxErrors>] = &[
                {
                    fn NotRollupOrOwner(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<ERC20InboxErrors> {
                        <NotRollupOrOwner as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(ERC20InboxErrors::NotRollupOrOwner)
                    }
                    NotRollupOrOwner
                },
                {
                    fn RetryableData(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<ERC20InboxErrors> {
                        <RetryableData as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(ERC20InboxErrors::RetryableData)
                    }
                    RetryableData
                },
                {
                    fn AmountTooLarge(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<ERC20InboxErrors> {
                        <AmountTooLarge as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(ERC20InboxErrors::AmountTooLarge)
                    }
                    AmountTooLarge
                },
                {
                    fn GasLimitTooLarge(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<ERC20InboxErrors> {
                        <GasLimitTooLarge as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(ERC20InboxErrors::GasLimitTooLarge)
                    }
                    GasLimitTooLarge
                },
                {
                    fn DataTooLarge(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<ERC20InboxErrors> {
                        <DataTooLarge as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(ERC20InboxErrors::DataTooLarge)
                    }
                    DataTooLarge
                },
                {
                    fn InsufficientValue(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<ERC20InboxErrors> {
                        <InsufficientValue as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(ERC20InboxErrors::InsufficientValue)
                    }
                    InsufficientValue
                },
                {
                    fn L1Forked(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<ERC20InboxErrors> {
                        <L1Forked as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(ERC20InboxErrors::L1Forked)
                    }
                    L1Forked
                },
                {
                    fn NotCodelessOrigin(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<ERC20InboxErrors> {
                        <NotCodelessOrigin as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(ERC20InboxErrors::NotCodelessOrigin)
                    }
                    NotCodelessOrigin
                },
                {
                    fn NotAllowedOrigin(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<ERC20InboxErrors> {
                        <NotAllowedOrigin as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(ERC20InboxErrors::NotAllowedOrigin)
                    }
                    NotAllowedOrigin
                },
                {
                    fn InsufficientSubmissionCost(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<ERC20InboxErrors> {
                        <InsufficientSubmissionCost as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(ERC20InboxErrors::InsufficientSubmissionCost)
                    }
                    InsufficientSubmissionCost
                },
            ];
            let Ok(idx) = Self::SELECTORS.binary_search(&selector) else {
                return Err(
                    alloy_sol_types::Error::unknown_selector(
                        <Self as alloy_sol_types::SolInterface>::NAME,
                        selector,
                    ),
                );
            };
            DECODE_SHIMS[idx](data, validate)
        }
        #[inline]
        fn abi_encoded_size(&self) -> usize {
            match self {
                Self::AmountTooLarge(inner) => {
                    <AmountTooLarge as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::DataTooLarge(inner) => {
                    <DataTooLarge as alloy_sol_types::SolError>::abi_encoded_size(inner)
                }
                Self::GasLimitTooLarge(inner) => {
                    <GasLimitTooLarge as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::InsufficientSubmissionCost(inner) => {
                    <InsufficientSubmissionCost as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::InsufficientValue(inner) => {
                    <InsufficientValue as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::L1Forked(inner) => {
                    <L1Forked as alloy_sol_types::SolError>::abi_encoded_size(inner)
                }
                Self::NotAllowedOrigin(inner) => {
                    <NotAllowedOrigin as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::NotCodelessOrigin(inner) => {
                    <NotCodelessOrigin as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::NotRollupOrOwner(inner) => {
                    <NotRollupOrOwner as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::RetryableData(inner) => {
                    <RetryableData as alloy_sol_types::SolError>::abi_encoded_size(inner)
                }
            }
        }
        #[inline]
        fn abi_encode_raw(&self, out: &mut alloy_sol_types::private::Vec<u8>) {
            match self {
                Self::AmountTooLarge(inner) => {
                    <AmountTooLarge as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::DataTooLarge(inner) => {
                    <DataTooLarge as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::GasLimitTooLarge(inner) => {
                    <GasLimitTooLarge as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::InsufficientSubmissionCost(inner) => {
                    <InsufficientSubmissionCost as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::InsufficientValue(inner) => {
                    <InsufficientValue as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::L1Forked(inner) => {
                    <L1Forked as alloy_sol_types::SolError>::abi_encode_raw(inner, out)
                }
                Self::NotAllowedOrigin(inner) => {
                    <NotAllowedOrigin as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::NotCodelessOrigin(inner) => {
                    <NotCodelessOrigin as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::NotRollupOrOwner(inner) => {
                    <NotRollupOrOwner as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::RetryableData(inner) => {
                    <RetryableData as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
            }
        }
    }
    ///Container for all the [`ERC20Inbox`](self) events.
    pub enum ERC20InboxEvents {
        #[allow(missing_docs)]
        AllowListAddressSet(AllowListAddressSet),
        #[allow(missing_docs)]
        AllowListEnabledUpdated(AllowListEnabledUpdated),
        #[allow(missing_docs)]
        InboxMessageDelivered(InboxMessageDelivered),
        #[allow(missing_docs)]
        InboxMessageDeliveredFromOrigin(InboxMessageDeliveredFromOrigin),
        #[allow(missing_docs)]
        Initialized(Initialized),
        #[allow(missing_docs)]
        Paused(Paused),
        #[allow(missing_docs)]
        Unpaused(Unpaused),
    }
    #[automatically_derived]
    impl ERC20InboxEvents {
        /// All the selectors of this enum.
        ///
        /// Note that the selectors might not be in the same order as the variants.
        /// No guarantees are made about the order of the selectors.
        ///
        /// Prefer using `SolInterface` methods instead.
        pub const SELECTORS: &'static [[u8; 32usize]] = &[
            [
                22u8,
                67u8,
                91u8,
                69u8,
                247u8,
                72u8,
                32u8,
                71u8,
                248u8,
                57u8,
                166u8,
                161u8,
                157u8,
                41u8,
                20u8,
                66u8,
                98u8,
                114u8,
                0u8,
                245u8,
                44u8,
                173u8,
                40u8,
                3u8,
                197u8,
                149u8,
                21u8,
                13u8,
                13u8,
                68u8,
                14u8,
                179u8,
            ],
            [
                93u8,
                185u8,
                238u8,
                10u8,
                73u8,
                91u8,
                242u8,
                230u8,
                255u8,
                156u8,
                145u8,
                167u8,
                131u8,
                76u8,
                27u8,
                164u8,
                253u8,
                210u8,
                68u8,
                165u8,
                232u8,
                170u8,
                78u8,
                83u8,
                123u8,
                211u8,
                138u8,
                234u8,
                228u8,
                176u8,
                115u8,
                170u8,
            ],
            [
                98u8,
                231u8,
                140u8,
                234u8,
                1u8,
                190u8,
                227u8,
                32u8,
                205u8,
                78u8,
                66u8,
                2u8,
                112u8,
                181u8,
                234u8,
                116u8,
                0u8,
                13u8,
                17u8,
                176u8,
                201u8,
                247u8,
                71u8,
                84u8,
                235u8,
                219u8,
                252u8,
                84u8,
                75u8,
                5u8,
                162u8,
                88u8,
            ],
            [
                127u8,
                38u8,
                184u8,
                63u8,
                249u8,
                110u8,
                31u8,
                43u8,
                106u8,
                104u8,
                47u8,
                19u8,
                56u8,
                82u8,
                246u8,
                121u8,
                138u8,
                9u8,
                196u8,
                101u8,
                218u8,
                149u8,
                146u8,
                20u8,
                96u8,
                206u8,
                251u8,
                56u8,
                71u8,
                64u8,
                36u8,
                152u8,
            ],
            [
                171u8,
                83u8,
                35u8,
                133u8,
                190u8,
                143u8,
                16u8,
                5u8,
                164u8,
                182u8,
                186u8,
                143u8,
                162u8,
                10u8,
                34u8,
                69u8,
                250u8,
                203u8,
                52u8,
                97u8,
                52u8,
                172u8,
                115u8,
                159u8,
                233u8,
                165u8,
                25u8,
                141u8,
                193u8,
                88u8,
                11u8,
                156u8,
            ],
            [
                217u8,
                115u8,
                159u8,
                69u8,
                160u8,
                28u8,
                224u8,
                146u8,
                197u8,
                205u8,
                179u8,
                214u8,
                143u8,
                99u8,
                214u8,
                61u8,
                33u8,
                103u8,
                107u8,
                28u8,
                108u8,
                11u8,
                79u8,
                156u8,
                188u8,
                107u8,
                228u8,
                207u8,
                84u8,
                73u8,
                89u8,
                90u8,
            ],
            [
                255u8,
                100u8,
                144u8,
                95u8,
                115u8,
                166u8,
                127u8,
                181u8,
                148u8,
                224u8,
                249u8,
                64u8,
                168u8,
                7u8,
                90u8,
                134u8,
                13u8,
                180u8,
                137u8,
                173u8,
                153u8,
                30u8,
                3u8,
                47u8,
                72u8,
                200u8,
                17u8,
                35u8,
                235u8,
                82u8,
                214u8,
                11u8,
            ],
        ];
    }
    #[automatically_derived]
    impl alloy_sol_types::SolEventInterface for ERC20InboxEvents {
        const NAME: &'static str = "ERC20InboxEvents";
        const COUNT: usize = 7usize;
        fn decode_raw_log(
            topics: &[alloy_sol_types::Word],
            data: &[u8],
            validate: bool,
        ) -> alloy_sol_types::Result<Self> {
            match topics.first().copied() {
                Some(
                    <AllowListAddressSet as alloy_sol_types::SolEvent>::SIGNATURE_HASH,
                ) => {
                    <AllowListAddressSet as alloy_sol_types::SolEvent>::decode_raw_log(
                            topics,
                            data,
                            validate,
                        )
                        .map(Self::AllowListAddressSet)
                }
                Some(
                    <AllowListEnabledUpdated as alloy_sol_types::SolEvent>::SIGNATURE_HASH,
                ) => {
                    <AllowListEnabledUpdated as alloy_sol_types::SolEvent>::decode_raw_log(
                            topics,
                            data,
                            validate,
                        )
                        .map(Self::AllowListEnabledUpdated)
                }
                Some(
                    <InboxMessageDelivered as alloy_sol_types::SolEvent>::SIGNATURE_HASH,
                ) => {
                    <InboxMessageDelivered as alloy_sol_types::SolEvent>::decode_raw_log(
                            topics,
                            data,
                            validate,
                        )
                        .map(Self::InboxMessageDelivered)
                }
                Some(
                    <InboxMessageDeliveredFromOrigin as alloy_sol_types::SolEvent>::SIGNATURE_HASH,
                ) => {
                    <InboxMessageDeliveredFromOrigin as alloy_sol_types::SolEvent>::decode_raw_log(
                            topics,
                            data,
                            validate,
                        )
                        .map(Self::InboxMessageDeliveredFromOrigin)
                }
                Some(<Initialized as alloy_sol_types::SolEvent>::SIGNATURE_HASH) => {
                    <Initialized as alloy_sol_types::SolEvent>::decode_raw_log(
                            topics,
                            data,
                            validate,
                        )
                        .map(Self::Initialized)
                }
                Some(<Paused as alloy_sol_types::SolEvent>::SIGNATURE_HASH) => {
                    <Paused as alloy_sol_types::SolEvent>::decode_raw_log(
                            topics,
                            data,
                            validate,
                        )
                        .map(Self::Paused)
                }
                Some(<Unpaused as alloy_sol_types::SolEvent>::SIGNATURE_HASH) => {
                    <Unpaused as alloy_sol_types::SolEvent>::decode_raw_log(
                            topics,
                            data,
                            validate,
                        )
                        .map(Self::Unpaused)
                }
                _ => {
                    alloy_sol_types::private::Err(alloy_sol_types::Error::InvalidLog {
                        name: <Self as alloy_sol_types::SolEventInterface>::NAME,
                        log: alloy_sol_types::private::Box::new(
                            alloy_sol_types::private::LogData::new_unchecked(
                                topics.to_vec(),
                                data.to_vec().into(),
                            ),
                        ),
                    })
                }
            }
        }
    }
    #[automatically_derived]
    impl alloy_sol_types::private::IntoLogData for ERC20InboxEvents {
        fn to_log_data(&self) -> alloy_sol_types::private::LogData {
            match self {
                Self::AllowListAddressSet(inner) => {
                    alloy_sol_types::private::IntoLogData::to_log_data(inner)
                }
                Self::AllowListEnabledUpdated(inner) => {
                    alloy_sol_types::private::IntoLogData::to_log_data(inner)
                }
                Self::InboxMessageDelivered(inner) => {
                    alloy_sol_types::private::IntoLogData::to_log_data(inner)
                }
                Self::InboxMessageDeliveredFromOrigin(inner) => {
                    alloy_sol_types::private::IntoLogData::to_log_data(inner)
                }
                Self::Initialized(inner) => {
                    alloy_sol_types::private::IntoLogData::to_log_data(inner)
                }
                Self::Paused(inner) => {
                    alloy_sol_types::private::IntoLogData::to_log_data(inner)
                }
                Self::Unpaused(inner) => {
                    alloy_sol_types::private::IntoLogData::to_log_data(inner)
                }
            }
        }
        fn into_log_data(self) -> alloy_sol_types::private::LogData {
            match self {
                Self::AllowListAddressSet(inner) => {
                    alloy_sol_types::private::IntoLogData::into_log_data(inner)
                }
                Self::AllowListEnabledUpdated(inner) => {
                    alloy_sol_types::private::IntoLogData::into_log_data(inner)
                }
                Self::InboxMessageDelivered(inner) => {
                    alloy_sol_types::private::IntoLogData::into_log_data(inner)
                }
                Self::InboxMessageDeliveredFromOrigin(inner) => {
                    alloy_sol_types::private::IntoLogData::into_log_data(inner)
                }
                Self::Initialized(inner) => {
                    alloy_sol_types::private::IntoLogData::into_log_data(inner)
                }
                Self::Paused(inner) => {
                    alloy_sol_types::private::IntoLogData::into_log_data(inner)
                }
                Self::Unpaused(inner) => {
                    alloy_sol_types::private::IntoLogData::into_log_data(inner)
                }
            }
        }
    }
    use alloy::contract as alloy_contract;
    /**Creates a new wrapper around an on-chain [`ERC20Inbox`](self) contract instance.

See the [wrapper's documentation](`ERC20InboxInstance`) for more details.*/
    #[inline]
    pub const fn new<
        T: alloy_contract::private::Transport + ::core::clone::Clone,
        P: alloy_contract::private::Provider<T, N>,
        N: alloy_contract::private::Network,
    >(
        address: alloy_sol_types::private::Address,
        provider: P,
    ) -> ERC20InboxInstance<T, P, N> {
        ERC20InboxInstance::<T, P, N>::new(address, provider)
    }
    /**Deploys this contract using the given `provider` and constructor arguments, if any.

Returns a new instance of the contract, if the deployment was successful.

For more fine-grained control over the deployment process, use [`deploy_builder`] instead.*/
    #[inline]
    pub fn deploy<
        T: alloy_contract::private::Transport + ::core::clone::Clone,
        P: alloy_contract::private::Provider<T, N>,
        N: alloy_contract::private::Network,
    >(
        provider: P,
        _maxDataSize: alloy::sol_types::private::primitives::aliases::U256,
    ) -> impl ::core::future::Future<
        Output = alloy_contract::Result<ERC20InboxInstance<T, P, N>>,
    > {
        ERC20InboxInstance::<T, P, N>::deploy(provider, _maxDataSize)
    }
    /**Creates a `RawCallBuilder` for deploying this contract using the given `provider`
and constructor arguments, if any.

This is a simple wrapper around creating a `RawCallBuilder` with the data set to
the bytecode concatenated with the constructor's ABI-encoded arguments.*/
    #[inline]
    pub fn deploy_builder<
        T: alloy_contract::private::Transport + ::core::clone::Clone,
        P: alloy_contract::private::Provider<T, N>,
        N: alloy_contract::private::Network,
    >(
        provider: P,
        _maxDataSize: alloy::sol_types::private::primitives::aliases::U256,
    ) -> alloy_contract::RawCallBuilder<T, P, N> {
        ERC20InboxInstance::<T, P, N>::deploy_builder(provider, _maxDataSize)
    }
    /**A [`ERC20Inbox`](self) instance.

Contains type-safe methods for interacting with an on-chain instance of the
[`ERC20Inbox`](self) contract located at a given `address`, using a given
provider `P`.

If the contract bytecode is available (see the [`sol!`](alloy_sol_types::sol!)
documentation on how to provide it), the `deploy` and `deploy_builder` methods can
be used to deploy a new instance of the contract.

See the [module-level documentation](self) for all the available methods.*/
    #[derive(Clone)]
    pub struct ERC20InboxInstance<T, P, N = alloy_contract::private::Ethereum> {
        address: alloy_sol_types::private::Address,
        provider: P,
        _network_transport: ::core::marker::PhantomData<(N, T)>,
    }
    #[automatically_derived]
    impl<T, P, N> ::core::fmt::Debug for ERC20InboxInstance<T, P, N> {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
            f.debug_tuple("ERC20InboxInstance").field(&self.address).finish()
        }
    }
    /// Instantiation and getters/setters.
    #[automatically_derived]
    impl<
        T: alloy_contract::private::Transport + ::core::clone::Clone,
        P: alloy_contract::private::Provider<T, N>,
        N: alloy_contract::private::Network,
    > ERC20InboxInstance<T, P, N> {
        /**Creates a new wrapper around an on-chain [`ERC20Inbox`](self) contract instance.

See the [wrapper's documentation](`ERC20InboxInstance`) for more details.*/
        #[inline]
        pub const fn new(
            address: alloy_sol_types::private::Address,
            provider: P,
        ) -> Self {
            Self {
                address,
                provider,
                _network_transport: ::core::marker::PhantomData,
            }
        }
        /**Deploys this contract using the given `provider` and constructor arguments, if any.

Returns a new instance of the contract, if the deployment was successful.

For more fine-grained control over the deployment process, use [`deploy_builder`] instead.*/
        #[inline]
        pub async fn deploy(
            provider: P,
            _maxDataSize: alloy::sol_types::private::primitives::aliases::U256,
        ) -> alloy_contract::Result<ERC20InboxInstance<T, P, N>> {
            let call_builder = Self::deploy_builder(provider, _maxDataSize);
            let contract_address = call_builder.deploy().await?;
            Ok(Self::new(contract_address, call_builder.provider))
        }
        /**Creates a `RawCallBuilder` for deploying this contract using the given `provider`
and constructor arguments, if any.

This is a simple wrapper around creating a `RawCallBuilder` with the data set to
the bytecode concatenated with the constructor's ABI-encoded arguments.*/
        #[inline]
        pub fn deploy_builder(
            provider: P,
            _maxDataSize: alloy::sol_types::private::primitives::aliases::U256,
        ) -> alloy_contract::RawCallBuilder<T, P, N> {
            alloy_contract::RawCallBuilder::new_raw_deploy(
                provider,
                [
                    &BYTECODE[..],
                    &alloy_sol_types::SolConstructor::abi_encode(
                        &constructorCall { _maxDataSize },
                    )[..],
                ]
                    .concat()
                    .into(),
            )
        }
        /// Returns a reference to the address.
        #[inline]
        pub const fn address(&self) -> &alloy_sol_types::private::Address {
            &self.address
        }
        /// Sets the address.
        #[inline]
        pub fn set_address(&mut self, address: alloy_sol_types::private::Address) {
            self.address = address;
        }
        /// Sets the address and returns `self`.
        pub fn at(mut self, address: alloy_sol_types::private::Address) -> Self {
            self.set_address(address);
            self
        }
        /// Returns a reference to the provider.
        #[inline]
        pub const fn provider(&self) -> &P {
            &self.provider
        }
    }
    impl<T, P: ::core::clone::Clone, N> ERC20InboxInstance<T, &P, N> {
        /// Clones the provider and returns a new instance with the cloned provider.
        #[inline]
        pub fn with_cloned_provider(self) -> ERC20InboxInstance<T, P, N> {
            ERC20InboxInstance {
                address: self.address,
                provider: ::core::clone::Clone::clone(&self.provider),
                _network_transport: ::core::marker::PhantomData,
            }
        }
    }
    /// Function calls.
    #[automatically_derived]
    impl<
        T: alloy_contract::private::Transport + ::core::clone::Clone,
        P: alloy_contract::private::Provider<T, N>,
        N: alloy_contract::private::Network,
    > ERC20InboxInstance<T, P, N> {
        /// Creates a new call builder using this contract instance's provider and address.
        ///
        /// Note that the call can be any function call, not just those defined in this
        /// contract. Prefer using the other methods for building type-safe contract calls.
        pub fn call_builder<C: alloy_sol_types::SolCall>(
            &self,
            call: &C,
        ) -> alloy_contract::SolCallBuilder<T, &P, C, N> {
            alloy_contract::SolCallBuilder::new_sol(&self.provider, &self.address, call)
        }
        ///Creates a new call builder for the [`allowListEnabled`] function.
        pub fn allowListEnabled(
            &self,
        ) -> alloy_contract::SolCallBuilder<T, &P, allowListEnabledCall, N> {
            self.call_builder(&allowListEnabledCall {})
        }
        ///Creates a new call builder for the [`bridge`] function.
        pub fn bridge(&self) -> alloy_contract::SolCallBuilder<T, &P, bridgeCall, N> {
            self.call_builder(&bridgeCall {})
        }
        ///Creates a new call builder for the [`calculateRetryableSubmissionFee`] function.
        pub fn calculateRetryableSubmissionFee(
            &self,
            _0: alloy::sol_types::private::primitives::aliases::U256,
            _1: alloy::sol_types::private::primitives::aliases::U256,
        ) -> alloy_contract::SolCallBuilder<
            T,
            &P,
            calculateRetryableSubmissionFeeCall,
            N,
        > {
            self.call_builder(
                &calculateRetryableSubmissionFeeCall {
                    _0,
                    _1,
                },
            )
        }
        ///Creates a new call builder for the [`createRetryableTicket`] function.
        pub fn createRetryableTicket(
            &self,
            to: alloy::sol_types::private::Address,
            l2CallValue: alloy::sol_types::private::primitives::aliases::U256,
            maxSubmissionCost: alloy::sol_types::private::primitives::aliases::U256,
            excessFeeRefundAddress: alloy::sol_types::private::Address,
            callValueRefundAddress: alloy::sol_types::private::Address,
            gasLimit: alloy::sol_types::private::primitives::aliases::U256,
            maxFeePerGas: alloy::sol_types::private::primitives::aliases::U256,
            tokenTotalFeeAmount: alloy::sol_types::private::primitives::aliases::U256,
            data: alloy::sol_types::private::Bytes,
        ) -> alloy_contract::SolCallBuilder<T, &P, createRetryableTicketCall, N> {
            self.call_builder(
                &createRetryableTicketCall {
                    to,
                    l2CallValue,
                    maxSubmissionCost,
                    excessFeeRefundAddress,
                    callValueRefundAddress,
                    gasLimit,
                    maxFeePerGas,
                    tokenTotalFeeAmount,
                    data,
                },
            )
        }
        ///Creates a new call builder for the [`depositERC20`] function.
        pub fn depositERC20(
            &self,
            amount: alloy::sol_types::private::primitives::aliases::U256,
        ) -> alloy_contract::SolCallBuilder<T, &P, depositERC20Call, N> {
            self.call_builder(&depositERC20Call { amount })
        }
        ///Creates a new call builder for the [`getProxyAdmin`] function.
        pub fn getProxyAdmin(
            &self,
        ) -> alloy_contract::SolCallBuilder<T, &P, getProxyAdminCall, N> {
            self.call_builder(&getProxyAdminCall {})
        }
        ///Creates a new call builder for the [`initialize`] function.
        pub fn initialize(
            &self,
            _bridge: alloy::sol_types::private::Address,
            _sequencerInbox: alloy::sol_types::private::Address,
        ) -> alloy_contract::SolCallBuilder<T, &P, initializeCall, N> {
            self.call_builder(
                &initializeCall {
                    _bridge,
                    _sequencerInbox,
                },
            )
        }
        ///Creates a new call builder for the [`isAllowed`] function.
        pub fn isAllowed(
            &self,
            _0: alloy::sol_types::private::Address,
        ) -> alloy_contract::SolCallBuilder<T, &P, isAllowedCall, N> {
            self.call_builder(&isAllowedCall { _0 })
        }
        ///Creates a new call builder for the [`maxDataSize`] function.
        pub fn maxDataSize(
            &self,
        ) -> alloy_contract::SolCallBuilder<T, &P, maxDataSizeCall, N> {
            self.call_builder(&maxDataSizeCall {})
        }
        ///Creates a new call builder for the [`pause`] function.
        pub fn pause(&self) -> alloy_contract::SolCallBuilder<T, &P, pauseCall, N> {
            self.call_builder(&pauseCall {})
        }
        ///Creates a new call builder for the [`paused`] function.
        pub fn paused(&self) -> alloy_contract::SolCallBuilder<T, &P, pausedCall, N> {
            self.call_builder(&pausedCall {})
        }
        ///Creates a new call builder for the [`sendContractTransaction`] function.
        pub fn sendContractTransaction(
            &self,
            gasLimit: alloy::sol_types::private::primitives::aliases::U256,
            maxFeePerGas: alloy::sol_types::private::primitives::aliases::U256,
            to: alloy::sol_types::private::Address,
            value: alloy::sol_types::private::primitives::aliases::U256,
            data: alloy::sol_types::private::Bytes,
        ) -> alloy_contract::SolCallBuilder<T, &P, sendContractTransactionCall, N> {
            self.call_builder(
                &sendContractTransactionCall {
                    gasLimit,
                    maxFeePerGas,
                    to,
                    value,
                    data,
                },
            )
        }
        ///Creates a new call builder for the [`sendL2Message`] function.
        pub fn sendL2Message(
            &self,
            messageData: alloy::sol_types::private::Bytes,
        ) -> alloy_contract::SolCallBuilder<T, &P, sendL2MessageCall, N> {
            self.call_builder(&sendL2MessageCall { messageData })
        }
        ///Creates a new call builder for the [`sendL2MessageFromOrigin`] function.
        pub fn sendL2MessageFromOrigin(
            &self,
            messageData: alloy::sol_types::private::Bytes,
        ) -> alloy_contract::SolCallBuilder<T, &P, sendL2MessageFromOriginCall, N> {
            self.call_builder(
                &sendL2MessageFromOriginCall {
                    messageData,
                },
            )
        }
        ///Creates a new call builder for the [`sendUnsignedTransaction`] function.
        pub fn sendUnsignedTransaction(
            &self,
            gasLimit: alloy::sol_types::private::primitives::aliases::U256,
            maxFeePerGas: alloy::sol_types::private::primitives::aliases::U256,
            nonce: alloy::sol_types::private::primitives::aliases::U256,
            to: alloy::sol_types::private::Address,
            value: alloy::sol_types::private::primitives::aliases::U256,
            data: alloy::sol_types::private::Bytes,
        ) -> alloy_contract::SolCallBuilder<T, &P, sendUnsignedTransactionCall, N> {
            self.call_builder(
                &sendUnsignedTransactionCall {
                    gasLimit,
                    maxFeePerGas,
                    nonce,
                    to,
                    value,
                    data,
                },
            )
        }
        ///Creates a new call builder for the [`sequencerInbox`] function.
        pub fn sequencerInbox(
            &self,
        ) -> alloy_contract::SolCallBuilder<T, &P, sequencerInboxCall, N> {
            self.call_builder(&sequencerInboxCall {})
        }
        ///Creates a new call builder for the [`setAllowList`] function.
        pub fn setAllowList(
            &self,
            user: alloy::sol_types::private::Vec<alloy::sol_types::private::Address>,
            val: alloy::sol_types::private::Vec<bool>,
        ) -> alloy_contract::SolCallBuilder<T, &P, setAllowListCall, N> {
            self.call_builder(&setAllowListCall { user, val })
        }
        ///Creates a new call builder for the [`setAllowListEnabled`] function.
        pub fn setAllowListEnabled(
            &self,
            _allowListEnabled: bool,
        ) -> alloy_contract::SolCallBuilder<T, &P, setAllowListEnabledCall, N> {
            self.call_builder(
                &setAllowListEnabledCall {
                    _allowListEnabled,
                },
            )
        }
        ///Creates a new call builder for the [`unpause`] function.
        pub fn unpause(&self) -> alloy_contract::SolCallBuilder<T, &P, unpauseCall, N> {
            self.call_builder(&unpauseCall {})
        }
        ///Creates a new call builder for the [`unsafeCreateRetryableTicket`] function.
        pub fn unsafeCreateRetryableTicket(
            &self,
            to: alloy::sol_types::private::Address,
            l2CallValue: alloy::sol_types::private::primitives::aliases::U256,
            maxSubmissionCost: alloy::sol_types::private::primitives::aliases::U256,
            excessFeeRefundAddress: alloy::sol_types::private::Address,
            callValueRefundAddress: alloy::sol_types::private::Address,
            gasLimit: alloy::sol_types::private::primitives::aliases::U256,
            maxFeePerGas: alloy::sol_types::private::primitives::aliases::U256,
            tokenTotalFeeAmount: alloy::sol_types::private::primitives::aliases::U256,
            data: alloy::sol_types::private::Bytes,
        ) -> alloy_contract::SolCallBuilder<T, &P, unsafeCreateRetryableTicketCall, N> {
            self.call_builder(
                &unsafeCreateRetryableTicketCall {
                    to,
                    l2CallValue,
                    maxSubmissionCost,
                    excessFeeRefundAddress,
                    callValueRefundAddress,
                    gasLimit,
                    maxFeePerGas,
                    tokenTotalFeeAmount,
                    data,
                },
            )
        }
    }
    /// Event filters.
    #[automatically_derived]
    impl<
        T: alloy_contract::private::Transport + ::core::clone::Clone,
        P: alloy_contract::private::Provider<T, N>,
        N: alloy_contract::private::Network,
    > ERC20InboxInstance<T, P, N> {
        /// Creates a new event filter using this contract instance's provider and address.
        ///
        /// Note that the type can be any event, not just those defined in this contract.
        /// Prefer using the other methods for building type-safe event filters.
        pub fn event_filter<E: alloy_sol_types::SolEvent>(
            &self,
        ) -> alloy_contract::Event<T, &P, E, N> {
            alloy_contract::Event::new_sol(&self.provider, &self.address)
        }
        ///Creates a new event filter for the [`AllowListAddressSet`] event.
        pub fn AllowListAddressSet_filter(
            &self,
        ) -> alloy_contract::Event<T, &P, AllowListAddressSet, N> {
            self.event_filter::<AllowListAddressSet>()
        }
        ///Creates a new event filter for the [`AllowListEnabledUpdated`] event.
        pub fn AllowListEnabledUpdated_filter(
            &self,
        ) -> alloy_contract::Event<T, &P, AllowListEnabledUpdated, N> {
            self.event_filter::<AllowListEnabledUpdated>()
        }
        ///Creates a new event filter for the [`InboxMessageDelivered`] event.
        pub fn InboxMessageDelivered_filter(
            &self,
        ) -> alloy_contract::Event<T, &P, InboxMessageDelivered, N> {
            self.event_filter::<InboxMessageDelivered>()
        }
        ///Creates a new event filter for the [`InboxMessageDeliveredFromOrigin`] event.
        pub fn InboxMessageDeliveredFromOrigin_filter(
            &self,
        ) -> alloy_contract::Event<T, &P, InboxMessageDeliveredFromOrigin, N> {
            self.event_filter::<InboxMessageDeliveredFromOrigin>()
        }
        ///Creates a new event filter for the [`Initialized`] event.
        pub fn Initialized_filter(
            &self,
        ) -> alloy_contract::Event<T, &P, Initialized, N> {
            self.event_filter::<Initialized>()
        }
        ///Creates a new event filter for the [`Paused`] event.
        pub fn Paused_filter(&self) -> alloy_contract::Event<T, &P, Paused, N> {
            self.event_filter::<Paused>()
        }
        ///Creates a new event filter for the [`Unpaused`] event.
        pub fn Unpaused_filter(&self) -> alloy_contract::Event<T, &P, Unpaused, N> {
            self.event_filter::<Unpaused>()
        }
    }
}
