/**

Generated by the following Solidity interface...
```solidity
interface DeployHelper {
    function ERC1820_DEPLOYER() external view returns (address);
    function ERC1820_PAYLOAD() external view returns (bytes memory);
    function ERC1820_VALUE() external view returns (uint256);
    function ERC2470_DEPLOYER() external view returns (address);
    function ERC2470_PAYLOAD() external view returns (bytes memory);
    function ERC2470_VALUE() external view returns (uint256);
    function NICK_CREATE2_DEPLOYER() external view returns (address);
    function NICK_CREATE2_PAYLOAD() external view returns (bytes memory);
    function NICK_CREATE2_VALUE() external view returns (uint256);
    function ZOLTU_CREATE2_DEPLOYER() external view returns (address);
    function ZOLTU_CREATE2_PAYLOAD() external view returns (bytes memory);
    function ZOLTU_VALUE() external view returns (uint256);
    function getDeploymentTotalCost(address inbox, uint256 maxFeePerGas) external view returns (uint256);
    function perform(address _inbox, address _nativeToken, uint256 _maxFeePerGas) external payable;
}
```

...which was generated by the following JSON ABI:
```json
[
  {
    "type": "function",
    "name": "ERC1820_DEPLOYER",
    "inputs": [],
    "outputs": [
      {
        "name": "",
        "type": "address",
        "internalType": "address"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "ERC1820_PAYLOAD",
    "inputs": [],
    "outputs": [
      {
        "name": "",
        "type": "bytes",
        "internalType": "bytes"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "ERC1820_VALUE",
    "inputs": [],
    "outputs": [
      {
        "name": "",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "ERC2470_DEPLOYER",
    "inputs": [],
    "outputs": [
      {
        "name": "",
        "type": "address",
        "internalType": "address"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "ERC2470_PAYLOAD",
    "inputs": [],
    "outputs": [
      {
        "name": "",
        "type": "bytes",
        "internalType": "bytes"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "ERC2470_VALUE",
    "inputs": [],
    "outputs": [
      {
        "name": "",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "NICK_CREATE2_DEPLOYER",
    "inputs": [],
    "outputs": [
      {
        "name": "",
        "type": "address",
        "internalType": "address"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "NICK_CREATE2_PAYLOAD",
    "inputs": [],
    "outputs": [
      {
        "name": "",
        "type": "bytes",
        "internalType": "bytes"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "NICK_CREATE2_VALUE",
    "inputs": [],
    "outputs": [
      {
        "name": "",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "ZOLTU_CREATE2_DEPLOYER",
    "inputs": [],
    "outputs": [
      {
        "name": "",
        "type": "address",
        "internalType": "address"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "ZOLTU_CREATE2_PAYLOAD",
    "inputs": [],
    "outputs": [
      {
        "name": "",
        "type": "bytes",
        "internalType": "bytes"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "ZOLTU_VALUE",
    "inputs": [],
    "outputs": [
      {
        "name": "",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "getDeploymentTotalCost",
    "inputs": [
      {
        "name": "inbox",
        "type": "address",
        "internalType": "contract IInboxBase"
      },
      {
        "name": "maxFeePerGas",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "perform",
    "inputs": [
      {
        "name": "_inbox",
        "type": "address",
        "internalType": "address"
      },
      {
        "name": "_nativeToken",
        "type": "address",
        "internalType": "address"
      },
      {
        "name": "_maxFeePerGas",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "outputs": [],
    "stateMutability": "payable"
  }
]
```*/
#[allow(
    non_camel_case_types,
    non_snake_case,
    clippy::pub_underscore_fields,
    clippy::style,
    clippy::empty_structs_with_brackets
)]
pub mod DeployHelper {
    use super::*;
    use alloy::sol_types as alloy_sol_types;
    /// The creation / init bytecode of the contract.
    ///
    /// ```text
    ///0x6080604052348015600e575f80fd5b506118de8061001c5f395ff3fe6080604052600436106100d9575f3560e01c80639ed2c6f01161007c578063d7c641e711610057578063d7c641e714610231578063db633c3e14610246578063dd0c625a1461015a578063ef77e71a14610261575f80fd5b80639ed2c6f0146101d1578063acd7d02a146101eb578063d3a3faab1461020a575f80fd5b80634367d652116100b75780634367d6521461015a57806355e34a6b1461018257806375ae22b5146101a957806389cf8ae6146101bd575f80fd5b80631b9a680c146100dd578063290302ce146101075780632e79664114610146575b5f80fd5b3480156100e8575f80fd5b506100f1610288565b6040516100fe9190610915565b60405180910390f35b348015610112575f80fd5b5061012e73a990077c3205cbdf861e17fa532eeb069ce9ff9681565b6040516001600160a01b0390911681526020016100fe565b348015610151575f80fd5b506100f16102a4565b348015610165575f80fd5b50610174662386f26fc1000081565b6040519081526020016100fe565b34801561018d575f80fd5b5061012e73bb6e024b9cffacb947a71991e386681b1cd1477d81565b3480156101b4575f80fd5b506100f16102c3565b3480156101c8575f80fd5b506100f16102df565b3480156101dc575f80fd5b506101746657c084e5f3c00081565b3480156101f6575f80fd5b5061017461020536600461097f565b6102fe565b348015610215575f80fd5b5061012e734c8d290a1b368ac4728d83a9e8321fc3af2b39b181565b61024461023f3660046109a9565b6103f5565b005b348015610251575f80fd5b5061017467011c37937e08000081565b34801561026c575f80fd5b5061012e733fab184622dc19b6109349b94811493bf2a4536281565b6040518060e0016040528060a8815260200161180160a8913981565b60405180610a600160405280610a3c8152602001610bd4610a3c913981565b6040518060c00160405280608181526020016116106081913981565b604051806101a001604052806101708152602001611691610170913981565b6040517fa66b327d0000000000000000000000000000000000000000000000000000000081525f600482018190524860248301529081906001600160a01b0385169063a66b327d90604401602060405180830381865afa158015610364573d5f803e3d5ffd5b505050506040513d601f19601f8201168201806040525081019061038891906109e7565b905061039683615208610a2b565b6103a09082610a42565b6103ab906004610a2b565b67011c37937e080000662386f26fc100006103cd6657c084e5f3c00082610a42565b6103d79190610a42565b6103e19190610a42565b6103eb9190610a42565b9150505b92915050565b61043683662386f26fc10000733fab184622dc19b6109349b94811493bf2a453626040518060e0016040528060a8815260200161180160a89139868661053e565b61047a836657c084e5f3c00073bb6e024b9cffacb947a71991e386681b1cd1477d604051806101a0016040528061017081526020016116916101709139868661053e565b6104bb83662386f26fc10000734c8d290a1b368ac4728d83a9e8321fc3af2b39b16040518060c001604052806081815260200161161060819139868661053e565b6105008367011c37937e08000073a990077c3205cbdf861e17fa532eeb069ce9ff9660405180610a600160405280610a3c8152602001610bd4610a3c9139868661053e565b6001600160a01b0382166105395760405133904780156108fc02915f818181858888f19350505050158015610537573d5f803e3d5ffd5b505b505050565b6040517fa66b327d0000000000000000000000000000000000000000000000000000000081525f60048201819052486024830152906001600160a01b0388169063a66b327d90604401602060405180830381865afa1580156105a2573d5f803e3d5ffd5b505050506040513d601f19601f820116820180604052508101906105c691906109e7565b90505f6105d583615208610a2b565b6105df8389610a42565b6105e99190610a42565b90506001600160a01b038416156107c4575f8190505f856001600160a01b031663313ce5676040518163ffffffff1660e01b8152600401602060405180830381865afa15801561063b573d5f803e3d5ffd5b505050506040513d601f19601f8201168201806040525081019061065f9190610a55565b905060128160ff1610156106c957610678816012610a7c565b61068390600a610b75565b61068d9084610b83565b91508261069b826012610a7c565b6106a690600a610b75565b6106b09084610a2b565b10156106c457816106c081610bbb565b9250505b6106f8565b60128160ff1611156106f8576106e0601282610a7c565b6106eb90600a610b75565b6106f59084610a2b565b91505b6040517f549e84260000000000000000000000000000000000000000000000000000000081526001600160a01b038981166004830152602482018b9052604482018690523360648301819052608483015261520860a483015260c4820187905260e482018490526101206101048301525f6101248301528b169063549e842690610144016020604051808303815f875af1158015610798573d5f803e3d5ffd5b505050506040513d601f19601f820116820180604052508101906107bc91906109e7565b505050610885565b6040517f679b6ded0000000000000000000000000000000000000000000000000000000081526001600160a01b03878116600483015260248201899052604482018490523360648301819052608483015261520860a483015260c4820185905261010060e48301525f61010483015289169063679b6ded9083906101240160206040518083038185885af115801561085e573d5f803e3d5ffd5b50505050506040513d601f19601f8201168201806040525081019061088391906109e7565b505b6040517fb75436bb0000000000000000000000000000000000000000000000000000000081526001600160a01b0389169063b75436bb906108ca908890600401610915565b6020604051808303815f875af11580156108e6573d5f803e3d5ffd5b505050506040513d601f19601f8201168201806040525081019061090a91906109e7565b505050505050505050565b602081525f82518060208401528060208501604085015e5f6040828501015260407fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe0601f83011684010191505092915050565b6001600160a01b038116811461097c575f80fd5b50565b5f8060408385031215610990575f80fd5b823561099b81610968565b946020939093013593505050565b5f805f606084860312156109bb575f80fd5b83356109c681610968565b925060208401356109d681610968565b929592945050506040919091013590565b5f602082840312156109f7575f80fd5b5051919050565b7f4e487b71000000000000000000000000000000000000000000000000000000005f52601160045260245ffd5b80820281158282048414176103ef576103ef6109fe565b808201808211156103ef576103ef6109fe565b5f60208284031215610a65575f80fd5b815160ff81168114610a75575f80fd5b9392505050565b60ff82811682821603908111156103ef576103ef6109fe565b600181815b80851115610acf57815f1904821115610ab557610ab56109fe565b80851615610ac257918102915b93841c9390800290610a9a565b509250929050565b5f82610ae5575060016103ef565b81610af157505f6103ef565b8160018114610b075760028114610b1157610b2d565b60019150506103ef565b60ff841115610b2257610b226109fe565b50506001821b6103ef565b5060208310610133831016604e8410600b8410161715610b50575081810a6103ef565b610b5a8383610a95565b805f1904821115610b6d57610b6d6109fe565b029392505050565b5f610a7560ff841683610ad7565b5f82610bb6577f4e487b71000000000000000000000000000000000000000000000000000000005f52601260045260245ffd5b500490565b5f5f198203610bcc57610bcc6109fe565b506001019056fe04f90a388085174876e800830c35008080b909e5608060405234801561001057600080fd5b506109c5806100206000396000f3fe608060405234801561001057600080fd5b50600436106100a5576000357c010000000000000000000000000000000000000000000000000000000090048063a41e7d5111610078578063a41e7d51146101d4578063aabbb8ca1461020a578063b705676514610236578063f712f3e814610280576100a5565b806329965a1d146100aa5780633d584063146100e25780635df8122f1461012457806365ba36c114610152575b600080fd5b6100e0600480360360608110156100c057600080fd5b50600160a060020a038135811691602081013591604090910135166102b6565b005b610108600480360360208110156100f857600080fd5b5035600160a060020a0316610570565b60408051600160a060020a039092168252519081900360200190f35b6100e06004803603604081101561013a57600080fd5b50600160a060020a03813581169160200135166105bc565b6101c26004803603602081101561016857600080fd5b81019060208101813564010000000081111561018357600080fd5b82018360208201111561019557600080fd5b803590602001918460018302840111640100000000831117156101b757600080fd5b5090925090506106b3565b60408051918252519081900360200190f35b6100e0600480360360408110156101ea57600080fd5b508035600160a060020a03169060200135600160e060020a0319166106ee565b6101086004803603604081101561022057600080fd5b50600160a060020a038135169060200135610778565b61026c6004803603604081101561024c57600080fd5b508035600160a060020a03169060200135600160e060020a0319166107ef565b604080519115158252519081900360200190f35b61026c6004803603604081101561029657600080fd5b508035600160a060020a03169060200135600160e060020a0319166108aa565b6000600160a060020a038416156102cd57836102cf565b335b9050336102db82610570565b600160a060020a031614610339576040805160e560020a62461bcd02815260206004820152600f60248201527f4e6f7420746865206d616e616765720000000000000000000000000000000000604482015290519081900360640190fd5b6103428361092a565b15610397576040805160e560020a62461bcd02815260206004820152601a60248201527f4d757374206e6f7420626520616e204552433136352068617368000000000000604482015290519081900360640190fd5b600160a060020a038216158015906103b85750600160a060020a0382163314155b156104ff5760405160200180807f455243313832305f4143434550545f4d4147494300000000000000000000000081525060140190506040516020818303038152906040528051906020012082600160a060020a031663249cb3fa85846040518363ffffffff167c01000000000000000000000000000000000000000000000000000000000281526004018083815260200182600160a060020a0316600160a060020a031681526020019250505060206040518083038186803b15801561047e57600080fd5b505afa158015610492573d6000803e3d6000fd5b505050506040513d60208110156104a857600080fd5b5051146104ff576040805160e560020a62461bcd02815260206004820181905260248201527f446f6573206e6f7420696d706c656d656e742074686520696e74657266616365604482015290519081900360640190fd5b600160a060020a03818116600081815260208181526040808320888452909152808220805473ffffffffffffffffffffffffffffffffffffffff19169487169485179055518692917f93baa6efbd2244243bfee6ce4cfdd1d04fc4c0e9a786abd3a41313bd352db15391a450505050565b600160a060020a03818116600090815260016020526040812054909116151561059a5750806105b7565b50600160a060020a03808216600090815260016020526040902054165b919050565b336105c683610570565b600160a060020a031614610624576040805160e560020a62461bcd02815260206004820152600f60248201527f4e6f7420746865206d616e616765720000000000000000000000000000000000604482015290519081900360640190fd5b81600160a060020a031681600160a060020a0316146106435780610646565b60005b600160a060020a03838116600081815260016020526040808220805473ffffffffffffffffffffffffffffffffffffffff19169585169590951790945592519184169290917f605c2dbf762e5f7d60a546d42e7205dcb1b011ebc62a61736a57c9089d3a43509190a35050565b600082826040516020018083838082843780830192505050925050506040516020818303038152906040528051906020012090505b92915050565b6106f882826107ef565b610703576000610705565b815b600160a060020a03928316600081815260208181526040808320600160e060020a031996909616808452958252808320805473ffffffffffffffffffffffffffffffffffffffff19169590971694909417909555908152600284528181209281529190925220805460ff19166001179055565b600080600160a060020a038416156107905783610792565b335b905061079d8361092a565b156107c357826107ad82826108aa565b6107b85760006107ba565b815b925050506106e8565b600160a060020a0390811660009081526020818152604080832086845290915290205416905092915050565b6000808061081d857f01ffc9a70000000000000000000000000000000000000000000000000000000061094c565b909250905081158061082d575080155b1561083d576000925050506106e8565b61084f85600160e060020a031961094c565b909250905081158061086057508015155b15610870576000925050506106e8565b61087a858561094c565b909250905060018214801561088f5750806001145b1561089f576001925050506106e8565b506000949350505050565b600160a060020a0382166000908152600260209081526040808320600160e060020a03198516845290915281205460ff1615156108f2576108eb83836107ef565b90506106e8565b50600160a060020a03808316600081815260208181526040808320600160e060020a0319871684529091529020549091161492915050565b7bffffffffffffffffffffffffffffffffffffffffffffffffffffffff161590565b6040517f01ffc9a7000000000000000000000000000000000000000000000000000000008082526004820183905260009182919060208160248189617530fa90519096909550935050505056fea165627a7a72305820377f4a2d4301ede9949f163f319021a6e9c687c292a5e2b2c4734c126b524e6c00291ba01820182018201820182018201820182018201820182018201820182018201820a0182018201820182018201820182018201820182018201820182018201820182004f87e8085174876e800830186a08080ad601f80600e600039806000f350fe60003681823780368234f58015156014578182fd5b80825250506014600cf31ba02222222222222222222222222222222222222222222222222222222222222222a0222222222222222222222222222222222222222222222222222222222222222204f9016c8085174876e8008303c4d88080b90154608060405234801561001057600080fd5b50610134806100206000396000f3fe6080604052348015600f57600080fd5b506004361060285760003560e01c80634af63f0214602d575b600080fd5b60cf60048036036040811015604157600080fd5b810190602081018135640100000000811115605b57600080fd5b820183602082011115606c57600080fd5b80359060200191846001830284011164010000000083111715608d57600080fd5b91908080601f016020809104026020016040519081016040528093929190818152602001838380828437600092019190915250929550509135925060eb915050565b604080516001600160a01b039092168252519081900360200190f35b6000818351602085016000f5939250505056fea26469706673582212206b44f8a82cb6b156bfcc3dc6aadd6df4eefd204bc928a4397fd15dacf6d5320564736f6c634300060200331b8324700082247004f8a58085174876e800830186a08080b853604580600e600039806000f350fe7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe03601600081602082378035828234f58015156039578182fd5b8082525050506014600cf31ba02222222222222222222222222222222222222222222222222222222222222222a02222222222222222222222222222222222222222222222222222222222222222a264697066735822122011e044925802508a8ecf8aecb24780422b3e0e735fa47e1e07c746292e21bbd664736f6c63430008190033
    /// ```
    #[rustfmt::skip]
    #[allow(clippy::all)]
    pub static BYTECODE: alloy_sol_types::private::Bytes = alloy_sol_types::private::Bytes::from_static(
        b"`\x80`@R4\x80\x15`\x0EW_\x80\xFD[Pa\x18\xDE\x80a\0\x1C_9_\xF3\xFE`\x80`@R`\x046\x10a\0\xD9W_5`\xE0\x1C\x80c\x9E\xD2\xC6\xF0\x11a\0|W\x80c\xD7\xC6A\xE7\x11a\0WW\x80c\xD7\xC6A\xE7\x14a\x021W\x80c\xDBc<>\x14a\x02FW\x80c\xDD\x0CbZ\x14a\x01ZW\x80c\xEFw\xE7\x1A\x14a\x02aW_\x80\xFD[\x80c\x9E\xD2\xC6\xF0\x14a\x01\xD1W\x80c\xAC\xD7\xD0*\x14a\x01\xEBW\x80c\xD3\xA3\xFA\xAB\x14a\x02\nW_\x80\xFD[\x80cCg\xD6R\x11a\0\xB7W\x80cCg\xD6R\x14a\x01ZW\x80cU\xE3Jk\x14a\x01\x82W\x80cu\xAE\"\xB5\x14a\x01\xA9W\x80c\x89\xCF\x8A\xE6\x14a\x01\xBDW_\x80\xFD[\x80c\x1B\x9Ah\x0C\x14a\0\xDDW\x80c)\x03\x02\xCE\x14a\x01\x07W\x80c.yfA\x14a\x01FW[_\x80\xFD[4\x80\x15a\0\xE8W_\x80\xFD[Pa\0\xF1a\x02\x88V[`@Qa\0\xFE\x91\x90a\t\x15V[`@Q\x80\x91\x03\x90\xF3[4\x80\x15a\x01\x12W_\x80\xFD[Pa\x01.s\xA9\x90\x07|2\x05\xCB\xDF\x86\x1E\x17\xFAS.\xEB\x06\x9C\xE9\xFF\x96\x81V[`@Q`\x01`\x01`\xA0\x1B\x03\x90\x91\x16\x81R` \x01a\0\xFEV[4\x80\x15a\x01QW_\x80\xFD[Pa\0\xF1a\x02\xA4V[4\x80\x15a\x01eW_\x80\xFD[Pa\x01tf#\x86\xF2o\xC1\0\0\x81V[`@Q\x90\x81R` \x01a\0\xFEV[4\x80\x15a\x01\x8DW_\x80\xFD[Pa\x01.s\xBBn\x02K\x9C\xFF\xAC\xB9G\xA7\x19\x91\xE3\x86h\x1B\x1C\xD1G}\x81V[4\x80\x15a\x01\xB4W_\x80\xFD[Pa\0\xF1a\x02\xC3V[4\x80\x15a\x01\xC8W_\x80\xFD[Pa\0\xF1a\x02\xDFV[4\x80\x15a\x01\xDCW_\x80\xFD[Pa\x01tfW\xC0\x84\xE5\xF3\xC0\0\x81V[4\x80\x15a\x01\xF6W_\x80\xFD[Pa\x01ta\x02\x056`\x04a\t\x7FV[a\x02\xFEV[4\x80\x15a\x02\x15W_\x80\xFD[Pa\x01.sL\x8D)\n\x1B6\x8A\xC4r\x8D\x83\xA9\xE82\x1F\xC3\xAF+9\xB1\x81V[a\x02Da\x02?6`\x04a\t\xA9V[a\x03\xF5V[\0[4\x80\x15a\x02QW_\x80\xFD[Pa\x01tg\x01\x1C7\x93~\x08\0\0\x81V[4\x80\x15a\x02lW_\x80\xFD[Pa\x01.s?\xAB\x18F\"\xDC\x19\xB6\x10\x93I\xB9H\x11I;\xF2\xA4Sb\x81V[`@Q\x80`\xE0\x01`@R\x80`\xA8\x81R` \x01a\x18\x01`\xA8\x919\x81V[`@Q\x80a\n`\x01`@R\x80a\n<\x81R` \x01a\x0B\xD4a\n<\x919\x81V[`@Q\x80`\xC0\x01`@R\x80`\x81\x81R` \x01a\x16\x10`\x81\x919\x81V[`@Q\x80a\x01\xA0\x01`@R\x80a\x01p\x81R` \x01a\x16\x91a\x01p\x919\x81V[`@Q\x7F\xA6k2}\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R_`\x04\x82\x01\x81\x90RH`$\x83\x01R\x90\x81\x90`\x01`\x01`\xA0\x1B\x03\x85\x16\x90c\xA6k2}\x90`D\x01` `@Q\x80\x83\x03\x81\x86Z\xFA\x15\x80\x15a\x03dW=_\x80>=_\xFD[PPPP`@Q=`\x1F\x19`\x1F\x82\x01\x16\x82\x01\x80`@RP\x81\x01\x90a\x03\x88\x91\x90a\t\xE7V[\x90Pa\x03\x96\x83aR\x08a\n+V[a\x03\xA0\x90\x82a\nBV[a\x03\xAB\x90`\x04a\n+V[g\x01\x1C7\x93~\x08\0\0f#\x86\xF2o\xC1\0\0a\x03\xCDfW\xC0\x84\xE5\xF3\xC0\0\x82a\nBV[a\x03\xD7\x91\x90a\nBV[a\x03\xE1\x91\x90a\nBV[a\x03\xEB\x91\x90a\nBV[\x91PP[\x92\x91PPV[a\x046\x83f#\x86\xF2o\xC1\0\0s?\xAB\x18F\"\xDC\x19\xB6\x10\x93I\xB9H\x11I;\xF2\xA4Sb`@Q\x80`\xE0\x01`@R\x80`\xA8\x81R` \x01a\x18\x01`\xA8\x919\x86\x86a\x05>V[a\x04z\x83fW\xC0\x84\xE5\xF3\xC0\0s\xBBn\x02K\x9C\xFF\xAC\xB9G\xA7\x19\x91\xE3\x86h\x1B\x1C\xD1G}`@Q\x80a\x01\xA0\x01`@R\x80a\x01p\x81R` \x01a\x16\x91a\x01p\x919\x86\x86a\x05>V[a\x04\xBB\x83f#\x86\xF2o\xC1\0\0sL\x8D)\n\x1B6\x8A\xC4r\x8D\x83\xA9\xE82\x1F\xC3\xAF+9\xB1`@Q\x80`\xC0\x01`@R\x80`\x81\x81R` \x01a\x16\x10`\x81\x919\x86\x86a\x05>V[a\x05\0\x83g\x01\x1C7\x93~\x08\0\0s\xA9\x90\x07|2\x05\xCB\xDF\x86\x1E\x17\xFAS.\xEB\x06\x9C\xE9\xFF\x96`@Q\x80a\n`\x01`@R\x80a\n<\x81R` \x01a\x0B\xD4a\n<\x919\x86\x86a\x05>V[`\x01`\x01`\xA0\x1B\x03\x82\x16a\x059W`@Q3\x90G\x80\x15a\x08\xFC\x02\x91_\x81\x81\x81\x85\x88\x88\xF1\x93PPPP\x15\x80\x15a\x057W=_\x80>=_\xFD[P[PPPV[`@Q\x7F\xA6k2}\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R_`\x04\x82\x01\x81\x90RH`$\x83\x01R\x90`\x01`\x01`\xA0\x1B\x03\x88\x16\x90c\xA6k2}\x90`D\x01` `@Q\x80\x83\x03\x81\x86Z\xFA\x15\x80\x15a\x05\xA2W=_\x80>=_\xFD[PPPP`@Q=`\x1F\x19`\x1F\x82\x01\x16\x82\x01\x80`@RP\x81\x01\x90a\x05\xC6\x91\x90a\t\xE7V[\x90P_a\x05\xD5\x83aR\x08a\n+V[a\x05\xDF\x83\x89a\nBV[a\x05\xE9\x91\x90a\nBV[\x90P`\x01`\x01`\xA0\x1B\x03\x84\x16\x15a\x07\xC4W_\x81\x90P_\x85`\x01`\x01`\xA0\x1B\x03\x16c1<\xE5g`@Q\x81c\xFF\xFF\xFF\xFF\x16`\xE0\x1B\x81R`\x04\x01` `@Q\x80\x83\x03\x81\x86Z\xFA\x15\x80\x15a\x06;W=_\x80>=_\xFD[PPPP`@Q=`\x1F\x19`\x1F\x82\x01\x16\x82\x01\x80`@RP\x81\x01\x90a\x06_\x91\x90a\nUV[\x90P`\x12\x81`\xFF\x16\x10\x15a\x06\xC9Wa\x06x\x81`\x12a\n|V[a\x06\x83\x90`\na\x0BuV[a\x06\x8D\x90\x84a\x0B\x83V[\x91P\x82a\x06\x9B\x82`\x12a\n|V[a\x06\xA6\x90`\na\x0BuV[a\x06\xB0\x90\x84a\n+V[\x10\x15a\x06\xC4W\x81a\x06\xC0\x81a\x0B\xBBV[\x92PP[a\x06\xF8V[`\x12\x81`\xFF\x16\x11\x15a\x06\xF8Wa\x06\xE0`\x12\x82a\n|V[a\x06\xEB\x90`\na\x0BuV[a\x06\xF5\x90\x84a\n+V[\x91P[`@Q\x7FT\x9E\x84&\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x01`\x01`\xA0\x1B\x03\x89\x81\x16`\x04\x83\x01R`$\x82\x01\x8B\x90R`D\x82\x01\x86\x90R3`d\x83\x01\x81\x90R`\x84\x83\x01RaR\x08`\xA4\x83\x01R`\xC4\x82\x01\x87\x90R`\xE4\x82\x01\x84\x90Ra\x01 a\x01\x04\x83\x01R_a\x01$\x83\x01R\x8B\x16\x90cT\x9E\x84&\x90a\x01D\x01` `@Q\x80\x83\x03\x81_\x87Z\xF1\x15\x80\x15a\x07\x98W=_\x80>=_\xFD[PPPP`@Q=`\x1F\x19`\x1F\x82\x01\x16\x82\x01\x80`@RP\x81\x01\x90a\x07\xBC\x91\x90a\t\xE7V[PPPa\x08\x85V[`@Q\x7Fg\x9Bm\xED\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x01`\x01`\xA0\x1B\x03\x87\x81\x16`\x04\x83\x01R`$\x82\x01\x89\x90R`D\x82\x01\x84\x90R3`d\x83\x01\x81\x90R`\x84\x83\x01RaR\x08`\xA4\x83\x01R`\xC4\x82\x01\x85\x90Ra\x01\0`\xE4\x83\x01R_a\x01\x04\x83\x01R\x89\x16\x90cg\x9Bm\xED\x90\x83\x90a\x01$\x01` `@Q\x80\x83\x03\x81\x85\x88Z\xF1\x15\x80\x15a\x08^W=_\x80>=_\xFD[PPPPP`@Q=`\x1F\x19`\x1F\x82\x01\x16\x82\x01\x80`@RP\x81\x01\x90a\x08\x83\x91\x90a\t\xE7V[P[`@Q\x7F\xB7T6\xBB\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x01`\x01`\xA0\x1B\x03\x89\x16\x90c\xB7T6\xBB\x90a\x08\xCA\x90\x88\x90`\x04\x01a\t\x15V[` `@Q\x80\x83\x03\x81_\x87Z\xF1\x15\x80\x15a\x08\xE6W=_\x80>=_\xFD[PPPP`@Q=`\x1F\x19`\x1F\x82\x01\x16\x82\x01\x80`@RP\x81\x01\x90a\t\n\x91\x90a\t\xE7V[PPPPPPPPPV[` \x81R_\x82Q\x80` \x84\x01R\x80` \x85\x01`@\x85\x01^_`@\x82\x85\x01\x01R`@\x7F\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xE0`\x1F\x83\x01\x16\x84\x01\x01\x91PP\x92\x91PPV[`\x01`\x01`\xA0\x1B\x03\x81\x16\x81\x14a\t|W_\x80\xFD[PV[_\x80`@\x83\x85\x03\x12\x15a\t\x90W_\x80\xFD[\x825a\t\x9B\x81a\thV[\x94` \x93\x90\x93\x015\x93PPPV[_\x80_``\x84\x86\x03\x12\x15a\t\xBBW_\x80\xFD[\x835a\t\xC6\x81a\thV[\x92P` \x84\x015a\t\xD6\x81a\thV[\x92\x95\x92\x94PPP`@\x91\x90\x91\x015\x90V[_` \x82\x84\x03\x12\x15a\t\xF7W_\x80\xFD[PQ\x91\x90PV[\x7FNH{q\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0_R`\x11`\x04R`$_\xFD[\x80\x82\x02\x81\x15\x82\x82\x04\x84\x14\x17a\x03\xEFWa\x03\xEFa\t\xFEV[\x80\x82\x01\x80\x82\x11\x15a\x03\xEFWa\x03\xEFa\t\xFEV[_` \x82\x84\x03\x12\x15a\neW_\x80\xFD[\x81Q`\xFF\x81\x16\x81\x14a\nuW_\x80\xFD[\x93\x92PPPV[`\xFF\x82\x81\x16\x82\x82\x16\x03\x90\x81\x11\x15a\x03\xEFWa\x03\xEFa\t\xFEV[`\x01\x81\x81[\x80\x85\x11\x15a\n\xCFW\x81_\x19\x04\x82\x11\x15a\n\xB5Wa\n\xB5a\t\xFEV[\x80\x85\x16\x15a\n\xC2W\x91\x81\x02\x91[\x93\x84\x1C\x93\x90\x80\x02\x90a\n\x9AV[P\x92P\x92\x90PV[_\x82a\n\xE5WP`\x01a\x03\xEFV[\x81a\n\xF1WP_a\x03\xEFV[\x81`\x01\x81\x14a\x0B\x07W`\x02\x81\x14a\x0B\x11Wa\x0B-V[`\x01\x91PPa\x03\xEFV[`\xFF\x84\x11\x15a\x0B\"Wa\x0B\"a\t\xFEV[PP`\x01\x82\x1Ba\x03\xEFV[P` \x83\x10a\x013\x83\x10\x16`N\x84\x10`\x0B\x84\x10\x16\x17\x15a\x0BPWP\x81\x81\na\x03\xEFV[a\x0BZ\x83\x83a\n\x95V[\x80_\x19\x04\x82\x11\x15a\x0BmWa\x0Bma\t\xFEV[\x02\x93\x92PPPV[_a\nu`\xFF\x84\x16\x83a\n\xD7V[_\x82a\x0B\xB6W\x7FNH{q\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0_R`\x12`\x04R`$_\xFD[P\x04\x90V[__\x19\x82\x03a\x0B\xCCWa\x0B\xCCa\t\xFEV[P`\x01\x01\x90V\xFE\x04\xF9\n8\x80\x85\x17Hv\xE8\0\x83\x0C5\0\x80\x80\xB9\t\xE5`\x80`@R4\x80\x15a\0\x10W`\0\x80\xFD[Pa\t\xC5\x80a\0 `\09`\0\xF3\xFE`\x80`@R4\x80\x15a\0\x10W`\0\x80\xFD[P`\x046\x10a\0\xA5W`\x005|\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x90\x04\x80c\xA4\x1E}Q\x11a\0xW\x80c\xA4\x1E}Q\x14a\x01\xD4W\x80c\xAA\xBB\xB8\xCA\x14a\x02\nW\x80c\xB7\x05ge\x14a\x026W\x80c\xF7\x12\xF3\xE8\x14a\x02\x80Wa\0\xA5V[\x80c)\x96Z\x1D\x14a\0\xAAW\x80c=X@c\x14a\0\xE2W\x80c]\xF8\x12/\x14a\x01$W\x80ce\xBA6\xC1\x14a\x01RW[`\0\x80\xFD[a\0\xE0`\x04\x806\x03``\x81\x10\x15a\0\xC0W`\0\x80\xFD[P`\x01`\xA0`\x02\n\x03\x815\x81\x16\x91` \x81\x015\x91`@\x90\x91\x015\x16a\x02\xB6V[\0[a\x01\x08`\x04\x806\x03` \x81\x10\x15a\0\xF8W`\0\x80\xFD[P5`\x01`\xA0`\x02\n\x03\x16a\x05pV[`@\x80Q`\x01`\xA0`\x02\n\x03\x90\x92\x16\x82RQ\x90\x81\x90\x03` \x01\x90\xF3[a\0\xE0`\x04\x806\x03`@\x81\x10\x15a\x01:W`\0\x80\xFD[P`\x01`\xA0`\x02\n\x03\x815\x81\x16\x91` \x015\x16a\x05\xBCV[a\x01\xC2`\x04\x806\x03` \x81\x10\x15a\x01hW`\0\x80\xFD[\x81\x01\x90` \x81\x01\x815d\x01\0\0\0\0\x81\x11\x15a\x01\x83W`\0\x80\xFD[\x82\x01\x83` \x82\x01\x11\x15a\x01\x95W`\0\x80\xFD[\x805\x90` \x01\x91\x84`\x01\x83\x02\x84\x01\x11d\x01\0\0\0\0\x83\x11\x17\x15a\x01\xB7W`\0\x80\xFD[P\x90\x92P\x90Pa\x06\xB3V[`@\x80Q\x91\x82RQ\x90\x81\x90\x03` \x01\x90\xF3[a\0\xE0`\x04\x806\x03`@\x81\x10\x15a\x01\xEAW`\0\x80\xFD[P\x805`\x01`\xA0`\x02\n\x03\x16\x90` \x015`\x01`\xE0`\x02\n\x03\x19\x16a\x06\xEEV[a\x01\x08`\x04\x806\x03`@\x81\x10\x15a\x02 W`\0\x80\xFD[P`\x01`\xA0`\x02\n\x03\x815\x16\x90` \x015a\x07xV[a\x02l`\x04\x806\x03`@\x81\x10\x15a\x02LW`\0\x80\xFD[P\x805`\x01`\xA0`\x02\n\x03\x16\x90` \x015`\x01`\xE0`\x02\n\x03\x19\x16a\x07\xEFV[`@\x80Q\x91\x15\x15\x82RQ\x90\x81\x90\x03` \x01\x90\xF3[a\x02l`\x04\x806\x03`@\x81\x10\x15a\x02\x96W`\0\x80\xFD[P\x805`\x01`\xA0`\x02\n\x03\x16\x90` \x015`\x01`\xE0`\x02\n\x03\x19\x16a\x08\xAAV[`\0`\x01`\xA0`\x02\n\x03\x84\x16\x15a\x02\xCDW\x83a\x02\xCFV[3[\x90P3a\x02\xDB\x82a\x05pV[`\x01`\xA0`\x02\n\x03\x16\x14a\x039W`@\x80Q`\xE5`\x02\nbF\x1B\xCD\x02\x81R` `\x04\x82\x01R`\x0F`$\x82\x01R\x7FNot the manager\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0`D\x82\x01R\x90Q\x90\x81\x90\x03`d\x01\x90\xFD[a\x03B\x83a\t*V[\x15a\x03\x97W`@\x80Q`\xE5`\x02\nbF\x1B\xCD\x02\x81R` `\x04\x82\x01R`\x1A`$\x82\x01R\x7FMust not be an ERC165 hash\0\0\0\0\0\0`D\x82\x01R\x90Q\x90\x81\x90\x03`d\x01\x90\xFD[`\x01`\xA0`\x02\n\x03\x82\x16\x15\x80\x15\x90a\x03\xB8WP`\x01`\xA0`\x02\n\x03\x82\x163\x14\x15[\x15a\x04\xFFW`@Q` \x01\x80\x80\x7FERC1820_ACCEPT_MAGIC\0\0\0\0\0\0\0\0\0\0\0\0\x81RP`\x14\x01\x90P`@Q` \x81\x83\x03\x03\x81R\x90`@R\x80Q\x90` \x01 \x82`\x01`\xA0`\x02\n\x03\x16c$\x9C\xB3\xFA\x85\x84`@Q\x83c\xFF\xFF\xFF\xFF\x16|\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x02\x81R`\x04\x01\x80\x83\x81R` \x01\x82`\x01`\xA0`\x02\n\x03\x16`\x01`\xA0`\x02\n\x03\x16\x81R` \x01\x92PPP` `@Q\x80\x83\x03\x81\x86\x80;\x15\x80\x15a\x04~W`\0\x80\xFD[PZ\xFA\x15\x80\x15a\x04\x92W=`\0\x80>=`\0\xFD[PPPP`@Q=` \x81\x10\x15a\x04\xA8W`\0\x80\xFD[PQ\x14a\x04\xFFW`@\x80Q`\xE5`\x02\nbF\x1B\xCD\x02\x81R` `\x04\x82\x01\x81\x90R`$\x82\x01R\x7FDoes not implement the interface`D\x82\x01R\x90Q\x90\x81\x90\x03`d\x01\x90\xFD[`\x01`\xA0`\x02\n\x03\x81\x81\x16`\0\x81\x81R` \x81\x81R`@\x80\x83 \x88\x84R\x90\x91R\x80\x82 \x80Ts\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x19\x16\x94\x87\x16\x94\x85\x17\x90UQ\x86\x92\x91\x7F\x93\xBA\xA6\xEF\xBD\"D$;\xFE\xE6\xCEL\xFD\xD1\xD0O\xC4\xC0\xE9\xA7\x86\xAB\xD3\xA4\x13\x13\xBD5-\xB1S\x91\xA4PPPPV[`\x01`\xA0`\x02\n\x03\x81\x81\x16`\0\x90\x81R`\x01` R`@\x81 T\x90\x91\x16\x15\x15a\x05\x9AWP\x80a\x05\xB7V[P`\x01`\xA0`\x02\n\x03\x80\x82\x16`\0\x90\x81R`\x01` R`@\x90 T\x16[\x91\x90PV[3a\x05\xC6\x83a\x05pV[`\x01`\xA0`\x02\n\x03\x16\x14a\x06$W`@\x80Q`\xE5`\x02\nbF\x1B\xCD\x02\x81R` `\x04\x82\x01R`\x0F`$\x82\x01R\x7FNot the manager\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0`D\x82\x01R\x90Q\x90\x81\x90\x03`d\x01\x90\xFD[\x81`\x01`\xA0`\x02\n\x03\x16\x81`\x01`\xA0`\x02\n\x03\x16\x14a\x06CW\x80a\x06FV[`\0[`\x01`\xA0`\x02\n\x03\x83\x81\x16`\0\x81\x81R`\x01` R`@\x80\x82 \x80Ts\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x19\x16\x95\x85\x16\x95\x90\x95\x17\x90\x94U\x92Q\x91\x84\x16\x92\x90\x91\x7F`\\-\xBFv._}`\xA5F\xD4.r\x05\xDC\xB1\xB0\x11\xEB\xC6*asjW\xC9\x08\x9D:CP\x91\x90\xA3PPV[`\0\x82\x82`@Q` \x01\x80\x83\x83\x80\x82\x847\x80\x83\x01\x92PPP\x92PPP`@Q` \x81\x83\x03\x03\x81R\x90`@R\x80Q\x90` \x01 \x90P[\x92\x91PPV[a\x06\xF8\x82\x82a\x07\xEFV[a\x07\x03W`\0a\x07\x05V[\x81[`\x01`\xA0`\x02\n\x03\x92\x83\x16`\0\x81\x81R` \x81\x81R`@\x80\x83 `\x01`\xE0`\x02\n\x03\x19\x96\x90\x96\x16\x80\x84R\x95\x82R\x80\x83 \x80Ts\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x19\x16\x95\x90\x97\x16\x94\x90\x94\x17\x90\x95U\x90\x81R`\x02\x84R\x81\x81 \x92\x81R\x91\x90\x92R \x80T`\xFF\x19\x16`\x01\x17\x90UV[`\0\x80`\x01`\xA0`\x02\n\x03\x84\x16\x15a\x07\x90W\x83a\x07\x92V[3[\x90Pa\x07\x9D\x83a\t*V[\x15a\x07\xC3W\x82a\x07\xAD\x82\x82a\x08\xAAV[a\x07\xB8W`\0a\x07\xBAV[\x81[\x92PPPa\x06\xE8V[`\x01`\xA0`\x02\n\x03\x90\x81\x16`\0\x90\x81R` \x81\x81R`@\x80\x83 \x86\x84R\x90\x91R\x90 T\x16\x90P\x92\x91PPV[`\0\x80\x80a\x08\x1D\x85\x7F\x01\xFF\xC9\xA7\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0a\tLV[\x90\x92P\x90P\x81\x15\x80a\x08-WP\x80\x15[\x15a\x08=W`\0\x92PPPa\x06\xE8V[a\x08O\x85`\x01`\xE0`\x02\n\x03\x19a\tLV[\x90\x92P\x90P\x81\x15\x80a\x08`WP\x80\x15\x15[\x15a\x08pW`\0\x92PPPa\x06\xE8V[a\x08z\x85\x85a\tLV[\x90\x92P\x90P`\x01\x82\x14\x80\x15a\x08\x8FWP\x80`\x01\x14[\x15a\x08\x9FW`\x01\x92PPPa\x06\xE8V[P`\0\x94\x93PPPPV[`\x01`\xA0`\x02\n\x03\x82\x16`\0\x90\x81R`\x02` \x90\x81R`@\x80\x83 `\x01`\xE0`\x02\n\x03\x19\x85\x16\x84R\x90\x91R\x81 T`\xFF\x16\x15\x15a\x08\xF2Wa\x08\xEB\x83\x83a\x07\xEFV[\x90Pa\x06\xE8V[P`\x01`\xA0`\x02\n\x03\x80\x83\x16`\0\x81\x81R` \x81\x81R`@\x80\x83 `\x01`\xE0`\x02\n\x03\x19\x87\x16\x84R\x90\x91R\x90 T\x90\x91\x16\x14\x92\x91PPV[{\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x15\x90V[`@Q\x7F\x01\xFF\xC9\xA7\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x80\x82R`\x04\x82\x01\x83\x90R`\0\x91\x82\x91\x90` \x81`$\x81\x89au0\xFA\x90Q\x90\x96\x90\x95P\x93PPPPV\xFE\xA1ebzzr0X 7\x7FJ-C\x01\xED\xE9\x94\x9F\x16?1\x90!\xA6\xE9\xC6\x87\xC2\x92\xA5\xE2\xB2\xC4sL\x12kRNl\0)\x1B\xA0\x18 \x18 \x18 \x18 \x18 \x18 \x18 \x18 \x18 \x18 \x18 \x18 \x18 \x18 \x18 \x18 \xA0\x18 \x18 \x18 \x18 \x18 \x18 \x18 \x18 \x18 \x18 \x18 \x18 \x18 \x18 \x18 \x18 \x04\xF8~\x80\x85\x17Hv\xE8\0\x83\x01\x86\xA0\x80\x80\xAD`\x1F\x80`\x0E`\09\x80`\0\xF3P\xFE`\x006\x81\x827\x806\x824\xF5\x80\x15\x15`\x14W\x81\x82\xFD[\x80\x82RPP`\x14`\x0C\xF3\x1B\xA0\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\xA0\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\x04\xF9\x01l\x80\x85\x17Hv\xE8\0\x83\x03\xC4\xD8\x80\x80\xB9\x01T`\x80`@R4\x80\x15a\0\x10W`\0\x80\xFD[Pa\x014\x80a\0 `\09`\0\xF3\xFE`\x80`@R4\x80\x15`\x0FW`\0\x80\xFD[P`\x046\x10`(W`\x005`\xE0\x1C\x80cJ\xF6?\x02\x14`-W[`\0\x80\xFD[`\xCF`\x04\x806\x03`@\x81\x10\x15`AW`\0\x80\xFD[\x81\x01\x90` \x81\x01\x815d\x01\0\0\0\0\x81\x11\x15`[W`\0\x80\xFD[\x82\x01\x83` \x82\x01\x11\x15`lW`\0\x80\xFD[\x805\x90` \x01\x91\x84`\x01\x83\x02\x84\x01\x11d\x01\0\0\0\0\x83\x11\x17\x15`\x8DW`\0\x80\xFD[\x91\x90\x80\x80`\x1F\x01` \x80\x91\x04\x02` \x01`@Q\x90\x81\x01`@R\x80\x93\x92\x91\x90\x81\x81R` \x01\x83\x83\x80\x82\x847`\0\x92\x01\x91\x90\x91RP\x92\x95PP\x915\x92P`\xEB\x91PPV[`@\x80Q`\x01`\x01`\xA0\x1B\x03\x90\x92\x16\x82RQ\x90\x81\x90\x03` \x01\x90\xF3[`\0\x81\x83Q` \x85\x01`\0\xF5\x93\x92PPPV\xFE\xA2dipfsX\"\x12 kD\xF8\xA8,\xB6\xB1V\xBF\xCC=\xC6\xAA\xDDm\xF4\xEE\xFD K\xC9(\xA49\x7F\xD1]\xAC\xF6\xD52\x05dsolcC\0\x06\x02\x003\x1B\x83$p\0\x82$p\x04\xF8\xA5\x80\x85\x17Hv\xE8\0\x83\x01\x86\xA0\x80\x80\xB8S`E\x80`\x0E`\09\x80`\0\xF3P\xFE\x7F\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xE06\x01`\0\x81` \x827\x805\x82\x824\xF5\x80\x15\x15`9W\x81\x82\xFD[\x80\x82RPPP`\x14`\x0C\xF3\x1B\xA0\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\xA0\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\xA2dipfsX\"\x12 \x11\xE0D\x92X\x02P\x8A\x8E\xCF\x8A\xEC\xB2G\x80B+>\x0Es_\xA4~\x1E\x07\xC7F).!\xBB\xD6dsolcC\0\x08\x19\x003",
    );
    /// The runtime bytecode of the contract, as deployed on the network.
    ///
    /// ```text
    ///0x6080604052600436106100d9575f3560e01c80639ed2c6f01161007c578063d7c641e711610057578063d7c641e714610231578063db633c3e14610246578063dd0c625a1461015a578063ef77e71a14610261575f80fd5b80639ed2c6f0146101d1578063acd7d02a146101eb578063d3a3faab1461020a575f80fd5b80634367d652116100b75780634367d6521461015a57806355e34a6b1461018257806375ae22b5146101a957806389cf8ae6146101bd575f80fd5b80631b9a680c146100dd578063290302ce146101075780632e79664114610146575b5f80fd5b3480156100e8575f80fd5b506100f1610288565b6040516100fe9190610915565b60405180910390f35b348015610112575f80fd5b5061012e73a990077c3205cbdf861e17fa532eeb069ce9ff9681565b6040516001600160a01b0390911681526020016100fe565b348015610151575f80fd5b506100f16102a4565b348015610165575f80fd5b50610174662386f26fc1000081565b6040519081526020016100fe565b34801561018d575f80fd5b5061012e73bb6e024b9cffacb947a71991e386681b1cd1477d81565b3480156101b4575f80fd5b506100f16102c3565b3480156101c8575f80fd5b506100f16102df565b3480156101dc575f80fd5b506101746657c084e5f3c00081565b3480156101f6575f80fd5b5061017461020536600461097f565b6102fe565b348015610215575f80fd5b5061012e734c8d290a1b368ac4728d83a9e8321fc3af2b39b181565b61024461023f3660046109a9565b6103f5565b005b348015610251575f80fd5b5061017467011c37937e08000081565b34801561026c575f80fd5b5061012e733fab184622dc19b6109349b94811493bf2a4536281565b6040518060e0016040528060a8815260200161180160a8913981565b60405180610a600160405280610a3c8152602001610bd4610a3c913981565b6040518060c00160405280608181526020016116106081913981565b604051806101a001604052806101708152602001611691610170913981565b6040517fa66b327d0000000000000000000000000000000000000000000000000000000081525f600482018190524860248301529081906001600160a01b0385169063a66b327d90604401602060405180830381865afa158015610364573d5f803e3d5ffd5b505050506040513d601f19601f8201168201806040525081019061038891906109e7565b905061039683615208610a2b565b6103a09082610a42565b6103ab906004610a2b565b67011c37937e080000662386f26fc100006103cd6657c084e5f3c00082610a42565b6103d79190610a42565b6103e19190610a42565b6103eb9190610a42565b9150505b92915050565b61043683662386f26fc10000733fab184622dc19b6109349b94811493bf2a453626040518060e0016040528060a8815260200161180160a89139868661053e565b61047a836657c084e5f3c00073bb6e024b9cffacb947a71991e386681b1cd1477d604051806101a0016040528061017081526020016116916101709139868661053e565b6104bb83662386f26fc10000734c8d290a1b368ac4728d83a9e8321fc3af2b39b16040518060c001604052806081815260200161161060819139868661053e565b6105008367011c37937e08000073a990077c3205cbdf861e17fa532eeb069ce9ff9660405180610a600160405280610a3c8152602001610bd4610a3c9139868661053e565b6001600160a01b0382166105395760405133904780156108fc02915f818181858888f19350505050158015610537573d5f803e3d5ffd5b505b505050565b6040517fa66b327d0000000000000000000000000000000000000000000000000000000081525f60048201819052486024830152906001600160a01b0388169063a66b327d90604401602060405180830381865afa1580156105a2573d5f803e3d5ffd5b505050506040513d601f19601f820116820180604052508101906105c691906109e7565b90505f6105d583615208610a2b565b6105df8389610a42565b6105e99190610a42565b90506001600160a01b038416156107c4575f8190505f856001600160a01b031663313ce5676040518163ffffffff1660e01b8152600401602060405180830381865afa15801561063b573d5f803e3d5ffd5b505050506040513d601f19601f8201168201806040525081019061065f9190610a55565b905060128160ff1610156106c957610678816012610a7c565b61068390600a610b75565b61068d9084610b83565b91508261069b826012610a7c565b6106a690600a610b75565b6106b09084610a2b565b10156106c457816106c081610bbb565b9250505b6106f8565b60128160ff1611156106f8576106e0601282610a7c565b6106eb90600a610b75565b6106f59084610a2b565b91505b6040517f549e84260000000000000000000000000000000000000000000000000000000081526001600160a01b038981166004830152602482018b9052604482018690523360648301819052608483015261520860a483015260c4820187905260e482018490526101206101048301525f6101248301528b169063549e842690610144016020604051808303815f875af1158015610798573d5f803e3d5ffd5b505050506040513d601f19601f820116820180604052508101906107bc91906109e7565b505050610885565b6040517f679b6ded0000000000000000000000000000000000000000000000000000000081526001600160a01b03878116600483015260248201899052604482018490523360648301819052608483015261520860a483015260c4820185905261010060e48301525f61010483015289169063679b6ded9083906101240160206040518083038185885af115801561085e573d5f803e3d5ffd5b50505050506040513d601f19601f8201168201806040525081019061088391906109e7565b505b6040517fb75436bb0000000000000000000000000000000000000000000000000000000081526001600160a01b0389169063b75436bb906108ca908890600401610915565b6020604051808303815f875af11580156108e6573d5f803e3d5ffd5b505050506040513d601f19601f8201168201806040525081019061090a91906109e7565b505050505050505050565b602081525f82518060208401528060208501604085015e5f6040828501015260407fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe0601f83011684010191505092915050565b6001600160a01b038116811461097c575f80fd5b50565b5f8060408385031215610990575f80fd5b823561099b81610968565b946020939093013593505050565b5f805f606084860312156109bb575f80fd5b83356109c681610968565b925060208401356109d681610968565b929592945050506040919091013590565b5f602082840312156109f7575f80fd5b5051919050565b7f4e487b71000000000000000000000000000000000000000000000000000000005f52601160045260245ffd5b80820281158282048414176103ef576103ef6109fe565b808201808211156103ef576103ef6109fe565b5f60208284031215610a65575f80fd5b815160ff81168114610a75575f80fd5b9392505050565b60ff82811682821603908111156103ef576103ef6109fe565b600181815b80851115610acf57815f1904821115610ab557610ab56109fe565b80851615610ac257918102915b93841c9390800290610a9a565b509250929050565b5f82610ae5575060016103ef565b81610af157505f6103ef565b8160018114610b075760028114610b1157610b2d565b60019150506103ef565b60ff841115610b2257610b226109fe565b50506001821b6103ef565b5060208310610133831016604e8410600b8410161715610b50575081810a6103ef565b610b5a8383610a95565b805f1904821115610b6d57610b6d6109fe565b029392505050565b5f610a7560ff841683610ad7565b5f82610bb6577f4e487b71000000000000000000000000000000000000000000000000000000005f52601260045260245ffd5b500490565b5f5f198203610bcc57610bcc6109fe565b506001019056fe04f90a388085174876e800830c35008080b909e5608060405234801561001057600080fd5b506109c5806100206000396000f3fe608060405234801561001057600080fd5b50600436106100a5576000357c010000000000000000000000000000000000000000000000000000000090048063a41e7d5111610078578063a41e7d51146101d4578063aabbb8ca1461020a578063b705676514610236578063f712f3e814610280576100a5565b806329965a1d146100aa5780633d584063146100e25780635df8122f1461012457806365ba36c114610152575b600080fd5b6100e0600480360360608110156100c057600080fd5b50600160a060020a038135811691602081013591604090910135166102b6565b005b610108600480360360208110156100f857600080fd5b5035600160a060020a0316610570565b60408051600160a060020a039092168252519081900360200190f35b6100e06004803603604081101561013a57600080fd5b50600160a060020a03813581169160200135166105bc565b6101c26004803603602081101561016857600080fd5b81019060208101813564010000000081111561018357600080fd5b82018360208201111561019557600080fd5b803590602001918460018302840111640100000000831117156101b757600080fd5b5090925090506106b3565b60408051918252519081900360200190f35b6100e0600480360360408110156101ea57600080fd5b508035600160a060020a03169060200135600160e060020a0319166106ee565b6101086004803603604081101561022057600080fd5b50600160a060020a038135169060200135610778565b61026c6004803603604081101561024c57600080fd5b508035600160a060020a03169060200135600160e060020a0319166107ef565b604080519115158252519081900360200190f35b61026c6004803603604081101561029657600080fd5b508035600160a060020a03169060200135600160e060020a0319166108aa565b6000600160a060020a038416156102cd57836102cf565b335b9050336102db82610570565b600160a060020a031614610339576040805160e560020a62461bcd02815260206004820152600f60248201527f4e6f7420746865206d616e616765720000000000000000000000000000000000604482015290519081900360640190fd5b6103428361092a565b15610397576040805160e560020a62461bcd02815260206004820152601a60248201527f4d757374206e6f7420626520616e204552433136352068617368000000000000604482015290519081900360640190fd5b600160a060020a038216158015906103b85750600160a060020a0382163314155b156104ff5760405160200180807f455243313832305f4143434550545f4d4147494300000000000000000000000081525060140190506040516020818303038152906040528051906020012082600160a060020a031663249cb3fa85846040518363ffffffff167c01000000000000000000000000000000000000000000000000000000000281526004018083815260200182600160a060020a0316600160a060020a031681526020019250505060206040518083038186803b15801561047e57600080fd5b505afa158015610492573d6000803e3d6000fd5b505050506040513d60208110156104a857600080fd5b5051146104ff576040805160e560020a62461bcd02815260206004820181905260248201527f446f6573206e6f7420696d706c656d656e742074686520696e74657266616365604482015290519081900360640190fd5b600160a060020a03818116600081815260208181526040808320888452909152808220805473ffffffffffffffffffffffffffffffffffffffff19169487169485179055518692917f93baa6efbd2244243bfee6ce4cfdd1d04fc4c0e9a786abd3a41313bd352db15391a450505050565b600160a060020a03818116600090815260016020526040812054909116151561059a5750806105b7565b50600160a060020a03808216600090815260016020526040902054165b919050565b336105c683610570565b600160a060020a031614610624576040805160e560020a62461bcd02815260206004820152600f60248201527f4e6f7420746865206d616e616765720000000000000000000000000000000000604482015290519081900360640190fd5b81600160a060020a031681600160a060020a0316146106435780610646565b60005b600160a060020a03838116600081815260016020526040808220805473ffffffffffffffffffffffffffffffffffffffff19169585169590951790945592519184169290917f605c2dbf762e5f7d60a546d42e7205dcb1b011ebc62a61736a57c9089d3a43509190a35050565b600082826040516020018083838082843780830192505050925050506040516020818303038152906040528051906020012090505b92915050565b6106f882826107ef565b610703576000610705565b815b600160a060020a03928316600081815260208181526040808320600160e060020a031996909616808452958252808320805473ffffffffffffffffffffffffffffffffffffffff19169590971694909417909555908152600284528181209281529190925220805460ff19166001179055565b600080600160a060020a038416156107905783610792565b335b905061079d8361092a565b156107c357826107ad82826108aa565b6107b85760006107ba565b815b925050506106e8565b600160a060020a0390811660009081526020818152604080832086845290915290205416905092915050565b6000808061081d857f01ffc9a70000000000000000000000000000000000000000000000000000000061094c565b909250905081158061082d575080155b1561083d576000925050506106e8565b61084f85600160e060020a031961094c565b909250905081158061086057508015155b15610870576000925050506106e8565b61087a858561094c565b909250905060018214801561088f5750806001145b1561089f576001925050506106e8565b506000949350505050565b600160a060020a0382166000908152600260209081526040808320600160e060020a03198516845290915281205460ff1615156108f2576108eb83836107ef565b90506106e8565b50600160a060020a03808316600081815260208181526040808320600160e060020a0319871684529091529020549091161492915050565b7bffffffffffffffffffffffffffffffffffffffffffffffffffffffff161590565b6040517f01ffc9a7000000000000000000000000000000000000000000000000000000008082526004820183905260009182919060208160248189617530fa90519096909550935050505056fea165627a7a72305820377f4a2d4301ede9949f163f319021a6e9c687c292a5e2b2c4734c126b524e6c00291ba01820182018201820182018201820182018201820182018201820182018201820a0182018201820182018201820182018201820182018201820182018201820182004f87e8085174876e800830186a08080ad601f80600e600039806000f350fe60003681823780368234f58015156014578182fd5b80825250506014600cf31ba02222222222222222222222222222222222222222222222222222222222222222a0222222222222222222222222222222222222222222222222222222222222222204f9016c8085174876e8008303c4d88080b90154608060405234801561001057600080fd5b50610134806100206000396000f3fe6080604052348015600f57600080fd5b506004361060285760003560e01c80634af63f0214602d575b600080fd5b60cf60048036036040811015604157600080fd5b810190602081018135640100000000811115605b57600080fd5b820183602082011115606c57600080fd5b80359060200191846001830284011164010000000083111715608d57600080fd5b91908080601f016020809104026020016040519081016040528093929190818152602001838380828437600092019190915250929550509135925060eb915050565b604080516001600160a01b039092168252519081900360200190f35b6000818351602085016000f5939250505056fea26469706673582212206b44f8a82cb6b156bfcc3dc6aadd6df4eefd204bc928a4397fd15dacf6d5320564736f6c634300060200331b8324700082247004f8a58085174876e800830186a08080b853604580600e600039806000f350fe7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe03601600081602082378035828234f58015156039578182fd5b8082525050506014600cf31ba02222222222222222222222222222222222222222222222222222222222222222a02222222222222222222222222222222222222222222222222222222222222222a264697066735822122011e044925802508a8ecf8aecb24780422b3e0e735fa47e1e07c746292e21bbd664736f6c63430008190033
    /// ```
    #[rustfmt::skip]
    #[allow(clippy::all)]
    pub static DEPLOYED_BYTECODE: alloy_sol_types::private::Bytes = alloy_sol_types::private::Bytes::from_static(
        b"`\x80`@R`\x046\x10a\0\xD9W_5`\xE0\x1C\x80c\x9E\xD2\xC6\xF0\x11a\0|W\x80c\xD7\xC6A\xE7\x11a\0WW\x80c\xD7\xC6A\xE7\x14a\x021W\x80c\xDBc<>\x14a\x02FW\x80c\xDD\x0CbZ\x14a\x01ZW\x80c\xEFw\xE7\x1A\x14a\x02aW_\x80\xFD[\x80c\x9E\xD2\xC6\xF0\x14a\x01\xD1W\x80c\xAC\xD7\xD0*\x14a\x01\xEBW\x80c\xD3\xA3\xFA\xAB\x14a\x02\nW_\x80\xFD[\x80cCg\xD6R\x11a\0\xB7W\x80cCg\xD6R\x14a\x01ZW\x80cU\xE3Jk\x14a\x01\x82W\x80cu\xAE\"\xB5\x14a\x01\xA9W\x80c\x89\xCF\x8A\xE6\x14a\x01\xBDW_\x80\xFD[\x80c\x1B\x9Ah\x0C\x14a\0\xDDW\x80c)\x03\x02\xCE\x14a\x01\x07W\x80c.yfA\x14a\x01FW[_\x80\xFD[4\x80\x15a\0\xE8W_\x80\xFD[Pa\0\xF1a\x02\x88V[`@Qa\0\xFE\x91\x90a\t\x15V[`@Q\x80\x91\x03\x90\xF3[4\x80\x15a\x01\x12W_\x80\xFD[Pa\x01.s\xA9\x90\x07|2\x05\xCB\xDF\x86\x1E\x17\xFAS.\xEB\x06\x9C\xE9\xFF\x96\x81V[`@Q`\x01`\x01`\xA0\x1B\x03\x90\x91\x16\x81R` \x01a\0\xFEV[4\x80\x15a\x01QW_\x80\xFD[Pa\0\xF1a\x02\xA4V[4\x80\x15a\x01eW_\x80\xFD[Pa\x01tf#\x86\xF2o\xC1\0\0\x81V[`@Q\x90\x81R` \x01a\0\xFEV[4\x80\x15a\x01\x8DW_\x80\xFD[Pa\x01.s\xBBn\x02K\x9C\xFF\xAC\xB9G\xA7\x19\x91\xE3\x86h\x1B\x1C\xD1G}\x81V[4\x80\x15a\x01\xB4W_\x80\xFD[Pa\0\xF1a\x02\xC3V[4\x80\x15a\x01\xC8W_\x80\xFD[Pa\0\xF1a\x02\xDFV[4\x80\x15a\x01\xDCW_\x80\xFD[Pa\x01tfW\xC0\x84\xE5\xF3\xC0\0\x81V[4\x80\x15a\x01\xF6W_\x80\xFD[Pa\x01ta\x02\x056`\x04a\t\x7FV[a\x02\xFEV[4\x80\x15a\x02\x15W_\x80\xFD[Pa\x01.sL\x8D)\n\x1B6\x8A\xC4r\x8D\x83\xA9\xE82\x1F\xC3\xAF+9\xB1\x81V[a\x02Da\x02?6`\x04a\t\xA9V[a\x03\xF5V[\0[4\x80\x15a\x02QW_\x80\xFD[Pa\x01tg\x01\x1C7\x93~\x08\0\0\x81V[4\x80\x15a\x02lW_\x80\xFD[Pa\x01.s?\xAB\x18F\"\xDC\x19\xB6\x10\x93I\xB9H\x11I;\xF2\xA4Sb\x81V[`@Q\x80`\xE0\x01`@R\x80`\xA8\x81R` \x01a\x18\x01`\xA8\x919\x81V[`@Q\x80a\n`\x01`@R\x80a\n<\x81R` \x01a\x0B\xD4a\n<\x919\x81V[`@Q\x80`\xC0\x01`@R\x80`\x81\x81R` \x01a\x16\x10`\x81\x919\x81V[`@Q\x80a\x01\xA0\x01`@R\x80a\x01p\x81R` \x01a\x16\x91a\x01p\x919\x81V[`@Q\x7F\xA6k2}\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R_`\x04\x82\x01\x81\x90RH`$\x83\x01R\x90\x81\x90`\x01`\x01`\xA0\x1B\x03\x85\x16\x90c\xA6k2}\x90`D\x01` `@Q\x80\x83\x03\x81\x86Z\xFA\x15\x80\x15a\x03dW=_\x80>=_\xFD[PPPP`@Q=`\x1F\x19`\x1F\x82\x01\x16\x82\x01\x80`@RP\x81\x01\x90a\x03\x88\x91\x90a\t\xE7V[\x90Pa\x03\x96\x83aR\x08a\n+V[a\x03\xA0\x90\x82a\nBV[a\x03\xAB\x90`\x04a\n+V[g\x01\x1C7\x93~\x08\0\0f#\x86\xF2o\xC1\0\0a\x03\xCDfW\xC0\x84\xE5\xF3\xC0\0\x82a\nBV[a\x03\xD7\x91\x90a\nBV[a\x03\xE1\x91\x90a\nBV[a\x03\xEB\x91\x90a\nBV[\x91PP[\x92\x91PPV[a\x046\x83f#\x86\xF2o\xC1\0\0s?\xAB\x18F\"\xDC\x19\xB6\x10\x93I\xB9H\x11I;\xF2\xA4Sb`@Q\x80`\xE0\x01`@R\x80`\xA8\x81R` \x01a\x18\x01`\xA8\x919\x86\x86a\x05>V[a\x04z\x83fW\xC0\x84\xE5\xF3\xC0\0s\xBBn\x02K\x9C\xFF\xAC\xB9G\xA7\x19\x91\xE3\x86h\x1B\x1C\xD1G}`@Q\x80a\x01\xA0\x01`@R\x80a\x01p\x81R` \x01a\x16\x91a\x01p\x919\x86\x86a\x05>V[a\x04\xBB\x83f#\x86\xF2o\xC1\0\0sL\x8D)\n\x1B6\x8A\xC4r\x8D\x83\xA9\xE82\x1F\xC3\xAF+9\xB1`@Q\x80`\xC0\x01`@R\x80`\x81\x81R` \x01a\x16\x10`\x81\x919\x86\x86a\x05>V[a\x05\0\x83g\x01\x1C7\x93~\x08\0\0s\xA9\x90\x07|2\x05\xCB\xDF\x86\x1E\x17\xFAS.\xEB\x06\x9C\xE9\xFF\x96`@Q\x80a\n`\x01`@R\x80a\n<\x81R` \x01a\x0B\xD4a\n<\x919\x86\x86a\x05>V[`\x01`\x01`\xA0\x1B\x03\x82\x16a\x059W`@Q3\x90G\x80\x15a\x08\xFC\x02\x91_\x81\x81\x81\x85\x88\x88\xF1\x93PPPP\x15\x80\x15a\x057W=_\x80>=_\xFD[P[PPPV[`@Q\x7F\xA6k2}\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R_`\x04\x82\x01\x81\x90RH`$\x83\x01R\x90`\x01`\x01`\xA0\x1B\x03\x88\x16\x90c\xA6k2}\x90`D\x01` `@Q\x80\x83\x03\x81\x86Z\xFA\x15\x80\x15a\x05\xA2W=_\x80>=_\xFD[PPPP`@Q=`\x1F\x19`\x1F\x82\x01\x16\x82\x01\x80`@RP\x81\x01\x90a\x05\xC6\x91\x90a\t\xE7V[\x90P_a\x05\xD5\x83aR\x08a\n+V[a\x05\xDF\x83\x89a\nBV[a\x05\xE9\x91\x90a\nBV[\x90P`\x01`\x01`\xA0\x1B\x03\x84\x16\x15a\x07\xC4W_\x81\x90P_\x85`\x01`\x01`\xA0\x1B\x03\x16c1<\xE5g`@Q\x81c\xFF\xFF\xFF\xFF\x16`\xE0\x1B\x81R`\x04\x01` `@Q\x80\x83\x03\x81\x86Z\xFA\x15\x80\x15a\x06;W=_\x80>=_\xFD[PPPP`@Q=`\x1F\x19`\x1F\x82\x01\x16\x82\x01\x80`@RP\x81\x01\x90a\x06_\x91\x90a\nUV[\x90P`\x12\x81`\xFF\x16\x10\x15a\x06\xC9Wa\x06x\x81`\x12a\n|V[a\x06\x83\x90`\na\x0BuV[a\x06\x8D\x90\x84a\x0B\x83V[\x91P\x82a\x06\x9B\x82`\x12a\n|V[a\x06\xA6\x90`\na\x0BuV[a\x06\xB0\x90\x84a\n+V[\x10\x15a\x06\xC4W\x81a\x06\xC0\x81a\x0B\xBBV[\x92PP[a\x06\xF8V[`\x12\x81`\xFF\x16\x11\x15a\x06\xF8Wa\x06\xE0`\x12\x82a\n|V[a\x06\xEB\x90`\na\x0BuV[a\x06\xF5\x90\x84a\n+V[\x91P[`@Q\x7FT\x9E\x84&\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x01`\x01`\xA0\x1B\x03\x89\x81\x16`\x04\x83\x01R`$\x82\x01\x8B\x90R`D\x82\x01\x86\x90R3`d\x83\x01\x81\x90R`\x84\x83\x01RaR\x08`\xA4\x83\x01R`\xC4\x82\x01\x87\x90R`\xE4\x82\x01\x84\x90Ra\x01 a\x01\x04\x83\x01R_a\x01$\x83\x01R\x8B\x16\x90cT\x9E\x84&\x90a\x01D\x01` `@Q\x80\x83\x03\x81_\x87Z\xF1\x15\x80\x15a\x07\x98W=_\x80>=_\xFD[PPPP`@Q=`\x1F\x19`\x1F\x82\x01\x16\x82\x01\x80`@RP\x81\x01\x90a\x07\xBC\x91\x90a\t\xE7V[PPPa\x08\x85V[`@Q\x7Fg\x9Bm\xED\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x01`\x01`\xA0\x1B\x03\x87\x81\x16`\x04\x83\x01R`$\x82\x01\x89\x90R`D\x82\x01\x84\x90R3`d\x83\x01\x81\x90R`\x84\x83\x01RaR\x08`\xA4\x83\x01R`\xC4\x82\x01\x85\x90Ra\x01\0`\xE4\x83\x01R_a\x01\x04\x83\x01R\x89\x16\x90cg\x9Bm\xED\x90\x83\x90a\x01$\x01` `@Q\x80\x83\x03\x81\x85\x88Z\xF1\x15\x80\x15a\x08^W=_\x80>=_\xFD[PPPPP`@Q=`\x1F\x19`\x1F\x82\x01\x16\x82\x01\x80`@RP\x81\x01\x90a\x08\x83\x91\x90a\t\xE7V[P[`@Q\x7F\xB7T6\xBB\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x01`\x01`\xA0\x1B\x03\x89\x16\x90c\xB7T6\xBB\x90a\x08\xCA\x90\x88\x90`\x04\x01a\t\x15V[` `@Q\x80\x83\x03\x81_\x87Z\xF1\x15\x80\x15a\x08\xE6W=_\x80>=_\xFD[PPPP`@Q=`\x1F\x19`\x1F\x82\x01\x16\x82\x01\x80`@RP\x81\x01\x90a\t\n\x91\x90a\t\xE7V[PPPPPPPPPV[` \x81R_\x82Q\x80` \x84\x01R\x80` \x85\x01`@\x85\x01^_`@\x82\x85\x01\x01R`@\x7F\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xE0`\x1F\x83\x01\x16\x84\x01\x01\x91PP\x92\x91PPV[`\x01`\x01`\xA0\x1B\x03\x81\x16\x81\x14a\t|W_\x80\xFD[PV[_\x80`@\x83\x85\x03\x12\x15a\t\x90W_\x80\xFD[\x825a\t\x9B\x81a\thV[\x94` \x93\x90\x93\x015\x93PPPV[_\x80_``\x84\x86\x03\x12\x15a\t\xBBW_\x80\xFD[\x835a\t\xC6\x81a\thV[\x92P` \x84\x015a\t\xD6\x81a\thV[\x92\x95\x92\x94PPP`@\x91\x90\x91\x015\x90V[_` \x82\x84\x03\x12\x15a\t\xF7W_\x80\xFD[PQ\x91\x90PV[\x7FNH{q\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0_R`\x11`\x04R`$_\xFD[\x80\x82\x02\x81\x15\x82\x82\x04\x84\x14\x17a\x03\xEFWa\x03\xEFa\t\xFEV[\x80\x82\x01\x80\x82\x11\x15a\x03\xEFWa\x03\xEFa\t\xFEV[_` \x82\x84\x03\x12\x15a\neW_\x80\xFD[\x81Q`\xFF\x81\x16\x81\x14a\nuW_\x80\xFD[\x93\x92PPPV[`\xFF\x82\x81\x16\x82\x82\x16\x03\x90\x81\x11\x15a\x03\xEFWa\x03\xEFa\t\xFEV[`\x01\x81\x81[\x80\x85\x11\x15a\n\xCFW\x81_\x19\x04\x82\x11\x15a\n\xB5Wa\n\xB5a\t\xFEV[\x80\x85\x16\x15a\n\xC2W\x91\x81\x02\x91[\x93\x84\x1C\x93\x90\x80\x02\x90a\n\x9AV[P\x92P\x92\x90PV[_\x82a\n\xE5WP`\x01a\x03\xEFV[\x81a\n\xF1WP_a\x03\xEFV[\x81`\x01\x81\x14a\x0B\x07W`\x02\x81\x14a\x0B\x11Wa\x0B-V[`\x01\x91PPa\x03\xEFV[`\xFF\x84\x11\x15a\x0B\"Wa\x0B\"a\t\xFEV[PP`\x01\x82\x1Ba\x03\xEFV[P` \x83\x10a\x013\x83\x10\x16`N\x84\x10`\x0B\x84\x10\x16\x17\x15a\x0BPWP\x81\x81\na\x03\xEFV[a\x0BZ\x83\x83a\n\x95V[\x80_\x19\x04\x82\x11\x15a\x0BmWa\x0Bma\t\xFEV[\x02\x93\x92PPPV[_a\nu`\xFF\x84\x16\x83a\n\xD7V[_\x82a\x0B\xB6W\x7FNH{q\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0_R`\x12`\x04R`$_\xFD[P\x04\x90V[__\x19\x82\x03a\x0B\xCCWa\x0B\xCCa\t\xFEV[P`\x01\x01\x90V\xFE\x04\xF9\n8\x80\x85\x17Hv\xE8\0\x83\x0C5\0\x80\x80\xB9\t\xE5`\x80`@R4\x80\x15a\0\x10W`\0\x80\xFD[Pa\t\xC5\x80a\0 `\09`\0\xF3\xFE`\x80`@R4\x80\x15a\0\x10W`\0\x80\xFD[P`\x046\x10a\0\xA5W`\x005|\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x90\x04\x80c\xA4\x1E}Q\x11a\0xW\x80c\xA4\x1E}Q\x14a\x01\xD4W\x80c\xAA\xBB\xB8\xCA\x14a\x02\nW\x80c\xB7\x05ge\x14a\x026W\x80c\xF7\x12\xF3\xE8\x14a\x02\x80Wa\0\xA5V[\x80c)\x96Z\x1D\x14a\0\xAAW\x80c=X@c\x14a\0\xE2W\x80c]\xF8\x12/\x14a\x01$W\x80ce\xBA6\xC1\x14a\x01RW[`\0\x80\xFD[a\0\xE0`\x04\x806\x03``\x81\x10\x15a\0\xC0W`\0\x80\xFD[P`\x01`\xA0`\x02\n\x03\x815\x81\x16\x91` \x81\x015\x91`@\x90\x91\x015\x16a\x02\xB6V[\0[a\x01\x08`\x04\x806\x03` \x81\x10\x15a\0\xF8W`\0\x80\xFD[P5`\x01`\xA0`\x02\n\x03\x16a\x05pV[`@\x80Q`\x01`\xA0`\x02\n\x03\x90\x92\x16\x82RQ\x90\x81\x90\x03` \x01\x90\xF3[a\0\xE0`\x04\x806\x03`@\x81\x10\x15a\x01:W`\0\x80\xFD[P`\x01`\xA0`\x02\n\x03\x815\x81\x16\x91` \x015\x16a\x05\xBCV[a\x01\xC2`\x04\x806\x03` \x81\x10\x15a\x01hW`\0\x80\xFD[\x81\x01\x90` \x81\x01\x815d\x01\0\0\0\0\x81\x11\x15a\x01\x83W`\0\x80\xFD[\x82\x01\x83` \x82\x01\x11\x15a\x01\x95W`\0\x80\xFD[\x805\x90` \x01\x91\x84`\x01\x83\x02\x84\x01\x11d\x01\0\0\0\0\x83\x11\x17\x15a\x01\xB7W`\0\x80\xFD[P\x90\x92P\x90Pa\x06\xB3V[`@\x80Q\x91\x82RQ\x90\x81\x90\x03` \x01\x90\xF3[a\0\xE0`\x04\x806\x03`@\x81\x10\x15a\x01\xEAW`\0\x80\xFD[P\x805`\x01`\xA0`\x02\n\x03\x16\x90` \x015`\x01`\xE0`\x02\n\x03\x19\x16a\x06\xEEV[a\x01\x08`\x04\x806\x03`@\x81\x10\x15a\x02 W`\0\x80\xFD[P`\x01`\xA0`\x02\n\x03\x815\x16\x90` \x015a\x07xV[a\x02l`\x04\x806\x03`@\x81\x10\x15a\x02LW`\0\x80\xFD[P\x805`\x01`\xA0`\x02\n\x03\x16\x90` \x015`\x01`\xE0`\x02\n\x03\x19\x16a\x07\xEFV[`@\x80Q\x91\x15\x15\x82RQ\x90\x81\x90\x03` \x01\x90\xF3[a\x02l`\x04\x806\x03`@\x81\x10\x15a\x02\x96W`\0\x80\xFD[P\x805`\x01`\xA0`\x02\n\x03\x16\x90` \x015`\x01`\xE0`\x02\n\x03\x19\x16a\x08\xAAV[`\0`\x01`\xA0`\x02\n\x03\x84\x16\x15a\x02\xCDW\x83a\x02\xCFV[3[\x90P3a\x02\xDB\x82a\x05pV[`\x01`\xA0`\x02\n\x03\x16\x14a\x039W`@\x80Q`\xE5`\x02\nbF\x1B\xCD\x02\x81R` `\x04\x82\x01R`\x0F`$\x82\x01R\x7FNot the manager\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0`D\x82\x01R\x90Q\x90\x81\x90\x03`d\x01\x90\xFD[a\x03B\x83a\t*V[\x15a\x03\x97W`@\x80Q`\xE5`\x02\nbF\x1B\xCD\x02\x81R` `\x04\x82\x01R`\x1A`$\x82\x01R\x7FMust not be an ERC165 hash\0\0\0\0\0\0`D\x82\x01R\x90Q\x90\x81\x90\x03`d\x01\x90\xFD[`\x01`\xA0`\x02\n\x03\x82\x16\x15\x80\x15\x90a\x03\xB8WP`\x01`\xA0`\x02\n\x03\x82\x163\x14\x15[\x15a\x04\xFFW`@Q` \x01\x80\x80\x7FERC1820_ACCEPT_MAGIC\0\0\0\0\0\0\0\0\0\0\0\0\x81RP`\x14\x01\x90P`@Q` \x81\x83\x03\x03\x81R\x90`@R\x80Q\x90` \x01 \x82`\x01`\xA0`\x02\n\x03\x16c$\x9C\xB3\xFA\x85\x84`@Q\x83c\xFF\xFF\xFF\xFF\x16|\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x02\x81R`\x04\x01\x80\x83\x81R` \x01\x82`\x01`\xA0`\x02\n\x03\x16`\x01`\xA0`\x02\n\x03\x16\x81R` \x01\x92PPP` `@Q\x80\x83\x03\x81\x86\x80;\x15\x80\x15a\x04~W`\0\x80\xFD[PZ\xFA\x15\x80\x15a\x04\x92W=`\0\x80>=`\0\xFD[PPPP`@Q=` \x81\x10\x15a\x04\xA8W`\0\x80\xFD[PQ\x14a\x04\xFFW`@\x80Q`\xE5`\x02\nbF\x1B\xCD\x02\x81R` `\x04\x82\x01\x81\x90R`$\x82\x01R\x7FDoes not implement the interface`D\x82\x01R\x90Q\x90\x81\x90\x03`d\x01\x90\xFD[`\x01`\xA0`\x02\n\x03\x81\x81\x16`\0\x81\x81R` \x81\x81R`@\x80\x83 \x88\x84R\x90\x91R\x80\x82 \x80Ts\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x19\x16\x94\x87\x16\x94\x85\x17\x90UQ\x86\x92\x91\x7F\x93\xBA\xA6\xEF\xBD\"D$;\xFE\xE6\xCEL\xFD\xD1\xD0O\xC4\xC0\xE9\xA7\x86\xAB\xD3\xA4\x13\x13\xBD5-\xB1S\x91\xA4PPPPV[`\x01`\xA0`\x02\n\x03\x81\x81\x16`\0\x90\x81R`\x01` R`@\x81 T\x90\x91\x16\x15\x15a\x05\x9AWP\x80a\x05\xB7V[P`\x01`\xA0`\x02\n\x03\x80\x82\x16`\0\x90\x81R`\x01` R`@\x90 T\x16[\x91\x90PV[3a\x05\xC6\x83a\x05pV[`\x01`\xA0`\x02\n\x03\x16\x14a\x06$W`@\x80Q`\xE5`\x02\nbF\x1B\xCD\x02\x81R` `\x04\x82\x01R`\x0F`$\x82\x01R\x7FNot the manager\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0`D\x82\x01R\x90Q\x90\x81\x90\x03`d\x01\x90\xFD[\x81`\x01`\xA0`\x02\n\x03\x16\x81`\x01`\xA0`\x02\n\x03\x16\x14a\x06CW\x80a\x06FV[`\0[`\x01`\xA0`\x02\n\x03\x83\x81\x16`\0\x81\x81R`\x01` R`@\x80\x82 \x80Ts\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x19\x16\x95\x85\x16\x95\x90\x95\x17\x90\x94U\x92Q\x91\x84\x16\x92\x90\x91\x7F`\\-\xBFv._}`\xA5F\xD4.r\x05\xDC\xB1\xB0\x11\xEB\xC6*asjW\xC9\x08\x9D:CP\x91\x90\xA3PPV[`\0\x82\x82`@Q` \x01\x80\x83\x83\x80\x82\x847\x80\x83\x01\x92PPP\x92PPP`@Q` \x81\x83\x03\x03\x81R\x90`@R\x80Q\x90` \x01 \x90P[\x92\x91PPV[a\x06\xF8\x82\x82a\x07\xEFV[a\x07\x03W`\0a\x07\x05V[\x81[`\x01`\xA0`\x02\n\x03\x92\x83\x16`\0\x81\x81R` \x81\x81R`@\x80\x83 `\x01`\xE0`\x02\n\x03\x19\x96\x90\x96\x16\x80\x84R\x95\x82R\x80\x83 \x80Ts\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x19\x16\x95\x90\x97\x16\x94\x90\x94\x17\x90\x95U\x90\x81R`\x02\x84R\x81\x81 \x92\x81R\x91\x90\x92R \x80T`\xFF\x19\x16`\x01\x17\x90UV[`\0\x80`\x01`\xA0`\x02\n\x03\x84\x16\x15a\x07\x90W\x83a\x07\x92V[3[\x90Pa\x07\x9D\x83a\t*V[\x15a\x07\xC3W\x82a\x07\xAD\x82\x82a\x08\xAAV[a\x07\xB8W`\0a\x07\xBAV[\x81[\x92PPPa\x06\xE8V[`\x01`\xA0`\x02\n\x03\x90\x81\x16`\0\x90\x81R` \x81\x81R`@\x80\x83 \x86\x84R\x90\x91R\x90 T\x16\x90P\x92\x91PPV[`\0\x80\x80a\x08\x1D\x85\x7F\x01\xFF\xC9\xA7\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0a\tLV[\x90\x92P\x90P\x81\x15\x80a\x08-WP\x80\x15[\x15a\x08=W`\0\x92PPPa\x06\xE8V[a\x08O\x85`\x01`\xE0`\x02\n\x03\x19a\tLV[\x90\x92P\x90P\x81\x15\x80a\x08`WP\x80\x15\x15[\x15a\x08pW`\0\x92PPPa\x06\xE8V[a\x08z\x85\x85a\tLV[\x90\x92P\x90P`\x01\x82\x14\x80\x15a\x08\x8FWP\x80`\x01\x14[\x15a\x08\x9FW`\x01\x92PPPa\x06\xE8V[P`\0\x94\x93PPPPV[`\x01`\xA0`\x02\n\x03\x82\x16`\0\x90\x81R`\x02` \x90\x81R`@\x80\x83 `\x01`\xE0`\x02\n\x03\x19\x85\x16\x84R\x90\x91R\x81 T`\xFF\x16\x15\x15a\x08\xF2Wa\x08\xEB\x83\x83a\x07\xEFV[\x90Pa\x06\xE8V[P`\x01`\xA0`\x02\n\x03\x80\x83\x16`\0\x81\x81R` \x81\x81R`@\x80\x83 `\x01`\xE0`\x02\n\x03\x19\x87\x16\x84R\x90\x91R\x90 T\x90\x91\x16\x14\x92\x91PPV[{\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x15\x90V[`@Q\x7F\x01\xFF\xC9\xA7\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x80\x82R`\x04\x82\x01\x83\x90R`\0\x91\x82\x91\x90` \x81`$\x81\x89au0\xFA\x90Q\x90\x96\x90\x95P\x93PPPPV\xFE\xA1ebzzr0X 7\x7FJ-C\x01\xED\xE9\x94\x9F\x16?1\x90!\xA6\xE9\xC6\x87\xC2\x92\xA5\xE2\xB2\xC4sL\x12kRNl\0)\x1B\xA0\x18 \x18 \x18 \x18 \x18 \x18 \x18 \x18 \x18 \x18 \x18 \x18 \x18 \x18 \x18 \x18 \xA0\x18 \x18 \x18 \x18 \x18 \x18 \x18 \x18 \x18 \x18 \x18 \x18 \x18 \x18 \x18 \x18 \x04\xF8~\x80\x85\x17Hv\xE8\0\x83\x01\x86\xA0\x80\x80\xAD`\x1F\x80`\x0E`\09\x80`\0\xF3P\xFE`\x006\x81\x827\x806\x824\xF5\x80\x15\x15`\x14W\x81\x82\xFD[\x80\x82RPP`\x14`\x0C\xF3\x1B\xA0\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\xA0\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\x04\xF9\x01l\x80\x85\x17Hv\xE8\0\x83\x03\xC4\xD8\x80\x80\xB9\x01T`\x80`@R4\x80\x15a\0\x10W`\0\x80\xFD[Pa\x014\x80a\0 `\09`\0\xF3\xFE`\x80`@R4\x80\x15`\x0FW`\0\x80\xFD[P`\x046\x10`(W`\x005`\xE0\x1C\x80cJ\xF6?\x02\x14`-W[`\0\x80\xFD[`\xCF`\x04\x806\x03`@\x81\x10\x15`AW`\0\x80\xFD[\x81\x01\x90` \x81\x01\x815d\x01\0\0\0\0\x81\x11\x15`[W`\0\x80\xFD[\x82\x01\x83` \x82\x01\x11\x15`lW`\0\x80\xFD[\x805\x90` \x01\x91\x84`\x01\x83\x02\x84\x01\x11d\x01\0\0\0\0\x83\x11\x17\x15`\x8DW`\0\x80\xFD[\x91\x90\x80\x80`\x1F\x01` \x80\x91\x04\x02` \x01`@Q\x90\x81\x01`@R\x80\x93\x92\x91\x90\x81\x81R` \x01\x83\x83\x80\x82\x847`\0\x92\x01\x91\x90\x91RP\x92\x95PP\x915\x92P`\xEB\x91PPV[`@\x80Q`\x01`\x01`\xA0\x1B\x03\x90\x92\x16\x82RQ\x90\x81\x90\x03` \x01\x90\xF3[`\0\x81\x83Q` \x85\x01`\0\xF5\x93\x92PPPV\xFE\xA2dipfsX\"\x12 kD\xF8\xA8,\xB6\xB1V\xBF\xCC=\xC6\xAA\xDDm\xF4\xEE\xFD K\xC9(\xA49\x7F\xD1]\xAC\xF6\xD52\x05dsolcC\0\x06\x02\x003\x1B\x83$p\0\x82$p\x04\xF8\xA5\x80\x85\x17Hv\xE8\0\x83\x01\x86\xA0\x80\x80\xB8S`E\x80`\x0E`\09\x80`\0\xF3P\xFE\x7F\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xE06\x01`\0\x81` \x827\x805\x82\x824\xF5\x80\x15\x15`9W\x81\x82\xFD[\x80\x82RPPP`\x14`\x0C\xF3\x1B\xA0\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\xA0\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\xA2dipfsX\"\x12 \x11\xE0D\x92X\x02P\x8A\x8E\xCF\x8A\xEC\xB2G\x80B+>\x0Es_\xA4~\x1E\x07\xC7F).!\xBB\xD6dsolcC\0\x08\x19\x003",
    );
    /**Function with signature `ERC1820_DEPLOYER()` and selector `0x290302ce`.
```solidity
function ERC1820_DEPLOYER() external view returns (address);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct ERC1820_DEPLOYERCall {}
    ///Container type for the return parameters of the [`ERC1820_DEPLOYER()`](ERC1820_DEPLOYERCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct ERC1820_DEPLOYERReturn {
        pub _0: alloy::sol_types::private::Address,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<ERC1820_DEPLOYERCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: ERC1820_DEPLOYERCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for ERC1820_DEPLOYERCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Address,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::Address,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<ERC1820_DEPLOYERReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: ERC1820_DEPLOYERReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for ERC1820_DEPLOYERReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for ERC1820_DEPLOYERCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = ERC1820_DEPLOYERReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Address,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "ERC1820_DEPLOYER()";
            const SELECTOR: [u8; 4] = [41u8, 3u8, 2u8, 206u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `ERC1820_PAYLOAD()` and selector `0x2e796641`.
```solidity
function ERC1820_PAYLOAD() external view returns (bytes memory);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct ERC1820_PAYLOADCall {}
    ///Container type for the return parameters of the [`ERC1820_PAYLOAD()`](ERC1820_PAYLOADCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct ERC1820_PAYLOADReturn {
        pub _0: alloy::sol_types::private::Bytes,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<ERC1820_PAYLOADCall> for UnderlyingRustTuple<'_> {
                fn from(value: ERC1820_PAYLOADCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for ERC1820_PAYLOADCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Bytes,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::Bytes,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<ERC1820_PAYLOADReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: ERC1820_PAYLOADReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for ERC1820_PAYLOADReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for ERC1820_PAYLOADCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = ERC1820_PAYLOADReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Bytes,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "ERC1820_PAYLOAD()";
            const SELECTOR: [u8; 4] = [46u8, 121u8, 102u8, 65u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `ERC1820_VALUE()` and selector `0xdb633c3e`.
```solidity
function ERC1820_VALUE() external view returns (uint256);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct ERC1820_VALUECall {}
    ///Container type for the return parameters of the [`ERC1820_VALUE()`](ERC1820_VALUECall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct ERC1820_VALUEReturn {
        pub _0: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<ERC1820_VALUECall> for UnderlyingRustTuple<'_> {
                fn from(value: ERC1820_VALUECall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for ERC1820_VALUECall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<ERC1820_VALUEReturn> for UnderlyingRustTuple<'_> {
                fn from(value: ERC1820_VALUEReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for ERC1820_VALUEReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for ERC1820_VALUECall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = ERC1820_VALUEReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "ERC1820_VALUE()";
            const SELECTOR: [u8; 4] = [219u8, 99u8, 60u8, 62u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `ERC2470_DEPLOYER()` and selector `0x55e34a6b`.
```solidity
function ERC2470_DEPLOYER() external view returns (address);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct ERC2470_DEPLOYERCall {}
    ///Container type for the return parameters of the [`ERC2470_DEPLOYER()`](ERC2470_DEPLOYERCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct ERC2470_DEPLOYERReturn {
        pub _0: alloy::sol_types::private::Address,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<ERC2470_DEPLOYERCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: ERC2470_DEPLOYERCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for ERC2470_DEPLOYERCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Address,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::Address,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<ERC2470_DEPLOYERReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: ERC2470_DEPLOYERReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for ERC2470_DEPLOYERReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for ERC2470_DEPLOYERCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = ERC2470_DEPLOYERReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Address,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "ERC2470_DEPLOYER()";
            const SELECTOR: [u8; 4] = [85u8, 227u8, 74u8, 107u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `ERC2470_PAYLOAD()` and selector `0x89cf8ae6`.
```solidity
function ERC2470_PAYLOAD() external view returns (bytes memory);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct ERC2470_PAYLOADCall {}
    ///Container type for the return parameters of the [`ERC2470_PAYLOAD()`](ERC2470_PAYLOADCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct ERC2470_PAYLOADReturn {
        pub _0: alloy::sol_types::private::Bytes,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<ERC2470_PAYLOADCall> for UnderlyingRustTuple<'_> {
                fn from(value: ERC2470_PAYLOADCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for ERC2470_PAYLOADCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Bytes,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::Bytes,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<ERC2470_PAYLOADReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: ERC2470_PAYLOADReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for ERC2470_PAYLOADReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for ERC2470_PAYLOADCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = ERC2470_PAYLOADReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Bytes,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "ERC2470_PAYLOAD()";
            const SELECTOR: [u8; 4] = [137u8, 207u8, 138u8, 230u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `ERC2470_VALUE()` and selector `0x9ed2c6f0`.
```solidity
function ERC2470_VALUE() external view returns (uint256);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct ERC2470_VALUECall {}
    ///Container type for the return parameters of the [`ERC2470_VALUE()`](ERC2470_VALUECall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct ERC2470_VALUEReturn {
        pub _0: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<ERC2470_VALUECall> for UnderlyingRustTuple<'_> {
                fn from(value: ERC2470_VALUECall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for ERC2470_VALUECall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<ERC2470_VALUEReturn> for UnderlyingRustTuple<'_> {
                fn from(value: ERC2470_VALUEReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for ERC2470_VALUEReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for ERC2470_VALUECall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = ERC2470_VALUEReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "ERC2470_VALUE()";
            const SELECTOR: [u8; 4] = [158u8, 210u8, 198u8, 240u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `NICK_CREATE2_DEPLOYER()` and selector `0xef77e71a`.
```solidity
function NICK_CREATE2_DEPLOYER() external view returns (address);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct NICK_CREATE2_DEPLOYERCall {}
    ///Container type for the return parameters of the [`NICK_CREATE2_DEPLOYER()`](NICK_CREATE2_DEPLOYERCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct NICK_CREATE2_DEPLOYERReturn {
        pub _0: alloy::sol_types::private::Address,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<NICK_CREATE2_DEPLOYERCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: NICK_CREATE2_DEPLOYERCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for NICK_CREATE2_DEPLOYERCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Address,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::Address,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<NICK_CREATE2_DEPLOYERReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: NICK_CREATE2_DEPLOYERReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for NICK_CREATE2_DEPLOYERReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for NICK_CREATE2_DEPLOYERCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = NICK_CREATE2_DEPLOYERReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Address,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "NICK_CREATE2_DEPLOYER()";
            const SELECTOR: [u8; 4] = [239u8, 119u8, 231u8, 26u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `NICK_CREATE2_PAYLOAD()` and selector `0x1b9a680c`.
```solidity
function NICK_CREATE2_PAYLOAD() external view returns (bytes memory);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct NICK_CREATE2_PAYLOADCall {}
    ///Container type for the return parameters of the [`NICK_CREATE2_PAYLOAD()`](NICK_CREATE2_PAYLOADCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct NICK_CREATE2_PAYLOADReturn {
        pub _0: alloy::sol_types::private::Bytes,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<NICK_CREATE2_PAYLOADCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: NICK_CREATE2_PAYLOADCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for NICK_CREATE2_PAYLOADCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Bytes,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::Bytes,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<NICK_CREATE2_PAYLOADReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: NICK_CREATE2_PAYLOADReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for NICK_CREATE2_PAYLOADReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for NICK_CREATE2_PAYLOADCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = NICK_CREATE2_PAYLOADReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Bytes,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "NICK_CREATE2_PAYLOAD()";
            const SELECTOR: [u8; 4] = [27u8, 154u8, 104u8, 12u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `NICK_CREATE2_VALUE()` and selector `0x4367d652`.
```solidity
function NICK_CREATE2_VALUE() external view returns (uint256);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct NICK_CREATE2_VALUECall {}
    ///Container type for the return parameters of the [`NICK_CREATE2_VALUE()`](NICK_CREATE2_VALUECall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct NICK_CREATE2_VALUEReturn {
        pub _0: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<NICK_CREATE2_VALUECall>
            for UnderlyingRustTuple<'_> {
                fn from(value: NICK_CREATE2_VALUECall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for NICK_CREATE2_VALUECall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<NICK_CREATE2_VALUEReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: NICK_CREATE2_VALUEReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for NICK_CREATE2_VALUEReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for NICK_CREATE2_VALUECall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = NICK_CREATE2_VALUEReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "NICK_CREATE2_VALUE()";
            const SELECTOR: [u8; 4] = [67u8, 103u8, 214u8, 82u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `ZOLTU_CREATE2_DEPLOYER()` and selector `0xd3a3faab`.
```solidity
function ZOLTU_CREATE2_DEPLOYER() external view returns (address);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct ZOLTU_CREATE2_DEPLOYERCall {}
    ///Container type for the return parameters of the [`ZOLTU_CREATE2_DEPLOYER()`](ZOLTU_CREATE2_DEPLOYERCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct ZOLTU_CREATE2_DEPLOYERReturn {
        pub _0: alloy::sol_types::private::Address,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<ZOLTU_CREATE2_DEPLOYERCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: ZOLTU_CREATE2_DEPLOYERCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for ZOLTU_CREATE2_DEPLOYERCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Address,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::Address,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<ZOLTU_CREATE2_DEPLOYERReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: ZOLTU_CREATE2_DEPLOYERReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for ZOLTU_CREATE2_DEPLOYERReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for ZOLTU_CREATE2_DEPLOYERCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = ZOLTU_CREATE2_DEPLOYERReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Address,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "ZOLTU_CREATE2_DEPLOYER()";
            const SELECTOR: [u8; 4] = [211u8, 163u8, 250u8, 171u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `ZOLTU_CREATE2_PAYLOAD()` and selector `0x75ae22b5`.
```solidity
function ZOLTU_CREATE2_PAYLOAD() external view returns (bytes memory);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct ZOLTU_CREATE2_PAYLOADCall {}
    ///Container type for the return parameters of the [`ZOLTU_CREATE2_PAYLOAD()`](ZOLTU_CREATE2_PAYLOADCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct ZOLTU_CREATE2_PAYLOADReturn {
        pub _0: alloy::sol_types::private::Bytes,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<ZOLTU_CREATE2_PAYLOADCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: ZOLTU_CREATE2_PAYLOADCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for ZOLTU_CREATE2_PAYLOADCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Bytes,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::Bytes,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<ZOLTU_CREATE2_PAYLOADReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: ZOLTU_CREATE2_PAYLOADReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for ZOLTU_CREATE2_PAYLOADReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for ZOLTU_CREATE2_PAYLOADCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = ZOLTU_CREATE2_PAYLOADReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Bytes,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "ZOLTU_CREATE2_PAYLOAD()";
            const SELECTOR: [u8; 4] = [117u8, 174u8, 34u8, 181u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `ZOLTU_VALUE()` and selector `0xdd0c625a`.
```solidity
function ZOLTU_VALUE() external view returns (uint256);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct ZOLTU_VALUECall {}
    ///Container type for the return parameters of the [`ZOLTU_VALUE()`](ZOLTU_VALUECall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct ZOLTU_VALUEReturn {
        pub _0: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<ZOLTU_VALUECall> for UnderlyingRustTuple<'_> {
                fn from(value: ZOLTU_VALUECall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for ZOLTU_VALUECall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<ZOLTU_VALUEReturn> for UnderlyingRustTuple<'_> {
                fn from(value: ZOLTU_VALUEReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for ZOLTU_VALUEReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for ZOLTU_VALUECall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = ZOLTU_VALUEReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "ZOLTU_VALUE()";
            const SELECTOR: [u8; 4] = [221u8, 12u8, 98u8, 90u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `getDeploymentTotalCost(address,uint256)` and selector `0xacd7d02a`.
```solidity
function getDeploymentTotalCost(address inbox, uint256 maxFeePerGas) external view returns (uint256);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct getDeploymentTotalCostCall {
        pub inbox: alloy::sol_types::private::Address,
        pub maxFeePerGas: alloy::sol_types::private::primitives::aliases::U256,
    }
    ///Container type for the return parameters of the [`getDeploymentTotalCost(address,uint256)`](getDeploymentTotalCostCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct getDeploymentTotalCostReturn {
        pub _0: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Uint<256>,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::Address,
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<getDeploymentTotalCostCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: getDeploymentTotalCostCall) -> Self {
                    (value.inbox, value.maxFeePerGas)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for getDeploymentTotalCostCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        inbox: tuple.0,
                        maxFeePerGas: tuple.1,
                    }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<getDeploymentTotalCostReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: getDeploymentTotalCostReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for getDeploymentTotalCostReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for getDeploymentTotalCostCall {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Uint<256>,
            );
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = getDeploymentTotalCostReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "getDeploymentTotalCost(address,uint256)";
            const SELECTOR: [u8; 4] = [172u8, 215u8, 208u8, 42u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.inbox,
                    ),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.maxFeePerGas),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `perform(address,address,uint256)` and selector `0xd7c641e7`.
```solidity
function perform(address _inbox, address _nativeToken, uint256 _maxFeePerGas) external payable;
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct performCall {
        pub _inbox: alloy::sol_types::private::Address,
        pub _nativeToken: alloy::sol_types::private::Address,
        pub _maxFeePerGas: alloy::sol_types::private::primitives::aliases::U256,
    }
    ///Container type for the return parameters of the [`perform(address,address,uint256)`](performCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct performReturn {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Uint<256>,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::Address,
                alloy::sol_types::private::Address,
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<performCall> for UnderlyingRustTuple<'_> {
                fn from(value: performCall) -> Self {
                    (value._inbox, value._nativeToken, value._maxFeePerGas)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for performCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        _inbox: tuple.0,
                        _nativeToken: tuple.1,
                        _maxFeePerGas: tuple.2,
                    }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<performReturn> for UnderlyingRustTuple<'_> {
                fn from(value: performReturn) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for performReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for performCall {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Uint<256>,
            );
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = performReturn;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "perform(address,address,uint256)";
            const SELECTOR: [u8; 4] = [215u8, 198u8, 65u8, 231u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self._inbox,
                    ),
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self._nativeToken,
                    ),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self._maxFeePerGas),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    ///Container for all the [`DeployHelper`](self) function calls.
    pub enum DeployHelperCalls {
        ERC1820_DEPLOYER(ERC1820_DEPLOYERCall),
        ERC1820_PAYLOAD(ERC1820_PAYLOADCall),
        ERC1820_VALUE(ERC1820_VALUECall),
        ERC2470_DEPLOYER(ERC2470_DEPLOYERCall),
        ERC2470_PAYLOAD(ERC2470_PAYLOADCall),
        ERC2470_VALUE(ERC2470_VALUECall),
        NICK_CREATE2_DEPLOYER(NICK_CREATE2_DEPLOYERCall),
        NICK_CREATE2_PAYLOAD(NICK_CREATE2_PAYLOADCall),
        NICK_CREATE2_VALUE(NICK_CREATE2_VALUECall),
        ZOLTU_CREATE2_DEPLOYER(ZOLTU_CREATE2_DEPLOYERCall),
        ZOLTU_CREATE2_PAYLOAD(ZOLTU_CREATE2_PAYLOADCall),
        ZOLTU_VALUE(ZOLTU_VALUECall),
        getDeploymentTotalCost(getDeploymentTotalCostCall),
        perform(performCall),
    }
    #[automatically_derived]
    impl DeployHelperCalls {
        /// All the selectors of this enum.
        ///
        /// Note that the selectors might not be in the same order as the variants.
        /// No guarantees are made about the order of the selectors.
        ///
        /// Prefer using `SolInterface` methods instead.
        pub const SELECTORS: &'static [[u8; 4usize]] = &[
            [27u8, 154u8, 104u8, 12u8],
            [41u8, 3u8, 2u8, 206u8],
            [46u8, 121u8, 102u8, 65u8],
            [67u8, 103u8, 214u8, 82u8],
            [85u8, 227u8, 74u8, 107u8],
            [117u8, 174u8, 34u8, 181u8],
            [137u8, 207u8, 138u8, 230u8],
            [158u8, 210u8, 198u8, 240u8],
            [172u8, 215u8, 208u8, 42u8],
            [211u8, 163u8, 250u8, 171u8],
            [215u8, 198u8, 65u8, 231u8],
            [219u8, 99u8, 60u8, 62u8],
            [221u8, 12u8, 98u8, 90u8],
            [239u8, 119u8, 231u8, 26u8],
        ];
    }
    #[automatically_derived]
    impl alloy_sol_types::SolInterface for DeployHelperCalls {
        const NAME: &'static str = "DeployHelperCalls";
        const MIN_DATA_LENGTH: usize = 0usize;
        const COUNT: usize = 14usize;
        #[inline]
        fn selector(&self) -> [u8; 4] {
            match self {
                Self::ERC1820_DEPLOYER(_) => {
                    <ERC1820_DEPLOYERCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::ERC1820_PAYLOAD(_) => {
                    <ERC1820_PAYLOADCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::ERC1820_VALUE(_) => {
                    <ERC1820_VALUECall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::ERC2470_DEPLOYER(_) => {
                    <ERC2470_DEPLOYERCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::ERC2470_PAYLOAD(_) => {
                    <ERC2470_PAYLOADCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::ERC2470_VALUE(_) => {
                    <ERC2470_VALUECall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::NICK_CREATE2_DEPLOYER(_) => {
                    <NICK_CREATE2_DEPLOYERCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::NICK_CREATE2_PAYLOAD(_) => {
                    <NICK_CREATE2_PAYLOADCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::NICK_CREATE2_VALUE(_) => {
                    <NICK_CREATE2_VALUECall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::ZOLTU_CREATE2_DEPLOYER(_) => {
                    <ZOLTU_CREATE2_DEPLOYERCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::ZOLTU_CREATE2_PAYLOAD(_) => {
                    <ZOLTU_CREATE2_PAYLOADCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::ZOLTU_VALUE(_) => {
                    <ZOLTU_VALUECall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::getDeploymentTotalCost(_) => {
                    <getDeploymentTotalCostCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::perform(_) => <performCall as alloy_sol_types::SolCall>::SELECTOR,
            }
        }
        #[inline]
        fn selector_at(i: usize) -> ::core::option::Option<[u8; 4]> {
            Self::SELECTORS.get(i).copied()
        }
        #[inline]
        fn valid_selector(selector: [u8; 4]) -> bool {
            Self::SELECTORS.binary_search(&selector).is_ok()
        }
        #[inline]
        #[allow(non_snake_case)]
        fn abi_decode_raw(
            selector: [u8; 4],
            data: &[u8],
            validate: bool,
        ) -> alloy_sol_types::Result<Self> {
            static DECODE_SHIMS: &[fn(
                &[u8],
                bool,
            ) -> alloy_sol_types::Result<DeployHelperCalls>] = &[
                {
                    fn NICK_CREATE2_PAYLOAD(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<DeployHelperCalls> {
                        <NICK_CREATE2_PAYLOADCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(DeployHelperCalls::NICK_CREATE2_PAYLOAD)
                    }
                    NICK_CREATE2_PAYLOAD
                },
                {
                    fn ERC1820_DEPLOYER(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<DeployHelperCalls> {
                        <ERC1820_DEPLOYERCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(DeployHelperCalls::ERC1820_DEPLOYER)
                    }
                    ERC1820_DEPLOYER
                },
                {
                    fn ERC1820_PAYLOAD(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<DeployHelperCalls> {
                        <ERC1820_PAYLOADCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(DeployHelperCalls::ERC1820_PAYLOAD)
                    }
                    ERC1820_PAYLOAD
                },
                {
                    fn NICK_CREATE2_VALUE(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<DeployHelperCalls> {
                        <NICK_CREATE2_VALUECall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(DeployHelperCalls::NICK_CREATE2_VALUE)
                    }
                    NICK_CREATE2_VALUE
                },
                {
                    fn ERC2470_DEPLOYER(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<DeployHelperCalls> {
                        <ERC2470_DEPLOYERCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(DeployHelperCalls::ERC2470_DEPLOYER)
                    }
                    ERC2470_DEPLOYER
                },
                {
                    fn ZOLTU_CREATE2_PAYLOAD(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<DeployHelperCalls> {
                        <ZOLTU_CREATE2_PAYLOADCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(DeployHelperCalls::ZOLTU_CREATE2_PAYLOAD)
                    }
                    ZOLTU_CREATE2_PAYLOAD
                },
                {
                    fn ERC2470_PAYLOAD(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<DeployHelperCalls> {
                        <ERC2470_PAYLOADCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(DeployHelperCalls::ERC2470_PAYLOAD)
                    }
                    ERC2470_PAYLOAD
                },
                {
                    fn ERC2470_VALUE(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<DeployHelperCalls> {
                        <ERC2470_VALUECall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(DeployHelperCalls::ERC2470_VALUE)
                    }
                    ERC2470_VALUE
                },
                {
                    fn getDeploymentTotalCost(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<DeployHelperCalls> {
                        <getDeploymentTotalCostCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(DeployHelperCalls::getDeploymentTotalCost)
                    }
                    getDeploymentTotalCost
                },
                {
                    fn ZOLTU_CREATE2_DEPLOYER(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<DeployHelperCalls> {
                        <ZOLTU_CREATE2_DEPLOYERCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(DeployHelperCalls::ZOLTU_CREATE2_DEPLOYER)
                    }
                    ZOLTU_CREATE2_DEPLOYER
                },
                {
                    fn perform(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<DeployHelperCalls> {
                        <performCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(DeployHelperCalls::perform)
                    }
                    perform
                },
                {
                    fn ERC1820_VALUE(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<DeployHelperCalls> {
                        <ERC1820_VALUECall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(DeployHelperCalls::ERC1820_VALUE)
                    }
                    ERC1820_VALUE
                },
                {
                    fn ZOLTU_VALUE(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<DeployHelperCalls> {
                        <ZOLTU_VALUECall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(DeployHelperCalls::ZOLTU_VALUE)
                    }
                    ZOLTU_VALUE
                },
                {
                    fn NICK_CREATE2_DEPLOYER(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<DeployHelperCalls> {
                        <NICK_CREATE2_DEPLOYERCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(DeployHelperCalls::NICK_CREATE2_DEPLOYER)
                    }
                    NICK_CREATE2_DEPLOYER
                },
            ];
            let Ok(idx) = Self::SELECTORS.binary_search(&selector) else {
                return Err(
                    alloy_sol_types::Error::unknown_selector(
                        <Self as alloy_sol_types::SolInterface>::NAME,
                        selector,
                    ),
                );
            };
            DECODE_SHIMS[idx](data, validate)
        }
        #[inline]
        fn abi_encoded_size(&self) -> usize {
            match self {
                Self::ERC1820_DEPLOYER(inner) => {
                    <ERC1820_DEPLOYERCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::ERC1820_PAYLOAD(inner) => {
                    <ERC1820_PAYLOADCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::ERC1820_VALUE(inner) => {
                    <ERC1820_VALUECall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::ERC2470_DEPLOYER(inner) => {
                    <ERC2470_DEPLOYERCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::ERC2470_PAYLOAD(inner) => {
                    <ERC2470_PAYLOADCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::ERC2470_VALUE(inner) => {
                    <ERC2470_VALUECall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::NICK_CREATE2_DEPLOYER(inner) => {
                    <NICK_CREATE2_DEPLOYERCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::NICK_CREATE2_PAYLOAD(inner) => {
                    <NICK_CREATE2_PAYLOADCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::NICK_CREATE2_VALUE(inner) => {
                    <NICK_CREATE2_VALUECall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::ZOLTU_CREATE2_DEPLOYER(inner) => {
                    <ZOLTU_CREATE2_DEPLOYERCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::ZOLTU_CREATE2_PAYLOAD(inner) => {
                    <ZOLTU_CREATE2_PAYLOADCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::ZOLTU_VALUE(inner) => {
                    <ZOLTU_VALUECall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::getDeploymentTotalCost(inner) => {
                    <getDeploymentTotalCostCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::perform(inner) => {
                    <performCall as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
            }
        }
        #[inline]
        fn abi_encode_raw(&self, out: &mut alloy_sol_types::private::Vec<u8>) {
            match self {
                Self::ERC1820_DEPLOYER(inner) => {
                    <ERC1820_DEPLOYERCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::ERC1820_PAYLOAD(inner) => {
                    <ERC1820_PAYLOADCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::ERC1820_VALUE(inner) => {
                    <ERC1820_VALUECall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::ERC2470_DEPLOYER(inner) => {
                    <ERC2470_DEPLOYERCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::ERC2470_PAYLOAD(inner) => {
                    <ERC2470_PAYLOADCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::ERC2470_VALUE(inner) => {
                    <ERC2470_VALUECall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::NICK_CREATE2_DEPLOYER(inner) => {
                    <NICK_CREATE2_DEPLOYERCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::NICK_CREATE2_PAYLOAD(inner) => {
                    <NICK_CREATE2_PAYLOADCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::NICK_CREATE2_VALUE(inner) => {
                    <NICK_CREATE2_VALUECall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::ZOLTU_CREATE2_DEPLOYER(inner) => {
                    <ZOLTU_CREATE2_DEPLOYERCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::ZOLTU_CREATE2_PAYLOAD(inner) => {
                    <ZOLTU_CREATE2_PAYLOADCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::ZOLTU_VALUE(inner) => {
                    <ZOLTU_VALUECall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::getDeploymentTotalCost(inner) => {
                    <getDeploymentTotalCostCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::perform(inner) => {
                    <performCall as alloy_sol_types::SolCall>::abi_encode_raw(inner, out)
                }
            }
        }
    }
    use alloy::contract as alloy_contract;
    /**Creates a new wrapper around an on-chain [`DeployHelper`](self) contract instance.

See the [wrapper's documentation](`DeployHelperInstance`) for more details.*/
    #[inline]
    pub const fn new<
        T: alloy_contract::private::Transport + ::core::clone::Clone,
        P: alloy_contract::private::Provider<T, N>,
        N: alloy_contract::private::Network,
    >(
        address: alloy_sol_types::private::Address,
        provider: P,
    ) -> DeployHelperInstance<T, P, N> {
        DeployHelperInstance::<T, P, N>::new(address, provider)
    }
    /**Deploys this contract using the given `provider` and constructor arguments, if any.

Returns a new instance of the contract, if the deployment was successful.

For more fine-grained control over the deployment process, use [`deploy_builder`] instead.*/
    #[inline]
    pub fn deploy<
        T: alloy_contract::private::Transport + ::core::clone::Clone,
        P: alloy_contract::private::Provider<T, N>,
        N: alloy_contract::private::Network,
    >(
        provider: P,
    ) -> impl ::core::future::Future<
        Output = alloy_contract::Result<DeployHelperInstance<T, P, N>>,
    > {
        DeployHelperInstance::<T, P, N>::deploy(provider)
    }
    /**Creates a `RawCallBuilder` for deploying this contract using the given `provider`
and constructor arguments, if any.

This is a simple wrapper around creating a `RawCallBuilder` with the data set to
the bytecode concatenated with the constructor's ABI-encoded arguments.*/
    #[inline]
    pub fn deploy_builder<
        T: alloy_contract::private::Transport + ::core::clone::Clone,
        P: alloy_contract::private::Provider<T, N>,
        N: alloy_contract::private::Network,
    >(provider: P) -> alloy_contract::RawCallBuilder<T, P, N> {
        DeployHelperInstance::<T, P, N>::deploy_builder(provider)
    }
    /**A [`DeployHelper`](self) instance.

Contains type-safe methods for interacting with an on-chain instance of the
[`DeployHelper`](self) contract located at a given `address`, using a given
provider `P`.

If the contract bytecode is available (see the [`sol!`](alloy_sol_types::sol!)
documentation on how to provide it), the `deploy` and `deploy_builder` methods can
be used to deploy a new instance of the contract.

See the [module-level documentation](self) for all the available methods.*/
    #[derive(Clone)]
    pub struct DeployHelperInstance<T, P, N = alloy_contract::private::Ethereum> {
        address: alloy_sol_types::private::Address,
        provider: P,
        _network_transport: ::core::marker::PhantomData<(N, T)>,
    }
    #[automatically_derived]
    impl<T, P, N> ::core::fmt::Debug for DeployHelperInstance<T, P, N> {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
            f.debug_tuple("DeployHelperInstance").field(&self.address).finish()
        }
    }
    /// Instantiation and getters/setters.
    #[automatically_derived]
    impl<
        T: alloy_contract::private::Transport + ::core::clone::Clone,
        P: alloy_contract::private::Provider<T, N>,
        N: alloy_contract::private::Network,
    > DeployHelperInstance<T, P, N> {
        /**Creates a new wrapper around an on-chain [`DeployHelper`](self) contract instance.

See the [wrapper's documentation](`DeployHelperInstance`) for more details.*/
        #[inline]
        pub const fn new(
            address: alloy_sol_types::private::Address,
            provider: P,
        ) -> Self {
            Self {
                address,
                provider,
                _network_transport: ::core::marker::PhantomData,
            }
        }
        /**Deploys this contract using the given `provider` and constructor arguments, if any.

Returns a new instance of the contract, if the deployment was successful.

For more fine-grained control over the deployment process, use [`deploy_builder`] instead.*/
        #[inline]
        pub async fn deploy(
            provider: P,
        ) -> alloy_contract::Result<DeployHelperInstance<T, P, N>> {
            let call_builder = Self::deploy_builder(provider);
            let contract_address = call_builder.deploy().await?;
            Ok(Self::new(contract_address, call_builder.provider))
        }
        /**Creates a `RawCallBuilder` for deploying this contract using the given `provider`
and constructor arguments, if any.

This is a simple wrapper around creating a `RawCallBuilder` with the data set to
the bytecode concatenated with the constructor's ABI-encoded arguments.*/
        #[inline]
        pub fn deploy_builder(provider: P) -> alloy_contract::RawCallBuilder<T, P, N> {
            alloy_contract::RawCallBuilder::new_raw_deploy(
                provider,
                ::core::clone::Clone::clone(&BYTECODE),
            )
        }
        /// Returns a reference to the address.
        #[inline]
        pub const fn address(&self) -> &alloy_sol_types::private::Address {
            &self.address
        }
        /// Sets the address.
        #[inline]
        pub fn set_address(&mut self, address: alloy_sol_types::private::Address) {
            self.address = address;
        }
        /// Sets the address and returns `self`.
        pub fn at(mut self, address: alloy_sol_types::private::Address) -> Self {
            self.set_address(address);
            self
        }
        /// Returns a reference to the provider.
        #[inline]
        pub const fn provider(&self) -> &P {
            &self.provider
        }
    }
    impl<T, P: ::core::clone::Clone, N> DeployHelperInstance<T, &P, N> {
        /// Clones the provider and returns a new instance with the cloned provider.
        #[inline]
        pub fn with_cloned_provider(self) -> DeployHelperInstance<T, P, N> {
            DeployHelperInstance {
                address: self.address,
                provider: ::core::clone::Clone::clone(&self.provider),
                _network_transport: ::core::marker::PhantomData,
            }
        }
    }
    /// Function calls.
    #[automatically_derived]
    impl<
        T: alloy_contract::private::Transport + ::core::clone::Clone,
        P: alloy_contract::private::Provider<T, N>,
        N: alloy_contract::private::Network,
    > DeployHelperInstance<T, P, N> {
        /// Creates a new call builder using this contract instance's provider and address.
        ///
        /// Note that the call can be any function call, not just those defined in this
        /// contract. Prefer using the other methods for building type-safe contract calls.
        pub fn call_builder<C: alloy_sol_types::SolCall>(
            &self,
            call: &C,
        ) -> alloy_contract::SolCallBuilder<T, &P, C, N> {
            alloy_contract::SolCallBuilder::new_sol(&self.provider, &self.address, call)
        }
        ///Creates a new call builder for the [`ERC1820_DEPLOYER`] function.
        pub fn ERC1820_DEPLOYER(
            &self,
        ) -> alloy_contract::SolCallBuilder<T, &P, ERC1820_DEPLOYERCall, N> {
            self.call_builder(&ERC1820_DEPLOYERCall {})
        }
        ///Creates a new call builder for the [`ERC1820_PAYLOAD`] function.
        pub fn ERC1820_PAYLOAD(
            &self,
        ) -> alloy_contract::SolCallBuilder<T, &P, ERC1820_PAYLOADCall, N> {
            self.call_builder(&ERC1820_PAYLOADCall {})
        }
        ///Creates a new call builder for the [`ERC1820_VALUE`] function.
        pub fn ERC1820_VALUE(
            &self,
        ) -> alloy_contract::SolCallBuilder<T, &P, ERC1820_VALUECall, N> {
            self.call_builder(&ERC1820_VALUECall {})
        }
        ///Creates a new call builder for the [`ERC2470_DEPLOYER`] function.
        pub fn ERC2470_DEPLOYER(
            &self,
        ) -> alloy_contract::SolCallBuilder<T, &P, ERC2470_DEPLOYERCall, N> {
            self.call_builder(&ERC2470_DEPLOYERCall {})
        }
        ///Creates a new call builder for the [`ERC2470_PAYLOAD`] function.
        pub fn ERC2470_PAYLOAD(
            &self,
        ) -> alloy_contract::SolCallBuilder<T, &P, ERC2470_PAYLOADCall, N> {
            self.call_builder(&ERC2470_PAYLOADCall {})
        }
        ///Creates a new call builder for the [`ERC2470_VALUE`] function.
        pub fn ERC2470_VALUE(
            &self,
        ) -> alloy_contract::SolCallBuilder<T, &P, ERC2470_VALUECall, N> {
            self.call_builder(&ERC2470_VALUECall {})
        }
        ///Creates a new call builder for the [`NICK_CREATE2_DEPLOYER`] function.
        pub fn NICK_CREATE2_DEPLOYER(
            &self,
        ) -> alloy_contract::SolCallBuilder<T, &P, NICK_CREATE2_DEPLOYERCall, N> {
            self.call_builder(&NICK_CREATE2_DEPLOYERCall {})
        }
        ///Creates a new call builder for the [`NICK_CREATE2_PAYLOAD`] function.
        pub fn NICK_CREATE2_PAYLOAD(
            &self,
        ) -> alloy_contract::SolCallBuilder<T, &P, NICK_CREATE2_PAYLOADCall, N> {
            self.call_builder(&NICK_CREATE2_PAYLOADCall {})
        }
        ///Creates a new call builder for the [`NICK_CREATE2_VALUE`] function.
        pub fn NICK_CREATE2_VALUE(
            &self,
        ) -> alloy_contract::SolCallBuilder<T, &P, NICK_CREATE2_VALUECall, N> {
            self.call_builder(&NICK_CREATE2_VALUECall {})
        }
        ///Creates a new call builder for the [`ZOLTU_CREATE2_DEPLOYER`] function.
        pub fn ZOLTU_CREATE2_DEPLOYER(
            &self,
        ) -> alloy_contract::SolCallBuilder<T, &P, ZOLTU_CREATE2_DEPLOYERCall, N> {
            self.call_builder(&ZOLTU_CREATE2_DEPLOYERCall {})
        }
        ///Creates a new call builder for the [`ZOLTU_CREATE2_PAYLOAD`] function.
        pub fn ZOLTU_CREATE2_PAYLOAD(
            &self,
        ) -> alloy_contract::SolCallBuilder<T, &P, ZOLTU_CREATE2_PAYLOADCall, N> {
            self.call_builder(&ZOLTU_CREATE2_PAYLOADCall {})
        }
        ///Creates a new call builder for the [`ZOLTU_VALUE`] function.
        pub fn ZOLTU_VALUE(
            &self,
        ) -> alloy_contract::SolCallBuilder<T, &P, ZOLTU_VALUECall, N> {
            self.call_builder(&ZOLTU_VALUECall {})
        }
        ///Creates a new call builder for the [`getDeploymentTotalCost`] function.
        pub fn getDeploymentTotalCost(
            &self,
            inbox: alloy::sol_types::private::Address,
            maxFeePerGas: alloy::sol_types::private::primitives::aliases::U256,
        ) -> alloy_contract::SolCallBuilder<T, &P, getDeploymentTotalCostCall, N> {
            self.call_builder(
                &getDeploymentTotalCostCall {
                    inbox,
                    maxFeePerGas,
                },
            )
        }
        ///Creates a new call builder for the [`perform`] function.
        pub fn perform(
            &self,
            _inbox: alloy::sol_types::private::Address,
            _nativeToken: alloy::sol_types::private::Address,
            _maxFeePerGas: alloy::sol_types::private::primitives::aliases::U256,
        ) -> alloy_contract::SolCallBuilder<T, &P, performCall, N> {
            self.call_builder(
                &performCall {
                    _inbox,
                    _nativeToken,
                    _maxFeePerGas,
                },
            )
        }
    }
    /// Event filters.
    #[automatically_derived]
    impl<
        T: alloy_contract::private::Transport + ::core::clone::Clone,
        P: alloy_contract::private::Provider<T, N>,
        N: alloy_contract::private::Network,
    > DeployHelperInstance<T, P, N> {
        /// Creates a new event filter using this contract instance's provider and address.
        ///
        /// Note that the type can be any event, not just those defined in this contract.
        /// Prefer using the other methods for building type-safe event filters.
        pub fn event_filter<E: alloy_sol_types::SolEvent>(
            &self,
        ) -> alloy_contract::Event<T, &P, E, N> {
            alloy_contract::Event::new_sol(&self.provider, &self.address)
        }
    }
}
