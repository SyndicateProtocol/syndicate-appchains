/**

Generated by the following Solidity interface...
```solidity
interface Simple {
    event CounterEvent(uint64 count);
    event LogAndIncrementCalled(uint256 expected, uint256 have);
    event NullEvent();
    event RedeemedEvent(address caller, address redeemer);

    function checkBlockHashes() external view returns (uint256);
    function checkCalls(bool useTopLevel, bool directCase, bool staticCase, bool delegateCase, bool callcodeCase, bool callCase) external;
    function checkGasUsed(address to, bytes memory input) external view returns (uint256);
    function checkIsTopLevelOrWasAliased(bool useTopLevel, bool expected) external view;
    function counter() external view returns (uint64);
    function difficulty() external view returns (uint256);
    function emitNullEvent() external;
    function getBlockDifficulty() external view returns (uint256);
    function increment() external;
    function incrementEmit() external;
    function incrementRedeem() external;
    function logAndIncrement(uint256 expected) external;
    function noop() external pure;
    function pleaseRevert() external pure;
    function postManyBatches(address sequencerInbox, bytes memory batchData, uint256 numberToPost) external;
    function storeDifficulty() external;
}
```

...which was generated by the following JSON ABI:
```json
[
  {
    "type": "function",
    "name": "checkBlockHashes",
    "inputs": [],
    "outputs": [
      {
        "name": "",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "checkCalls",
    "inputs": [
      {
        "name": "useTopLevel",
        "type": "bool",
        "internalType": "bool"
      },
      {
        "name": "directCase",
        "type": "bool",
        "internalType": "bool"
      },
      {
        "name": "staticCase",
        "type": "bool",
        "internalType": "bool"
      },
      {
        "name": "delegateCase",
        "type": "bool",
        "internalType": "bool"
      },
      {
        "name": "callcodeCase",
        "type": "bool",
        "internalType": "bool"
      },
      {
        "name": "callCase",
        "type": "bool",
        "internalType": "bool"
      }
    ],
    "outputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "checkGasUsed",
    "inputs": [
      {
        "name": "to",
        "type": "address",
        "internalType": "address"
      },
      {
        "name": "input",
        "type": "bytes",
        "internalType": "bytes"
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "checkIsTopLevelOrWasAliased",
    "inputs": [
      {
        "name": "useTopLevel",
        "type": "bool",
        "internalType": "bool"
      },
      {
        "name": "expected",
        "type": "bool",
        "internalType": "bool"
      }
    ],
    "outputs": [],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "counter",
    "inputs": [],
    "outputs": [
      {
        "name": "",
        "type": "uint64",
        "internalType": "uint64"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "difficulty",
    "inputs": [],
    "outputs": [
      {
        "name": "",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "emitNullEvent",
    "inputs": [],
    "outputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "getBlockDifficulty",
    "inputs": [],
    "outputs": [
      {
        "name": "",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "increment",
    "inputs": [],
    "outputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "incrementEmit",
    "inputs": [],
    "outputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "incrementRedeem",
    "inputs": [],
    "outputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "logAndIncrement",
    "inputs": [
      {
        "name": "expected",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "outputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "noop",
    "inputs": [],
    "outputs": [],
    "stateMutability": "pure"
  },
  {
    "type": "function",
    "name": "pleaseRevert",
    "inputs": [],
    "outputs": [],
    "stateMutability": "pure"
  },
  {
    "type": "function",
    "name": "postManyBatches",
    "inputs": [
      {
        "name": "sequencerInbox",
        "type": "address",
        "internalType": "contract ISequencerInbox"
      },
      {
        "name": "batchData",
        "type": "bytes",
        "internalType": "bytes"
      },
      {
        "name": "numberToPost",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "outputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "storeDifficulty",
    "inputs": [],
    "outputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "event",
    "name": "CounterEvent",
    "inputs": [
      {
        "name": "count",
        "type": "uint64",
        "indexed": false,
        "internalType": "uint64"
      }
    ],
    "anonymous": false
  },
  {
    "type": "event",
    "name": "LogAndIncrementCalled",
    "inputs": [
      {
        "name": "expected",
        "type": "uint256",
        "indexed": false,
        "internalType": "uint256"
      },
      {
        "name": "have",
        "type": "uint256",
        "indexed": false,
        "internalType": "uint256"
      }
    ],
    "anonymous": false
  },
  {
    "type": "event",
    "name": "NullEvent",
    "inputs": [],
    "anonymous": false
  },
  {
    "type": "event",
    "name": "RedeemedEvent",
    "inputs": [
      {
        "name": "caller",
        "type": "address",
        "indexed": false,
        "internalType": "address"
      },
      {
        "name": "redeemer",
        "type": "address",
        "indexed": false,
        "internalType": "address"
      }
    ],
    "anonymous": false
  }
]
```*/
#[allow(
    non_camel_case_types,
    non_snake_case,
    clippy::pub_underscore_fields,
    clippy::style,
    clippy::empty_structs_with_brackets
)]
pub mod Simple {
    use super::*;
    use alloy::sol_types as alloy_sol_types;
    /// The creation / init bytecode of the contract.
    ///
    /// ```text
    ///0x6080604052348015600e575f80fd5b506111538061001c5f395ff3fe608060405234801561000f575f80fd5b50600436106100fb575f3560e01c806361bc221a11610093578063b226a96411610063578063b226a964146101b9578063cff36f2d146101c1578063d09de08a146101ca578063ded5ecad146101d2575f80fd5b806361bc221a1461015f5780638a3908771461018b5780639ff5ccac1461019e578063b1948fc3146101a6575f80fd5b80631a2f8a92116100ce5780631a2f8a921461013157806344c25fba146101445780635677c11e146101575780635dfc2e4a14610107575f80fd5b806305795f73146100ff5780630e8c389f1461010957806312e05dd11461011157806319cae46214610128575b5f80fd5b6101076101e5565b005b610107610232565b6001545b6040519081526020015b60405180910390f35b61011560015481565b61011561013f366004610d56565b610416565b610107610152366004610de1565b610496565b61011561090e565b5f546101729067ffffffffffffffff1681565b60405167ffffffffffffffff909116815260200161011f565b610107610199366004610e5f565b610979565b610107610a00565b6101076101b4366004610ea3565b610a6d565b610107610bd7565b61010744600155565b610107610c01565b6101076101e0366004610f69565b610c42565b60405162461bcd60e51b815260206004820152601260248201527f534f4c49444954595f524556455254494e47000000000000000000000000000060448201526064015b60405180910390fd5b3332146102815760405162461bcd60e51b815260206004820152601160248201527f53454e4445525f4e4f545f4f524947494e0000000000000000000000000000006044820152606401610229565b60646001600160a01b031663175a260b6040518163ffffffff1660e01b8152600401602060405180830381865afa1580156102be573d5f803e3d5ffd5b505050506040513d601f19601f820116820180604052508101906102e29190610fa0565b61032e5760405162461bcd60e51b815260206004820152600b60248201527f4e4f545f414c49415345440000000000000000000000000000000000000000006044820152606401610229565b5f805467ffffffffffffffff16908061034683610fef565b91906101000a81548167ffffffffffffffff021916908367ffffffffffffffff160217905550507f773c78bf96e65f61c1a2622b47d76e78bfe70dd59cf4f11470c4c121c315941333606e6001600160a01b031663de4ba2b36040518163ffffffff1660e01b8152600401602060405180830381865afa1580156103cc573d5f803e3d5ffd5b505050506040513d601f19601f820116820180604052508101906103f09190611015565b604080516001600160a01b039384168152929091166020830152015b60405180910390a1565b5f805a90506001600160a01b03851661043161271083611030565b8585604051610441929190611049565b5f604051808303818686fa925050503d805f811461047a576040519150601f19603f3d011682016040523d82523d5f602084013e61047f565b606091505b5050505a61048d9082611030565b95945050505050565b85156105545784151560646001600160a01b03166308bd624c6040518163ffffffff1660e01b8152600401602060405180830381865afa1580156104dc573d5f803e3d5ffd5b505050506040513d601f19601f820116820180604052508101906105009190610fa0565b15151461054f5760405162461bcd60e51b815260206004820152601160248201527f554e45585045435445445f524553554c540000000000000000000000000000006044820152606401610229565b610607565b84151560646001600160a01b031663175a260b6040518163ffffffff1660e01b8152600401602060405180830381865afa158015610594573d5f803e3d5ffd5b505050506040513d601f19601f820116820180604052508101906105b89190610fa0565b1515146106075760405162461bcd60e51b815260206004820152601160248201527f554e45585045435445445f524553554c540000000000000000000000000000006044820152606401610229565b60405163ded5ecad60e01b815286151560048201528415156024820152309063ded5ecad906044015f6040518083038186803b158015610645575f80fd5b505afa158015610657573d5f803e3d5ffd5b505060408051891515602482015286151560448083019190915282518083039091018152606490910182526020810180517bffffffffffffffffffffffffffffffffffffffffffffffffffffffff1663ded5ecad60e01b17905290519092505f915030906106c6908490611058565b5f60405180830381855af49150503d805f81146106fe576040519150601f19603f3d011682016040523d82523d5f602084013e610703565b606091505b50509050806107545760405162461bcd60e51b815260206004820152601460248201527f44454c45474154455f43414c4c5f4641494c45440000000000000000000000006044820152606401610229565b6040805189151560248201528515156044808301919091528251808303909101815260649091019091526020810180517bffffffffffffffffffffffffffffffffffffffffffffffffffffffff1663ded5ecad60e01b17815281519193505f91829182305af29050806108095760405162461bcd60e51b815260206004820152600f60248201527f43414c4c434f44455f4641494c454400000000000000000000000000000000006044820152606401610229565b60408051891515602482015284151560448083019190915282518083039091018152606490910182526020810180517bffffffffffffffffffffffffffffffffffffffffffffffffffffffff1663ded5ecad60e01b17905290519092503090610873908490611058565b5f604051808303815f865af19150503d805f81146108ac576040519150601f19603f3d011682016040523d82523d5f602084013e6108b1565b606091505b505080915050806109045760405162461bcd60e51b815260206004820152600b60248201527f43414c4c5f4641494c45440000000000000000000000000000000000000000006044820152606401610229565b5050505050505050565b5f61091a600243611030565b40610926600143611030565b40036109745760405162461bcd60e51b815260206004820152600f60248201527f53414d455f424c4f434b5f4841534800000000000000000000000000000000006044820152606401610229565b504390565b5f546040805183815267ffffffffffffffff90921660208301527f8df8e492f407b078593c5d8fd7e65ef68505999d911d5b99b017c0b7077398b9910160405180910390a15f805467ffffffffffffffff1690806109d683610fef565b91906101000a81548167ffffffffffffffff021916908367ffffffffffffffff1602179055505050565b5f805467ffffffffffffffff169080610a1883610fef565b82546101009290920a67ffffffffffffffff8181021990931691831602179091555f54604051911681527fa45d7e79cb3c6044f30c8dd891e6571301d6b8b6618df519c987905ec70742e7915060200161040c565b5f836001600160a01b03166306f130566040518163ffffffff1660e01b8152600401602060405180830381865afa158015610aaa573d5f803e3d5ffd5b505050506040513d601f19601f82011682018060405250810190610ace919061106e565b90505f846001600160a01b0316637fa3a40e6040518163ffffffff1660e01b8152600401602060405180830381865afa158015610b0d573d5f803e3d5ffd5b505050506040513d601f19601f82011682018060405250810190610b31919061106e565b90505f5b83811015610bcf576040517fe0bc97290000000000000000000000000000000000000000000000000000000081526001600160a01b0387169063e0bc972990610b8c908690899087905f9081908190600401611085565b5f604051808303815f87803b158015610ba3575f80fd5b505af1158015610bb5573d5f803e3d5ffd5b505050508280610bc4906110e6565b935050600101610b35565b505050505050565b6040517f6f59c82101949290205a9ae9d0c657e6dae1a71c301ae76d385c2792294585fe905f90a1565b5f805467ffffffffffffffff169080610c1983610fef565b91906101000a81548167ffffffffffffffff021916908367ffffffffffffffff16021790555050565b8115610cff5780151560646001600160a01b03166308bd624c6040518163ffffffff1660e01b8152600401602060405180830381865afa158015610c88573d5f803e3d5ffd5b505050506040513d601f19601f82011682018060405250810190610cac9190610fa0565b151514610cfb5760405162461bcd60e51b815260206004820152601160248201527f554e45585045435445445f524553554c540000000000000000000000000000006044820152606401610229565b5050565b80151560646001600160a01b031663175a260b6040518163ffffffff1660e01b8152600401602060405180830381865afa158015610c88573d5f803e3d5ffd5b6001600160a01b0381168114610d53575f80fd5b50565b5f805f60408486031215610d68575f80fd5b8335610d7381610d3f565b9250602084013567ffffffffffffffff80821115610d8f575f80fd5b818601915086601f830112610da2575f80fd5b813581811115610db0575f80fd5b876020828501011115610dc1575f80fd5b6020830194508093505050509250925092565b8015158114610d53575f80fd5b5f805f805f8060c08789031215610df6575f80fd5b8635610e0181610dd4565b95506020870135610e1181610dd4565b94506040870135610e2181610dd4565b93506060870135610e3181610dd4565b92506080870135610e4181610dd4565b915060a0870135610e5181610dd4565b809150509295509295509295565b5f60208284031215610e6f575f80fd5b5035919050565b7f4e487b71000000000000000000000000000000000000000000000000000000005f52604160045260245ffd5b5f805f60608486031215610eb5575f80fd5b8335610ec081610d3f565b9250602084013567ffffffffffffffff80821115610edc575f80fd5b818601915086601f830112610eef575f80fd5b813581811115610f0157610f01610e76565b604051601f8201601f19908116603f01168101908382118183101715610f2957610f29610e76565b81604052828152896020848701011115610f41575f80fd5b826020860160208301375f602084830101528096505050505050604084013590509250925092565b5f8060408385031215610f7a575f80fd5b8235610f8581610dd4565b91506020830135610f9581610dd4565b809150509250929050565b5f60208284031215610fb0575f80fd5b8151610fbb81610dd4565b9392505050565b7f4e487b71000000000000000000000000000000000000000000000000000000005f52601160045260245ffd5b5f67ffffffffffffffff80831681810361100b5761100b610fc2565b6001019392505050565b5f60208284031215611025575f80fd5b8151610fbb81610d3f565b8181038181111561104357611043610fc2565b92915050565b818382375f9101908152919050565b5f82518060208501845e5f920191825250919050565b5f6020828403121561107e575f80fd5b5051919050565b86815260c060208201525f86518060c0840152806020890160e085015e5f60e0828501015260e0601f19601f8301168401019150508560408301526001600160a01b03851660608301528360808301528260a0830152979650505050505050565b5f7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff820361111657611116610fc2565b506001019056fea2646970667358221220755ea1899f9602caf36352d4727aadc193b02dc45916e3eb70bb9dd2ddaa38de64736f6c63430008190033
    /// ```
    #[rustfmt::skip]
    #[allow(clippy::all)]
    pub static BYTECODE: alloy_sol_types::private::Bytes = alloy_sol_types::private::Bytes::from_static(
        b"`\x80`@R4\x80\x15`\x0EW_\x80\xFD[Pa\x11S\x80a\0\x1C_9_\xF3\xFE`\x80`@R4\x80\x15a\0\x0FW_\x80\xFD[P`\x046\x10a\0\xFBW_5`\xE0\x1C\x80ca\xBC\"\x1A\x11a\0\x93W\x80c\xB2&\xA9d\x11a\0cW\x80c\xB2&\xA9d\x14a\x01\xB9W\x80c\xCF\xF3o-\x14a\x01\xC1W\x80c\xD0\x9D\xE0\x8A\x14a\x01\xCAW\x80c\xDE\xD5\xEC\xAD\x14a\x01\xD2W_\x80\xFD[\x80ca\xBC\"\x1A\x14a\x01_W\x80c\x8A9\x08w\x14a\x01\x8BW\x80c\x9F\xF5\xCC\xAC\x14a\x01\x9EW\x80c\xB1\x94\x8F\xC3\x14a\x01\xA6W_\x80\xFD[\x80c\x1A/\x8A\x92\x11a\0\xCEW\x80c\x1A/\x8A\x92\x14a\x011W\x80cD\xC2_\xBA\x14a\x01DW\x80cVw\xC1\x1E\x14a\x01WW\x80c]\xFC.J\x14a\x01\x07W_\x80\xFD[\x80c\x05y_s\x14a\0\xFFW\x80c\x0E\x8C8\x9F\x14a\x01\tW\x80c\x12\xE0]\xD1\x14a\x01\x11W\x80c\x19\xCA\xE4b\x14a\x01(W[_\x80\xFD[a\x01\x07a\x01\xE5V[\0[a\x01\x07a\x022V[`\x01T[`@Q\x90\x81R` \x01[`@Q\x80\x91\x03\x90\xF3[a\x01\x15`\x01T\x81V[a\x01\x15a\x01?6`\x04a\rVV[a\x04\x16V[a\x01\x07a\x01R6`\x04a\r\xE1V[a\x04\x96V[a\x01\x15a\t\x0EV[_Ta\x01r\x90g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x81V[`@Qg\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x90\x91\x16\x81R` \x01a\x01\x1FV[a\x01\x07a\x01\x996`\x04a\x0E_V[a\tyV[a\x01\x07a\n\0V[a\x01\x07a\x01\xB46`\x04a\x0E\xA3V[a\nmV[a\x01\x07a\x0B\xD7V[a\x01\x07D`\x01UV[a\x01\x07a\x0C\x01V[a\x01\x07a\x01\xE06`\x04a\x0FiV[a\x0CBV[`@QbF\x1B\xCD`\xE5\x1B\x81R` `\x04\x82\x01R`\x12`$\x82\x01R\x7FSOLIDITY_REVERTING\0\0\0\0\0\0\0\0\0\0\0\0\0\0`D\x82\x01R`d\x01[`@Q\x80\x91\x03\x90\xFD[32\x14a\x02\x81W`@QbF\x1B\xCD`\xE5\x1B\x81R` `\x04\x82\x01R`\x11`$\x82\x01R\x7FSENDER_NOT_ORIGIN\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0`D\x82\x01R`d\x01a\x02)V[`d`\x01`\x01`\xA0\x1B\x03\x16c\x17Z&\x0B`@Q\x81c\xFF\xFF\xFF\xFF\x16`\xE0\x1B\x81R`\x04\x01` `@Q\x80\x83\x03\x81\x86Z\xFA\x15\x80\x15a\x02\xBEW=_\x80>=_\xFD[PPPP`@Q=`\x1F\x19`\x1F\x82\x01\x16\x82\x01\x80`@RP\x81\x01\x90a\x02\xE2\x91\x90a\x0F\xA0V[a\x03.W`@QbF\x1B\xCD`\xE5\x1B\x81R` `\x04\x82\x01R`\x0B`$\x82\x01R\x7FNOT_ALIASED\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0`D\x82\x01R`d\x01a\x02)V[_\x80Tg\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x90\x80a\x03F\x83a\x0F\xEFV[\x91\x90a\x01\0\n\x81T\x81g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x02\x19\x16\x90\x83g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x02\x17\x90UPP\x7Fw<x\xBF\x96\xE6_a\xC1\xA2b+G\xD7nx\xBF\xE7\r\xD5\x9C\xF4\xF1\x14p\xC4\xC1!\xC3\x15\x94\x133`n`\x01`\x01`\xA0\x1B\x03\x16c\xDEK\xA2\xB3`@Q\x81c\xFF\xFF\xFF\xFF\x16`\xE0\x1B\x81R`\x04\x01` `@Q\x80\x83\x03\x81\x86Z\xFA\x15\x80\x15a\x03\xCCW=_\x80>=_\xFD[PPPP`@Q=`\x1F\x19`\x1F\x82\x01\x16\x82\x01\x80`@RP\x81\x01\x90a\x03\xF0\x91\x90a\x10\x15V[`@\x80Q`\x01`\x01`\xA0\x1B\x03\x93\x84\x16\x81R\x92\x90\x91\x16` \x83\x01R\x01[`@Q\x80\x91\x03\x90\xA1V[_\x80Z\x90P`\x01`\x01`\xA0\x1B\x03\x85\x16a\x041a'\x10\x83a\x100V[\x85\x85`@Qa\x04A\x92\x91\x90a\x10IV[_`@Q\x80\x83\x03\x81\x86\x86\xFA\x92PPP=\x80_\x81\x14a\x04zW`@Q\x91P`\x1F\x19`?=\x01\x16\x82\x01`@R=\x82R=_` \x84\x01>a\x04\x7FV[``\x91P[PPPZa\x04\x8D\x90\x82a\x100V[\x95\x94PPPPPV[\x85\x15a\x05TW\x84\x15\x15`d`\x01`\x01`\xA0\x1B\x03\x16c\x08\xBDbL`@Q\x81c\xFF\xFF\xFF\xFF\x16`\xE0\x1B\x81R`\x04\x01` `@Q\x80\x83\x03\x81\x86Z\xFA\x15\x80\x15a\x04\xDCW=_\x80>=_\xFD[PPPP`@Q=`\x1F\x19`\x1F\x82\x01\x16\x82\x01\x80`@RP\x81\x01\x90a\x05\0\x91\x90a\x0F\xA0V[\x15\x15\x14a\x05OW`@QbF\x1B\xCD`\xE5\x1B\x81R` `\x04\x82\x01R`\x11`$\x82\x01R\x7FUNEXPECTED_RESULT\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0`D\x82\x01R`d\x01a\x02)V[a\x06\x07V[\x84\x15\x15`d`\x01`\x01`\xA0\x1B\x03\x16c\x17Z&\x0B`@Q\x81c\xFF\xFF\xFF\xFF\x16`\xE0\x1B\x81R`\x04\x01` `@Q\x80\x83\x03\x81\x86Z\xFA\x15\x80\x15a\x05\x94W=_\x80>=_\xFD[PPPP`@Q=`\x1F\x19`\x1F\x82\x01\x16\x82\x01\x80`@RP\x81\x01\x90a\x05\xB8\x91\x90a\x0F\xA0V[\x15\x15\x14a\x06\x07W`@QbF\x1B\xCD`\xE5\x1B\x81R` `\x04\x82\x01R`\x11`$\x82\x01R\x7FUNEXPECTED_RESULT\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0`D\x82\x01R`d\x01a\x02)V[`@Qc\xDE\xD5\xEC\xAD`\xE0\x1B\x81R\x86\x15\x15`\x04\x82\x01R\x84\x15\x15`$\x82\x01R0\x90c\xDE\xD5\xEC\xAD\x90`D\x01_`@Q\x80\x83\x03\x81\x86\x80;\x15\x80\x15a\x06EW_\x80\xFD[PZ\xFA\x15\x80\x15a\x06WW=_\x80>=_\xFD[PP`@\x80Q\x89\x15\x15`$\x82\x01R\x86\x15\x15`D\x80\x83\x01\x91\x90\x91R\x82Q\x80\x83\x03\x90\x91\x01\x81R`d\x90\x91\x01\x82R` \x81\x01\x80Q{\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16c\xDE\xD5\xEC\xAD`\xE0\x1B\x17\x90R\x90Q\x90\x92P_\x91P0\x90a\x06\xC6\x90\x84\x90a\x10XV[_`@Q\x80\x83\x03\x81\x85Z\xF4\x91PP=\x80_\x81\x14a\x06\xFEW`@Q\x91P`\x1F\x19`?=\x01\x16\x82\x01`@R=\x82R=_` \x84\x01>a\x07\x03V[``\x91P[PP\x90P\x80a\x07TW`@QbF\x1B\xCD`\xE5\x1B\x81R` `\x04\x82\x01R`\x14`$\x82\x01R\x7FDELEGATE_CALL_FAILED\0\0\0\0\0\0\0\0\0\0\0\0`D\x82\x01R`d\x01a\x02)V[`@\x80Q\x89\x15\x15`$\x82\x01R\x85\x15\x15`D\x80\x83\x01\x91\x90\x91R\x82Q\x80\x83\x03\x90\x91\x01\x81R`d\x90\x91\x01\x90\x91R` \x81\x01\x80Q{\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16c\xDE\xD5\xEC\xAD`\xE0\x1B\x17\x81R\x81Q\x91\x93P_\x91\x82\x91\x820Z\xF2\x90P\x80a\x08\tW`@QbF\x1B\xCD`\xE5\x1B\x81R` `\x04\x82\x01R`\x0F`$\x82\x01R\x7FCALLCODE_FAILED\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0`D\x82\x01R`d\x01a\x02)V[`@\x80Q\x89\x15\x15`$\x82\x01R\x84\x15\x15`D\x80\x83\x01\x91\x90\x91R\x82Q\x80\x83\x03\x90\x91\x01\x81R`d\x90\x91\x01\x82R` \x81\x01\x80Q{\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16c\xDE\xD5\xEC\xAD`\xE0\x1B\x17\x90R\x90Q\x90\x92P0\x90a\x08s\x90\x84\x90a\x10XV[_`@Q\x80\x83\x03\x81_\x86Z\xF1\x91PP=\x80_\x81\x14a\x08\xACW`@Q\x91P`\x1F\x19`?=\x01\x16\x82\x01`@R=\x82R=_` \x84\x01>a\x08\xB1V[``\x91P[PP\x80\x91PP\x80a\t\x04W`@QbF\x1B\xCD`\xE5\x1B\x81R` `\x04\x82\x01R`\x0B`$\x82\x01R\x7FCALL_FAILED\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0`D\x82\x01R`d\x01a\x02)V[PPPPPPPPV[_a\t\x1A`\x02Ca\x100V[@a\t&`\x01Ca\x100V[@\x03a\ttW`@QbF\x1B\xCD`\xE5\x1B\x81R` `\x04\x82\x01R`\x0F`$\x82\x01R\x7FSAME_BLOCK_HASH\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0`D\x82\x01R`d\x01a\x02)V[PC\x90V[_T`@\x80Q\x83\x81Rg\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x90\x92\x16` \x83\x01R\x7F\x8D\xF8\xE4\x92\xF4\x07\xB0xY<]\x8F\xD7\xE6^\xF6\x85\x05\x99\x9D\x91\x1D[\x99\xB0\x17\xC0\xB7\x07s\x98\xB9\x91\x01`@Q\x80\x91\x03\x90\xA1_\x80Tg\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x90\x80a\t\xD6\x83a\x0F\xEFV[\x91\x90a\x01\0\n\x81T\x81g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x02\x19\x16\x90\x83g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x02\x17\x90UPPPV[_\x80Tg\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x90\x80a\n\x18\x83a\x0F\xEFV[\x82Ta\x01\0\x92\x90\x92\ng\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x81\x02\x19\x90\x93\x16\x91\x83\x16\x02\x17\x90\x91U_T`@Q\x91\x16\x81R\x7F\xA4]~y\xCB<`D\xF3\x0C\x8D\xD8\x91\xE6W\x13\x01\xD6\xB8\xB6a\x8D\xF5\x19\xC9\x87\x90^\xC7\x07B\xE7\x91P` \x01a\x04\x0CV[_\x83`\x01`\x01`\xA0\x1B\x03\x16c\x06\xF10V`@Q\x81c\xFF\xFF\xFF\xFF\x16`\xE0\x1B\x81R`\x04\x01` `@Q\x80\x83\x03\x81\x86Z\xFA\x15\x80\x15a\n\xAAW=_\x80>=_\xFD[PPPP`@Q=`\x1F\x19`\x1F\x82\x01\x16\x82\x01\x80`@RP\x81\x01\x90a\n\xCE\x91\x90a\x10nV[\x90P_\x84`\x01`\x01`\xA0\x1B\x03\x16c\x7F\xA3\xA4\x0E`@Q\x81c\xFF\xFF\xFF\xFF\x16`\xE0\x1B\x81R`\x04\x01` `@Q\x80\x83\x03\x81\x86Z\xFA\x15\x80\x15a\x0B\rW=_\x80>=_\xFD[PPPP`@Q=`\x1F\x19`\x1F\x82\x01\x16\x82\x01\x80`@RP\x81\x01\x90a\x0B1\x91\x90a\x10nV[\x90P_[\x83\x81\x10\x15a\x0B\xCFW`@Q\x7F\xE0\xBC\x97)\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x01`\x01`\xA0\x1B\x03\x87\x16\x90c\xE0\xBC\x97)\x90a\x0B\x8C\x90\x86\x90\x89\x90\x87\x90_\x90\x81\x90\x81\x90`\x04\x01a\x10\x85V[_`@Q\x80\x83\x03\x81_\x87\x80;\x15\x80\x15a\x0B\xA3W_\x80\xFD[PZ\xF1\x15\x80\x15a\x0B\xB5W=_\x80>=_\xFD[PPPP\x82\x80a\x0B\xC4\x90a\x10\xE6V[\x93PP`\x01\x01a\x0B5V[PPPPPPV[`@Q\x7FoY\xC8!\x01\x94\x92\x90 Z\x9A\xE9\xD0\xC6W\xE6\xDA\xE1\xA7\x1C0\x1A\xE7m8\\'\x92)E\x85\xFE\x90_\x90\xA1V[_\x80Tg\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x90\x80a\x0C\x19\x83a\x0F\xEFV[\x91\x90a\x01\0\n\x81T\x81g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x02\x19\x16\x90\x83g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x02\x17\x90UPPV[\x81\x15a\x0C\xFFW\x80\x15\x15`d`\x01`\x01`\xA0\x1B\x03\x16c\x08\xBDbL`@Q\x81c\xFF\xFF\xFF\xFF\x16`\xE0\x1B\x81R`\x04\x01` `@Q\x80\x83\x03\x81\x86Z\xFA\x15\x80\x15a\x0C\x88W=_\x80>=_\xFD[PPPP`@Q=`\x1F\x19`\x1F\x82\x01\x16\x82\x01\x80`@RP\x81\x01\x90a\x0C\xAC\x91\x90a\x0F\xA0V[\x15\x15\x14a\x0C\xFBW`@QbF\x1B\xCD`\xE5\x1B\x81R` `\x04\x82\x01R`\x11`$\x82\x01R\x7FUNEXPECTED_RESULT\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0`D\x82\x01R`d\x01a\x02)V[PPV[\x80\x15\x15`d`\x01`\x01`\xA0\x1B\x03\x16c\x17Z&\x0B`@Q\x81c\xFF\xFF\xFF\xFF\x16`\xE0\x1B\x81R`\x04\x01` `@Q\x80\x83\x03\x81\x86Z\xFA\x15\x80\x15a\x0C\x88W=_\x80>=_\xFD[`\x01`\x01`\xA0\x1B\x03\x81\x16\x81\x14a\rSW_\x80\xFD[PV[_\x80_`@\x84\x86\x03\x12\x15a\rhW_\x80\xFD[\x835a\rs\x81a\r?V[\x92P` \x84\x015g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x80\x82\x11\x15a\r\x8FW_\x80\xFD[\x81\x86\x01\x91P\x86`\x1F\x83\x01\x12a\r\xA2W_\x80\xFD[\x815\x81\x81\x11\x15a\r\xB0W_\x80\xFD[\x87` \x82\x85\x01\x01\x11\x15a\r\xC1W_\x80\xFD[` \x83\x01\x94P\x80\x93PPPP\x92P\x92P\x92V[\x80\x15\x15\x81\x14a\rSW_\x80\xFD[_\x80_\x80_\x80`\xC0\x87\x89\x03\x12\x15a\r\xF6W_\x80\xFD[\x865a\x0E\x01\x81a\r\xD4V[\x95P` \x87\x015a\x0E\x11\x81a\r\xD4V[\x94P`@\x87\x015a\x0E!\x81a\r\xD4V[\x93P``\x87\x015a\x0E1\x81a\r\xD4V[\x92P`\x80\x87\x015a\x0EA\x81a\r\xD4V[\x91P`\xA0\x87\x015a\x0EQ\x81a\r\xD4V[\x80\x91PP\x92\x95P\x92\x95P\x92\x95V[_` \x82\x84\x03\x12\x15a\x0EoW_\x80\xFD[P5\x91\x90PV[\x7FNH{q\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0_R`A`\x04R`$_\xFD[_\x80_``\x84\x86\x03\x12\x15a\x0E\xB5W_\x80\xFD[\x835a\x0E\xC0\x81a\r?V[\x92P` \x84\x015g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x80\x82\x11\x15a\x0E\xDCW_\x80\xFD[\x81\x86\x01\x91P\x86`\x1F\x83\x01\x12a\x0E\xEFW_\x80\xFD[\x815\x81\x81\x11\x15a\x0F\x01Wa\x0F\x01a\x0EvV[`@Q`\x1F\x82\x01`\x1F\x19\x90\x81\x16`?\x01\x16\x81\x01\x90\x83\x82\x11\x81\x83\x10\x17\x15a\x0F)Wa\x0F)a\x0EvV[\x81`@R\x82\x81R\x89` \x84\x87\x01\x01\x11\x15a\x0FAW_\x80\xFD[\x82` \x86\x01` \x83\x017_` \x84\x83\x01\x01R\x80\x96PPPPPP`@\x84\x015\x90P\x92P\x92P\x92V[_\x80`@\x83\x85\x03\x12\x15a\x0FzW_\x80\xFD[\x825a\x0F\x85\x81a\r\xD4V[\x91P` \x83\x015a\x0F\x95\x81a\r\xD4V[\x80\x91PP\x92P\x92\x90PV[_` \x82\x84\x03\x12\x15a\x0F\xB0W_\x80\xFD[\x81Qa\x0F\xBB\x81a\r\xD4V[\x93\x92PPPV[\x7FNH{q\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0_R`\x11`\x04R`$_\xFD[_g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x80\x83\x16\x81\x81\x03a\x10\x0BWa\x10\x0Ba\x0F\xC2V[`\x01\x01\x93\x92PPPV[_` \x82\x84\x03\x12\x15a\x10%W_\x80\xFD[\x81Qa\x0F\xBB\x81a\r?V[\x81\x81\x03\x81\x81\x11\x15a\x10CWa\x10Ca\x0F\xC2V[\x92\x91PPV[\x81\x83\x827_\x91\x01\x90\x81R\x91\x90PV[_\x82Q\x80` \x85\x01\x84^_\x92\x01\x91\x82RP\x91\x90PV[_` \x82\x84\x03\x12\x15a\x10~W_\x80\xFD[PQ\x91\x90PV[\x86\x81R`\xC0` \x82\x01R_\x86Q\x80`\xC0\x84\x01R\x80` \x89\x01`\xE0\x85\x01^_`\xE0\x82\x85\x01\x01R`\xE0`\x1F\x19`\x1F\x83\x01\x16\x84\x01\x01\x91PP\x85`@\x83\x01R`\x01`\x01`\xA0\x1B\x03\x85\x16``\x83\x01R\x83`\x80\x83\x01R\x82`\xA0\x83\x01R\x97\x96PPPPPPPV[_\x7F\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x82\x03a\x11\x16Wa\x11\x16a\x0F\xC2V[P`\x01\x01\x90V\xFE\xA2dipfsX\"\x12 u^\xA1\x89\x9F\x96\x02\xCA\xF3cR\xD4rz\xAD\xC1\x93\xB0-\xC4Y\x16\xE3\xEBp\xBB\x9D\xD2\xDD\xAA8\xDEdsolcC\0\x08\x19\x003",
    );
    /// The runtime bytecode of the contract, as deployed on the network.
    ///
    /// ```text
    ///0x608060405234801561000f575f80fd5b50600436106100fb575f3560e01c806361bc221a11610093578063b226a96411610063578063b226a964146101b9578063cff36f2d146101c1578063d09de08a146101ca578063ded5ecad146101d2575f80fd5b806361bc221a1461015f5780638a3908771461018b5780639ff5ccac1461019e578063b1948fc3146101a6575f80fd5b80631a2f8a92116100ce5780631a2f8a921461013157806344c25fba146101445780635677c11e146101575780635dfc2e4a14610107575f80fd5b806305795f73146100ff5780630e8c389f1461010957806312e05dd11461011157806319cae46214610128575b5f80fd5b6101076101e5565b005b610107610232565b6001545b6040519081526020015b60405180910390f35b61011560015481565b61011561013f366004610d56565b610416565b610107610152366004610de1565b610496565b61011561090e565b5f546101729067ffffffffffffffff1681565b60405167ffffffffffffffff909116815260200161011f565b610107610199366004610e5f565b610979565b610107610a00565b6101076101b4366004610ea3565b610a6d565b610107610bd7565b61010744600155565b610107610c01565b6101076101e0366004610f69565b610c42565b60405162461bcd60e51b815260206004820152601260248201527f534f4c49444954595f524556455254494e47000000000000000000000000000060448201526064015b60405180910390fd5b3332146102815760405162461bcd60e51b815260206004820152601160248201527f53454e4445525f4e4f545f4f524947494e0000000000000000000000000000006044820152606401610229565b60646001600160a01b031663175a260b6040518163ffffffff1660e01b8152600401602060405180830381865afa1580156102be573d5f803e3d5ffd5b505050506040513d601f19601f820116820180604052508101906102e29190610fa0565b61032e5760405162461bcd60e51b815260206004820152600b60248201527f4e4f545f414c49415345440000000000000000000000000000000000000000006044820152606401610229565b5f805467ffffffffffffffff16908061034683610fef565b91906101000a81548167ffffffffffffffff021916908367ffffffffffffffff160217905550507f773c78bf96e65f61c1a2622b47d76e78bfe70dd59cf4f11470c4c121c315941333606e6001600160a01b031663de4ba2b36040518163ffffffff1660e01b8152600401602060405180830381865afa1580156103cc573d5f803e3d5ffd5b505050506040513d601f19601f820116820180604052508101906103f09190611015565b604080516001600160a01b039384168152929091166020830152015b60405180910390a1565b5f805a90506001600160a01b03851661043161271083611030565b8585604051610441929190611049565b5f604051808303818686fa925050503d805f811461047a576040519150601f19603f3d011682016040523d82523d5f602084013e61047f565b606091505b5050505a61048d9082611030565b95945050505050565b85156105545784151560646001600160a01b03166308bd624c6040518163ffffffff1660e01b8152600401602060405180830381865afa1580156104dc573d5f803e3d5ffd5b505050506040513d601f19601f820116820180604052508101906105009190610fa0565b15151461054f5760405162461bcd60e51b815260206004820152601160248201527f554e45585045435445445f524553554c540000000000000000000000000000006044820152606401610229565b610607565b84151560646001600160a01b031663175a260b6040518163ffffffff1660e01b8152600401602060405180830381865afa158015610594573d5f803e3d5ffd5b505050506040513d601f19601f820116820180604052508101906105b89190610fa0565b1515146106075760405162461bcd60e51b815260206004820152601160248201527f554e45585045435445445f524553554c540000000000000000000000000000006044820152606401610229565b60405163ded5ecad60e01b815286151560048201528415156024820152309063ded5ecad906044015f6040518083038186803b158015610645575f80fd5b505afa158015610657573d5f803e3d5ffd5b505060408051891515602482015286151560448083019190915282518083039091018152606490910182526020810180517bffffffffffffffffffffffffffffffffffffffffffffffffffffffff1663ded5ecad60e01b17905290519092505f915030906106c6908490611058565b5f60405180830381855af49150503d805f81146106fe576040519150601f19603f3d011682016040523d82523d5f602084013e610703565b606091505b50509050806107545760405162461bcd60e51b815260206004820152601460248201527f44454c45474154455f43414c4c5f4641494c45440000000000000000000000006044820152606401610229565b6040805189151560248201528515156044808301919091528251808303909101815260649091019091526020810180517bffffffffffffffffffffffffffffffffffffffffffffffffffffffff1663ded5ecad60e01b17815281519193505f91829182305af29050806108095760405162461bcd60e51b815260206004820152600f60248201527f43414c4c434f44455f4641494c454400000000000000000000000000000000006044820152606401610229565b60408051891515602482015284151560448083019190915282518083039091018152606490910182526020810180517bffffffffffffffffffffffffffffffffffffffffffffffffffffffff1663ded5ecad60e01b17905290519092503090610873908490611058565b5f604051808303815f865af19150503d805f81146108ac576040519150601f19603f3d011682016040523d82523d5f602084013e6108b1565b606091505b505080915050806109045760405162461bcd60e51b815260206004820152600b60248201527f43414c4c5f4641494c45440000000000000000000000000000000000000000006044820152606401610229565b5050505050505050565b5f61091a600243611030565b40610926600143611030565b40036109745760405162461bcd60e51b815260206004820152600f60248201527f53414d455f424c4f434b5f4841534800000000000000000000000000000000006044820152606401610229565b504390565b5f546040805183815267ffffffffffffffff90921660208301527f8df8e492f407b078593c5d8fd7e65ef68505999d911d5b99b017c0b7077398b9910160405180910390a15f805467ffffffffffffffff1690806109d683610fef565b91906101000a81548167ffffffffffffffff021916908367ffffffffffffffff1602179055505050565b5f805467ffffffffffffffff169080610a1883610fef565b82546101009290920a67ffffffffffffffff8181021990931691831602179091555f54604051911681527fa45d7e79cb3c6044f30c8dd891e6571301d6b8b6618df519c987905ec70742e7915060200161040c565b5f836001600160a01b03166306f130566040518163ffffffff1660e01b8152600401602060405180830381865afa158015610aaa573d5f803e3d5ffd5b505050506040513d601f19601f82011682018060405250810190610ace919061106e565b90505f846001600160a01b0316637fa3a40e6040518163ffffffff1660e01b8152600401602060405180830381865afa158015610b0d573d5f803e3d5ffd5b505050506040513d601f19601f82011682018060405250810190610b31919061106e565b90505f5b83811015610bcf576040517fe0bc97290000000000000000000000000000000000000000000000000000000081526001600160a01b0387169063e0bc972990610b8c908690899087905f9081908190600401611085565b5f604051808303815f87803b158015610ba3575f80fd5b505af1158015610bb5573d5f803e3d5ffd5b505050508280610bc4906110e6565b935050600101610b35565b505050505050565b6040517f6f59c82101949290205a9ae9d0c657e6dae1a71c301ae76d385c2792294585fe905f90a1565b5f805467ffffffffffffffff169080610c1983610fef565b91906101000a81548167ffffffffffffffff021916908367ffffffffffffffff16021790555050565b8115610cff5780151560646001600160a01b03166308bd624c6040518163ffffffff1660e01b8152600401602060405180830381865afa158015610c88573d5f803e3d5ffd5b505050506040513d601f19601f82011682018060405250810190610cac9190610fa0565b151514610cfb5760405162461bcd60e51b815260206004820152601160248201527f554e45585045435445445f524553554c540000000000000000000000000000006044820152606401610229565b5050565b80151560646001600160a01b031663175a260b6040518163ffffffff1660e01b8152600401602060405180830381865afa158015610c88573d5f803e3d5ffd5b6001600160a01b0381168114610d53575f80fd5b50565b5f805f60408486031215610d68575f80fd5b8335610d7381610d3f565b9250602084013567ffffffffffffffff80821115610d8f575f80fd5b818601915086601f830112610da2575f80fd5b813581811115610db0575f80fd5b876020828501011115610dc1575f80fd5b6020830194508093505050509250925092565b8015158114610d53575f80fd5b5f805f805f8060c08789031215610df6575f80fd5b8635610e0181610dd4565b95506020870135610e1181610dd4565b94506040870135610e2181610dd4565b93506060870135610e3181610dd4565b92506080870135610e4181610dd4565b915060a0870135610e5181610dd4565b809150509295509295509295565b5f60208284031215610e6f575f80fd5b5035919050565b7f4e487b71000000000000000000000000000000000000000000000000000000005f52604160045260245ffd5b5f805f60608486031215610eb5575f80fd5b8335610ec081610d3f565b9250602084013567ffffffffffffffff80821115610edc575f80fd5b818601915086601f830112610eef575f80fd5b813581811115610f0157610f01610e76565b604051601f8201601f19908116603f01168101908382118183101715610f2957610f29610e76565b81604052828152896020848701011115610f41575f80fd5b826020860160208301375f602084830101528096505050505050604084013590509250925092565b5f8060408385031215610f7a575f80fd5b8235610f8581610dd4565b91506020830135610f9581610dd4565b809150509250929050565b5f60208284031215610fb0575f80fd5b8151610fbb81610dd4565b9392505050565b7f4e487b71000000000000000000000000000000000000000000000000000000005f52601160045260245ffd5b5f67ffffffffffffffff80831681810361100b5761100b610fc2565b6001019392505050565b5f60208284031215611025575f80fd5b8151610fbb81610d3f565b8181038181111561104357611043610fc2565b92915050565b818382375f9101908152919050565b5f82518060208501845e5f920191825250919050565b5f6020828403121561107e575f80fd5b5051919050565b86815260c060208201525f86518060c0840152806020890160e085015e5f60e0828501015260e0601f19601f8301168401019150508560408301526001600160a01b03851660608301528360808301528260a0830152979650505050505050565b5f7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff820361111657611116610fc2565b506001019056fea2646970667358221220755ea1899f9602caf36352d4727aadc193b02dc45916e3eb70bb9dd2ddaa38de64736f6c63430008190033
    /// ```
    #[rustfmt::skip]
    #[allow(clippy::all)]
    pub static DEPLOYED_BYTECODE: alloy_sol_types::private::Bytes = alloy_sol_types::private::Bytes::from_static(
        b"`\x80`@R4\x80\x15a\0\x0FW_\x80\xFD[P`\x046\x10a\0\xFBW_5`\xE0\x1C\x80ca\xBC\"\x1A\x11a\0\x93W\x80c\xB2&\xA9d\x11a\0cW\x80c\xB2&\xA9d\x14a\x01\xB9W\x80c\xCF\xF3o-\x14a\x01\xC1W\x80c\xD0\x9D\xE0\x8A\x14a\x01\xCAW\x80c\xDE\xD5\xEC\xAD\x14a\x01\xD2W_\x80\xFD[\x80ca\xBC\"\x1A\x14a\x01_W\x80c\x8A9\x08w\x14a\x01\x8BW\x80c\x9F\xF5\xCC\xAC\x14a\x01\x9EW\x80c\xB1\x94\x8F\xC3\x14a\x01\xA6W_\x80\xFD[\x80c\x1A/\x8A\x92\x11a\0\xCEW\x80c\x1A/\x8A\x92\x14a\x011W\x80cD\xC2_\xBA\x14a\x01DW\x80cVw\xC1\x1E\x14a\x01WW\x80c]\xFC.J\x14a\x01\x07W_\x80\xFD[\x80c\x05y_s\x14a\0\xFFW\x80c\x0E\x8C8\x9F\x14a\x01\tW\x80c\x12\xE0]\xD1\x14a\x01\x11W\x80c\x19\xCA\xE4b\x14a\x01(W[_\x80\xFD[a\x01\x07a\x01\xE5V[\0[a\x01\x07a\x022V[`\x01T[`@Q\x90\x81R` \x01[`@Q\x80\x91\x03\x90\xF3[a\x01\x15`\x01T\x81V[a\x01\x15a\x01?6`\x04a\rVV[a\x04\x16V[a\x01\x07a\x01R6`\x04a\r\xE1V[a\x04\x96V[a\x01\x15a\t\x0EV[_Ta\x01r\x90g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x81V[`@Qg\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x90\x91\x16\x81R` \x01a\x01\x1FV[a\x01\x07a\x01\x996`\x04a\x0E_V[a\tyV[a\x01\x07a\n\0V[a\x01\x07a\x01\xB46`\x04a\x0E\xA3V[a\nmV[a\x01\x07a\x0B\xD7V[a\x01\x07D`\x01UV[a\x01\x07a\x0C\x01V[a\x01\x07a\x01\xE06`\x04a\x0FiV[a\x0CBV[`@QbF\x1B\xCD`\xE5\x1B\x81R` `\x04\x82\x01R`\x12`$\x82\x01R\x7FSOLIDITY_REVERTING\0\0\0\0\0\0\0\0\0\0\0\0\0\0`D\x82\x01R`d\x01[`@Q\x80\x91\x03\x90\xFD[32\x14a\x02\x81W`@QbF\x1B\xCD`\xE5\x1B\x81R` `\x04\x82\x01R`\x11`$\x82\x01R\x7FSENDER_NOT_ORIGIN\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0`D\x82\x01R`d\x01a\x02)V[`d`\x01`\x01`\xA0\x1B\x03\x16c\x17Z&\x0B`@Q\x81c\xFF\xFF\xFF\xFF\x16`\xE0\x1B\x81R`\x04\x01` `@Q\x80\x83\x03\x81\x86Z\xFA\x15\x80\x15a\x02\xBEW=_\x80>=_\xFD[PPPP`@Q=`\x1F\x19`\x1F\x82\x01\x16\x82\x01\x80`@RP\x81\x01\x90a\x02\xE2\x91\x90a\x0F\xA0V[a\x03.W`@QbF\x1B\xCD`\xE5\x1B\x81R` `\x04\x82\x01R`\x0B`$\x82\x01R\x7FNOT_ALIASED\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0`D\x82\x01R`d\x01a\x02)V[_\x80Tg\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x90\x80a\x03F\x83a\x0F\xEFV[\x91\x90a\x01\0\n\x81T\x81g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x02\x19\x16\x90\x83g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x02\x17\x90UPP\x7Fw<x\xBF\x96\xE6_a\xC1\xA2b+G\xD7nx\xBF\xE7\r\xD5\x9C\xF4\xF1\x14p\xC4\xC1!\xC3\x15\x94\x133`n`\x01`\x01`\xA0\x1B\x03\x16c\xDEK\xA2\xB3`@Q\x81c\xFF\xFF\xFF\xFF\x16`\xE0\x1B\x81R`\x04\x01` `@Q\x80\x83\x03\x81\x86Z\xFA\x15\x80\x15a\x03\xCCW=_\x80>=_\xFD[PPPP`@Q=`\x1F\x19`\x1F\x82\x01\x16\x82\x01\x80`@RP\x81\x01\x90a\x03\xF0\x91\x90a\x10\x15V[`@\x80Q`\x01`\x01`\xA0\x1B\x03\x93\x84\x16\x81R\x92\x90\x91\x16` \x83\x01R\x01[`@Q\x80\x91\x03\x90\xA1V[_\x80Z\x90P`\x01`\x01`\xA0\x1B\x03\x85\x16a\x041a'\x10\x83a\x100V[\x85\x85`@Qa\x04A\x92\x91\x90a\x10IV[_`@Q\x80\x83\x03\x81\x86\x86\xFA\x92PPP=\x80_\x81\x14a\x04zW`@Q\x91P`\x1F\x19`?=\x01\x16\x82\x01`@R=\x82R=_` \x84\x01>a\x04\x7FV[``\x91P[PPPZa\x04\x8D\x90\x82a\x100V[\x95\x94PPPPPV[\x85\x15a\x05TW\x84\x15\x15`d`\x01`\x01`\xA0\x1B\x03\x16c\x08\xBDbL`@Q\x81c\xFF\xFF\xFF\xFF\x16`\xE0\x1B\x81R`\x04\x01` `@Q\x80\x83\x03\x81\x86Z\xFA\x15\x80\x15a\x04\xDCW=_\x80>=_\xFD[PPPP`@Q=`\x1F\x19`\x1F\x82\x01\x16\x82\x01\x80`@RP\x81\x01\x90a\x05\0\x91\x90a\x0F\xA0V[\x15\x15\x14a\x05OW`@QbF\x1B\xCD`\xE5\x1B\x81R` `\x04\x82\x01R`\x11`$\x82\x01R\x7FUNEXPECTED_RESULT\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0`D\x82\x01R`d\x01a\x02)V[a\x06\x07V[\x84\x15\x15`d`\x01`\x01`\xA0\x1B\x03\x16c\x17Z&\x0B`@Q\x81c\xFF\xFF\xFF\xFF\x16`\xE0\x1B\x81R`\x04\x01` `@Q\x80\x83\x03\x81\x86Z\xFA\x15\x80\x15a\x05\x94W=_\x80>=_\xFD[PPPP`@Q=`\x1F\x19`\x1F\x82\x01\x16\x82\x01\x80`@RP\x81\x01\x90a\x05\xB8\x91\x90a\x0F\xA0V[\x15\x15\x14a\x06\x07W`@QbF\x1B\xCD`\xE5\x1B\x81R` `\x04\x82\x01R`\x11`$\x82\x01R\x7FUNEXPECTED_RESULT\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0`D\x82\x01R`d\x01a\x02)V[`@Qc\xDE\xD5\xEC\xAD`\xE0\x1B\x81R\x86\x15\x15`\x04\x82\x01R\x84\x15\x15`$\x82\x01R0\x90c\xDE\xD5\xEC\xAD\x90`D\x01_`@Q\x80\x83\x03\x81\x86\x80;\x15\x80\x15a\x06EW_\x80\xFD[PZ\xFA\x15\x80\x15a\x06WW=_\x80>=_\xFD[PP`@\x80Q\x89\x15\x15`$\x82\x01R\x86\x15\x15`D\x80\x83\x01\x91\x90\x91R\x82Q\x80\x83\x03\x90\x91\x01\x81R`d\x90\x91\x01\x82R` \x81\x01\x80Q{\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16c\xDE\xD5\xEC\xAD`\xE0\x1B\x17\x90R\x90Q\x90\x92P_\x91P0\x90a\x06\xC6\x90\x84\x90a\x10XV[_`@Q\x80\x83\x03\x81\x85Z\xF4\x91PP=\x80_\x81\x14a\x06\xFEW`@Q\x91P`\x1F\x19`?=\x01\x16\x82\x01`@R=\x82R=_` \x84\x01>a\x07\x03V[``\x91P[PP\x90P\x80a\x07TW`@QbF\x1B\xCD`\xE5\x1B\x81R` `\x04\x82\x01R`\x14`$\x82\x01R\x7FDELEGATE_CALL_FAILED\0\0\0\0\0\0\0\0\0\0\0\0`D\x82\x01R`d\x01a\x02)V[`@\x80Q\x89\x15\x15`$\x82\x01R\x85\x15\x15`D\x80\x83\x01\x91\x90\x91R\x82Q\x80\x83\x03\x90\x91\x01\x81R`d\x90\x91\x01\x90\x91R` \x81\x01\x80Q{\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16c\xDE\xD5\xEC\xAD`\xE0\x1B\x17\x81R\x81Q\x91\x93P_\x91\x82\x91\x820Z\xF2\x90P\x80a\x08\tW`@QbF\x1B\xCD`\xE5\x1B\x81R` `\x04\x82\x01R`\x0F`$\x82\x01R\x7FCALLCODE_FAILED\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0`D\x82\x01R`d\x01a\x02)V[`@\x80Q\x89\x15\x15`$\x82\x01R\x84\x15\x15`D\x80\x83\x01\x91\x90\x91R\x82Q\x80\x83\x03\x90\x91\x01\x81R`d\x90\x91\x01\x82R` \x81\x01\x80Q{\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16c\xDE\xD5\xEC\xAD`\xE0\x1B\x17\x90R\x90Q\x90\x92P0\x90a\x08s\x90\x84\x90a\x10XV[_`@Q\x80\x83\x03\x81_\x86Z\xF1\x91PP=\x80_\x81\x14a\x08\xACW`@Q\x91P`\x1F\x19`?=\x01\x16\x82\x01`@R=\x82R=_` \x84\x01>a\x08\xB1V[``\x91P[PP\x80\x91PP\x80a\t\x04W`@QbF\x1B\xCD`\xE5\x1B\x81R` `\x04\x82\x01R`\x0B`$\x82\x01R\x7FCALL_FAILED\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0`D\x82\x01R`d\x01a\x02)V[PPPPPPPPV[_a\t\x1A`\x02Ca\x100V[@a\t&`\x01Ca\x100V[@\x03a\ttW`@QbF\x1B\xCD`\xE5\x1B\x81R` `\x04\x82\x01R`\x0F`$\x82\x01R\x7FSAME_BLOCK_HASH\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0`D\x82\x01R`d\x01a\x02)V[PC\x90V[_T`@\x80Q\x83\x81Rg\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x90\x92\x16` \x83\x01R\x7F\x8D\xF8\xE4\x92\xF4\x07\xB0xY<]\x8F\xD7\xE6^\xF6\x85\x05\x99\x9D\x91\x1D[\x99\xB0\x17\xC0\xB7\x07s\x98\xB9\x91\x01`@Q\x80\x91\x03\x90\xA1_\x80Tg\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x90\x80a\t\xD6\x83a\x0F\xEFV[\x91\x90a\x01\0\n\x81T\x81g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x02\x19\x16\x90\x83g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x02\x17\x90UPPPV[_\x80Tg\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x90\x80a\n\x18\x83a\x0F\xEFV[\x82Ta\x01\0\x92\x90\x92\ng\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x81\x02\x19\x90\x93\x16\x91\x83\x16\x02\x17\x90\x91U_T`@Q\x91\x16\x81R\x7F\xA4]~y\xCB<`D\xF3\x0C\x8D\xD8\x91\xE6W\x13\x01\xD6\xB8\xB6a\x8D\xF5\x19\xC9\x87\x90^\xC7\x07B\xE7\x91P` \x01a\x04\x0CV[_\x83`\x01`\x01`\xA0\x1B\x03\x16c\x06\xF10V`@Q\x81c\xFF\xFF\xFF\xFF\x16`\xE0\x1B\x81R`\x04\x01` `@Q\x80\x83\x03\x81\x86Z\xFA\x15\x80\x15a\n\xAAW=_\x80>=_\xFD[PPPP`@Q=`\x1F\x19`\x1F\x82\x01\x16\x82\x01\x80`@RP\x81\x01\x90a\n\xCE\x91\x90a\x10nV[\x90P_\x84`\x01`\x01`\xA0\x1B\x03\x16c\x7F\xA3\xA4\x0E`@Q\x81c\xFF\xFF\xFF\xFF\x16`\xE0\x1B\x81R`\x04\x01` `@Q\x80\x83\x03\x81\x86Z\xFA\x15\x80\x15a\x0B\rW=_\x80>=_\xFD[PPPP`@Q=`\x1F\x19`\x1F\x82\x01\x16\x82\x01\x80`@RP\x81\x01\x90a\x0B1\x91\x90a\x10nV[\x90P_[\x83\x81\x10\x15a\x0B\xCFW`@Q\x7F\xE0\xBC\x97)\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x01`\x01`\xA0\x1B\x03\x87\x16\x90c\xE0\xBC\x97)\x90a\x0B\x8C\x90\x86\x90\x89\x90\x87\x90_\x90\x81\x90\x81\x90`\x04\x01a\x10\x85V[_`@Q\x80\x83\x03\x81_\x87\x80;\x15\x80\x15a\x0B\xA3W_\x80\xFD[PZ\xF1\x15\x80\x15a\x0B\xB5W=_\x80>=_\xFD[PPPP\x82\x80a\x0B\xC4\x90a\x10\xE6V[\x93PP`\x01\x01a\x0B5V[PPPPPPV[`@Q\x7FoY\xC8!\x01\x94\x92\x90 Z\x9A\xE9\xD0\xC6W\xE6\xDA\xE1\xA7\x1C0\x1A\xE7m8\\'\x92)E\x85\xFE\x90_\x90\xA1V[_\x80Tg\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x90\x80a\x0C\x19\x83a\x0F\xEFV[\x91\x90a\x01\0\n\x81T\x81g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x02\x19\x16\x90\x83g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x02\x17\x90UPPV[\x81\x15a\x0C\xFFW\x80\x15\x15`d`\x01`\x01`\xA0\x1B\x03\x16c\x08\xBDbL`@Q\x81c\xFF\xFF\xFF\xFF\x16`\xE0\x1B\x81R`\x04\x01` `@Q\x80\x83\x03\x81\x86Z\xFA\x15\x80\x15a\x0C\x88W=_\x80>=_\xFD[PPPP`@Q=`\x1F\x19`\x1F\x82\x01\x16\x82\x01\x80`@RP\x81\x01\x90a\x0C\xAC\x91\x90a\x0F\xA0V[\x15\x15\x14a\x0C\xFBW`@QbF\x1B\xCD`\xE5\x1B\x81R` `\x04\x82\x01R`\x11`$\x82\x01R\x7FUNEXPECTED_RESULT\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0`D\x82\x01R`d\x01a\x02)V[PPV[\x80\x15\x15`d`\x01`\x01`\xA0\x1B\x03\x16c\x17Z&\x0B`@Q\x81c\xFF\xFF\xFF\xFF\x16`\xE0\x1B\x81R`\x04\x01` `@Q\x80\x83\x03\x81\x86Z\xFA\x15\x80\x15a\x0C\x88W=_\x80>=_\xFD[`\x01`\x01`\xA0\x1B\x03\x81\x16\x81\x14a\rSW_\x80\xFD[PV[_\x80_`@\x84\x86\x03\x12\x15a\rhW_\x80\xFD[\x835a\rs\x81a\r?V[\x92P` \x84\x015g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x80\x82\x11\x15a\r\x8FW_\x80\xFD[\x81\x86\x01\x91P\x86`\x1F\x83\x01\x12a\r\xA2W_\x80\xFD[\x815\x81\x81\x11\x15a\r\xB0W_\x80\xFD[\x87` \x82\x85\x01\x01\x11\x15a\r\xC1W_\x80\xFD[` \x83\x01\x94P\x80\x93PPPP\x92P\x92P\x92V[\x80\x15\x15\x81\x14a\rSW_\x80\xFD[_\x80_\x80_\x80`\xC0\x87\x89\x03\x12\x15a\r\xF6W_\x80\xFD[\x865a\x0E\x01\x81a\r\xD4V[\x95P` \x87\x015a\x0E\x11\x81a\r\xD4V[\x94P`@\x87\x015a\x0E!\x81a\r\xD4V[\x93P``\x87\x015a\x0E1\x81a\r\xD4V[\x92P`\x80\x87\x015a\x0EA\x81a\r\xD4V[\x91P`\xA0\x87\x015a\x0EQ\x81a\r\xD4V[\x80\x91PP\x92\x95P\x92\x95P\x92\x95V[_` \x82\x84\x03\x12\x15a\x0EoW_\x80\xFD[P5\x91\x90PV[\x7FNH{q\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0_R`A`\x04R`$_\xFD[_\x80_``\x84\x86\x03\x12\x15a\x0E\xB5W_\x80\xFD[\x835a\x0E\xC0\x81a\r?V[\x92P` \x84\x015g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x80\x82\x11\x15a\x0E\xDCW_\x80\xFD[\x81\x86\x01\x91P\x86`\x1F\x83\x01\x12a\x0E\xEFW_\x80\xFD[\x815\x81\x81\x11\x15a\x0F\x01Wa\x0F\x01a\x0EvV[`@Q`\x1F\x82\x01`\x1F\x19\x90\x81\x16`?\x01\x16\x81\x01\x90\x83\x82\x11\x81\x83\x10\x17\x15a\x0F)Wa\x0F)a\x0EvV[\x81`@R\x82\x81R\x89` \x84\x87\x01\x01\x11\x15a\x0FAW_\x80\xFD[\x82` \x86\x01` \x83\x017_` \x84\x83\x01\x01R\x80\x96PPPPPP`@\x84\x015\x90P\x92P\x92P\x92V[_\x80`@\x83\x85\x03\x12\x15a\x0FzW_\x80\xFD[\x825a\x0F\x85\x81a\r\xD4V[\x91P` \x83\x015a\x0F\x95\x81a\r\xD4V[\x80\x91PP\x92P\x92\x90PV[_` \x82\x84\x03\x12\x15a\x0F\xB0W_\x80\xFD[\x81Qa\x0F\xBB\x81a\r\xD4V[\x93\x92PPPV[\x7FNH{q\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0_R`\x11`\x04R`$_\xFD[_g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x80\x83\x16\x81\x81\x03a\x10\x0BWa\x10\x0Ba\x0F\xC2V[`\x01\x01\x93\x92PPPV[_` \x82\x84\x03\x12\x15a\x10%W_\x80\xFD[\x81Qa\x0F\xBB\x81a\r?V[\x81\x81\x03\x81\x81\x11\x15a\x10CWa\x10Ca\x0F\xC2V[\x92\x91PPV[\x81\x83\x827_\x91\x01\x90\x81R\x91\x90PV[_\x82Q\x80` \x85\x01\x84^_\x92\x01\x91\x82RP\x91\x90PV[_` \x82\x84\x03\x12\x15a\x10~W_\x80\xFD[PQ\x91\x90PV[\x86\x81R`\xC0` \x82\x01R_\x86Q\x80`\xC0\x84\x01R\x80` \x89\x01`\xE0\x85\x01^_`\xE0\x82\x85\x01\x01R`\xE0`\x1F\x19`\x1F\x83\x01\x16\x84\x01\x01\x91PP\x85`@\x83\x01R`\x01`\x01`\xA0\x1B\x03\x85\x16``\x83\x01R\x83`\x80\x83\x01R\x82`\xA0\x83\x01R\x97\x96PPPPPPPV[_\x7F\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x82\x03a\x11\x16Wa\x11\x16a\x0F\xC2V[P`\x01\x01\x90V\xFE\xA2dipfsX\"\x12 u^\xA1\x89\x9F\x96\x02\xCA\xF3cR\xD4rz\xAD\xC1\x93\xB0-\xC4Y\x16\xE3\xEBp\xBB\x9D\xD2\xDD\xAA8\xDEdsolcC\0\x08\x19\x003",
    );
    /**Event with signature `CounterEvent(uint64)` and selector `0xa45d7e79cb3c6044f30c8dd891e6571301d6b8b6618df519c987905ec70742e7`.
```solidity
event CounterEvent(uint64 count);
```*/
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    #[derive(Clone)]
    pub struct CounterEvent {
        #[allow(missing_docs)]
        pub count: u64,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[automatically_derived]
        impl alloy_sol_types::SolEvent for CounterEvent {
            type DataTuple<'a> = (alloy::sol_types::sol_data::Uint<64>,);
            type DataToken<'a> = <Self::DataTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type TopicList = (alloy_sol_types::sol_data::FixedBytes<32>,);
            const SIGNATURE: &'static str = "CounterEvent(uint64)";
            const SIGNATURE_HASH: alloy_sol_types::private::B256 = alloy_sol_types::private::B256::new([
                164u8,
                93u8,
                126u8,
                121u8,
                203u8,
                60u8,
                96u8,
                68u8,
                243u8,
                12u8,
                141u8,
                216u8,
                145u8,
                230u8,
                87u8,
                19u8,
                1u8,
                214u8,
                184u8,
                182u8,
                97u8,
                141u8,
                245u8,
                25u8,
                201u8,
                135u8,
                144u8,
                94u8,
                199u8,
                7u8,
                66u8,
                231u8,
            ]);
            const ANONYMOUS: bool = false;
            #[allow(unused_variables)]
            #[inline]
            fn new(
                topics: <Self::TopicList as alloy_sol_types::SolType>::RustType,
                data: <Self::DataTuple<'_> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                Self { count: data.0 }
            }
            #[inline]
            fn check_signature(
                topics: &<Self::TopicList as alloy_sol_types::SolType>::RustType,
            ) -> alloy_sol_types::Result<()> {
                if topics.0 != Self::SIGNATURE_HASH {
                    return Err(
                        alloy_sol_types::Error::invalid_event_signature_hash(
                            Self::SIGNATURE,
                            topics.0,
                            Self::SIGNATURE_HASH,
                        ),
                    );
                }
                Ok(())
            }
            #[inline]
            fn tokenize_body(&self) -> Self::DataToken<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        64,
                    > as alloy_sol_types::SolType>::tokenize(&self.count),
                )
            }
            #[inline]
            fn topics(&self) -> <Self::TopicList as alloy_sol_types::SolType>::RustType {
                (Self::SIGNATURE_HASH.into(),)
            }
            #[inline]
            fn encode_topics_raw(
                &self,
                out: &mut [alloy_sol_types::abi::token::WordToken],
            ) -> alloy_sol_types::Result<()> {
                if out.len() < <Self::TopicList as alloy_sol_types::TopicList>::COUNT {
                    return Err(alloy_sol_types::Error::Overrun);
                }
                out[0usize] = alloy_sol_types::abi::token::WordToken(
                    Self::SIGNATURE_HASH,
                );
                Ok(())
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::private::IntoLogData for CounterEvent {
            fn to_log_data(&self) -> alloy_sol_types::private::LogData {
                From::from(self)
            }
            fn into_log_data(self) -> alloy_sol_types::private::LogData {
                From::from(&self)
            }
        }
        #[automatically_derived]
        impl From<&CounterEvent> for alloy_sol_types::private::LogData {
            #[inline]
            fn from(this: &CounterEvent) -> alloy_sol_types::private::LogData {
                alloy_sol_types::SolEvent::encode_log_data(this)
            }
        }
    };
    /**Event with signature `LogAndIncrementCalled(uint256,uint256)` and selector `0x8df8e492f407b078593c5d8fd7e65ef68505999d911d5b99b017c0b7077398b9`.
```solidity
event LogAndIncrementCalled(uint256 expected, uint256 have);
```*/
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    #[derive(Clone)]
    pub struct LogAndIncrementCalled {
        #[allow(missing_docs)]
        pub expected: alloy::sol_types::private::primitives::aliases::U256,
        #[allow(missing_docs)]
        pub have: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[automatically_derived]
        impl alloy_sol_types::SolEvent for LogAndIncrementCalled {
            type DataTuple<'a> = (
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Uint<256>,
            );
            type DataToken<'a> = <Self::DataTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type TopicList = (alloy_sol_types::sol_data::FixedBytes<32>,);
            const SIGNATURE: &'static str = "LogAndIncrementCalled(uint256,uint256)";
            const SIGNATURE_HASH: alloy_sol_types::private::B256 = alloy_sol_types::private::B256::new([
                141u8,
                248u8,
                228u8,
                146u8,
                244u8,
                7u8,
                176u8,
                120u8,
                89u8,
                60u8,
                93u8,
                143u8,
                215u8,
                230u8,
                94u8,
                246u8,
                133u8,
                5u8,
                153u8,
                157u8,
                145u8,
                29u8,
                91u8,
                153u8,
                176u8,
                23u8,
                192u8,
                183u8,
                7u8,
                115u8,
                152u8,
                185u8,
            ]);
            const ANONYMOUS: bool = false;
            #[allow(unused_variables)]
            #[inline]
            fn new(
                topics: <Self::TopicList as alloy_sol_types::SolType>::RustType,
                data: <Self::DataTuple<'_> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                Self {
                    expected: data.0,
                    have: data.1,
                }
            }
            #[inline]
            fn check_signature(
                topics: &<Self::TopicList as alloy_sol_types::SolType>::RustType,
            ) -> alloy_sol_types::Result<()> {
                if topics.0 != Self::SIGNATURE_HASH {
                    return Err(
                        alloy_sol_types::Error::invalid_event_signature_hash(
                            Self::SIGNATURE,
                            topics.0,
                            Self::SIGNATURE_HASH,
                        ),
                    );
                }
                Ok(())
            }
            #[inline]
            fn tokenize_body(&self) -> Self::DataToken<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.expected),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.have),
                )
            }
            #[inline]
            fn topics(&self) -> <Self::TopicList as alloy_sol_types::SolType>::RustType {
                (Self::SIGNATURE_HASH.into(),)
            }
            #[inline]
            fn encode_topics_raw(
                &self,
                out: &mut [alloy_sol_types::abi::token::WordToken],
            ) -> alloy_sol_types::Result<()> {
                if out.len() < <Self::TopicList as alloy_sol_types::TopicList>::COUNT {
                    return Err(alloy_sol_types::Error::Overrun);
                }
                out[0usize] = alloy_sol_types::abi::token::WordToken(
                    Self::SIGNATURE_HASH,
                );
                Ok(())
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::private::IntoLogData for LogAndIncrementCalled {
            fn to_log_data(&self) -> alloy_sol_types::private::LogData {
                From::from(self)
            }
            fn into_log_data(self) -> alloy_sol_types::private::LogData {
                From::from(&self)
            }
        }
        #[automatically_derived]
        impl From<&LogAndIncrementCalled> for alloy_sol_types::private::LogData {
            #[inline]
            fn from(this: &LogAndIncrementCalled) -> alloy_sol_types::private::LogData {
                alloy_sol_types::SolEvent::encode_log_data(this)
            }
        }
    };
    /**Event with signature `NullEvent()` and selector `0x6f59c82101949290205a9ae9d0c657e6dae1a71c301ae76d385c2792294585fe`.
```solidity
event NullEvent();
```*/
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    #[derive(Clone)]
    pub struct NullEvent {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[automatically_derived]
        impl alloy_sol_types::SolEvent for NullEvent {
            type DataTuple<'a> = ();
            type DataToken<'a> = <Self::DataTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type TopicList = (alloy_sol_types::sol_data::FixedBytes<32>,);
            const SIGNATURE: &'static str = "NullEvent()";
            const SIGNATURE_HASH: alloy_sol_types::private::B256 = alloy_sol_types::private::B256::new([
                111u8,
                89u8,
                200u8,
                33u8,
                1u8,
                148u8,
                146u8,
                144u8,
                32u8,
                90u8,
                154u8,
                233u8,
                208u8,
                198u8,
                87u8,
                230u8,
                218u8,
                225u8,
                167u8,
                28u8,
                48u8,
                26u8,
                231u8,
                109u8,
                56u8,
                92u8,
                39u8,
                146u8,
                41u8,
                69u8,
                133u8,
                254u8,
            ]);
            const ANONYMOUS: bool = false;
            #[allow(unused_variables)]
            #[inline]
            fn new(
                topics: <Self::TopicList as alloy_sol_types::SolType>::RustType,
                data: <Self::DataTuple<'_> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                Self {}
            }
            #[inline]
            fn check_signature(
                topics: &<Self::TopicList as alloy_sol_types::SolType>::RustType,
            ) -> alloy_sol_types::Result<()> {
                if topics.0 != Self::SIGNATURE_HASH {
                    return Err(
                        alloy_sol_types::Error::invalid_event_signature_hash(
                            Self::SIGNATURE,
                            topics.0,
                            Self::SIGNATURE_HASH,
                        ),
                    );
                }
                Ok(())
            }
            #[inline]
            fn tokenize_body(&self) -> Self::DataToken<'_> {
                ()
            }
            #[inline]
            fn topics(&self) -> <Self::TopicList as alloy_sol_types::SolType>::RustType {
                (Self::SIGNATURE_HASH.into(),)
            }
            #[inline]
            fn encode_topics_raw(
                &self,
                out: &mut [alloy_sol_types::abi::token::WordToken],
            ) -> alloy_sol_types::Result<()> {
                if out.len() < <Self::TopicList as alloy_sol_types::TopicList>::COUNT {
                    return Err(alloy_sol_types::Error::Overrun);
                }
                out[0usize] = alloy_sol_types::abi::token::WordToken(
                    Self::SIGNATURE_HASH,
                );
                Ok(())
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::private::IntoLogData for NullEvent {
            fn to_log_data(&self) -> alloy_sol_types::private::LogData {
                From::from(self)
            }
            fn into_log_data(self) -> alloy_sol_types::private::LogData {
                From::from(&self)
            }
        }
        #[automatically_derived]
        impl From<&NullEvent> for alloy_sol_types::private::LogData {
            #[inline]
            fn from(this: &NullEvent) -> alloy_sol_types::private::LogData {
                alloy_sol_types::SolEvent::encode_log_data(this)
            }
        }
    };
    /**Event with signature `RedeemedEvent(address,address)` and selector `0x773c78bf96e65f61c1a2622b47d76e78bfe70dd59cf4f11470c4c121c3159413`.
```solidity
event RedeemedEvent(address caller, address redeemer);
```*/
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    #[derive(Clone)]
    pub struct RedeemedEvent {
        #[allow(missing_docs)]
        pub caller: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub redeemer: alloy::sol_types::private::Address,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[automatically_derived]
        impl alloy_sol_types::SolEvent for RedeemedEvent {
            type DataTuple<'a> = (
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Address,
            );
            type DataToken<'a> = <Self::DataTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type TopicList = (alloy_sol_types::sol_data::FixedBytes<32>,);
            const SIGNATURE: &'static str = "RedeemedEvent(address,address)";
            const SIGNATURE_HASH: alloy_sol_types::private::B256 = alloy_sol_types::private::B256::new([
                119u8,
                60u8,
                120u8,
                191u8,
                150u8,
                230u8,
                95u8,
                97u8,
                193u8,
                162u8,
                98u8,
                43u8,
                71u8,
                215u8,
                110u8,
                120u8,
                191u8,
                231u8,
                13u8,
                213u8,
                156u8,
                244u8,
                241u8,
                20u8,
                112u8,
                196u8,
                193u8,
                33u8,
                195u8,
                21u8,
                148u8,
                19u8,
            ]);
            const ANONYMOUS: bool = false;
            #[allow(unused_variables)]
            #[inline]
            fn new(
                topics: <Self::TopicList as alloy_sol_types::SolType>::RustType,
                data: <Self::DataTuple<'_> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                Self {
                    caller: data.0,
                    redeemer: data.1,
                }
            }
            #[inline]
            fn check_signature(
                topics: &<Self::TopicList as alloy_sol_types::SolType>::RustType,
            ) -> alloy_sol_types::Result<()> {
                if topics.0 != Self::SIGNATURE_HASH {
                    return Err(
                        alloy_sol_types::Error::invalid_event_signature_hash(
                            Self::SIGNATURE,
                            topics.0,
                            Self::SIGNATURE_HASH,
                        ),
                    );
                }
                Ok(())
            }
            #[inline]
            fn tokenize_body(&self) -> Self::DataToken<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.caller,
                    ),
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.redeemer,
                    ),
                )
            }
            #[inline]
            fn topics(&self) -> <Self::TopicList as alloy_sol_types::SolType>::RustType {
                (Self::SIGNATURE_HASH.into(),)
            }
            #[inline]
            fn encode_topics_raw(
                &self,
                out: &mut [alloy_sol_types::abi::token::WordToken],
            ) -> alloy_sol_types::Result<()> {
                if out.len() < <Self::TopicList as alloy_sol_types::TopicList>::COUNT {
                    return Err(alloy_sol_types::Error::Overrun);
                }
                out[0usize] = alloy_sol_types::abi::token::WordToken(
                    Self::SIGNATURE_HASH,
                );
                Ok(())
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::private::IntoLogData for RedeemedEvent {
            fn to_log_data(&self) -> alloy_sol_types::private::LogData {
                From::from(self)
            }
            fn into_log_data(self) -> alloy_sol_types::private::LogData {
                From::from(&self)
            }
        }
        #[automatically_derived]
        impl From<&RedeemedEvent> for alloy_sol_types::private::LogData {
            #[inline]
            fn from(this: &RedeemedEvent) -> alloy_sol_types::private::LogData {
                alloy_sol_types::SolEvent::encode_log_data(this)
            }
        }
    };
    /**Function with signature `checkBlockHashes()` and selector `0x5677c11e`.
```solidity
function checkBlockHashes() external view returns (uint256);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct checkBlockHashesCall {}
    ///Container type for the return parameters of the [`checkBlockHashes()`](checkBlockHashesCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct checkBlockHashesReturn {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<checkBlockHashesCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: checkBlockHashesCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for checkBlockHashesCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<checkBlockHashesReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: checkBlockHashesReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for checkBlockHashesReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for checkBlockHashesCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = checkBlockHashesReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "checkBlockHashes()";
            const SELECTOR: [u8; 4] = [86u8, 119u8, 193u8, 30u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `checkCalls(bool,bool,bool,bool,bool,bool)` and selector `0x44c25fba`.
```solidity
function checkCalls(bool useTopLevel, bool directCase, bool staticCase, bool delegateCase, bool callcodeCase, bool callCase) external;
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct checkCallsCall {
        #[allow(missing_docs)]
        pub useTopLevel: bool,
        #[allow(missing_docs)]
        pub directCase: bool,
        #[allow(missing_docs)]
        pub staticCase: bool,
        #[allow(missing_docs)]
        pub delegateCase: bool,
        #[allow(missing_docs)]
        pub callcodeCase: bool,
        #[allow(missing_docs)]
        pub callCase: bool,
    }
    ///Container type for the return parameters of the [`checkCalls(bool,bool,bool,bool,bool,bool)`](checkCallsCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct checkCallsReturn {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::Bool,
                alloy::sol_types::sol_data::Bool,
                alloy::sol_types::sol_data::Bool,
                alloy::sol_types::sol_data::Bool,
                alloy::sol_types::sol_data::Bool,
                alloy::sol_types::sol_data::Bool,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (bool, bool, bool, bool, bool, bool);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<checkCallsCall> for UnderlyingRustTuple<'_> {
                fn from(value: checkCallsCall) -> Self {
                    (
                        value.useTopLevel,
                        value.directCase,
                        value.staticCase,
                        value.delegateCase,
                        value.callcodeCase,
                        value.callCase,
                    )
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for checkCallsCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        useTopLevel: tuple.0,
                        directCase: tuple.1,
                        staticCase: tuple.2,
                        delegateCase: tuple.3,
                        callcodeCase: tuple.4,
                        callCase: tuple.5,
                    }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<checkCallsReturn> for UnderlyingRustTuple<'_> {
                fn from(value: checkCallsReturn) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for checkCallsReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for checkCallsCall {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::Bool,
                alloy::sol_types::sol_data::Bool,
                alloy::sol_types::sol_data::Bool,
                alloy::sol_types::sol_data::Bool,
                alloy::sol_types::sol_data::Bool,
                alloy::sol_types::sol_data::Bool,
            );
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = checkCallsReturn;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "checkCalls(bool,bool,bool,bool,bool,bool)";
            const SELECTOR: [u8; 4] = [68u8, 194u8, 95u8, 186u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Bool as alloy_sol_types::SolType>::tokenize(
                        &self.useTopLevel,
                    ),
                    <alloy::sol_types::sol_data::Bool as alloy_sol_types::SolType>::tokenize(
                        &self.directCase,
                    ),
                    <alloy::sol_types::sol_data::Bool as alloy_sol_types::SolType>::tokenize(
                        &self.staticCase,
                    ),
                    <alloy::sol_types::sol_data::Bool as alloy_sol_types::SolType>::tokenize(
                        &self.delegateCase,
                    ),
                    <alloy::sol_types::sol_data::Bool as alloy_sol_types::SolType>::tokenize(
                        &self.callcodeCase,
                    ),
                    <alloy::sol_types::sol_data::Bool as alloy_sol_types::SolType>::tokenize(
                        &self.callCase,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `checkGasUsed(address,bytes)` and selector `0x1a2f8a92`.
```solidity
function checkGasUsed(address to, bytes memory input) external view returns (uint256);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct checkGasUsedCall {
        #[allow(missing_docs)]
        pub to: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub input: alloy::sol_types::private::Bytes,
    }
    ///Container type for the return parameters of the [`checkGasUsed(address,bytes)`](checkGasUsedCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct checkGasUsedReturn {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Bytes,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::Address,
                alloy::sol_types::private::Bytes,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<checkGasUsedCall> for UnderlyingRustTuple<'_> {
                fn from(value: checkGasUsedCall) -> Self {
                    (value.to, value.input)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for checkGasUsedCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        to: tuple.0,
                        input: tuple.1,
                    }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<checkGasUsedReturn> for UnderlyingRustTuple<'_> {
                fn from(value: checkGasUsedReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for checkGasUsedReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for checkGasUsedCall {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Bytes,
            );
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = checkGasUsedReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "checkGasUsed(address,bytes)";
            const SELECTOR: [u8; 4] = [26u8, 47u8, 138u8, 146u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.to,
                    ),
                    <alloy::sol_types::sol_data::Bytes as alloy_sol_types::SolType>::tokenize(
                        &self.input,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `checkIsTopLevelOrWasAliased(bool,bool)` and selector `0xded5ecad`.
```solidity
function checkIsTopLevelOrWasAliased(bool useTopLevel, bool expected) external view;
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct checkIsTopLevelOrWasAliasedCall {
        #[allow(missing_docs)]
        pub useTopLevel: bool,
        #[allow(missing_docs)]
        pub expected: bool,
    }
    ///Container type for the return parameters of the [`checkIsTopLevelOrWasAliased(bool,bool)`](checkIsTopLevelOrWasAliasedCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct checkIsTopLevelOrWasAliasedReturn {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::Bool,
                alloy::sol_types::sol_data::Bool,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (bool, bool);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<checkIsTopLevelOrWasAliasedCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: checkIsTopLevelOrWasAliasedCall) -> Self {
                    (value.useTopLevel, value.expected)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for checkIsTopLevelOrWasAliasedCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        useTopLevel: tuple.0,
                        expected: tuple.1,
                    }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<checkIsTopLevelOrWasAliasedReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: checkIsTopLevelOrWasAliasedReturn) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for checkIsTopLevelOrWasAliasedReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for checkIsTopLevelOrWasAliasedCall {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::Bool,
                alloy::sol_types::sol_data::Bool,
            );
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = checkIsTopLevelOrWasAliasedReturn;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "checkIsTopLevelOrWasAliased(bool,bool)";
            const SELECTOR: [u8; 4] = [222u8, 213u8, 236u8, 173u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Bool as alloy_sol_types::SolType>::tokenize(
                        &self.useTopLevel,
                    ),
                    <alloy::sol_types::sol_data::Bool as alloy_sol_types::SolType>::tokenize(
                        &self.expected,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `counter()` and selector `0x61bc221a`.
```solidity
function counter() external view returns (uint64);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct counterCall {}
    ///Container type for the return parameters of the [`counter()`](counterCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct counterReturn {
        #[allow(missing_docs)]
        pub _0: u64,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<counterCall> for UnderlyingRustTuple<'_> {
                fn from(value: counterCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for counterCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<64>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (u64,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<counterReturn> for UnderlyingRustTuple<'_> {
                fn from(value: counterReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for counterReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for counterCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = counterReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Uint<64>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "counter()";
            const SELECTOR: [u8; 4] = [97u8, 188u8, 34u8, 26u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `difficulty()` and selector `0x19cae462`.
```solidity
function difficulty() external view returns (uint256);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct difficultyCall {}
    ///Container type for the return parameters of the [`difficulty()`](difficultyCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct difficultyReturn {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<difficultyCall> for UnderlyingRustTuple<'_> {
                fn from(value: difficultyCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for difficultyCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<difficultyReturn> for UnderlyingRustTuple<'_> {
                fn from(value: difficultyReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for difficultyReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for difficultyCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = difficultyReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "difficulty()";
            const SELECTOR: [u8; 4] = [25u8, 202u8, 228u8, 98u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `emitNullEvent()` and selector `0xb226a964`.
```solidity
function emitNullEvent() external;
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct emitNullEventCall {}
    ///Container type for the return parameters of the [`emitNullEvent()`](emitNullEventCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct emitNullEventReturn {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<emitNullEventCall> for UnderlyingRustTuple<'_> {
                fn from(value: emitNullEventCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for emitNullEventCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<emitNullEventReturn> for UnderlyingRustTuple<'_> {
                fn from(value: emitNullEventReturn) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for emitNullEventReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for emitNullEventCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = emitNullEventReturn;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "emitNullEvent()";
            const SELECTOR: [u8; 4] = [178u8, 38u8, 169u8, 100u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `getBlockDifficulty()` and selector `0x12e05dd1`.
```solidity
function getBlockDifficulty() external view returns (uint256);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct getBlockDifficultyCall {}
    ///Container type for the return parameters of the [`getBlockDifficulty()`](getBlockDifficultyCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct getBlockDifficultyReturn {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<getBlockDifficultyCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: getBlockDifficultyCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for getBlockDifficultyCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<getBlockDifficultyReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: getBlockDifficultyReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for getBlockDifficultyReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for getBlockDifficultyCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = getBlockDifficultyReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "getBlockDifficulty()";
            const SELECTOR: [u8; 4] = [18u8, 224u8, 93u8, 209u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `increment()` and selector `0xd09de08a`.
```solidity
function increment() external;
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct incrementCall {}
    ///Container type for the return parameters of the [`increment()`](incrementCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct incrementReturn {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<incrementCall> for UnderlyingRustTuple<'_> {
                fn from(value: incrementCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for incrementCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<incrementReturn> for UnderlyingRustTuple<'_> {
                fn from(value: incrementReturn) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for incrementReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for incrementCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = incrementReturn;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "increment()";
            const SELECTOR: [u8; 4] = [208u8, 157u8, 224u8, 138u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `incrementEmit()` and selector `0x9ff5ccac`.
```solidity
function incrementEmit() external;
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct incrementEmitCall {}
    ///Container type for the return parameters of the [`incrementEmit()`](incrementEmitCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct incrementEmitReturn {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<incrementEmitCall> for UnderlyingRustTuple<'_> {
                fn from(value: incrementEmitCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for incrementEmitCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<incrementEmitReturn> for UnderlyingRustTuple<'_> {
                fn from(value: incrementEmitReturn) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for incrementEmitReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for incrementEmitCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = incrementEmitReturn;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "incrementEmit()";
            const SELECTOR: [u8; 4] = [159u8, 245u8, 204u8, 172u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `incrementRedeem()` and selector `0x0e8c389f`.
```solidity
function incrementRedeem() external;
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct incrementRedeemCall {}
    ///Container type for the return parameters of the [`incrementRedeem()`](incrementRedeemCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct incrementRedeemReturn {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<incrementRedeemCall> for UnderlyingRustTuple<'_> {
                fn from(value: incrementRedeemCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for incrementRedeemCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<incrementRedeemReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: incrementRedeemReturn) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for incrementRedeemReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for incrementRedeemCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = incrementRedeemReturn;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "incrementRedeem()";
            const SELECTOR: [u8; 4] = [14u8, 140u8, 56u8, 159u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `logAndIncrement(uint256)` and selector `0x8a390877`.
```solidity
function logAndIncrement(uint256 expected) external;
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct logAndIncrementCall {
        #[allow(missing_docs)]
        pub expected: alloy::sol_types::private::primitives::aliases::U256,
    }
    ///Container type for the return parameters of the [`logAndIncrement(uint256)`](logAndIncrementCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct logAndIncrementReturn {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<logAndIncrementCall> for UnderlyingRustTuple<'_> {
                fn from(value: logAndIncrementCall) -> Self {
                    (value.expected,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for logAndIncrementCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { expected: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<logAndIncrementReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: logAndIncrementReturn) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for logAndIncrementReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for logAndIncrementCall {
            type Parameters<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = logAndIncrementReturn;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "logAndIncrement(uint256)";
            const SELECTOR: [u8; 4] = [138u8, 57u8, 8u8, 119u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.expected),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `noop()` and selector `0x5dfc2e4a`.
```solidity
function noop() external pure;
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct noopCall {}
    ///Container type for the return parameters of the [`noop()`](noopCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct noopReturn {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<noopCall> for UnderlyingRustTuple<'_> {
                fn from(value: noopCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for noopCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<noopReturn> for UnderlyingRustTuple<'_> {
                fn from(value: noopReturn) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for noopReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for noopCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = noopReturn;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "noop()";
            const SELECTOR: [u8; 4] = [93u8, 252u8, 46u8, 74u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `pleaseRevert()` and selector `0x05795f73`.
```solidity
function pleaseRevert() external pure;
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct pleaseRevertCall {}
    ///Container type for the return parameters of the [`pleaseRevert()`](pleaseRevertCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct pleaseRevertReturn {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<pleaseRevertCall> for UnderlyingRustTuple<'_> {
                fn from(value: pleaseRevertCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for pleaseRevertCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<pleaseRevertReturn> for UnderlyingRustTuple<'_> {
                fn from(value: pleaseRevertReturn) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for pleaseRevertReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for pleaseRevertCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = pleaseRevertReturn;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "pleaseRevert()";
            const SELECTOR: [u8; 4] = [5u8, 121u8, 95u8, 115u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `postManyBatches(address,bytes,uint256)` and selector `0xb1948fc3`.
```solidity
function postManyBatches(address sequencerInbox, bytes memory batchData, uint256 numberToPost) external;
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct postManyBatchesCall {
        #[allow(missing_docs)]
        pub sequencerInbox: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub batchData: alloy::sol_types::private::Bytes,
        #[allow(missing_docs)]
        pub numberToPost: alloy::sol_types::private::primitives::aliases::U256,
    }
    ///Container type for the return parameters of the [`postManyBatches(address,bytes,uint256)`](postManyBatchesCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct postManyBatchesReturn {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Bytes,
                alloy::sol_types::sol_data::Uint<256>,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::Address,
                alloy::sol_types::private::Bytes,
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<postManyBatchesCall> for UnderlyingRustTuple<'_> {
                fn from(value: postManyBatchesCall) -> Self {
                    (value.sequencerInbox, value.batchData, value.numberToPost)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for postManyBatchesCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        sequencerInbox: tuple.0,
                        batchData: tuple.1,
                        numberToPost: tuple.2,
                    }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<postManyBatchesReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: postManyBatchesReturn) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for postManyBatchesReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for postManyBatchesCall {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Bytes,
                alloy::sol_types::sol_data::Uint<256>,
            );
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = postManyBatchesReturn;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "postManyBatches(address,bytes,uint256)";
            const SELECTOR: [u8; 4] = [177u8, 148u8, 143u8, 195u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.sequencerInbox,
                    ),
                    <alloy::sol_types::sol_data::Bytes as alloy_sol_types::SolType>::tokenize(
                        &self.batchData,
                    ),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.numberToPost),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `storeDifficulty()` and selector `0xcff36f2d`.
```solidity
function storeDifficulty() external;
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct storeDifficultyCall {}
    ///Container type for the return parameters of the [`storeDifficulty()`](storeDifficultyCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct storeDifficultyReturn {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<storeDifficultyCall> for UnderlyingRustTuple<'_> {
                fn from(value: storeDifficultyCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for storeDifficultyCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<storeDifficultyReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: storeDifficultyReturn) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for storeDifficultyReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for storeDifficultyCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = storeDifficultyReturn;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "storeDifficulty()";
            const SELECTOR: [u8; 4] = [207u8, 243u8, 111u8, 45u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    ///Container for all the [`Simple`](self) function calls.
    pub enum SimpleCalls {
        #[allow(missing_docs)]
        checkBlockHashes(checkBlockHashesCall),
        #[allow(missing_docs)]
        checkCalls(checkCallsCall),
        #[allow(missing_docs)]
        checkGasUsed(checkGasUsedCall),
        #[allow(missing_docs)]
        checkIsTopLevelOrWasAliased(checkIsTopLevelOrWasAliasedCall),
        #[allow(missing_docs)]
        counter(counterCall),
        #[allow(missing_docs)]
        difficulty(difficultyCall),
        #[allow(missing_docs)]
        emitNullEvent(emitNullEventCall),
        #[allow(missing_docs)]
        getBlockDifficulty(getBlockDifficultyCall),
        #[allow(missing_docs)]
        increment(incrementCall),
        #[allow(missing_docs)]
        incrementEmit(incrementEmitCall),
        #[allow(missing_docs)]
        incrementRedeem(incrementRedeemCall),
        #[allow(missing_docs)]
        logAndIncrement(logAndIncrementCall),
        #[allow(missing_docs)]
        noop(noopCall),
        #[allow(missing_docs)]
        pleaseRevert(pleaseRevertCall),
        #[allow(missing_docs)]
        postManyBatches(postManyBatchesCall),
        #[allow(missing_docs)]
        storeDifficulty(storeDifficultyCall),
    }
    #[automatically_derived]
    impl SimpleCalls {
        /// All the selectors of this enum.
        ///
        /// Note that the selectors might not be in the same order as the variants.
        /// No guarantees are made about the order of the selectors.
        ///
        /// Prefer using `SolInterface` methods instead.
        pub const SELECTORS: &'static [[u8; 4usize]] = &[
            [5u8, 121u8, 95u8, 115u8],
            [14u8, 140u8, 56u8, 159u8],
            [18u8, 224u8, 93u8, 209u8],
            [25u8, 202u8, 228u8, 98u8],
            [26u8, 47u8, 138u8, 146u8],
            [68u8, 194u8, 95u8, 186u8],
            [86u8, 119u8, 193u8, 30u8],
            [93u8, 252u8, 46u8, 74u8],
            [97u8, 188u8, 34u8, 26u8],
            [138u8, 57u8, 8u8, 119u8],
            [159u8, 245u8, 204u8, 172u8],
            [177u8, 148u8, 143u8, 195u8],
            [178u8, 38u8, 169u8, 100u8],
            [207u8, 243u8, 111u8, 45u8],
            [208u8, 157u8, 224u8, 138u8],
            [222u8, 213u8, 236u8, 173u8],
        ];
    }
    #[automatically_derived]
    impl alloy_sol_types::SolInterface for SimpleCalls {
        const NAME: &'static str = "SimpleCalls";
        const MIN_DATA_LENGTH: usize = 0usize;
        const COUNT: usize = 16usize;
        #[inline]
        fn selector(&self) -> [u8; 4] {
            match self {
                Self::checkBlockHashes(_) => {
                    <checkBlockHashesCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::checkCalls(_) => {
                    <checkCallsCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::checkGasUsed(_) => {
                    <checkGasUsedCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::checkIsTopLevelOrWasAliased(_) => {
                    <checkIsTopLevelOrWasAliasedCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::counter(_) => <counterCall as alloy_sol_types::SolCall>::SELECTOR,
                Self::difficulty(_) => {
                    <difficultyCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::emitNullEvent(_) => {
                    <emitNullEventCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::getBlockDifficulty(_) => {
                    <getBlockDifficultyCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::increment(_) => {
                    <incrementCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::incrementEmit(_) => {
                    <incrementEmitCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::incrementRedeem(_) => {
                    <incrementRedeemCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::logAndIncrement(_) => {
                    <logAndIncrementCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::noop(_) => <noopCall as alloy_sol_types::SolCall>::SELECTOR,
                Self::pleaseRevert(_) => {
                    <pleaseRevertCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::postManyBatches(_) => {
                    <postManyBatchesCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::storeDifficulty(_) => {
                    <storeDifficultyCall as alloy_sol_types::SolCall>::SELECTOR
                }
            }
        }
        #[inline]
        fn selector_at(i: usize) -> ::core::option::Option<[u8; 4]> {
            Self::SELECTORS.get(i).copied()
        }
        #[inline]
        fn valid_selector(selector: [u8; 4]) -> bool {
            Self::SELECTORS.binary_search(&selector).is_ok()
        }
        #[inline]
        #[allow(non_snake_case)]
        fn abi_decode_raw(
            selector: [u8; 4],
            data: &[u8],
            validate: bool,
        ) -> alloy_sol_types::Result<Self> {
            static DECODE_SHIMS: &[fn(
                &[u8],
                bool,
            ) -> alloy_sol_types::Result<SimpleCalls>] = &[
                {
                    fn pleaseRevert(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<SimpleCalls> {
                        <pleaseRevertCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(SimpleCalls::pleaseRevert)
                    }
                    pleaseRevert
                },
                {
                    fn incrementRedeem(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<SimpleCalls> {
                        <incrementRedeemCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(SimpleCalls::incrementRedeem)
                    }
                    incrementRedeem
                },
                {
                    fn getBlockDifficulty(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<SimpleCalls> {
                        <getBlockDifficultyCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(SimpleCalls::getBlockDifficulty)
                    }
                    getBlockDifficulty
                },
                {
                    fn difficulty(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<SimpleCalls> {
                        <difficultyCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(SimpleCalls::difficulty)
                    }
                    difficulty
                },
                {
                    fn checkGasUsed(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<SimpleCalls> {
                        <checkGasUsedCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(SimpleCalls::checkGasUsed)
                    }
                    checkGasUsed
                },
                {
                    fn checkCalls(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<SimpleCalls> {
                        <checkCallsCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(SimpleCalls::checkCalls)
                    }
                    checkCalls
                },
                {
                    fn checkBlockHashes(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<SimpleCalls> {
                        <checkBlockHashesCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(SimpleCalls::checkBlockHashes)
                    }
                    checkBlockHashes
                },
                {
                    fn noop(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<SimpleCalls> {
                        <noopCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(SimpleCalls::noop)
                    }
                    noop
                },
                {
                    fn counter(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<SimpleCalls> {
                        <counterCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(SimpleCalls::counter)
                    }
                    counter
                },
                {
                    fn logAndIncrement(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<SimpleCalls> {
                        <logAndIncrementCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(SimpleCalls::logAndIncrement)
                    }
                    logAndIncrement
                },
                {
                    fn incrementEmit(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<SimpleCalls> {
                        <incrementEmitCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(SimpleCalls::incrementEmit)
                    }
                    incrementEmit
                },
                {
                    fn postManyBatches(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<SimpleCalls> {
                        <postManyBatchesCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(SimpleCalls::postManyBatches)
                    }
                    postManyBatches
                },
                {
                    fn emitNullEvent(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<SimpleCalls> {
                        <emitNullEventCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(SimpleCalls::emitNullEvent)
                    }
                    emitNullEvent
                },
                {
                    fn storeDifficulty(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<SimpleCalls> {
                        <storeDifficultyCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(SimpleCalls::storeDifficulty)
                    }
                    storeDifficulty
                },
                {
                    fn increment(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<SimpleCalls> {
                        <incrementCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(SimpleCalls::increment)
                    }
                    increment
                },
                {
                    fn checkIsTopLevelOrWasAliased(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<SimpleCalls> {
                        <checkIsTopLevelOrWasAliasedCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(SimpleCalls::checkIsTopLevelOrWasAliased)
                    }
                    checkIsTopLevelOrWasAliased
                },
            ];
            let Ok(idx) = Self::SELECTORS.binary_search(&selector) else {
                return Err(
                    alloy_sol_types::Error::unknown_selector(
                        <Self as alloy_sol_types::SolInterface>::NAME,
                        selector,
                    ),
                );
            };
            DECODE_SHIMS[idx](data, validate)
        }
        #[inline]
        fn abi_encoded_size(&self) -> usize {
            match self {
                Self::checkBlockHashes(inner) => {
                    <checkBlockHashesCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::checkCalls(inner) => {
                    <checkCallsCall as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::checkGasUsed(inner) => {
                    <checkGasUsedCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::checkIsTopLevelOrWasAliased(inner) => {
                    <checkIsTopLevelOrWasAliasedCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::counter(inner) => {
                    <counterCall as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::difficulty(inner) => {
                    <difficultyCall as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::emitNullEvent(inner) => {
                    <emitNullEventCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::getBlockDifficulty(inner) => {
                    <getBlockDifficultyCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::increment(inner) => {
                    <incrementCall as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::incrementEmit(inner) => {
                    <incrementEmitCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::incrementRedeem(inner) => {
                    <incrementRedeemCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::logAndIncrement(inner) => {
                    <logAndIncrementCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::noop(inner) => {
                    <noopCall as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::pleaseRevert(inner) => {
                    <pleaseRevertCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::postManyBatches(inner) => {
                    <postManyBatchesCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::storeDifficulty(inner) => {
                    <storeDifficultyCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
            }
        }
        #[inline]
        fn abi_encode_raw(&self, out: &mut alloy_sol_types::private::Vec<u8>) {
            match self {
                Self::checkBlockHashes(inner) => {
                    <checkBlockHashesCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::checkCalls(inner) => {
                    <checkCallsCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::checkGasUsed(inner) => {
                    <checkGasUsedCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::checkIsTopLevelOrWasAliased(inner) => {
                    <checkIsTopLevelOrWasAliasedCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::counter(inner) => {
                    <counterCall as alloy_sol_types::SolCall>::abi_encode_raw(inner, out)
                }
                Self::difficulty(inner) => {
                    <difficultyCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::emitNullEvent(inner) => {
                    <emitNullEventCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::getBlockDifficulty(inner) => {
                    <getBlockDifficultyCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::increment(inner) => {
                    <incrementCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::incrementEmit(inner) => {
                    <incrementEmitCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::incrementRedeem(inner) => {
                    <incrementRedeemCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::logAndIncrement(inner) => {
                    <logAndIncrementCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::noop(inner) => {
                    <noopCall as alloy_sol_types::SolCall>::abi_encode_raw(inner, out)
                }
                Self::pleaseRevert(inner) => {
                    <pleaseRevertCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::postManyBatches(inner) => {
                    <postManyBatchesCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::storeDifficulty(inner) => {
                    <storeDifficultyCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
            }
        }
    }
    ///Container for all the [`Simple`](self) events.
    pub enum SimpleEvents {
        #[allow(missing_docs)]
        CounterEvent(CounterEvent),
        #[allow(missing_docs)]
        LogAndIncrementCalled(LogAndIncrementCalled),
        #[allow(missing_docs)]
        NullEvent(NullEvent),
        #[allow(missing_docs)]
        RedeemedEvent(RedeemedEvent),
    }
    #[automatically_derived]
    impl SimpleEvents {
        /// All the selectors of this enum.
        ///
        /// Note that the selectors might not be in the same order as the variants.
        /// No guarantees are made about the order of the selectors.
        ///
        /// Prefer using `SolInterface` methods instead.
        pub const SELECTORS: &'static [[u8; 32usize]] = &[
            [
                111u8,
                89u8,
                200u8,
                33u8,
                1u8,
                148u8,
                146u8,
                144u8,
                32u8,
                90u8,
                154u8,
                233u8,
                208u8,
                198u8,
                87u8,
                230u8,
                218u8,
                225u8,
                167u8,
                28u8,
                48u8,
                26u8,
                231u8,
                109u8,
                56u8,
                92u8,
                39u8,
                146u8,
                41u8,
                69u8,
                133u8,
                254u8,
            ],
            [
                119u8,
                60u8,
                120u8,
                191u8,
                150u8,
                230u8,
                95u8,
                97u8,
                193u8,
                162u8,
                98u8,
                43u8,
                71u8,
                215u8,
                110u8,
                120u8,
                191u8,
                231u8,
                13u8,
                213u8,
                156u8,
                244u8,
                241u8,
                20u8,
                112u8,
                196u8,
                193u8,
                33u8,
                195u8,
                21u8,
                148u8,
                19u8,
            ],
            [
                141u8,
                248u8,
                228u8,
                146u8,
                244u8,
                7u8,
                176u8,
                120u8,
                89u8,
                60u8,
                93u8,
                143u8,
                215u8,
                230u8,
                94u8,
                246u8,
                133u8,
                5u8,
                153u8,
                157u8,
                145u8,
                29u8,
                91u8,
                153u8,
                176u8,
                23u8,
                192u8,
                183u8,
                7u8,
                115u8,
                152u8,
                185u8,
            ],
            [
                164u8,
                93u8,
                126u8,
                121u8,
                203u8,
                60u8,
                96u8,
                68u8,
                243u8,
                12u8,
                141u8,
                216u8,
                145u8,
                230u8,
                87u8,
                19u8,
                1u8,
                214u8,
                184u8,
                182u8,
                97u8,
                141u8,
                245u8,
                25u8,
                201u8,
                135u8,
                144u8,
                94u8,
                199u8,
                7u8,
                66u8,
                231u8,
            ],
        ];
    }
    #[automatically_derived]
    impl alloy_sol_types::SolEventInterface for SimpleEvents {
        const NAME: &'static str = "SimpleEvents";
        const COUNT: usize = 4usize;
        fn decode_raw_log(
            topics: &[alloy_sol_types::Word],
            data: &[u8],
            validate: bool,
        ) -> alloy_sol_types::Result<Self> {
            match topics.first().copied() {
                Some(<CounterEvent as alloy_sol_types::SolEvent>::SIGNATURE_HASH) => {
                    <CounterEvent as alloy_sol_types::SolEvent>::decode_raw_log(
                            topics,
                            data,
                            validate,
                        )
                        .map(Self::CounterEvent)
                }
                Some(
                    <LogAndIncrementCalled as alloy_sol_types::SolEvent>::SIGNATURE_HASH,
                ) => {
                    <LogAndIncrementCalled as alloy_sol_types::SolEvent>::decode_raw_log(
                            topics,
                            data,
                            validate,
                        )
                        .map(Self::LogAndIncrementCalled)
                }
                Some(<NullEvent as alloy_sol_types::SolEvent>::SIGNATURE_HASH) => {
                    <NullEvent as alloy_sol_types::SolEvent>::decode_raw_log(
                            topics,
                            data,
                            validate,
                        )
                        .map(Self::NullEvent)
                }
                Some(<RedeemedEvent as alloy_sol_types::SolEvent>::SIGNATURE_HASH) => {
                    <RedeemedEvent as alloy_sol_types::SolEvent>::decode_raw_log(
                            topics,
                            data,
                            validate,
                        )
                        .map(Self::RedeemedEvent)
                }
                _ => {
                    alloy_sol_types::private::Err(alloy_sol_types::Error::InvalidLog {
                        name: <Self as alloy_sol_types::SolEventInterface>::NAME,
                        log: alloy_sol_types::private::Box::new(
                            alloy_sol_types::private::LogData::new_unchecked(
                                topics.to_vec(),
                                data.to_vec().into(),
                            ),
                        ),
                    })
                }
            }
        }
    }
    #[automatically_derived]
    impl alloy_sol_types::private::IntoLogData for SimpleEvents {
        fn to_log_data(&self) -> alloy_sol_types::private::LogData {
            match self {
                Self::CounterEvent(inner) => {
                    alloy_sol_types::private::IntoLogData::to_log_data(inner)
                }
                Self::LogAndIncrementCalled(inner) => {
                    alloy_sol_types::private::IntoLogData::to_log_data(inner)
                }
                Self::NullEvent(inner) => {
                    alloy_sol_types::private::IntoLogData::to_log_data(inner)
                }
                Self::RedeemedEvent(inner) => {
                    alloy_sol_types::private::IntoLogData::to_log_data(inner)
                }
            }
        }
        fn into_log_data(self) -> alloy_sol_types::private::LogData {
            match self {
                Self::CounterEvent(inner) => {
                    alloy_sol_types::private::IntoLogData::into_log_data(inner)
                }
                Self::LogAndIncrementCalled(inner) => {
                    alloy_sol_types::private::IntoLogData::into_log_data(inner)
                }
                Self::NullEvent(inner) => {
                    alloy_sol_types::private::IntoLogData::into_log_data(inner)
                }
                Self::RedeemedEvent(inner) => {
                    alloy_sol_types::private::IntoLogData::into_log_data(inner)
                }
            }
        }
    }
    use alloy::contract as alloy_contract;
    /**Creates a new wrapper around an on-chain [`Simple`](self) contract instance.

See the [wrapper's documentation](`SimpleInstance`) for more details.*/
    #[inline]
    pub const fn new<
        T: alloy_contract::private::Transport + ::core::clone::Clone,
        P: alloy_contract::private::Provider<T, N>,
        N: alloy_contract::private::Network,
    >(
        address: alloy_sol_types::private::Address,
        provider: P,
    ) -> SimpleInstance<T, P, N> {
        SimpleInstance::<T, P, N>::new(address, provider)
    }
    /**Deploys this contract using the given `provider` and constructor arguments, if any.

Returns a new instance of the contract, if the deployment was successful.

For more fine-grained control over the deployment process, use [`deploy_builder`] instead.*/
    #[inline]
    pub fn deploy<
        T: alloy_contract::private::Transport + ::core::clone::Clone,
        P: alloy_contract::private::Provider<T, N>,
        N: alloy_contract::private::Network,
    >(
        provider: P,
    ) -> impl ::core::future::Future<
        Output = alloy_contract::Result<SimpleInstance<T, P, N>>,
    > {
        SimpleInstance::<T, P, N>::deploy(provider)
    }
    /**Creates a `RawCallBuilder` for deploying this contract using the given `provider`
and constructor arguments, if any.

This is a simple wrapper around creating a `RawCallBuilder` with the data set to
the bytecode concatenated with the constructor's ABI-encoded arguments.*/
    #[inline]
    pub fn deploy_builder<
        T: alloy_contract::private::Transport + ::core::clone::Clone,
        P: alloy_contract::private::Provider<T, N>,
        N: alloy_contract::private::Network,
    >(provider: P) -> alloy_contract::RawCallBuilder<T, P, N> {
        SimpleInstance::<T, P, N>::deploy_builder(provider)
    }
    /**A [`Simple`](self) instance.

Contains type-safe methods for interacting with an on-chain instance of the
[`Simple`](self) contract located at a given `address`, using a given
provider `P`.

If the contract bytecode is available (see the [`sol!`](alloy_sol_types::sol!)
documentation on how to provide it), the `deploy` and `deploy_builder` methods can
be used to deploy a new instance of the contract.

See the [module-level documentation](self) for all the available methods.*/
    #[derive(Clone)]
    pub struct SimpleInstance<T, P, N = alloy_contract::private::Ethereum> {
        address: alloy_sol_types::private::Address,
        provider: P,
        _network_transport: ::core::marker::PhantomData<(N, T)>,
    }
    #[automatically_derived]
    impl<T, P, N> ::core::fmt::Debug for SimpleInstance<T, P, N> {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
            f.debug_tuple("SimpleInstance").field(&self.address).finish()
        }
    }
    /// Instantiation and getters/setters.
    #[automatically_derived]
    impl<
        T: alloy_contract::private::Transport + ::core::clone::Clone,
        P: alloy_contract::private::Provider<T, N>,
        N: alloy_contract::private::Network,
    > SimpleInstance<T, P, N> {
        /**Creates a new wrapper around an on-chain [`Simple`](self) contract instance.

See the [wrapper's documentation](`SimpleInstance`) for more details.*/
        #[inline]
        pub const fn new(
            address: alloy_sol_types::private::Address,
            provider: P,
        ) -> Self {
            Self {
                address,
                provider,
                _network_transport: ::core::marker::PhantomData,
            }
        }
        /**Deploys this contract using the given `provider` and constructor arguments, if any.

Returns a new instance of the contract, if the deployment was successful.

For more fine-grained control over the deployment process, use [`deploy_builder`] instead.*/
        #[inline]
        pub async fn deploy(
            provider: P,
        ) -> alloy_contract::Result<SimpleInstance<T, P, N>> {
            let call_builder = Self::deploy_builder(provider);
            let contract_address = call_builder.deploy().await?;
            Ok(Self::new(contract_address, call_builder.provider))
        }
        /**Creates a `RawCallBuilder` for deploying this contract using the given `provider`
and constructor arguments, if any.

This is a simple wrapper around creating a `RawCallBuilder` with the data set to
the bytecode concatenated with the constructor's ABI-encoded arguments.*/
        #[inline]
        pub fn deploy_builder(provider: P) -> alloy_contract::RawCallBuilder<T, P, N> {
            alloy_contract::RawCallBuilder::new_raw_deploy(
                provider,
                ::core::clone::Clone::clone(&BYTECODE),
            )
        }
        /// Returns a reference to the address.
        #[inline]
        pub const fn address(&self) -> &alloy_sol_types::private::Address {
            &self.address
        }
        /// Sets the address.
        #[inline]
        pub fn set_address(&mut self, address: alloy_sol_types::private::Address) {
            self.address = address;
        }
        /// Sets the address and returns `self`.
        pub fn at(mut self, address: alloy_sol_types::private::Address) -> Self {
            self.set_address(address);
            self
        }
        /// Returns a reference to the provider.
        #[inline]
        pub const fn provider(&self) -> &P {
            &self.provider
        }
    }
    impl<T, P: ::core::clone::Clone, N> SimpleInstance<T, &P, N> {
        /// Clones the provider and returns a new instance with the cloned provider.
        #[inline]
        pub fn with_cloned_provider(self) -> SimpleInstance<T, P, N> {
            SimpleInstance {
                address: self.address,
                provider: ::core::clone::Clone::clone(&self.provider),
                _network_transport: ::core::marker::PhantomData,
            }
        }
    }
    /// Function calls.
    #[automatically_derived]
    impl<
        T: alloy_contract::private::Transport + ::core::clone::Clone,
        P: alloy_contract::private::Provider<T, N>,
        N: alloy_contract::private::Network,
    > SimpleInstance<T, P, N> {
        /// Creates a new call builder using this contract instance's provider and address.
        ///
        /// Note that the call can be any function call, not just those defined in this
        /// contract. Prefer using the other methods for building type-safe contract calls.
        pub fn call_builder<C: alloy_sol_types::SolCall>(
            &self,
            call: &C,
        ) -> alloy_contract::SolCallBuilder<T, &P, C, N> {
            alloy_contract::SolCallBuilder::new_sol(&self.provider, &self.address, call)
        }
        ///Creates a new call builder for the [`checkBlockHashes`] function.
        pub fn checkBlockHashes(
            &self,
        ) -> alloy_contract::SolCallBuilder<T, &P, checkBlockHashesCall, N> {
            self.call_builder(&checkBlockHashesCall {})
        }
        ///Creates a new call builder for the [`checkCalls`] function.
        pub fn checkCalls(
            &self,
            useTopLevel: bool,
            directCase: bool,
            staticCase: bool,
            delegateCase: bool,
            callcodeCase: bool,
            callCase: bool,
        ) -> alloy_contract::SolCallBuilder<T, &P, checkCallsCall, N> {
            self.call_builder(
                &checkCallsCall {
                    useTopLevel,
                    directCase,
                    staticCase,
                    delegateCase,
                    callcodeCase,
                    callCase,
                },
            )
        }
        ///Creates a new call builder for the [`checkGasUsed`] function.
        pub fn checkGasUsed(
            &self,
            to: alloy::sol_types::private::Address,
            input: alloy::sol_types::private::Bytes,
        ) -> alloy_contract::SolCallBuilder<T, &P, checkGasUsedCall, N> {
            self.call_builder(&checkGasUsedCall { to, input })
        }
        ///Creates a new call builder for the [`checkIsTopLevelOrWasAliased`] function.
        pub fn checkIsTopLevelOrWasAliased(
            &self,
            useTopLevel: bool,
            expected: bool,
        ) -> alloy_contract::SolCallBuilder<T, &P, checkIsTopLevelOrWasAliasedCall, N> {
            self.call_builder(
                &checkIsTopLevelOrWasAliasedCall {
                    useTopLevel,
                    expected,
                },
            )
        }
        ///Creates a new call builder for the [`counter`] function.
        pub fn counter(&self) -> alloy_contract::SolCallBuilder<T, &P, counterCall, N> {
            self.call_builder(&counterCall {})
        }
        ///Creates a new call builder for the [`difficulty`] function.
        pub fn difficulty(
            &self,
        ) -> alloy_contract::SolCallBuilder<T, &P, difficultyCall, N> {
            self.call_builder(&difficultyCall {})
        }
        ///Creates a new call builder for the [`emitNullEvent`] function.
        pub fn emitNullEvent(
            &self,
        ) -> alloy_contract::SolCallBuilder<T, &P, emitNullEventCall, N> {
            self.call_builder(&emitNullEventCall {})
        }
        ///Creates a new call builder for the [`getBlockDifficulty`] function.
        pub fn getBlockDifficulty(
            &self,
        ) -> alloy_contract::SolCallBuilder<T, &P, getBlockDifficultyCall, N> {
            self.call_builder(&getBlockDifficultyCall {})
        }
        ///Creates a new call builder for the [`increment`] function.
        pub fn increment(
            &self,
        ) -> alloy_contract::SolCallBuilder<T, &P, incrementCall, N> {
            self.call_builder(&incrementCall {})
        }
        ///Creates a new call builder for the [`incrementEmit`] function.
        pub fn incrementEmit(
            &self,
        ) -> alloy_contract::SolCallBuilder<T, &P, incrementEmitCall, N> {
            self.call_builder(&incrementEmitCall {})
        }
        ///Creates a new call builder for the [`incrementRedeem`] function.
        pub fn incrementRedeem(
            &self,
        ) -> alloy_contract::SolCallBuilder<T, &P, incrementRedeemCall, N> {
            self.call_builder(&incrementRedeemCall {})
        }
        ///Creates a new call builder for the [`logAndIncrement`] function.
        pub fn logAndIncrement(
            &self,
            expected: alloy::sol_types::private::primitives::aliases::U256,
        ) -> alloy_contract::SolCallBuilder<T, &P, logAndIncrementCall, N> {
            self.call_builder(&logAndIncrementCall { expected })
        }
        ///Creates a new call builder for the [`noop`] function.
        pub fn noop(&self) -> alloy_contract::SolCallBuilder<T, &P, noopCall, N> {
            self.call_builder(&noopCall {})
        }
        ///Creates a new call builder for the [`pleaseRevert`] function.
        pub fn pleaseRevert(
            &self,
        ) -> alloy_contract::SolCallBuilder<T, &P, pleaseRevertCall, N> {
            self.call_builder(&pleaseRevertCall {})
        }
        ///Creates a new call builder for the [`postManyBatches`] function.
        pub fn postManyBatches(
            &self,
            sequencerInbox: alloy::sol_types::private::Address,
            batchData: alloy::sol_types::private::Bytes,
            numberToPost: alloy::sol_types::private::primitives::aliases::U256,
        ) -> alloy_contract::SolCallBuilder<T, &P, postManyBatchesCall, N> {
            self.call_builder(
                &postManyBatchesCall {
                    sequencerInbox,
                    batchData,
                    numberToPost,
                },
            )
        }
        ///Creates a new call builder for the [`storeDifficulty`] function.
        pub fn storeDifficulty(
            &self,
        ) -> alloy_contract::SolCallBuilder<T, &P, storeDifficultyCall, N> {
            self.call_builder(&storeDifficultyCall {})
        }
    }
    /// Event filters.
    #[automatically_derived]
    impl<
        T: alloy_contract::private::Transport + ::core::clone::Clone,
        P: alloy_contract::private::Provider<T, N>,
        N: alloy_contract::private::Network,
    > SimpleInstance<T, P, N> {
        /// Creates a new event filter using this contract instance's provider and address.
        ///
        /// Note that the type can be any event, not just those defined in this contract.
        /// Prefer using the other methods for building type-safe event filters.
        pub fn event_filter<E: alloy_sol_types::SolEvent>(
            &self,
        ) -> alloy_contract::Event<T, &P, E, N> {
            alloy_contract::Event::new_sol(&self.provider, &self.address)
        }
        ///Creates a new event filter for the [`CounterEvent`] event.
        pub fn CounterEvent_filter(
            &self,
        ) -> alloy_contract::Event<T, &P, CounterEvent, N> {
            self.event_filter::<CounterEvent>()
        }
        ///Creates a new event filter for the [`LogAndIncrementCalled`] event.
        pub fn LogAndIncrementCalled_filter(
            &self,
        ) -> alloy_contract::Event<T, &P, LogAndIncrementCalled, N> {
            self.event_filter::<LogAndIncrementCalled>()
        }
        ///Creates a new event filter for the [`NullEvent`] event.
        pub fn NullEvent_filter(&self) -> alloy_contract::Event<T, &P, NullEvent, N> {
            self.event_filter::<NullEvent>()
        }
        ///Creates a new event filter for the [`RedeemedEvent`] event.
        pub fn RedeemedEvent_filter(
            &self,
        ) -> alloy_contract::Event<T, &P, RedeemedEvent, N> {
            self.event_filter::<RedeemedEvent>()
        }
    }
}
