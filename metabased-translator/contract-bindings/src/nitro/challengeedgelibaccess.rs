/**

Generated by the following Solidity interface...
```solidity
interface ChallengeEdgeLibAccess {
    type EdgeStatus is uint8;
    type EdgeType is uint8;
    struct ChallengeEdge {
        bytes32 originId;
        bytes32 startHistoryRoot;
        uint256 startHeight;
        bytes32 endHistoryRoot;
        uint256 endHeight;
        bytes32 lowerChildId;
        bytes32 upperChildId;
        bytes32 claimId;
        address staker;
        uint64 createdAtBlock;
        uint64 confirmedAtBlock;
        EdgeStatus status;
        uint8 level;
        bool refunded;
        uint64 totalTimeUnrivaledCache;
    }

    error ChildrenAlreadySet(bytes32 edgeId, bytes32 lowerChildId, bytes32 upperChildId);
    error EdgeAlreadyRefunded(bytes32 edgeId);
    error EdgeNotConfirmed(bytes32 edgeId, EdgeStatus);
    error EdgeNotExists(bytes32 edgeId);
    error EdgeNotLayerZero(bytes32 edgeId, address staker, bytes32 claimId);
    error EdgeNotPending(bytes32 edgeId, EdgeStatus status);
    error EmptyClaimId();
    error EmptyEndRoot();
    error EmptyOriginId();
    error EmptyStaker();
    error EmptyStartRoot();
    error InvalidHeights(uint256 start, uint256 end);
    error LevelTooHigh(uint8 level, uint8 numBigStepLevels);

    function deleteChallengeEdge() external;
    function exists() external view returns (bool);
    function getChallengeEdge() external view returns (ChallengeEdge memory);
    function id() external view returns (bytes32);
    function idComponent(uint8 level, bytes32 originId, uint256 startHeight, bytes32 startHistoryRoot, uint256 endHeight, bytes32 endHistoryRoot) external pure returns (bytes32);
    function idMem(ChallengeEdge memory edge) external pure returns (bytes32);
    function isLayerZero() external view returns (bool);
    function length() external view returns (uint256);
    function levelToType(uint8 level, uint8 numBigStepLevels) external pure returns (EdgeType eType);
    function mutualId() external view returns (bytes32);
    function mutualIdComponent(uint8 level, bytes32 originId, uint256 startHeight, bytes32 startHistoryRoot, uint256 endHeight) external pure returns (bytes32);
    function mutualIdMem(ChallengeEdge memory ce) external pure returns (bytes32);
    function newChildEdge(bytes32 originId, bytes32 startHistoryRoot, uint256 startHeight, bytes32 endHistoryRoot, uint256 endHeight, uint8 level) external view returns (ChallengeEdge memory);
    function newEdgeChecks(bytes32 originId, bytes32 startHistoryRoot, uint256 startHeight, bytes32 endHistoryRoot, uint256 endHeight) external pure;
    function newLayerZeroEdge(bytes32 originId, bytes32 startHistoryRoot, uint256 startHeight, bytes32 endHistoryRoot, uint256 endHeight, bytes32 claimId, address staker, uint8 level) external view returns (ChallengeEdge memory);
    function setChallengeEdge(ChallengeEdge memory edge) external;
    function setChildren(bytes32 lowerChildId, bytes32 upperChildId) external;
    function setConfirmed() external;
    function setRefunded() external;
}
```

...which was generated by the following JSON ABI:
```json
[
  {
    "type": "function",
    "name": "deleteChallengeEdge",
    "inputs": [],
    "outputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "exists",
    "inputs": [],
    "outputs": [
      {
        "name": "",
        "type": "bool",
        "internalType": "bool"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "getChallengeEdge",
    "inputs": [],
    "outputs": [
      {
        "name": "",
        "type": "tuple",
        "internalType": "struct ChallengeEdge",
        "components": [
          {
            "name": "originId",
            "type": "bytes32",
            "internalType": "bytes32"
          },
          {
            "name": "startHistoryRoot",
            "type": "bytes32",
            "internalType": "bytes32"
          },
          {
            "name": "startHeight",
            "type": "uint256",
            "internalType": "uint256"
          },
          {
            "name": "endHistoryRoot",
            "type": "bytes32",
            "internalType": "bytes32"
          },
          {
            "name": "endHeight",
            "type": "uint256",
            "internalType": "uint256"
          },
          {
            "name": "lowerChildId",
            "type": "bytes32",
            "internalType": "bytes32"
          },
          {
            "name": "upperChildId",
            "type": "bytes32",
            "internalType": "bytes32"
          },
          {
            "name": "claimId",
            "type": "bytes32",
            "internalType": "bytes32"
          },
          {
            "name": "staker",
            "type": "address",
            "internalType": "address"
          },
          {
            "name": "createdAtBlock",
            "type": "uint64",
            "internalType": "uint64"
          },
          {
            "name": "confirmedAtBlock",
            "type": "uint64",
            "internalType": "uint64"
          },
          {
            "name": "status",
            "type": "uint8",
            "internalType": "enum EdgeStatus"
          },
          {
            "name": "level",
            "type": "uint8",
            "internalType": "uint8"
          },
          {
            "name": "refunded",
            "type": "bool",
            "internalType": "bool"
          },
          {
            "name": "totalTimeUnrivaledCache",
            "type": "uint64",
            "internalType": "uint64"
          }
        ]
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "id",
    "inputs": [],
    "outputs": [
      {
        "name": "",
        "type": "bytes32",
        "internalType": "bytes32"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "idComponent",
    "inputs": [
      {
        "name": "level",
        "type": "uint8",
        "internalType": "uint8"
      },
      {
        "name": "originId",
        "type": "bytes32",
        "internalType": "bytes32"
      },
      {
        "name": "startHeight",
        "type": "uint256",
        "internalType": "uint256"
      },
      {
        "name": "startHistoryRoot",
        "type": "bytes32",
        "internalType": "bytes32"
      },
      {
        "name": "endHeight",
        "type": "uint256",
        "internalType": "uint256"
      },
      {
        "name": "endHistoryRoot",
        "type": "bytes32",
        "internalType": "bytes32"
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "bytes32",
        "internalType": "bytes32"
      }
    ],
    "stateMutability": "pure"
  },
  {
    "type": "function",
    "name": "idMem",
    "inputs": [
      {
        "name": "edge",
        "type": "tuple",
        "internalType": "struct ChallengeEdge",
        "components": [
          {
            "name": "originId",
            "type": "bytes32",
            "internalType": "bytes32"
          },
          {
            "name": "startHistoryRoot",
            "type": "bytes32",
            "internalType": "bytes32"
          },
          {
            "name": "startHeight",
            "type": "uint256",
            "internalType": "uint256"
          },
          {
            "name": "endHistoryRoot",
            "type": "bytes32",
            "internalType": "bytes32"
          },
          {
            "name": "endHeight",
            "type": "uint256",
            "internalType": "uint256"
          },
          {
            "name": "lowerChildId",
            "type": "bytes32",
            "internalType": "bytes32"
          },
          {
            "name": "upperChildId",
            "type": "bytes32",
            "internalType": "bytes32"
          },
          {
            "name": "claimId",
            "type": "bytes32",
            "internalType": "bytes32"
          },
          {
            "name": "staker",
            "type": "address",
            "internalType": "address"
          },
          {
            "name": "createdAtBlock",
            "type": "uint64",
            "internalType": "uint64"
          },
          {
            "name": "confirmedAtBlock",
            "type": "uint64",
            "internalType": "uint64"
          },
          {
            "name": "status",
            "type": "uint8",
            "internalType": "enum EdgeStatus"
          },
          {
            "name": "level",
            "type": "uint8",
            "internalType": "uint8"
          },
          {
            "name": "refunded",
            "type": "bool",
            "internalType": "bool"
          },
          {
            "name": "totalTimeUnrivaledCache",
            "type": "uint64",
            "internalType": "uint64"
          }
        ]
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "bytes32",
        "internalType": "bytes32"
      }
    ],
    "stateMutability": "pure"
  },
  {
    "type": "function",
    "name": "isLayerZero",
    "inputs": [],
    "outputs": [
      {
        "name": "",
        "type": "bool",
        "internalType": "bool"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "length",
    "inputs": [],
    "outputs": [
      {
        "name": "",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "levelToType",
    "inputs": [
      {
        "name": "level",
        "type": "uint8",
        "internalType": "uint8"
      },
      {
        "name": "numBigStepLevels",
        "type": "uint8",
        "internalType": "uint8"
      }
    ],
    "outputs": [
      {
        "name": "eType",
        "type": "uint8",
        "internalType": "enum EdgeType"
      }
    ],
    "stateMutability": "pure"
  },
  {
    "type": "function",
    "name": "mutualId",
    "inputs": [],
    "outputs": [
      {
        "name": "",
        "type": "bytes32",
        "internalType": "bytes32"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "mutualIdComponent",
    "inputs": [
      {
        "name": "level",
        "type": "uint8",
        "internalType": "uint8"
      },
      {
        "name": "originId",
        "type": "bytes32",
        "internalType": "bytes32"
      },
      {
        "name": "startHeight",
        "type": "uint256",
        "internalType": "uint256"
      },
      {
        "name": "startHistoryRoot",
        "type": "bytes32",
        "internalType": "bytes32"
      },
      {
        "name": "endHeight",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "bytes32",
        "internalType": "bytes32"
      }
    ],
    "stateMutability": "pure"
  },
  {
    "type": "function",
    "name": "mutualIdMem",
    "inputs": [
      {
        "name": "ce",
        "type": "tuple",
        "internalType": "struct ChallengeEdge",
        "components": [
          {
            "name": "originId",
            "type": "bytes32",
            "internalType": "bytes32"
          },
          {
            "name": "startHistoryRoot",
            "type": "bytes32",
            "internalType": "bytes32"
          },
          {
            "name": "startHeight",
            "type": "uint256",
            "internalType": "uint256"
          },
          {
            "name": "endHistoryRoot",
            "type": "bytes32",
            "internalType": "bytes32"
          },
          {
            "name": "endHeight",
            "type": "uint256",
            "internalType": "uint256"
          },
          {
            "name": "lowerChildId",
            "type": "bytes32",
            "internalType": "bytes32"
          },
          {
            "name": "upperChildId",
            "type": "bytes32",
            "internalType": "bytes32"
          },
          {
            "name": "claimId",
            "type": "bytes32",
            "internalType": "bytes32"
          },
          {
            "name": "staker",
            "type": "address",
            "internalType": "address"
          },
          {
            "name": "createdAtBlock",
            "type": "uint64",
            "internalType": "uint64"
          },
          {
            "name": "confirmedAtBlock",
            "type": "uint64",
            "internalType": "uint64"
          },
          {
            "name": "status",
            "type": "uint8",
            "internalType": "enum EdgeStatus"
          },
          {
            "name": "level",
            "type": "uint8",
            "internalType": "uint8"
          },
          {
            "name": "refunded",
            "type": "bool",
            "internalType": "bool"
          },
          {
            "name": "totalTimeUnrivaledCache",
            "type": "uint64",
            "internalType": "uint64"
          }
        ]
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "bytes32",
        "internalType": "bytes32"
      }
    ],
    "stateMutability": "pure"
  },
  {
    "type": "function",
    "name": "newChildEdge",
    "inputs": [
      {
        "name": "originId",
        "type": "bytes32",
        "internalType": "bytes32"
      },
      {
        "name": "startHistoryRoot",
        "type": "bytes32",
        "internalType": "bytes32"
      },
      {
        "name": "startHeight",
        "type": "uint256",
        "internalType": "uint256"
      },
      {
        "name": "endHistoryRoot",
        "type": "bytes32",
        "internalType": "bytes32"
      },
      {
        "name": "endHeight",
        "type": "uint256",
        "internalType": "uint256"
      },
      {
        "name": "level",
        "type": "uint8",
        "internalType": "uint8"
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "tuple",
        "internalType": "struct ChallengeEdge",
        "components": [
          {
            "name": "originId",
            "type": "bytes32",
            "internalType": "bytes32"
          },
          {
            "name": "startHistoryRoot",
            "type": "bytes32",
            "internalType": "bytes32"
          },
          {
            "name": "startHeight",
            "type": "uint256",
            "internalType": "uint256"
          },
          {
            "name": "endHistoryRoot",
            "type": "bytes32",
            "internalType": "bytes32"
          },
          {
            "name": "endHeight",
            "type": "uint256",
            "internalType": "uint256"
          },
          {
            "name": "lowerChildId",
            "type": "bytes32",
            "internalType": "bytes32"
          },
          {
            "name": "upperChildId",
            "type": "bytes32",
            "internalType": "bytes32"
          },
          {
            "name": "claimId",
            "type": "bytes32",
            "internalType": "bytes32"
          },
          {
            "name": "staker",
            "type": "address",
            "internalType": "address"
          },
          {
            "name": "createdAtBlock",
            "type": "uint64",
            "internalType": "uint64"
          },
          {
            "name": "confirmedAtBlock",
            "type": "uint64",
            "internalType": "uint64"
          },
          {
            "name": "status",
            "type": "uint8",
            "internalType": "enum EdgeStatus"
          },
          {
            "name": "level",
            "type": "uint8",
            "internalType": "uint8"
          },
          {
            "name": "refunded",
            "type": "bool",
            "internalType": "bool"
          },
          {
            "name": "totalTimeUnrivaledCache",
            "type": "uint64",
            "internalType": "uint64"
          }
        ]
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "newEdgeChecks",
    "inputs": [
      {
        "name": "originId",
        "type": "bytes32",
        "internalType": "bytes32"
      },
      {
        "name": "startHistoryRoot",
        "type": "bytes32",
        "internalType": "bytes32"
      },
      {
        "name": "startHeight",
        "type": "uint256",
        "internalType": "uint256"
      },
      {
        "name": "endHistoryRoot",
        "type": "bytes32",
        "internalType": "bytes32"
      },
      {
        "name": "endHeight",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "outputs": [],
    "stateMutability": "pure"
  },
  {
    "type": "function",
    "name": "newLayerZeroEdge",
    "inputs": [
      {
        "name": "originId",
        "type": "bytes32",
        "internalType": "bytes32"
      },
      {
        "name": "startHistoryRoot",
        "type": "bytes32",
        "internalType": "bytes32"
      },
      {
        "name": "startHeight",
        "type": "uint256",
        "internalType": "uint256"
      },
      {
        "name": "endHistoryRoot",
        "type": "bytes32",
        "internalType": "bytes32"
      },
      {
        "name": "endHeight",
        "type": "uint256",
        "internalType": "uint256"
      },
      {
        "name": "claimId",
        "type": "bytes32",
        "internalType": "bytes32"
      },
      {
        "name": "staker",
        "type": "address",
        "internalType": "address"
      },
      {
        "name": "level",
        "type": "uint8",
        "internalType": "uint8"
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "tuple",
        "internalType": "struct ChallengeEdge",
        "components": [
          {
            "name": "originId",
            "type": "bytes32",
            "internalType": "bytes32"
          },
          {
            "name": "startHistoryRoot",
            "type": "bytes32",
            "internalType": "bytes32"
          },
          {
            "name": "startHeight",
            "type": "uint256",
            "internalType": "uint256"
          },
          {
            "name": "endHistoryRoot",
            "type": "bytes32",
            "internalType": "bytes32"
          },
          {
            "name": "endHeight",
            "type": "uint256",
            "internalType": "uint256"
          },
          {
            "name": "lowerChildId",
            "type": "bytes32",
            "internalType": "bytes32"
          },
          {
            "name": "upperChildId",
            "type": "bytes32",
            "internalType": "bytes32"
          },
          {
            "name": "claimId",
            "type": "bytes32",
            "internalType": "bytes32"
          },
          {
            "name": "staker",
            "type": "address",
            "internalType": "address"
          },
          {
            "name": "createdAtBlock",
            "type": "uint64",
            "internalType": "uint64"
          },
          {
            "name": "confirmedAtBlock",
            "type": "uint64",
            "internalType": "uint64"
          },
          {
            "name": "status",
            "type": "uint8",
            "internalType": "enum EdgeStatus"
          },
          {
            "name": "level",
            "type": "uint8",
            "internalType": "uint8"
          },
          {
            "name": "refunded",
            "type": "bool",
            "internalType": "bool"
          },
          {
            "name": "totalTimeUnrivaledCache",
            "type": "uint64",
            "internalType": "uint64"
          }
        ]
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "setChallengeEdge",
    "inputs": [
      {
        "name": "edge",
        "type": "tuple",
        "internalType": "struct ChallengeEdge",
        "components": [
          {
            "name": "originId",
            "type": "bytes32",
            "internalType": "bytes32"
          },
          {
            "name": "startHistoryRoot",
            "type": "bytes32",
            "internalType": "bytes32"
          },
          {
            "name": "startHeight",
            "type": "uint256",
            "internalType": "uint256"
          },
          {
            "name": "endHistoryRoot",
            "type": "bytes32",
            "internalType": "bytes32"
          },
          {
            "name": "endHeight",
            "type": "uint256",
            "internalType": "uint256"
          },
          {
            "name": "lowerChildId",
            "type": "bytes32",
            "internalType": "bytes32"
          },
          {
            "name": "upperChildId",
            "type": "bytes32",
            "internalType": "bytes32"
          },
          {
            "name": "claimId",
            "type": "bytes32",
            "internalType": "bytes32"
          },
          {
            "name": "staker",
            "type": "address",
            "internalType": "address"
          },
          {
            "name": "createdAtBlock",
            "type": "uint64",
            "internalType": "uint64"
          },
          {
            "name": "confirmedAtBlock",
            "type": "uint64",
            "internalType": "uint64"
          },
          {
            "name": "status",
            "type": "uint8",
            "internalType": "enum EdgeStatus"
          },
          {
            "name": "level",
            "type": "uint8",
            "internalType": "uint8"
          },
          {
            "name": "refunded",
            "type": "bool",
            "internalType": "bool"
          },
          {
            "name": "totalTimeUnrivaledCache",
            "type": "uint64",
            "internalType": "uint64"
          }
        ]
      }
    ],
    "outputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "setChildren",
    "inputs": [
      {
        "name": "lowerChildId",
        "type": "bytes32",
        "internalType": "bytes32"
      },
      {
        "name": "upperChildId",
        "type": "bytes32",
        "internalType": "bytes32"
      }
    ],
    "outputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "setConfirmed",
    "inputs": [],
    "outputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "setRefunded",
    "inputs": [],
    "outputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "error",
    "name": "ChildrenAlreadySet",
    "inputs": [
      {
        "name": "edgeId",
        "type": "bytes32",
        "internalType": "bytes32"
      },
      {
        "name": "lowerChildId",
        "type": "bytes32",
        "internalType": "bytes32"
      },
      {
        "name": "upperChildId",
        "type": "bytes32",
        "internalType": "bytes32"
      }
    ]
  },
  {
    "type": "error",
    "name": "EdgeAlreadyRefunded",
    "inputs": [
      {
        "name": "edgeId",
        "type": "bytes32",
        "internalType": "bytes32"
      }
    ]
  },
  {
    "type": "error",
    "name": "EdgeNotConfirmed",
    "inputs": [
      {
        "name": "edgeId",
        "type": "bytes32",
        "internalType": "bytes32"
      },
      {
        "name": "",
        "type": "uint8",
        "internalType": "enum EdgeStatus"
      }
    ]
  },
  {
    "type": "error",
    "name": "EdgeNotExists",
    "inputs": [
      {
        "name": "edgeId",
        "type": "bytes32",
        "internalType": "bytes32"
      }
    ]
  },
  {
    "type": "error",
    "name": "EdgeNotLayerZero",
    "inputs": [
      {
        "name": "edgeId",
        "type": "bytes32",
        "internalType": "bytes32"
      },
      {
        "name": "staker",
        "type": "address",
        "internalType": "address"
      },
      {
        "name": "claimId",
        "type": "bytes32",
        "internalType": "bytes32"
      }
    ]
  },
  {
    "type": "error",
    "name": "EdgeNotPending",
    "inputs": [
      {
        "name": "edgeId",
        "type": "bytes32",
        "internalType": "bytes32"
      },
      {
        "name": "status",
        "type": "uint8",
        "internalType": "enum EdgeStatus"
      }
    ]
  },
  {
    "type": "error",
    "name": "EmptyClaimId",
    "inputs": []
  },
  {
    "type": "error",
    "name": "EmptyEndRoot",
    "inputs": []
  },
  {
    "type": "error",
    "name": "EmptyOriginId",
    "inputs": []
  },
  {
    "type": "error",
    "name": "EmptyStaker",
    "inputs": []
  },
  {
    "type": "error",
    "name": "EmptyStartRoot",
    "inputs": []
  },
  {
    "type": "error",
    "name": "InvalidHeights",
    "inputs": [
      {
        "name": "start",
        "type": "uint256",
        "internalType": "uint256"
      },
      {
        "name": "end",
        "type": "uint256",
        "internalType": "uint256"
      }
    ]
  },
  {
    "type": "error",
    "name": "LevelTooHigh",
    "inputs": [
      {
        "name": "level",
        "type": "uint8",
        "internalType": "uint8"
      },
      {
        "name": "numBigStepLevels",
        "type": "uint8",
        "internalType": "uint8"
      }
    ]
  }
]
```*/
#[allow(
    non_camel_case_types,
    non_snake_case,
    clippy::pub_underscore_fields,
    clippy::style,
    clippy::empty_structs_with_brackets
)]
pub mod ChallengeEdgeLibAccess {
    use super::*;
    use alloy::sol_types as alloy_sol_types;
    /// The creation / init bytecode of the contract.
    ///
    /// ```text
    ///0x6080604052348015600e575f5ffd5b506117078061001c5f395ff3fe608060405234801561000f575f5ffd5b5060043610610149575f3560e01c8063786ac408116100c7578063a7d002491161007d578063af77dddc11610063578063af77dddc14610304578063b845b4991461037e578063e35b755c14610386575f5ffd5b8063a7d00249146102dc578063af640d0f146102fc575f5ffd5b80638bc53485116100ad5780638bc53485146102ae5780638cb30f2d146102c15780639689d175146102d4575f5ffd5b8063786ac40814610286578063878b5f1c146102a6575f5ffd5b8063267c4ae41161011c57806343e06f291161010257806343e06f291461024d5780635b6d1377146102605780636af3eca814610273575f5ffd5b8063267c4ae41461020d57806341b98aa114610245575f5ffd5b8063012e9a6f1461014d57806307eae6d7146101735780631f7b6d32146101f057806320cb1457146101f8575b5f5ffd5b61016061015b36600461126b565b61038e565b6040519081526020015b60405180910390f35b61016061018136600461135c565b6040805160f89690961b7fff00000000000000000000000000000000000000000000000000000000000000166020808801919091526021870195909552604186019390935260618501919091526081808501919091528151808503909101815260a19093019052815191012090565b61016061041a565b61020b61020636600461139a565b610429565b005b60085474010000000000000000000000000000000000000000900467ffffffffffffffff1615155b604051901515815260200161016a565b61020b61043d565b61020b61025b36600461126b565b610448565b61020b61026e3660046113d1565b61062b565b6101606102813660046113f1565b61063a565b610299610294366004611437565b6106d4565b60405161016a91906114c7565b6102356106f9565b6101606102bc36600461126b565b610703565b6102996102cf3660046115e5565b61070d565b610299610723565b6102ef6102ea366004611632565b610861565b60405161016a9190611663565b610160610873565b61020b5f808055600181905560028190556003819055600481905560058190556006819055600755600880547fffffffff00000000000000000000000000000000000000000000000000000000169055600980547fffffffffffffffffffffffffff00000000000000000000000000000000000000169055565b61016061087d565b61020b610887565b5f6104148261018081015181516040808401516020808601516080870151845160f89790971b7fff0000000000000000000000000000000000000000000000000000000000000016878401526021870195909552604186019290925260618501919091526081808501939093528151808503909301835260a1909301905280519101205f905b92915050565b5f6104245f610890565b905090565b61043685858585856108f5565b5050505050565b6104465f6109e6565b565b80515f9081556020820151600190815560408301516002556060830151600355608083015160045560a083015160055560c083015160065560e08301516007556101008301516008805461012086015167ffffffffffffffff90811674010000000000000000000000000000000000000000027fffffffff0000000000000000000000000000000000000000000000000000000090921673ffffffffffffffffffffffffffffffffffffffff9094169390931717905561014084015160098054919092167fffffffffffffffffffffffffffffffffffffffffffffffff000000000000000082168117835561016086015186959490939268ffffffffffffffffff1916909117906801000000000000000090849081111561056b5761056b61149f565b0217905550610180820151600990910180546101a08401516101c09094015167ffffffffffffffff166b010000000000000000000000027fffffffffffffffffffffffffff0000000000000000ffffffffffffffffffffff9415156a0100000000000000000000026aff000000000000000000001960ff909516690100000000000000000002949094167fffffffffffffffffffffffffffffffffffffffffff0000ffffffffffffffffff90921691909117929092179290921617905550565b6106365f8383610a90565b5050565b6040805160f888901b7fff000000000000000000000000000000000000000000000000000000000000001660208083019190915260218201889052604182018790526061820186905260818083018690528351808403909101815260a18301845280519082012060c183015260e18083018590528351808403909101815261010190920190925280519101205f905b979650505050505050565b6106dc611125565b6106ec8989898989898989610b10565b9998505050505050505050565b5f6104245f610c61565b5f61041482610c91565b610715611125565b6106c9878787878787610d40565b61072b611125565b604080516101e0810182525f80548252600180546020840152600254938301939093526003546060830152600454608083015260055460a083015260065460c083015260075460e083015260085473ffffffffffffffffffffffffffffffffffffffff811661010084015274010000000000000000000000000000000000000000900467ffffffffffffffff908116610120840152600954908116610140840152919290916101608401916801000000000000000090910460ff16908111156107f6576107f661149f565b60018111156108075761080761149f565b81526009919091015460ff69010000000000000000008204811660208401526a01000000000000000000008204161515604083015267ffffffffffffffff6b01000000000000000000000090910416606090910152919050565b5f61086c8383610dd8565b9392505050565b5f6104245f610e5d565b5f6104245f610f1b565b6104465f610faf565b5f5f826002015483600401546108a69190611691565b9050805f03610414576108b883610e5d565b6040517ea7b02b0000000000000000000000000000000000000000000000000000000081526004016108ec91815260200190565b60405180910390fd5b5f85900361092f576040517f8d79dbbc00000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b828111610972576040517f2060faf400000000000000000000000000000000000000000000000000000000815260048101849052602481018290526044016108ec565b5f8490036109ac576040517f83c683e400000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b5f829003610436576040517f5cb6e5bb00000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b5f600982015468010000000000000000900460ff166001811115610a0c57610a0c61149f565b14610a6257610a1a81610e5d565b60098201546040517f23f8405d0000000000000000000000000000000000000000000000000000000081526108ec929168010000000000000000900460ff16906004016116a4565b600901805467ffffffffffffffff431668ffffffffffffffffff199091161768010000000000000000179055565b6005830154151580610aa55750600683015415155b15610b0057610ab383610e5d565b600584015460068501546040517f8b0e71d00000000000000000000000000000000000000000000000000000000081526004810193909352602483019190915260448201526064016108ec565b6005830191909155600690910155565b610b18611125565b73ffffffffffffffffffffffffffffffffffffffff8316610b65576040517ff289e65700000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b5f849003610b9f576040517f6932bcfd00000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b610bac89898989896108f5565b604051806101e001604052808a81526020018981526020018881526020018781526020018681526020015f5f1b81526020015f5f1b81526020018581526020018473ffffffffffffffffffffffffffffffffffffffff1681526020014367ffffffffffffffff1681526020015f67ffffffffffffffff1681526020015f6001811115610c3a57610c3a61149f565b815260ff841660208201525f60408201819052606090910152905098975050505050505050565b60078101545f90158015906104145750506008015473ffffffffffffffffffffffffffffffffffffffff16151590565b610180810151815160408084015160208086015160808701516060880151855160f89890981b7fff0000000000000000000000000000000000000000000000000000000000000016888501526021880196909652604187019390935260618601526081808601929092528251808603909201825260a18501835281519181019190912060c185015260e18085019390935281518085039093018352610101909301905280519101205f90610414565b610d48611125565b610d5587878787876108f5565b50604080516101e081018252968752602087019590955293850192909252606084015260808301525f60a0830181905260c0830181905260e08301819052610100830181905267ffffffffffffffff43166101208401526101408301819052610160830181905260ff9091166101808301526101a082018190526101c082015290565b5f8260ff165f03610dea57505f610414565b8160ff168360ff1611610dff57506001610414565b610e0a8260016116b8565b60ff168360ff1603610e1e57506002610414565b6040517fae0da57800000000000000000000000000000000000000000000000000000000815260ff8085166004830152831660248201526044016108ec565b60098101548154600283015460018401546004850154600386015460408051690100000000000000000090970460f81b7fff00000000000000000000000000000000000000000000000000000000000000166020808901919091526021880196909652604187019490945260618601929092526081808601919091528251808603909101815260a18501835280519084012060c185015260e18085019190915281518085039091018152610101909301905281519101205f90610414565b6009810154815460028301546001840154600485015460408051690100000000000000000090960460f81b7fff00000000000000000000000000000000000000000000000000000000000000166020808801919091526021870195909552604186019390935260618501919091526081808501919091528151808503909101815260a1909301905281519101205f90610414565b6001600982015468010000000000000000900460ff166001811115610fd657610fd661149f565b1461102c57610fe481610e5d565b60098201546040517fef1267b40000000000000000000000000000000000000000000000000000000081526108ec929168010000000000000000900460ff16906004016116a4565b61103581610c61565b6110a45761104281610e5d565b600882015460078301546040517fe58c8308000000000000000000000000000000000000000000000000000000008152600481019390935273ffffffffffffffffffffffffffffffffffffffff909116602483015260448201526064016108ec565b60098101546a0100000000000000000000900460ff161515600103611101576110cc81610e5d565b6040517f307f76690000000000000000000000000000000000000000000000000000000081526004016108ec91815260200190565b60090180546aff0000000000000000000019166a0100000000000000000000179055565b604051806101e001604052805f81526020015f81526020015f81526020015f81526020015f81526020015f81526020015f81526020015f81526020015f73ffffffffffffffffffffffffffffffffffffffff1681526020015f67ffffffffffffffff1681526020015f67ffffffffffffffff1681526020015f60018111156111af576111af61149f565b81525f602082018190526040820181905260609091015290565b6040516101e0810167ffffffffffffffff811182821017156111f957634e487b7160e01b5f52604160045260245ffd5b60405290565b803573ffffffffffffffffffffffffffffffffffffffff81168114611222575f5ffd5b919050565b803567ffffffffffffffff81168114611222575f5ffd5b803560028110611222575f5ffd5b803560ff81168114611222575f5ffd5b80358015158114611222575f5ffd5b5f6101e082840312801561127d575f5ffd5b506112866111c9565b823581526020808401359082015260408084013590820152606080840135908201526080808401359082015260a0808401359082015260c0808401359082015260e080840135908201526112dd61010084016111ff565b6101008201526112f06101208401611227565b6101208201526113036101408401611227565b610140820152611316610160840161123e565b610160820152611329610180840161124c565b61018082015261133c6101a0840161125c565b6101a082015261134f6101c08401611227565b6101c08201529392505050565b5f5f5f5f5f60a08688031215611370575f5ffd5b6113798661124c565b97602087013597506040870135966060810135965060800135945092505050565b5f5f5f5f5f60a086880312156113ae575f5ffd5b505083359560208501359550604085013594606081013594506080013592509050565b5f5f604083850312156113e2575f5ffd5b50508035926020909101359150565b5f5f5f5f5f5f60c08789031215611406575f5ffd5b61140f8761124c565b9860208801359850604088013597606081013597506080810135965060a00135945092505050565b5f5f5f5f5f5f5f5f610100898b03121561144f575f5ffd5b883597506020890135965060408901359550606089013594506080890135935060a0890135925061148260c08a016111ff565b915061149060e08a0161124c565b90509295985092959890939650565b634e487b7160e01b5f52602160045260245ffd5b600281106114c3576114c361149f565b9052565b5f6101e082019050825182526020830151602083015260408301516040830152606083015160608301526080830151608083015260a083015160a083015260c083015160c083015260e083015160e083015261010083015161154261010084018273ffffffffffffffffffffffffffffffffffffffff169052565b5061012083015161156061012084018267ffffffffffffffff169052565b5061014083015161157e61014084018267ffffffffffffffff169052565b506101608301516115936101608401826114b3565b506101808301516115aa61018084018260ff169052565b506101a08301516115c06101a084018215159052565b506101c08301516115de6101c084018267ffffffffffffffff169052565b5092915050565b5f5f5f5f5f5f60c087890312156115fa575f5ffd5b863595506020870135945060408701359350606087013592506080870135915061162660a0880161124c565b90509295509295509295565b5f5f60408385031215611643575f5ffd5b61164c8361124c565b915061165a6020840161124c565b90509250929050565b60208101600383106116775761167761149f565b91905290565b634e487b7160e01b5f52601160045260245ffd5b818103818111156104145761041461167d565b8281526040810161086c60208301846114b3565b60ff81811683821601908111156104145761041461167d56fea2646970667358221220c5c3deeda01609293f3730dfa6718b34c31ed42ff8abfe36a6fffee4925f09b764736f6c634300081c0033
    /// ```
    #[rustfmt::skip]
    #[allow(clippy::all)]
    pub static BYTECODE: alloy_sol_types::private::Bytes = alloy_sol_types::private::Bytes::from_static(
        b"`\x80`@R4\x80\x15`\x0EW__\xFD[Pa\x17\x07\x80a\0\x1C_9_\xF3\xFE`\x80`@R4\x80\x15a\0\x0FW__\xFD[P`\x046\x10a\x01IW_5`\xE0\x1C\x80cxj\xC4\x08\x11a\0\xC7W\x80c\xA7\xD0\x02I\x11a\0}W\x80c\xAFw\xDD\xDC\x11a\0cW\x80c\xAFw\xDD\xDC\x14a\x03\x04W\x80c\xB8E\xB4\x99\x14a\x03~W\x80c\xE3[u\\\x14a\x03\x86W__\xFD[\x80c\xA7\xD0\x02I\x14a\x02\xDCW\x80c\xAFd\r\x0F\x14a\x02\xFCW__\xFD[\x80c\x8B\xC54\x85\x11a\0\xADW\x80c\x8B\xC54\x85\x14a\x02\xAEW\x80c\x8C\xB3\x0F-\x14a\x02\xC1W\x80c\x96\x89\xD1u\x14a\x02\xD4W__\xFD[\x80cxj\xC4\x08\x14a\x02\x86W\x80c\x87\x8B_\x1C\x14a\x02\xA6W__\xFD[\x80c&|J\xE4\x11a\x01\x1CW\x80cC\xE0o)\x11a\x01\x02W\x80cC\xE0o)\x14a\x02MW\x80c[m\x13w\x14a\x02`W\x80cj\xF3\xEC\xA8\x14a\x02sW__\xFD[\x80c&|J\xE4\x14a\x02\rW\x80cA\xB9\x8A\xA1\x14a\x02EW__\xFD[\x80c\x01.\x9Ao\x14a\x01MW\x80c\x07\xEA\xE6\xD7\x14a\x01sW\x80c\x1F{m2\x14a\x01\xF0W\x80c \xCB\x14W\x14a\x01\xF8W[__\xFD[a\x01`a\x01[6`\x04a\x12kV[a\x03\x8EV[`@Q\x90\x81R` \x01[`@Q\x80\x91\x03\x90\xF3[a\x01`a\x01\x816`\x04a\x13\\V[`@\x80Q`\xF8\x96\x90\x96\x1B\x7F\xFF\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x16` \x80\x88\x01\x91\x90\x91R`!\x87\x01\x95\x90\x95R`A\x86\x01\x93\x90\x93R`a\x85\x01\x91\x90\x91R`\x81\x80\x85\x01\x91\x90\x91R\x81Q\x80\x85\x03\x90\x91\x01\x81R`\xA1\x90\x93\x01\x90R\x81Q\x91\x01 \x90V[a\x01`a\x04\x1AV[a\x02\x0Ba\x02\x066`\x04a\x13\x9AV[a\x04)V[\0[`\x08Tt\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x90\x04g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x15\x15[`@Q\x90\x15\x15\x81R` \x01a\x01jV[a\x02\x0Ba\x04=V[a\x02\x0Ba\x02[6`\x04a\x12kV[a\x04HV[a\x02\x0Ba\x02n6`\x04a\x13\xD1V[a\x06+V[a\x01`a\x02\x816`\x04a\x13\xF1V[a\x06:V[a\x02\x99a\x02\x946`\x04a\x147V[a\x06\xD4V[`@Qa\x01j\x91\x90a\x14\xC7V[a\x025a\x06\xF9V[a\x01`a\x02\xBC6`\x04a\x12kV[a\x07\x03V[a\x02\x99a\x02\xCF6`\x04a\x15\xE5V[a\x07\rV[a\x02\x99a\x07#V[a\x02\xEFa\x02\xEA6`\x04a\x162V[a\x08aV[`@Qa\x01j\x91\x90a\x16cV[a\x01`a\x08sV[a\x02\x0B_\x80\x80U`\x01\x81\x90U`\x02\x81\x90U`\x03\x81\x90U`\x04\x81\x90U`\x05\x81\x90U`\x06\x81\x90U`\x07U`\x08\x80T\x7F\xFF\xFF\xFF\xFF\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x16\x90U`\t\x80T\x7F\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x16\x90UV[a\x01`a\x08}V[a\x02\x0Ba\x08\x87V[_a\x04\x14\x82a\x01\x80\x81\x01Q\x81Q`@\x80\x84\x01Q` \x80\x86\x01Q`\x80\x87\x01Q\x84Q`\xF8\x97\x90\x97\x1B\x7F\xFF\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x16\x87\x84\x01R`!\x87\x01\x95\x90\x95R`A\x86\x01\x92\x90\x92R`a\x85\x01\x91\x90\x91R`\x81\x80\x85\x01\x93\x90\x93R\x81Q\x80\x85\x03\x90\x93\x01\x83R`\xA1\x90\x93\x01\x90R\x80Q\x91\x01 _\x90[\x92\x91PPV[_a\x04$_a\x08\x90V[\x90P\x90V[a\x046\x85\x85\x85\x85\x85a\x08\xF5V[PPPPPV[a\x04F_a\t\xE6V[V[\x80Q_\x90\x81U` \x82\x01Q`\x01\x90\x81U`@\x83\x01Q`\x02U``\x83\x01Q`\x03U`\x80\x83\x01Q`\x04U`\xA0\x83\x01Q`\x05U`\xC0\x83\x01Q`\x06U`\xE0\x83\x01Q`\x07Ua\x01\0\x83\x01Q`\x08\x80Ta\x01 \x86\x01Qg\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x90\x81\x16t\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x02\x7F\xFF\xFF\xFF\xFF\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x90\x92\x16s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x90\x94\x16\x93\x90\x93\x17\x17\x90Ua\x01@\x84\x01Q`\t\x80T\x91\x90\x92\x16\x7F\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\0\0\0\0\0\0\0\0\x82\x16\x81\x17\x83Ua\x01`\x86\x01Q\x86\x95\x94\x90\x93\x92h\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x19\x16\x90\x91\x17\x90h\x01\0\0\0\0\0\0\0\0\x90\x84\x90\x81\x11\x15a\x05kWa\x05ka\x14\x9FV[\x02\x17\x90UPa\x01\x80\x82\x01Q`\t\x90\x91\x01\x80Ta\x01\xA0\x84\x01Qa\x01\xC0\x90\x94\x01Qg\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16k\x01\0\0\0\0\0\0\0\0\0\0\0\x02\x7F\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\0\0\0\0\0\0\0\0\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x94\x15\x15j\x01\0\0\0\0\0\0\0\0\0\0\x02j\xFF\0\0\0\0\0\0\0\0\0\0\x19`\xFF\x90\x95\x16i\x01\0\0\0\0\0\0\0\0\0\x02\x94\x90\x94\x16\x7F\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\0\0\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x90\x92\x16\x91\x90\x91\x17\x92\x90\x92\x17\x92\x90\x92\x16\x17\x90UPV[a\x066_\x83\x83a\n\x90V[PPV[`@\x80Q`\xF8\x88\x90\x1B\x7F\xFF\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x16` \x80\x83\x01\x91\x90\x91R`!\x82\x01\x88\x90R`A\x82\x01\x87\x90R`a\x82\x01\x86\x90R`\x81\x80\x83\x01\x86\x90R\x83Q\x80\x84\x03\x90\x91\x01\x81R`\xA1\x83\x01\x84R\x80Q\x90\x82\x01 `\xC1\x83\x01R`\xE1\x80\x83\x01\x85\x90R\x83Q\x80\x84\x03\x90\x91\x01\x81Ra\x01\x01\x90\x92\x01\x90\x92R\x80Q\x91\x01 _\x90[\x97\x96PPPPPPPV[a\x06\xDCa\x11%V[a\x06\xEC\x89\x89\x89\x89\x89\x89\x89\x89a\x0B\x10V[\x99\x98PPPPPPPPPV[_a\x04$_a\x0CaV[_a\x04\x14\x82a\x0C\x91V[a\x07\x15a\x11%V[a\x06\xC9\x87\x87\x87\x87\x87\x87a\r@V[a\x07+a\x11%V[`@\x80Qa\x01\xE0\x81\x01\x82R_\x80T\x82R`\x01\x80T` \x84\x01R`\x02T\x93\x83\x01\x93\x90\x93R`\x03T``\x83\x01R`\x04T`\x80\x83\x01R`\x05T`\xA0\x83\x01R`\x06T`\xC0\x83\x01R`\x07T`\xE0\x83\x01R`\x08Ts\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x16a\x01\0\x84\x01Rt\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x90\x04g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x90\x81\x16a\x01 \x84\x01R`\tT\x90\x81\x16a\x01@\x84\x01R\x91\x92\x90\x91a\x01`\x84\x01\x91h\x01\0\0\0\0\0\0\0\0\x90\x91\x04`\xFF\x16\x90\x81\x11\x15a\x07\xF6Wa\x07\xF6a\x14\x9FV[`\x01\x81\x11\x15a\x08\x07Wa\x08\x07a\x14\x9FV[\x81R`\t\x91\x90\x91\x01T`\xFFi\x01\0\0\0\0\0\0\0\0\0\x82\x04\x81\x16` \x84\x01Rj\x01\0\0\0\0\0\0\0\0\0\0\x82\x04\x16\x15\x15`@\x83\x01Rg\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFFk\x01\0\0\0\0\0\0\0\0\0\0\0\x90\x91\x04\x16``\x90\x91\x01R\x91\x90PV[_a\x08l\x83\x83a\r\xD8V[\x93\x92PPPV[_a\x04$_a\x0E]V[_a\x04$_a\x0F\x1BV[a\x04F_a\x0F\xAFV[__\x82`\x02\x01T\x83`\x04\x01Ta\x08\xA6\x91\x90a\x16\x91V[\x90P\x80_\x03a\x04\x14Wa\x08\xB8\x83a\x0E]V[`@Q~\xA7\xB0+\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01a\x08\xEC\x91\x81R` \x01\x90V[`@Q\x80\x91\x03\x90\xFD[_\x85\x90\x03a\t/W`@Q\x7F\x8Dy\xDB\xBC\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[\x82\x81\x11a\trW`@Q\x7F `\xFA\xF4\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x81\x01\x84\x90R`$\x81\x01\x82\x90R`D\x01a\x08\xECV[_\x84\x90\x03a\t\xACW`@Q\x7F\x83\xC6\x83\xE4\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[_\x82\x90\x03a\x046W`@Q\x7F\\\xB6\xE5\xBB\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[_`\t\x82\x01Th\x01\0\0\0\0\0\0\0\0\x90\x04`\xFF\x16`\x01\x81\x11\x15a\n\x0CWa\n\x0Ca\x14\x9FV[\x14a\nbWa\n\x1A\x81a\x0E]V[`\t\x82\x01T`@Q\x7F#\xF8@]\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81Ra\x08\xEC\x92\x91h\x01\0\0\0\0\0\0\0\0\x90\x04`\xFF\x16\x90`\x04\x01a\x16\xA4V[`\t\x01\x80Tg\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFFC\x16h\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x19\x90\x91\x16\x17h\x01\0\0\0\0\0\0\0\0\x17\x90UV[`\x05\x83\x01T\x15\x15\x80a\n\xA5WP`\x06\x83\x01T\x15\x15[\x15a\x0B\0Wa\n\xB3\x83a\x0E]V[`\x05\x84\x01T`\x06\x85\x01T`@Q\x7F\x8B\x0Eq\xD0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x81\x01\x93\x90\x93R`$\x83\x01\x91\x90\x91R`D\x82\x01R`d\x01a\x08\xECV[`\x05\x83\x01\x91\x90\x91U`\x06\x90\x91\x01UV[a\x0B\x18a\x11%V[s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x83\x16a\x0BeW`@Q\x7F\xF2\x89\xE6W\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[_\x84\x90\x03a\x0B\x9FW`@Q\x7Fi2\xBC\xFD\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[a\x0B\xAC\x89\x89\x89\x89\x89a\x08\xF5V[`@Q\x80a\x01\xE0\x01`@R\x80\x8A\x81R` \x01\x89\x81R` \x01\x88\x81R` \x01\x87\x81R` \x01\x86\x81R` \x01__\x1B\x81R` \x01__\x1B\x81R` \x01\x85\x81R` \x01\x84s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x81R` \x01Cg\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x81R` \x01_g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x81R` \x01_`\x01\x81\x11\x15a\x0C:Wa\x0C:a\x14\x9FV[\x81R`\xFF\x84\x16` \x82\x01R_`@\x82\x01\x81\x90R``\x90\x91\x01R\x90P\x98\x97PPPPPPPPV[`\x07\x81\x01T_\x90\x15\x80\x15\x90a\x04\x14WPP`\x08\x01Ts\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x15\x15\x90V[a\x01\x80\x81\x01Q\x81Q`@\x80\x84\x01Q` \x80\x86\x01Q`\x80\x87\x01Q``\x88\x01Q\x85Q`\xF8\x98\x90\x98\x1B\x7F\xFF\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x16\x88\x85\x01R`!\x88\x01\x96\x90\x96R`A\x87\x01\x93\x90\x93R`a\x86\x01R`\x81\x80\x86\x01\x92\x90\x92R\x82Q\x80\x86\x03\x90\x92\x01\x82R`\xA1\x85\x01\x83R\x81Q\x91\x81\x01\x91\x90\x91 `\xC1\x85\x01R`\xE1\x80\x85\x01\x93\x90\x93R\x81Q\x80\x85\x03\x90\x93\x01\x83Ra\x01\x01\x90\x93\x01\x90R\x80Q\x91\x01 _\x90a\x04\x14V[a\rHa\x11%V[a\rU\x87\x87\x87\x87\x87a\x08\xF5V[P`@\x80Qa\x01\xE0\x81\x01\x82R\x96\x87R` \x87\x01\x95\x90\x95R\x93\x85\x01\x92\x90\x92R``\x84\x01R`\x80\x83\x01R_`\xA0\x83\x01\x81\x90R`\xC0\x83\x01\x81\x90R`\xE0\x83\x01\x81\x90Ra\x01\0\x83\x01\x81\x90Rg\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFFC\x16a\x01 \x84\x01Ra\x01@\x83\x01\x81\x90Ra\x01`\x83\x01\x81\x90R`\xFF\x90\x91\x16a\x01\x80\x83\x01Ra\x01\xA0\x82\x01\x81\x90Ra\x01\xC0\x82\x01R\x90V[_\x82`\xFF\x16_\x03a\r\xEAWP_a\x04\x14V[\x81`\xFF\x16\x83`\xFF\x16\x11a\r\xFFWP`\x01a\x04\x14V[a\x0E\n\x82`\x01a\x16\xB8V[`\xFF\x16\x83`\xFF\x16\x03a\x0E\x1EWP`\x02a\x04\x14V[`@Q\x7F\xAE\r\xA5x\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\xFF\x80\x85\x16`\x04\x83\x01R\x83\x16`$\x82\x01R`D\x01a\x08\xECV[`\t\x81\x01T\x81T`\x02\x83\x01T`\x01\x84\x01T`\x04\x85\x01T`\x03\x86\x01T`@\x80Qi\x01\0\0\0\0\0\0\0\0\0\x90\x97\x04`\xF8\x1B\x7F\xFF\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x16` \x80\x89\x01\x91\x90\x91R`!\x88\x01\x96\x90\x96R`A\x87\x01\x94\x90\x94R`a\x86\x01\x92\x90\x92R`\x81\x80\x86\x01\x91\x90\x91R\x82Q\x80\x86\x03\x90\x91\x01\x81R`\xA1\x85\x01\x83R\x80Q\x90\x84\x01 `\xC1\x85\x01R`\xE1\x80\x85\x01\x91\x90\x91R\x81Q\x80\x85\x03\x90\x91\x01\x81Ra\x01\x01\x90\x93\x01\x90R\x81Q\x91\x01 _\x90a\x04\x14V[`\t\x81\x01T\x81T`\x02\x83\x01T`\x01\x84\x01T`\x04\x85\x01T`@\x80Qi\x01\0\0\0\0\0\0\0\0\0\x90\x96\x04`\xF8\x1B\x7F\xFF\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x16` \x80\x88\x01\x91\x90\x91R`!\x87\x01\x95\x90\x95R`A\x86\x01\x93\x90\x93R`a\x85\x01\x91\x90\x91R`\x81\x80\x85\x01\x91\x90\x91R\x81Q\x80\x85\x03\x90\x91\x01\x81R`\xA1\x90\x93\x01\x90R\x81Q\x91\x01 _\x90a\x04\x14V[`\x01`\t\x82\x01Th\x01\0\0\0\0\0\0\0\0\x90\x04`\xFF\x16`\x01\x81\x11\x15a\x0F\xD6Wa\x0F\xD6a\x14\x9FV[\x14a\x10,Wa\x0F\xE4\x81a\x0E]V[`\t\x82\x01T`@Q\x7F\xEF\x12g\xB4\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81Ra\x08\xEC\x92\x91h\x01\0\0\0\0\0\0\0\0\x90\x04`\xFF\x16\x90`\x04\x01a\x16\xA4V[a\x105\x81a\x0CaV[a\x10\xA4Wa\x10B\x81a\x0E]V[`\x08\x82\x01T`\x07\x83\x01T`@Q\x7F\xE5\x8C\x83\x08\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x81\x01\x93\x90\x93Rs\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x90\x91\x16`$\x83\x01R`D\x82\x01R`d\x01a\x08\xECV[`\t\x81\x01Tj\x01\0\0\0\0\0\0\0\0\0\0\x90\x04`\xFF\x16\x15\x15`\x01\x03a\x11\x01Wa\x10\xCC\x81a\x0E]V[`@Q\x7F0\x7Fvi\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01a\x08\xEC\x91\x81R` \x01\x90V[`\t\x01\x80Tj\xFF\0\0\0\0\0\0\0\0\0\0\x19\x16j\x01\0\0\0\0\0\0\0\0\0\0\x17\x90UV[`@Q\x80a\x01\xE0\x01`@R\x80_\x81R` \x01_\x81R` \x01_\x81R` \x01_\x81R` \x01_\x81R` \x01_\x81R` \x01_\x81R` \x01_\x81R` \x01_s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x81R` \x01_g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x81R` \x01_g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x81R` \x01_`\x01\x81\x11\x15a\x11\xAFWa\x11\xAFa\x14\x9FV[\x81R_` \x82\x01\x81\x90R`@\x82\x01\x81\x90R``\x90\x91\x01R\x90V[`@Qa\x01\xE0\x81\x01g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x11\x82\x82\x10\x17\x15a\x11\xF9WcNH{q`\xE0\x1B_R`A`\x04R`$_\xFD[`@R\x90V[\x805s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x16\x81\x14a\x12\"W__\xFD[\x91\x90PV[\x805g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x16\x81\x14a\x12\"W__\xFD[\x805`\x02\x81\x10a\x12\"W__\xFD[\x805`\xFF\x81\x16\x81\x14a\x12\"W__\xFD[\x805\x80\x15\x15\x81\x14a\x12\"W__\xFD[_a\x01\xE0\x82\x84\x03\x12\x80\x15a\x12}W__\xFD[Pa\x12\x86a\x11\xC9V[\x825\x81R` \x80\x84\x015\x90\x82\x01R`@\x80\x84\x015\x90\x82\x01R``\x80\x84\x015\x90\x82\x01R`\x80\x80\x84\x015\x90\x82\x01R`\xA0\x80\x84\x015\x90\x82\x01R`\xC0\x80\x84\x015\x90\x82\x01R`\xE0\x80\x84\x015\x90\x82\x01Ra\x12\xDDa\x01\0\x84\x01a\x11\xFFV[a\x01\0\x82\x01Ra\x12\xF0a\x01 \x84\x01a\x12'V[a\x01 \x82\x01Ra\x13\x03a\x01@\x84\x01a\x12'V[a\x01@\x82\x01Ra\x13\x16a\x01`\x84\x01a\x12>V[a\x01`\x82\x01Ra\x13)a\x01\x80\x84\x01a\x12LV[a\x01\x80\x82\x01Ra\x13<a\x01\xA0\x84\x01a\x12\\V[a\x01\xA0\x82\x01Ra\x13Oa\x01\xC0\x84\x01a\x12'V[a\x01\xC0\x82\x01R\x93\x92PPPV[_____`\xA0\x86\x88\x03\x12\x15a\x13pW__\xFD[a\x13y\x86a\x12LV[\x97` \x87\x015\x97P`@\x87\x015\x96``\x81\x015\x96P`\x80\x015\x94P\x92PPPV[_____`\xA0\x86\x88\x03\x12\x15a\x13\xAEW__\xFD[PP\x835\x95` \x85\x015\x95P`@\x85\x015\x94``\x81\x015\x94P`\x80\x015\x92P\x90PV[__`@\x83\x85\x03\x12\x15a\x13\xE2W__\xFD[PP\x805\x92` \x90\x91\x015\x91PV[______`\xC0\x87\x89\x03\x12\x15a\x14\x06W__\xFD[a\x14\x0F\x87a\x12LV[\x98` \x88\x015\x98P`@\x88\x015\x97``\x81\x015\x97P`\x80\x81\x015\x96P`\xA0\x015\x94P\x92PPPV[________a\x01\0\x89\x8B\x03\x12\x15a\x14OW__\xFD[\x885\x97P` \x89\x015\x96P`@\x89\x015\x95P``\x89\x015\x94P`\x80\x89\x015\x93P`\xA0\x89\x015\x92Pa\x14\x82`\xC0\x8A\x01a\x11\xFFV[\x91Pa\x14\x90`\xE0\x8A\x01a\x12LV[\x90P\x92\x95\x98P\x92\x95\x98\x90\x93\x96PV[cNH{q`\xE0\x1B_R`!`\x04R`$_\xFD[`\x02\x81\x10a\x14\xC3Wa\x14\xC3a\x14\x9FV[\x90RV[_a\x01\xE0\x82\x01\x90P\x82Q\x82R` \x83\x01Q` \x83\x01R`@\x83\x01Q`@\x83\x01R``\x83\x01Q``\x83\x01R`\x80\x83\x01Q`\x80\x83\x01R`\xA0\x83\x01Q`\xA0\x83\x01R`\xC0\x83\x01Q`\xC0\x83\x01R`\xE0\x83\x01Q`\xE0\x83\x01Ra\x01\0\x83\x01Qa\x15Ba\x01\0\x84\x01\x82s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x90RV[Pa\x01 \x83\x01Qa\x15`a\x01 \x84\x01\x82g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x90RV[Pa\x01@\x83\x01Qa\x15~a\x01@\x84\x01\x82g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x90RV[Pa\x01`\x83\x01Qa\x15\x93a\x01`\x84\x01\x82a\x14\xB3V[Pa\x01\x80\x83\x01Qa\x15\xAAa\x01\x80\x84\x01\x82`\xFF\x16\x90RV[Pa\x01\xA0\x83\x01Qa\x15\xC0a\x01\xA0\x84\x01\x82\x15\x15\x90RV[Pa\x01\xC0\x83\x01Qa\x15\xDEa\x01\xC0\x84\x01\x82g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x90RV[P\x92\x91PPV[______`\xC0\x87\x89\x03\x12\x15a\x15\xFAW__\xFD[\x865\x95P` \x87\x015\x94P`@\x87\x015\x93P``\x87\x015\x92P`\x80\x87\x015\x91Pa\x16&`\xA0\x88\x01a\x12LV[\x90P\x92\x95P\x92\x95P\x92\x95V[__`@\x83\x85\x03\x12\x15a\x16CW__\xFD[a\x16L\x83a\x12LV[\x91Pa\x16Z` \x84\x01a\x12LV[\x90P\x92P\x92\x90PV[` \x81\x01`\x03\x83\x10a\x16wWa\x16wa\x14\x9FV[\x91\x90R\x90V[cNH{q`\xE0\x1B_R`\x11`\x04R`$_\xFD[\x81\x81\x03\x81\x81\x11\x15a\x04\x14Wa\x04\x14a\x16}V[\x82\x81R`@\x81\x01a\x08l` \x83\x01\x84a\x14\xB3V[`\xFF\x81\x81\x16\x83\x82\x16\x01\x90\x81\x11\x15a\x04\x14Wa\x04\x14a\x16}V\xFE\xA2dipfsX\"\x12 \xC5\xC3\xDE\xED\xA0\x16\t)?70\xDF\xA6q\x8B4\xC3\x1E\xD4/\xF8\xAB\xFE6\xA6\xFF\xFE\xE4\x92_\t\xB7dsolcC\0\x08\x1C\x003",
    );
    /// The runtime bytecode of the contract, as deployed on the network.
    ///
    /// ```text
    ///0x608060405234801561000f575f5ffd5b5060043610610149575f3560e01c8063786ac408116100c7578063a7d002491161007d578063af77dddc11610063578063af77dddc14610304578063b845b4991461037e578063e35b755c14610386575f5ffd5b8063a7d00249146102dc578063af640d0f146102fc575f5ffd5b80638bc53485116100ad5780638bc53485146102ae5780638cb30f2d146102c15780639689d175146102d4575f5ffd5b8063786ac40814610286578063878b5f1c146102a6575f5ffd5b8063267c4ae41161011c57806343e06f291161010257806343e06f291461024d5780635b6d1377146102605780636af3eca814610273575f5ffd5b8063267c4ae41461020d57806341b98aa114610245575f5ffd5b8063012e9a6f1461014d57806307eae6d7146101735780631f7b6d32146101f057806320cb1457146101f8575b5f5ffd5b61016061015b36600461126b565b61038e565b6040519081526020015b60405180910390f35b61016061018136600461135c565b6040805160f89690961b7fff00000000000000000000000000000000000000000000000000000000000000166020808801919091526021870195909552604186019390935260618501919091526081808501919091528151808503909101815260a19093019052815191012090565b61016061041a565b61020b61020636600461139a565b610429565b005b60085474010000000000000000000000000000000000000000900467ffffffffffffffff1615155b604051901515815260200161016a565b61020b61043d565b61020b61025b36600461126b565b610448565b61020b61026e3660046113d1565b61062b565b6101606102813660046113f1565b61063a565b610299610294366004611437565b6106d4565b60405161016a91906114c7565b6102356106f9565b6101606102bc36600461126b565b610703565b6102996102cf3660046115e5565b61070d565b610299610723565b6102ef6102ea366004611632565b610861565b60405161016a9190611663565b610160610873565b61020b5f808055600181905560028190556003819055600481905560058190556006819055600755600880547fffffffff00000000000000000000000000000000000000000000000000000000169055600980547fffffffffffffffffffffffffff00000000000000000000000000000000000000169055565b61016061087d565b61020b610887565b5f6104148261018081015181516040808401516020808601516080870151845160f89790971b7fff0000000000000000000000000000000000000000000000000000000000000016878401526021870195909552604186019290925260618501919091526081808501939093528151808503909301835260a1909301905280519101205f905b92915050565b5f6104245f610890565b905090565b61043685858585856108f5565b5050505050565b6104465f6109e6565b565b80515f9081556020820151600190815560408301516002556060830151600355608083015160045560a083015160055560c083015160065560e08301516007556101008301516008805461012086015167ffffffffffffffff90811674010000000000000000000000000000000000000000027fffffffff0000000000000000000000000000000000000000000000000000000090921673ffffffffffffffffffffffffffffffffffffffff9094169390931717905561014084015160098054919092167fffffffffffffffffffffffffffffffffffffffffffffffff000000000000000082168117835561016086015186959490939268ffffffffffffffffff1916909117906801000000000000000090849081111561056b5761056b61149f565b0217905550610180820151600990910180546101a08401516101c09094015167ffffffffffffffff166b010000000000000000000000027fffffffffffffffffffffffffff0000000000000000ffffffffffffffffffffff9415156a0100000000000000000000026aff000000000000000000001960ff909516690100000000000000000002949094167fffffffffffffffffffffffffffffffffffffffffff0000ffffffffffffffffff90921691909117929092179290921617905550565b6106365f8383610a90565b5050565b6040805160f888901b7fff000000000000000000000000000000000000000000000000000000000000001660208083019190915260218201889052604182018790526061820186905260818083018690528351808403909101815260a18301845280519082012060c183015260e18083018590528351808403909101815261010190920190925280519101205f905b979650505050505050565b6106dc611125565b6106ec8989898989898989610b10565b9998505050505050505050565b5f6104245f610c61565b5f61041482610c91565b610715611125565b6106c9878787878787610d40565b61072b611125565b604080516101e0810182525f80548252600180546020840152600254938301939093526003546060830152600454608083015260055460a083015260065460c083015260075460e083015260085473ffffffffffffffffffffffffffffffffffffffff811661010084015274010000000000000000000000000000000000000000900467ffffffffffffffff908116610120840152600954908116610140840152919290916101608401916801000000000000000090910460ff16908111156107f6576107f661149f565b60018111156108075761080761149f565b81526009919091015460ff69010000000000000000008204811660208401526a01000000000000000000008204161515604083015267ffffffffffffffff6b01000000000000000000000090910416606090910152919050565b5f61086c8383610dd8565b9392505050565b5f6104245f610e5d565b5f6104245f610f1b565b6104465f610faf565b5f5f826002015483600401546108a69190611691565b9050805f03610414576108b883610e5d565b6040517ea7b02b0000000000000000000000000000000000000000000000000000000081526004016108ec91815260200190565b60405180910390fd5b5f85900361092f576040517f8d79dbbc00000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b828111610972576040517f2060faf400000000000000000000000000000000000000000000000000000000815260048101849052602481018290526044016108ec565b5f8490036109ac576040517f83c683e400000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b5f829003610436576040517f5cb6e5bb00000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b5f600982015468010000000000000000900460ff166001811115610a0c57610a0c61149f565b14610a6257610a1a81610e5d565b60098201546040517f23f8405d0000000000000000000000000000000000000000000000000000000081526108ec929168010000000000000000900460ff16906004016116a4565b600901805467ffffffffffffffff431668ffffffffffffffffff199091161768010000000000000000179055565b6005830154151580610aa55750600683015415155b15610b0057610ab383610e5d565b600584015460068501546040517f8b0e71d00000000000000000000000000000000000000000000000000000000081526004810193909352602483019190915260448201526064016108ec565b6005830191909155600690910155565b610b18611125565b73ffffffffffffffffffffffffffffffffffffffff8316610b65576040517ff289e65700000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b5f849003610b9f576040517f6932bcfd00000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b610bac89898989896108f5565b604051806101e001604052808a81526020018981526020018881526020018781526020018681526020015f5f1b81526020015f5f1b81526020018581526020018473ffffffffffffffffffffffffffffffffffffffff1681526020014367ffffffffffffffff1681526020015f67ffffffffffffffff1681526020015f6001811115610c3a57610c3a61149f565b815260ff841660208201525f60408201819052606090910152905098975050505050505050565b60078101545f90158015906104145750506008015473ffffffffffffffffffffffffffffffffffffffff16151590565b610180810151815160408084015160208086015160808701516060880151855160f89890981b7fff0000000000000000000000000000000000000000000000000000000000000016888501526021880196909652604187019390935260618601526081808601929092528251808603909201825260a18501835281519181019190912060c185015260e18085019390935281518085039093018352610101909301905280519101205f90610414565b610d48611125565b610d5587878787876108f5565b50604080516101e081018252968752602087019590955293850192909252606084015260808301525f60a0830181905260c0830181905260e08301819052610100830181905267ffffffffffffffff43166101208401526101408301819052610160830181905260ff9091166101808301526101a082018190526101c082015290565b5f8260ff165f03610dea57505f610414565b8160ff168360ff1611610dff57506001610414565b610e0a8260016116b8565b60ff168360ff1603610e1e57506002610414565b6040517fae0da57800000000000000000000000000000000000000000000000000000000815260ff8085166004830152831660248201526044016108ec565b60098101548154600283015460018401546004850154600386015460408051690100000000000000000090970460f81b7fff00000000000000000000000000000000000000000000000000000000000000166020808901919091526021880196909652604187019490945260618601929092526081808601919091528251808603909101815260a18501835280519084012060c185015260e18085019190915281518085039091018152610101909301905281519101205f90610414565b6009810154815460028301546001840154600485015460408051690100000000000000000090960460f81b7fff00000000000000000000000000000000000000000000000000000000000000166020808801919091526021870195909552604186019390935260618501919091526081808501919091528151808503909101815260a1909301905281519101205f90610414565b6001600982015468010000000000000000900460ff166001811115610fd657610fd661149f565b1461102c57610fe481610e5d565b60098201546040517fef1267b40000000000000000000000000000000000000000000000000000000081526108ec929168010000000000000000900460ff16906004016116a4565b61103581610c61565b6110a45761104281610e5d565b600882015460078301546040517fe58c8308000000000000000000000000000000000000000000000000000000008152600481019390935273ffffffffffffffffffffffffffffffffffffffff909116602483015260448201526064016108ec565b60098101546a0100000000000000000000900460ff161515600103611101576110cc81610e5d565b6040517f307f76690000000000000000000000000000000000000000000000000000000081526004016108ec91815260200190565b60090180546aff0000000000000000000019166a0100000000000000000000179055565b604051806101e001604052805f81526020015f81526020015f81526020015f81526020015f81526020015f81526020015f81526020015f81526020015f73ffffffffffffffffffffffffffffffffffffffff1681526020015f67ffffffffffffffff1681526020015f67ffffffffffffffff1681526020015f60018111156111af576111af61149f565b81525f602082018190526040820181905260609091015290565b6040516101e0810167ffffffffffffffff811182821017156111f957634e487b7160e01b5f52604160045260245ffd5b60405290565b803573ffffffffffffffffffffffffffffffffffffffff81168114611222575f5ffd5b919050565b803567ffffffffffffffff81168114611222575f5ffd5b803560028110611222575f5ffd5b803560ff81168114611222575f5ffd5b80358015158114611222575f5ffd5b5f6101e082840312801561127d575f5ffd5b506112866111c9565b823581526020808401359082015260408084013590820152606080840135908201526080808401359082015260a0808401359082015260c0808401359082015260e080840135908201526112dd61010084016111ff565b6101008201526112f06101208401611227565b6101208201526113036101408401611227565b610140820152611316610160840161123e565b610160820152611329610180840161124c565b61018082015261133c6101a0840161125c565b6101a082015261134f6101c08401611227565b6101c08201529392505050565b5f5f5f5f5f60a08688031215611370575f5ffd5b6113798661124c565b97602087013597506040870135966060810135965060800135945092505050565b5f5f5f5f5f60a086880312156113ae575f5ffd5b505083359560208501359550604085013594606081013594506080013592509050565b5f5f604083850312156113e2575f5ffd5b50508035926020909101359150565b5f5f5f5f5f5f60c08789031215611406575f5ffd5b61140f8761124c565b9860208801359850604088013597606081013597506080810135965060a00135945092505050565b5f5f5f5f5f5f5f5f610100898b03121561144f575f5ffd5b883597506020890135965060408901359550606089013594506080890135935060a0890135925061148260c08a016111ff565b915061149060e08a0161124c565b90509295985092959890939650565b634e487b7160e01b5f52602160045260245ffd5b600281106114c3576114c361149f565b9052565b5f6101e082019050825182526020830151602083015260408301516040830152606083015160608301526080830151608083015260a083015160a083015260c083015160c083015260e083015160e083015261010083015161154261010084018273ffffffffffffffffffffffffffffffffffffffff169052565b5061012083015161156061012084018267ffffffffffffffff169052565b5061014083015161157e61014084018267ffffffffffffffff169052565b506101608301516115936101608401826114b3565b506101808301516115aa61018084018260ff169052565b506101a08301516115c06101a084018215159052565b506101c08301516115de6101c084018267ffffffffffffffff169052565b5092915050565b5f5f5f5f5f5f60c087890312156115fa575f5ffd5b863595506020870135945060408701359350606087013592506080870135915061162660a0880161124c565b90509295509295509295565b5f5f60408385031215611643575f5ffd5b61164c8361124c565b915061165a6020840161124c565b90509250929050565b60208101600383106116775761167761149f565b91905290565b634e487b7160e01b5f52601160045260245ffd5b818103818111156104145761041461167d565b8281526040810161086c60208301846114b3565b60ff81811683821601908111156104145761041461167d56fea2646970667358221220c5c3deeda01609293f3730dfa6718b34c31ed42ff8abfe36a6fffee4925f09b764736f6c634300081c0033
    /// ```
    #[rustfmt::skip]
    #[allow(clippy::all)]
    pub static DEPLOYED_BYTECODE: alloy_sol_types::private::Bytes = alloy_sol_types::private::Bytes::from_static(
        b"`\x80`@R4\x80\x15a\0\x0FW__\xFD[P`\x046\x10a\x01IW_5`\xE0\x1C\x80cxj\xC4\x08\x11a\0\xC7W\x80c\xA7\xD0\x02I\x11a\0}W\x80c\xAFw\xDD\xDC\x11a\0cW\x80c\xAFw\xDD\xDC\x14a\x03\x04W\x80c\xB8E\xB4\x99\x14a\x03~W\x80c\xE3[u\\\x14a\x03\x86W__\xFD[\x80c\xA7\xD0\x02I\x14a\x02\xDCW\x80c\xAFd\r\x0F\x14a\x02\xFCW__\xFD[\x80c\x8B\xC54\x85\x11a\0\xADW\x80c\x8B\xC54\x85\x14a\x02\xAEW\x80c\x8C\xB3\x0F-\x14a\x02\xC1W\x80c\x96\x89\xD1u\x14a\x02\xD4W__\xFD[\x80cxj\xC4\x08\x14a\x02\x86W\x80c\x87\x8B_\x1C\x14a\x02\xA6W__\xFD[\x80c&|J\xE4\x11a\x01\x1CW\x80cC\xE0o)\x11a\x01\x02W\x80cC\xE0o)\x14a\x02MW\x80c[m\x13w\x14a\x02`W\x80cj\xF3\xEC\xA8\x14a\x02sW__\xFD[\x80c&|J\xE4\x14a\x02\rW\x80cA\xB9\x8A\xA1\x14a\x02EW__\xFD[\x80c\x01.\x9Ao\x14a\x01MW\x80c\x07\xEA\xE6\xD7\x14a\x01sW\x80c\x1F{m2\x14a\x01\xF0W\x80c \xCB\x14W\x14a\x01\xF8W[__\xFD[a\x01`a\x01[6`\x04a\x12kV[a\x03\x8EV[`@Q\x90\x81R` \x01[`@Q\x80\x91\x03\x90\xF3[a\x01`a\x01\x816`\x04a\x13\\V[`@\x80Q`\xF8\x96\x90\x96\x1B\x7F\xFF\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x16` \x80\x88\x01\x91\x90\x91R`!\x87\x01\x95\x90\x95R`A\x86\x01\x93\x90\x93R`a\x85\x01\x91\x90\x91R`\x81\x80\x85\x01\x91\x90\x91R\x81Q\x80\x85\x03\x90\x91\x01\x81R`\xA1\x90\x93\x01\x90R\x81Q\x91\x01 \x90V[a\x01`a\x04\x1AV[a\x02\x0Ba\x02\x066`\x04a\x13\x9AV[a\x04)V[\0[`\x08Tt\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x90\x04g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x15\x15[`@Q\x90\x15\x15\x81R` \x01a\x01jV[a\x02\x0Ba\x04=V[a\x02\x0Ba\x02[6`\x04a\x12kV[a\x04HV[a\x02\x0Ba\x02n6`\x04a\x13\xD1V[a\x06+V[a\x01`a\x02\x816`\x04a\x13\xF1V[a\x06:V[a\x02\x99a\x02\x946`\x04a\x147V[a\x06\xD4V[`@Qa\x01j\x91\x90a\x14\xC7V[a\x025a\x06\xF9V[a\x01`a\x02\xBC6`\x04a\x12kV[a\x07\x03V[a\x02\x99a\x02\xCF6`\x04a\x15\xE5V[a\x07\rV[a\x02\x99a\x07#V[a\x02\xEFa\x02\xEA6`\x04a\x162V[a\x08aV[`@Qa\x01j\x91\x90a\x16cV[a\x01`a\x08sV[a\x02\x0B_\x80\x80U`\x01\x81\x90U`\x02\x81\x90U`\x03\x81\x90U`\x04\x81\x90U`\x05\x81\x90U`\x06\x81\x90U`\x07U`\x08\x80T\x7F\xFF\xFF\xFF\xFF\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x16\x90U`\t\x80T\x7F\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x16\x90UV[a\x01`a\x08}V[a\x02\x0Ba\x08\x87V[_a\x04\x14\x82a\x01\x80\x81\x01Q\x81Q`@\x80\x84\x01Q` \x80\x86\x01Q`\x80\x87\x01Q\x84Q`\xF8\x97\x90\x97\x1B\x7F\xFF\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x16\x87\x84\x01R`!\x87\x01\x95\x90\x95R`A\x86\x01\x92\x90\x92R`a\x85\x01\x91\x90\x91R`\x81\x80\x85\x01\x93\x90\x93R\x81Q\x80\x85\x03\x90\x93\x01\x83R`\xA1\x90\x93\x01\x90R\x80Q\x91\x01 _\x90[\x92\x91PPV[_a\x04$_a\x08\x90V[\x90P\x90V[a\x046\x85\x85\x85\x85\x85a\x08\xF5V[PPPPPV[a\x04F_a\t\xE6V[V[\x80Q_\x90\x81U` \x82\x01Q`\x01\x90\x81U`@\x83\x01Q`\x02U``\x83\x01Q`\x03U`\x80\x83\x01Q`\x04U`\xA0\x83\x01Q`\x05U`\xC0\x83\x01Q`\x06U`\xE0\x83\x01Q`\x07Ua\x01\0\x83\x01Q`\x08\x80Ta\x01 \x86\x01Qg\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x90\x81\x16t\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x02\x7F\xFF\xFF\xFF\xFF\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x90\x92\x16s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x90\x94\x16\x93\x90\x93\x17\x17\x90Ua\x01@\x84\x01Q`\t\x80T\x91\x90\x92\x16\x7F\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\0\0\0\0\0\0\0\0\x82\x16\x81\x17\x83Ua\x01`\x86\x01Q\x86\x95\x94\x90\x93\x92h\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x19\x16\x90\x91\x17\x90h\x01\0\0\0\0\0\0\0\0\x90\x84\x90\x81\x11\x15a\x05kWa\x05ka\x14\x9FV[\x02\x17\x90UPa\x01\x80\x82\x01Q`\t\x90\x91\x01\x80Ta\x01\xA0\x84\x01Qa\x01\xC0\x90\x94\x01Qg\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16k\x01\0\0\0\0\0\0\0\0\0\0\0\x02\x7F\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\0\0\0\0\0\0\0\0\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x94\x15\x15j\x01\0\0\0\0\0\0\0\0\0\0\x02j\xFF\0\0\0\0\0\0\0\0\0\0\x19`\xFF\x90\x95\x16i\x01\0\0\0\0\0\0\0\0\0\x02\x94\x90\x94\x16\x7F\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\0\0\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x90\x92\x16\x91\x90\x91\x17\x92\x90\x92\x17\x92\x90\x92\x16\x17\x90UPV[a\x066_\x83\x83a\n\x90V[PPV[`@\x80Q`\xF8\x88\x90\x1B\x7F\xFF\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x16` \x80\x83\x01\x91\x90\x91R`!\x82\x01\x88\x90R`A\x82\x01\x87\x90R`a\x82\x01\x86\x90R`\x81\x80\x83\x01\x86\x90R\x83Q\x80\x84\x03\x90\x91\x01\x81R`\xA1\x83\x01\x84R\x80Q\x90\x82\x01 `\xC1\x83\x01R`\xE1\x80\x83\x01\x85\x90R\x83Q\x80\x84\x03\x90\x91\x01\x81Ra\x01\x01\x90\x92\x01\x90\x92R\x80Q\x91\x01 _\x90[\x97\x96PPPPPPPV[a\x06\xDCa\x11%V[a\x06\xEC\x89\x89\x89\x89\x89\x89\x89\x89a\x0B\x10V[\x99\x98PPPPPPPPPV[_a\x04$_a\x0CaV[_a\x04\x14\x82a\x0C\x91V[a\x07\x15a\x11%V[a\x06\xC9\x87\x87\x87\x87\x87\x87a\r@V[a\x07+a\x11%V[`@\x80Qa\x01\xE0\x81\x01\x82R_\x80T\x82R`\x01\x80T` \x84\x01R`\x02T\x93\x83\x01\x93\x90\x93R`\x03T``\x83\x01R`\x04T`\x80\x83\x01R`\x05T`\xA0\x83\x01R`\x06T`\xC0\x83\x01R`\x07T`\xE0\x83\x01R`\x08Ts\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x16a\x01\0\x84\x01Rt\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x90\x04g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x90\x81\x16a\x01 \x84\x01R`\tT\x90\x81\x16a\x01@\x84\x01R\x91\x92\x90\x91a\x01`\x84\x01\x91h\x01\0\0\0\0\0\0\0\0\x90\x91\x04`\xFF\x16\x90\x81\x11\x15a\x07\xF6Wa\x07\xF6a\x14\x9FV[`\x01\x81\x11\x15a\x08\x07Wa\x08\x07a\x14\x9FV[\x81R`\t\x91\x90\x91\x01T`\xFFi\x01\0\0\0\0\0\0\0\0\0\x82\x04\x81\x16` \x84\x01Rj\x01\0\0\0\0\0\0\0\0\0\0\x82\x04\x16\x15\x15`@\x83\x01Rg\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFFk\x01\0\0\0\0\0\0\0\0\0\0\0\x90\x91\x04\x16``\x90\x91\x01R\x91\x90PV[_a\x08l\x83\x83a\r\xD8V[\x93\x92PPPV[_a\x04$_a\x0E]V[_a\x04$_a\x0F\x1BV[a\x04F_a\x0F\xAFV[__\x82`\x02\x01T\x83`\x04\x01Ta\x08\xA6\x91\x90a\x16\x91V[\x90P\x80_\x03a\x04\x14Wa\x08\xB8\x83a\x0E]V[`@Q~\xA7\xB0+\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01a\x08\xEC\x91\x81R` \x01\x90V[`@Q\x80\x91\x03\x90\xFD[_\x85\x90\x03a\t/W`@Q\x7F\x8Dy\xDB\xBC\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[\x82\x81\x11a\trW`@Q\x7F `\xFA\xF4\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x81\x01\x84\x90R`$\x81\x01\x82\x90R`D\x01a\x08\xECV[_\x84\x90\x03a\t\xACW`@Q\x7F\x83\xC6\x83\xE4\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[_\x82\x90\x03a\x046W`@Q\x7F\\\xB6\xE5\xBB\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[_`\t\x82\x01Th\x01\0\0\0\0\0\0\0\0\x90\x04`\xFF\x16`\x01\x81\x11\x15a\n\x0CWa\n\x0Ca\x14\x9FV[\x14a\nbWa\n\x1A\x81a\x0E]V[`\t\x82\x01T`@Q\x7F#\xF8@]\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81Ra\x08\xEC\x92\x91h\x01\0\0\0\0\0\0\0\0\x90\x04`\xFF\x16\x90`\x04\x01a\x16\xA4V[`\t\x01\x80Tg\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFFC\x16h\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x19\x90\x91\x16\x17h\x01\0\0\0\0\0\0\0\0\x17\x90UV[`\x05\x83\x01T\x15\x15\x80a\n\xA5WP`\x06\x83\x01T\x15\x15[\x15a\x0B\0Wa\n\xB3\x83a\x0E]V[`\x05\x84\x01T`\x06\x85\x01T`@Q\x7F\x8B\x0Eq\xD0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x81\x01\x93\x90\x93R`$\x83\x01\x91\x90\x91R`D\x82\x01R`d\x01a\x08\xECV[`\x05\x83\x01\x91\x90\x91U`\x06\x90\x91\x01UV[a\x0B\x18a\x11%V[s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x83\x16a\x0BeW`@Q\x7F\xF2\x89\xE6W\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[_\x84\x90\x03a\x0B\x9FW`@Q\x7Fi2\xBC\xFD\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[a\x0B\xAC\x89\x89\x89\x89\x89a\x08\xF5V[`@Q\x80a\x01\xE0\x01`@R\x80\x8A\x81R` \x01\x89\x81R` \x01\x88\x81R` \x01\x87\x81R` \x01\x86\x81R` \x01__\x1B\x81R` \x01__\x1B\x81R` \x01\x85\x81R` \x01\x84s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x81R` \x01Cg\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x81R` \x01_g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x81R` \x01_`\x01\x81\x11\x15a\x0C:Wa\x0C:a\x14\x9FV[\x81R`\xFF\x84\x16` \x82\x01R_`@\x82\x01\x81\x90R``\x90\x91\x01R\x90P\x98\x97PPPPPPPPV[`\x07\x81\x01T_\x90\x15\x80\x15\x90a\x04\x14WPP`\x08\x01Ts\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x15\x15\x90V[a\x01\x80\x81\x01Q\x81Q`@\x80\x84\x01Q` \x80\x86\x01Q`\x80\x87\x01Q``\x88\x01Q\x85Q`\xF8\x98\x90\x98\x1B\x7F\xFF\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x16\x88\x85\x01R`!\x88\x01\x96\x90\x96R`A\x87\x01\x93\x90\x93R`a\x86\x01R`\x81\x80\x86\x01\x92\x90\x92R\x82Q\x80\x86\x03\x90\x92\x01\x82R`\xA1\x85\x01\x83R\x81Q\x91\x81\x01\x91\x90\x91 `\xC1\x85\x01R`\xE1\x80\x85\x01\x93\x90\x93R\x81Q\x80\x85\x03\x90\x93\x01\x83Ra\x01\x01\x90\x93\x01\x90R\x80Q\x91\x01 _\x90a\x04\x14V[a\rHa\x11%V[a\rU\x87\x87\x87\x87\x87a\x08\xF5V[P`@\x80Qa\x01\xE0\x81\x01\x82R\x96\x87R` \x87\x01\x95\x90\x95R\x93\x85\x01\x92\x90\x92R``\x84\x01R`\x80\x83\x01R_`\xA0\x83\x01\x81\x90R`\xC0\x83\x01\x81\x90R`\xE0\x83\x01\x81\x90Ra\x01\0\x83\x01\x81\x90Rg\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFFC\x16a\x01 \x84\x01Ra\x01@\x83\x01\x81\x90Ra\x01`\x83\x01\x81\x90R`\xFF\x90\x91\x16a\x01\x80\x83\x01Ra\x01\xA0\x82\x01\x81\x90Ra\x01\xC0\x82\x01R\x90V[_\x82`\xFF\x16_\x03a\r\xEAWP_a\x04\x14V[\x81`\xFF\x16\x83`\xFF\x16\x11a\r\xFFWP`\x01a\x04\x14V[a\x0E\n\x82`\x01a\x16\xB8V[`\xFF\x16\x83`\xFF\x16\x03a\x0E\x1EWP`\x02a\x04\x14V[`@Q\x7F\xAE\r\xA5x\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\xFF\x80\x85\x16`\x04\x83\x01R\x83\x16`$\x82\x01R`D\x01a\x08\xECV[`\t\x81\x01T\x81T`\x02\x83\x01T`\x01\x84\x01T`\x04\x85\x01T`\x03\x86\x01T`@\x80Qi\x01\0\0\0\0\0\0\0\0\0\x90\x97\x04`\xF8\x1B\x7F\xFF\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x16` \x80\x89\x01\x91\x90\x91R`!\x88\x01\x96\x90\x96R`A\x87\x01\x94\x90\x94R`a\x86\x01\x92\x90\x92R`\x81\x80\x86\x01\x91\x90\x91R\x82Q\x80\x86\x03\x90\x91\x01\x81R`\xA1\x85\x01\x83R\x80Q\x90\x84\x01 `\xC1\x85\x01R`\xE1\x80\x85\x01\x91\x90\x91R\x81Q\x80\x85\x03\x90\x91\x01\x81Ra\x01\x01\x90\x93\x01\x90R\x81Q\x91\x01 _\x90a\x04\x14V[`\t\x81\x01T\x81T`\x02\x83\x01T`\x01\x84\x01T`\x04\x85\x01T`@\x80Qi\x01\0\0\0\0\0\0\0\0\0\x90\x96\x04`\xF8\x1B\x7F\xFF\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x16` \x80\x88\x01\x91\x90\x91R`!\x87\x01\x95\x90\x95R`A\x86\x01\x93\x90\x93R`a\x85\x01\x91\x90\x91R`\x81\x80\x85\x01\x91\x90\x91R\x81Q\x80\x85\x03\x90\x91\x01\x81R`\xA1\x90\x93\x01\x90R\x81Q\x91\x01 _\x90a\x04\x14V[`\x01`\t\x82\x01Th\x01\0\0\0\0\0\0\0\0\x90\x04`\xFF\x16`\x01\x81\x11\x15a\x0F\xD6Wa\x0F\xD6a\x14\x9FV[\x14a\x10,Wa\x0F\xE4\x81a\x0E]V[`\t\x82\x01T`@Q\x7F\xEF\x12g\xB4\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81Ra\x08\xEC\x92\x91h\x01\0\0\0\0\0\0\0\0\x90\x04`\xFF\x16\x90`\x04\x01a\x16\xA4V[a\x105\x81a\x0CaV[a\x10\xA4Wa\x10B\x81a\x0E]V[`\x08\x82\x01T`\x07\x83\x01T`@Q\x7F\xE5\x8C\x83\x08\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x81\x01\x93\x90\x93Rs\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x90\x91\x16`$\x83\x01R`D\x82\x01R`d\x01a\x08\xECV[`\t\x81\x01Tj\x01\0\0\0\0\0\0\0\0\0\0\x90\x04`\xFF\x16\x15\x15`\x01\x03a\x11\x01Wa\x10\xCC\x81a\x0E]V[`@Q\x7F0\x7Fvi\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01a\x08\xEC\x91\x81R` \x01\x90V[`\t\x01\x80Tj\xFF\0\0\0\0\0\0\0\0\0\0\x19\x16j\x01\0\0\0\0\0\0\0\0\0\0\x17\x90UV[`@Q\x80a\x01\xE0\x01`@R\x80_\x81R` \x01_\x81R` \x01_\x81R` \x01_\x81R` \x01_\x81R` \x01_\x81R` \x01_\x81R` \x01_\x81R` \x01_s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x81R` \x01_g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x81R` \x01_g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x81R` \x01_`\x01\x81\x11\x15a\x11\xAFWa\x11\xAFa\x14\x9FV[\x81R_` \x82\x01\x81\x90R`@\x82\x01\x81\x90R``\x90\x91\x01R\x90V[`@Qa\x01\xE0\x81\x01g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x11\x82\x82\x10\x17\x15a\x11\xF9WcNH{q`\xE0\x1B_R`A`\x04R`$_\xFD[`@R\x90V[\x805s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x16\x81\x14a\x12\"W__\xFD[\x91\x90PV[\x805g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x16\x81\x14a\x12\"W__\xFD[\x805`\x02\x81\x10a\x12\"W__\xFD[\x805`\xFF\x81\x16\x81\x14a\x12\"W__\xFD[\x805\x80\x15\x15\x81\x14a\x12\"W__\xFD[_a\x01\xE0\x82\x84\x03\x12\x80\x15a\x12}W__\xFD[Pa\x12\x86a\x11\xC9V[\x825\x81R` \x80\x84\x015\x90\x82\x01R`@\x80\x84\x015\x90\x82\x01R``\x80\x84\x015\x90\x82\x01R`\x80\x80\x84\x015\x90\x82\x01R`\xA0\x80\x84\x015\x90\x82\x01R`\xC0\x80\x84\x015\x90\x82\x01R`\xE0\x80\x84\x015\x90\x82\x01Ra\x12\xDDa\x01\0\x84\x01a\x11\xFFV[a\x01\0\x82\x01Ra\x12\xF0a\x01 \x84\x01a\x12'V[a\x01 \x82\x01Ra\x13\x03a\x01@\x84\x01a\x12'V[a\x01@\x82\x01Ra\x13\x16a\x01`\x84\x01a\x12>V[a\x01`\x82\x01Ra\x13)a\x01\x80\x84\x01a\x12LV[a\x01\x80\x82\x01Ra\x13<a\x01\xA0\x84\x01a\x12\\V[a\x01\xA0\x82\x01Ra\x13Oa\x01\xC0\x84\x01a\x12'V[a\x01\xC0\x82\x01R\x93\x92PPPV[_____`\xA0\x86\x88\x03\x12\x15a\x13pW__\xFD[a\x13y\x86a\x12LV[\x97` \x87\x015\x97P`@\x87\x015\x96``\x81\x015\x96P`\x80\x015\x94P\x92PPPV[_____`\xA0\x86\x88\x03\x12\x15a\x13\xAEW__\xFD[PP\x835\x95` \x85\x015\x95P`@\x85\x015\x94``\x81\x015\x94P`\x80\x015\x92P\x90PV[__`@\x83\x85\x03\x12\x15a\x13\xE2W__\xFD[PP\x805\x92` \x90\x91\x015\x91PV[______`\xC0\x87\x89\x03\x12\x15a\x14\x06W__\xFD[a\x14\x0F\x87a\x12LV[\x98` \x88\x015\x98P`@\x88\x015\x97``\x81\x015\x97P`\x80\x81\x015\x96P`\xA0\x015\x94P\x92PPPV[________a\x01\0\x89\x8B\x03\x12\x15a\x14OW__\xFD[\x885\x97P` \x89\x015\x96P`@\x89\x015\x95P``\x89\x015\x94P`\x80\x89\x015\x93P`\xA0\x89\x015\x92Pa\x14\x82`\xC0\x8A\x01a\x11\xFFV[\x91Pa\x14\x90`\xE0\x8A\x01a\x12LV[\x90P\x92\x95\x98P\x92\x95\x98\x90\x93\x96PV[cNH{q`\xE0\x1B_R`!`\x04R`$_\xFD[`\x02\x81\x10a\x14\xC3Wa\x14\xC3a\x14\x9FV[\x90RV[_a\x01\xE0\x82\x01\x90P\x82Q\x82R` \x83\x01Q` \x83\x01R`@\x83\x01Q`@\x83\x01R``\x83\x01Q``\x83\x01R`\x80\x83\x01Q`\x80\x83\x01R`\xA0\x83\x01Q`\xA0\x83\x01R`\xC0\x83\x01Q`\xC0\x83\x01R`\xE0\x83\x01Q`\xE0\x83\x01Ra\x01\0\x83\x01Qa\x15Ba\x01\0\x84\x01\x82s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x90RV[Pa\x01 \x83\x01Qa\x15`a\x01 \x84\x01\x82g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x90RV[Pa\x01@\x83\x01Qa\x15~a\x01@\x84\x01\x82g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x90RV[Pa\x01`\x83\x01Qa\x15\x93a\x01`\x84\x01\x82a\x14\xB3V[Pa\x01\x80\x83\x01Qa\x15\xAAa\x01\x80\x84\x01\x82`\xFF\x16\x90RV[Pa\x01\xA0\x83\x01Qa\x15\xC0a\x01\xA0\x84\x01\x82\x15\x15\x90RV[Pa\x01\xC0\x83\x01Qa\x15\xDEa\x01\xC0\x84\x01\x82g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x90RV[P\x92\x91PPV[______`\xC0\x87\x89\x03\x12\x15a\x15\xFAW__\xFD[\x865\x95P` \x87\x015\x94P`@\x87\x015\x93P``\x87\x015\x92P`\x80\x87\x015\x91Pa\x16&`\xA0\x88\x01a\x12LV[\x90P\x92\x95P\x92\x95P\x92\x95V[__`@\x83\x85\x03\x12\x15a\x16CW__\xFD[a\x16L\x83a\x12LV[\x91Pa\x16Z` \x84\x01a\x12LV[\x90P\x92P\x92\x90PV[` \x81\x01`\x03\x83\x10a\x16wWa\x16wa\x14\x9FV[\x91\x90R\x90V[cNH{q`\xE0\x1B_R`\x11`\x04R`$_\xFD[\x81\x81\x03\x81\x81\x11\x15a\x04\x14Wa\x04\x14a\x16}V[\x82\x81R`@\x81\x01a\x08l` \x83\x01\x84a\x14\xB3V[`\xFF\x81\x81\x16\x83\x82\x16\x01\x90\x81\x11\x15a\x04\x14Wa\x04\x14a\x16}V\xFE\xA2dipfsX\"\x12 \xC5\xC3\xDE\xED\xA0\x16\t)?70\xDF\xA6q\x8B4\xC3\x1E\xD4/\xF8\xAB\xFE6\xA6\xFF\xFE\xE4\x92_\t\xB7dsolcC\0\x08\x1C\x003",
    );
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct EdgeStatus(u8);
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[automatically_derived]
        impl alloy_sol_types::private::SolTypeValue<EdgeStatus> for u8 {
            #[inline]
            fn stv_to_tokens(
                &self,
            ) -> <alloy::sol_types::sol_data::Uint<
                8,
            > as alloy_sol_types::SolType>::Token<'_> {
                alloy_sol_types::private::SolTypeValue::<
                    alloy::sol_types::sol_data::Uint<8>,
                >::stv_to_tokens(self)
            }
            #[inline]
            fn stv_eip712_data_word(&self) -> alloy_sol_types::Word {
                <alloy::sol_types::sol_data::Uint<
                    8,
                > as alloy_sol_types::SolType>::tokenize(self)
                    .0
            }
            #[inline]
            fn stv_abi_encode_packed_to(
                &self,
                out: &mut alloy_sol_types::private::Vec<u8>,
            ) {
                <alloy::sol_types::sol_data::Uint<
                    8,
                > as alloy_sol_types::SolType>::abi_encode_packed_to(self, out)
            }
            #[inline]
            fn stv_abi_packed_encoded_size(&self) -> usize {
                <alloy::sol_types::sol_data::Uint<
                    8,
                > as alloy_sol_types::SolType>::abi_encoded_size(self)
            }
        }
        #[automatically_derived]
        impl EdgeStatus {
            /// The Solidity type name.
            pub const NAME: &'static str = stringify!(@ name);
            /// Convert from the underlying value type.
            #[inline]
            pub const fn from(value: u8) -> Self {
                Self(value)
            }
            /// Return the underlying value.
            #[inline]
            pub const fn into(self) -> u8 {
                self.0
            }
            /// Return the single encoding of this value, delegating to the
            /// underlying type.
            #[inline]
            pub fn abi_encode(&self) -> alloy_sol_types::private::Vec<u8> {
                <Self as alloy_sol_types::SolType>::abi_encode(&self.0)
            }
            /// Return the packed encoding of this value, delegating to the
            /// underlying type.
            #[inline]
            pub fn abi_encode_packed(&self) -> alloy_sol_types::private::Vec<u8> {
                <Self as alloy_sol_types::SolType>::abi_encode_packed(&self.0)
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolType for EdgeStatus {
            type RustType = u8;
            type Token<'a> = <alloy::sol_types::sol_data::Uint<
                8,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SOL_NAME: &'static str = Self::NAME;
            const ENCODED_SIZE: Option<usize> = <alloy::sol_types::sol_data::Uint<
                8,
            > as alloy_sol_types::SolType>::ENCODED_SIZE;
            const PACKED_ENCODED_SIZE: Option<usize> = <alloy::sol_types::sol_data::Uint<
                8,
            > as alloy_sol_types::SolType>::PACKED_ENCODED_SIZE;
            #[inline]
            fn valid_token(token: &Self::Token<'_>) -> bool {
                Self::type_check(token).is_ok()
            }
            #[inline]
            fn type_check(token: &Self::Token<'_>) -> alloy_sol_types::Result<()> {
                <alloy::sol_types::sol_data::Uint<
                    8,
                > as alloy_sol_types::SolType>::type_check(token)
            }
            #[inline]
            fn detokenize(token: Self::Token<'_>) -> Self::RustType {
                <alloy::sol_types::sol_data::Uint<
                    8,
                > as alloy_sol_types::SolType>::detokenize(token)
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::EventTopic for EdgeStatus {
            #[inline]
            fn topic_preimage_length(rust: &Self::RustType) -> usize {
                <alloy::sol_types::sol_data::Uint<
                    8,
                > as alloy_sol_types::EventTopic>::topic_preimage_length(rust)
            }
            #[inline]
            fn encode_topic_preimage(
                rust: &Self::RustType,
                out: &mut alloy_sol_types::private::Vec<u8>,
            ) {
                <alloy::sol_types::sol_data::Uint<
                    8,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(rust, out)
            }
            #[inline]
            fn encode_topic(
                rust: &Self::RustType,
            ) -> alloy_sol_types::abi::token::WordToken {
                <alloy::sol_types::sol_data::Uint<
                    8,
                > as alloy_sol_types::EventTopic>::encode_topic(rust)
            }
        }
    };
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct EdgeType(u8);
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[automatically_derived]
        impl alloy_sol_types::private::SolTypeValue<EdgeType> for u8 {
            #[inline]
            fn stv_to_tokens(
                &self,
            ) -> <alloy::sol_types::sol_data::Uint<
                8,
            > as alloy_sol_types::SolType>::Token<'_> {
                alloy_sol_types::private::SolTypeValue::<
                    alloy::sol_types::sol_data::Uint<8>,
                >::stv_to_tokens(self)
            }
            #[inline]
            fn stv_eip712_data_word(&self) -> alloy_sol_types::Word {
                <alloy::sol_types::sol_data::Uint<
                    8,
                > as alloy_sol_types::SolType>::tokenize(self)
                    .0
            }
            #[inline]
            fn stv_abi_encode_packed_to(
                &self,
                out: &mut alloy_sol_types::private::Vec<u8>,
            ) {
                <alloy::sol_types::sol_data::Uint<
                    8,
                > as alloy_sol_types::SolType>::abi_encode_packed_to(self, out)
            }
            #[inline]
            fn stv_abi_packed_encoded_size(&self) -> usize {
                <alloy::sol_types::sol_data::Uint<
                    8,
                > as alloy_sol_types::SolType>::abi_encoded_size(self)
            }
        }
        #[automatically_derived]
        impl EdgeType {
            /// The Solidity type name.
            pub const NAME: &'static str = stringify!(@ name);
            /// Convert from the underlying value type.
            #[inline]
            pub const fn from(value: u8) -> Self {
                Self(value)
            }
            /// Return the underlying value.
            #[inline]
            pub const fn into(self) -> u8 {
                self.0
            }
            /// Return the single encoding of this value, delegating to the
            /// underlying type.
            #[inline]
            pub fn abi_encode(&self) -> alloy_sol_types::private::Vec<u8> {
                <Self as alloy_sol_types::SolType>::abi_encode(&self.0)
            }
            /// Return the packed encoding of this value, delegating to the
            /// underlying type.
            #[inline]
            pub fn abi_encode_packed(&self) -> alloy_sol_types::private::Vec<u8> {
                <Self as alloy_sol_types::SolType>::abi_encode_packed(&self.0)
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolType for EdgeType {
            type RustType = u8;
            type Token<'a> = <alloy::sol_types::sol_data::Uint<
                8,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SOL_NAME: &'static str = Self::NAME;
            const ENCODED_SIZE: Option<usize> = <alloy::sol_types::sol_data::Uint<
                8,
            > as alloy_sol_types::SolType>::ENCODED_SIZE;
            const PACKED_ENCODED_SIZE: Option<usize> = <alloy::sol_types::sol_data::Uint<
                8,
            > as alloy_sol_types::SolType>::PACKED_ENCODED_SIZE;
            #[inline]
            fn valid_token(token: &Self::Token<'_>) -> bool {
                Self::type_check(token).is_ok()
            }
            #[inline]
            fn type_check(token: &Self::Token<'_>) -> alloy_sol_types::Result<()> {
                <alloy::sol_types::sol_data::Uint<
                    8,
                > as alloy_sol_types::SolType>::type_check(token)
            }
            #[inline]
            fn detokenize(token: Self::Token<'_>) -> Self::RustType {
                <alloy::sol_types::sol_data::Uint<
                    8,
                > as alloy_sol_types::SolType>::detokenize(token)
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::EventTopic for EdgeType {
            #[inline]
            fn topic_preimage_length(rust: &Self::RustType) -> usize {
                <alloy::sol_types::sol_data::Uint<
                    8,
                > as alloy_sol_types::EventTopic>::topic_preimage_length(rust)
            }
            #[inline]
            fn encode_topic_preimage(
                rust: &Self::RustType,
                out: &mut alloy_sol_types::private::Vec<u8>,
            ) {
                <alloy::sol_types::sol_data::Uint<
                    8,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(rust, out)
            }
            #[inline]
            fn encode_topic(
                rust: &Self::RustType,
            ) -> alloy_sol_types::abi::token::WordToken {
                <alloy::sol_types::sol_data::Uint<
                    8,
                > as alloy_sol_types::EventTopic>::encode_topic(rust)
            }
        }
    };
    /**```solidity
struct ChallengeEdge { bytes32 originId; bytes32 startHistoryRoot; uint256 startHeight; bytes32 endHistoryRoot; uint256 endHeight; bytes32 lowerChildId; bytes32 upperChildId; bytes32 claimId; address staker; uint64 createdAtBlock; uint64 confirmedAtBlock; EdgeStatus status; uint8 level; bool refunded; uint64 totalTimeUnrivaledCache; }
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct ChallengeEdge {
        #[allow(missing_docs)]
        pub originId: alloy::sol_types::private::FixedBytes<32>,
        #[allow(missing_docs)]
        pub startHistoryRoot: alloy::sol_types::private::FixedBytes<32>,
        #[allow(missing_docs)]
        pub startHeight: alloy::sol_types::private::primitives::aliases::U256,
        #[allow(missing_docs)]
        pub endHistoryRoot: alloy::sol_types::private::FixedBytes<32>,
        #[allow(missing_docs)]
        pub endHeight: alloy::sol_types::private::primitives::aliases::U256,
        #[allow(missing_docs)]
        pub lowerChildId: alloy::sol_types::private::FixedBytes<32>,
        #[allow(missing_docs)]
        pub upperChildId: alloy::sol_types::private::FixedBytes<32>,
        #[allow(missing_docs)]
        pub claimId: alloy::sol_types::private::FixedBytes<32>,
        #[allow(missing_docs)]
        pub staker: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub createdAtBlock: u64,
        #[allow(missing_docs)]
        pub confirmedAtBlock: u64,
        #[allow(missing_docs)]
        pub status: <EdgeStatus as alloy::sol_types::SolType>::RustType,
        #[allow(missing_docs)]
        pub level: u8,
        #[allow(missing_docs)]
        pub refunded: bool,
        #[allow(missing_docs)]
        pub totalTimeUnrivaledCache: u64,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = (
            alloy::sol_types::sol_data::FixedBytes<32>,
            alloy::sol_types::sol_data::FixedBytes<32>,
            alloy::sol_types::sol_data::Uint<256>,
            alloy::sol_types::sol_data::FixedBytes<32>,
            alloy::sol_types::sol_data::Uint<256>,
            alloy::sol_types::sol_data::FixedBytes<32>,
            alloy::sol_types::sol_data::FixedBytes<32>,
            alloy::sol_types::sol_data::FixedBytes<32>,
            alloy::sol_types::sol_data::Address,
            alloy::sol_types::sol_data::Uint<64>,
            alloy::sol_types::sol_data::Uint<64>,
            EdgeStatus,
            alloy::sol_types::sol_data::Uint<8>,
            alloy::sol_types::sol_data::Bool,
            alloy::sol_types::sol_data::Uint<64>,
        );
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = (
            alloy::sol_types::private::FixedBytes<32>,
            alloy::sol_types::private::FixedBytes<32>,
            alloy::sol_types::private::primitives::aliases::U256,
            alloy::sol_types::private::FixedBytes<32>,
            alloy::sol_types::private::primitives::aliases::U256,
            alloy::sol_types::private::FixedBytes<32>,
            alloy::sol_types::private::FixedBytes<32>,
            alloy::sol_types::private::FixedBytes<32>,
            alloy::sol_types::private::Address,
            u64,
            u64,
            <EdgeStatus as alloy::sol_types::SolType>::RustType,
            u8,
            bool,
            u64,
        );
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<ChallengeEdge> for UnderlyingRustTuple<'_> {
            fn from(value: ChallengeEdge) -> Self {
                (
                    value.originId,
                    value.startHistoryRoot,
                    value.startHeight,
                    value.endHistoryRoot,
                    value.endHeight,
                    value.lowerChildId,
                    value.upperChildId,
                    value.claimId,
                    value.staker,
                    value.createdAtBlock,
                    value.confirmedAtBlock,
                    value.status,
                    value.level,
                    value.refunded,
                    value.totalTimeUnrivaledCache,
                )
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for ChallengeEdge {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self {
                    originId: tuple.0,
                    startHistoryRoot: tuple.1,
                    startHeight: tuple.2,
                    endHistoryRoot: tuple.3,
                    endHeight: tuple.4,
                    lowerChildId: tuple.5,
                    upperChildId: tuple.6,
                    claimId: tuple.7,
                    staker: tuple.8,
                    createdAtBlock: tuple.9,
                    confirmedAtBlock: tuple.10,
                    status: tuple.11,
                    level: tuple.12,
                    refunded: tuple.13,
                    totalTimeUnrivaledCache: tuple.14,
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolValue for ChallengeEdge {
            type SolType = Self;
        }
        #[automatically_derived]
        impl alloy_sol_types::private::SolTypeValue<Self> for ChallengeEdge {
            #[inline]
            fn stv_to_tokens(&self) -> <Self as alloy_sol_types::SolType>::Token<'_> {
                (
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.originId),
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.startHistoryRoot),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.startHeight),
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.endHistoryRoot),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.endHeight),
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.lowerChildId),
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.upperChildId),
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.claimId),
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.staker,
                    ),
                    <alloy::sol_types::sol_data::Uint<
                        64,
                    > as alloy_sol_types::SolType>::tokenize(&self.createdAtBlock),
                    <alloy::sol_types::sol_data::Uint<
                        64,
                    > as alloy_sol_types::SolType>::tokenize(&self.confirmedAtBlock),
                    <EdgeStatus as alloy_sol_types::SolType>::tokenize(&self.status),
                    <alloy::sol_types::sol_data::Uint<
                        8,
                    > as alloy_sol_types::SolType>::tokenize(&self.level),
                    <alloy::sol_types::sol_data::Bool as alloy_sol_types::SolType>::tokenize(
                        &self.refunded,
                    ),
                    <alloy::sol_types::sol_data::Uint<
                        64,
                    > as alloy_sol_types::SolType>::tokenize(
                        &self.totalTimeUnrivaledCache,
                    ),
                )
            }
            #[inline]
            fn stv_abi_encoded_size(&self) -> usize {
                if let Some(size) = <Self as alloy_sol_types::SolType>::ENCODED_SIZE {
                    return size;
                }
                let tuple = <UnderlyingRustTuple<
                    '_,
                > as ::core::convert::From<Self>>::from(self.clone());
                <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_encoded_size(&tuple)
            }
            #[inline]
            fn stv_eip712_data_word(&self) -> alloy_sol_types::Word {
                <Self as alloy_sol_types::SolStruct>::eip712_hash_struct(self)
            }
            #[inline]
            fn stv_abi_encode_packed_to(
                &self,
                out: &mut alloy_sol_types::private::Vec<u8>,
            ) {
                let tuple = <UnderlyingRustTuple<
                    '_,
                > as ::core::convert::From<Self>>::from(self.clone());
                <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_encode_packed_to(&tuple, out)
            }
            #[inline]
            fn stv_abi_packed_encoded_size(&self) -> usize {
                if let Some(size) = <Self as alloy_sol_types::SolType>::PACKED_ENCODED_SIZE {
                    return size;
                }
                let tuple = <UnderlyingRustTuple<
                    '_,
                > as ::core::convert::From<Self>>::from(self.clone());
                <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_packed_encoded_size(&tuple)
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolType for ChallengeEdge {
            type RustType = Self;
            type Token<'a> = <UnderlyingSolTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SOL_NAME: &'static str = <Self as alloy_sol_types::SolStruct>::NAME;
            const ENCODED_SIZE: Option<usize> = <UnderlyingSolTuple<
                '_,
            > as alloy_sol_types::SolType>::ENCODED_SIZE;
            const PACKED_ENCODED_SIZE: Option<usize> = <UnderlyingSolTuple<
                '_,
            > as alloy_sol_types::SolType>::PACKED_ENCODED_SIZE;
            #[inline]
            fn valid_token(token: &Self::Token<'_>) -> bool {
                <UnderlyingSolTuple<'_> as alloy_sol_types::SolType>::valid_token(token)
            }
            #[inline]
            fn detokenize(token: Self::Token<'_>) -> Self::RustType {
                let tuple = <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::detokenize(token);
                <Self as ::core::convert::From<UnderlyingRustTuple<'_>>>::from(tuple)
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolStruct for ChallengeEdge {
            const NAME: &'static str = "ChallengeEdge";
            #[inline]
            fn eip712_root_type() -> alloy_sol_types::private::Cow<'static, str> {
                alloy_sol_types::private::Cow::Borrowed(
                    "ChallengeEdge(bytes32 originId,bytes32 startHistoryRoot,uint256 startHeight,bytes32 endHistoryRoot,uint256 endHeight,bytes32 lowerChildId,bytes32 upperChildId,bytes32 claimId,address staker,uint64 createdAtBlock,uint64 confirmedAtBlock,uint8 status,uint8 level,bool refunded,uint64 totalTimeUnrivaledCache)",
                )
            }
            #[inline]
            fn eip712_components() -> alloy_sol_types::private::Vec<
                alloy_sol_types::private::Cow<'static, str>,
            > {
                alloy_sol_types::private::Vec::new()
            }
            #[inline]
            fn eip712_encode_type() -> alloy_sol_types::private::Cow<'static, str> {
                <Self as alloy_sol_types::SolStruct>::eip712_root_type()
            }
            #[inline]
            fn eip712_encode_data(&self) -> alloy_sol_types::private::Vec<u8> {
                [
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::eip712_data_word(&self.originId)
                        .0,
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::eip712_data_word(
                            &self.startHistoryRoot,
                        )
                        .0,
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::eip712_data_word(&self.startHeight)
                        .0,
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::eip712_data_word(
                            &self.endHistoryRoot,
                        )
                        .0,
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::eip712_data_word(&self.endHeight)
                        .0,
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::eip712_data_word(&self.lowerChildId)
                        .0,
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::eip712_data_word(&self.upperChildId)
                        .0,
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::eip712_data_word(&self.claimId)
                        .0,
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::eip712_data_word(
                            &self.staker,
                        )
                        .0,
                    <alloy::sol_types::sol_data::Uint<
                        64,
                    > as alloy_sol_types::SolType>::eip712_data_word(
                            &self.createdAtBlock,
                        )
                        .0,
                    <alloy::sol_types::sol_data::Uint<
                        64,
                    > as alloy_sol_types::SolType>::eip712_data_word(
                            &self.confirmedAtBlock,
                        )
                        .0,
                    <EdgeStatus as alloy_sol_types::SolType>::eip712_data_word(
                            &self.status,
                        )
                        .0,
                    <alloy::sol_types::sol_data::Uint<
                        8,
                    > as alloy_sol_types::SolType>::eip712_data_word(&self.level)
                        .0,
                    <alloy::sol_types::sol_data::Bool as alloy_sol_types::SolType>::eip712_data_word(
                            &self.refunded,
                        )
                        .0,
                    <alloy::sol_types::sol_data::Uint<
                        64,
                    > as alloy_sol_types::SolType>::eip712_data_word(
                            &self.totalTimeUnrivaledCache,
                        )
                        .0,
                ]
                    .concat()
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::EventTopic for ChallengeEdge {
            #[inline]
            fn topic_preimage_length(rust: &Self::RustType) -> usize {
                0usize
                    + <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.originId,
                    )
                    + <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.startHistoryRoot,
                    )
                    + <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.startHeight,
                    )
                    + <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.endHistoryRoot,
                    )
                    + <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.endHeight,
                    )
                    + <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.lowerChildId,
                    )
                    + <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.upperChildId,
                    )
                    + <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.claimId,
                    )
                    + <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.staker,
                    )
                    + <alloy::sol_types::sol_data::Uint<
                        64,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.createdAtBlock,
                    )
                    + <alloy::sol_types::sol_data::Uint<
                        64,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.confirmedAtBlock,
                    )
                    + <EdgeStatus as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.status,
                    )
                    + <alloy::sol_types::sol_data::Uint<
                        8,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(&rust.level)
                    + <alloy::sol_types::sol_data::Bool as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.refunded,
                    )
                    + <alloy::sol_types::sol_data::Uint<
                        64,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.totalTimeUnrivaledCache,
                    )
            }
            #[inline]
            fn encode_topic_preimage(
                rust: &Self::RustType,
                out: &mut alloy_sol_types::private::Vec<u8>,
            ) {
                out.reserve(
                    <Self as alloy_sol_types::EventTopic>::topic_preimage_length(rust),
                );
                <alloy::sol_types::sol_data::FixedBytes<
                    32,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.originId,
                    out,
                );
                <alloy::sol_types::sol_data::FixedBytes<
                    32,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.startHistoryRoot,
                    out,
                );
                <alloy::sol_types::sol_data::Uint<
                    256,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.startHeight,
                    out,
                );
                <alloy::sol_types::sol_data::FixedBytes<
                    32,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.endHistoryRoot,
                    out,
                );
                <alloy::sol_types::sol_data::Uint<
                    256,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.endHeight,
                    out,
                );
                <alloy::sol_types::sol_data::FixedBytes<
                    32,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.lowerChildId,
                    out,
                );
                <alloy::sol_types::sol_data::FixedBytes<
                    32,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.upperChildId,
                    out,
                );
                <alloy::sol_types::sol_data::FixedBytes<
                    32,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.claimId,
                    out,
                );
                <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.staker,
                    out,
                );
                <alloy::sol_types::sol_data::Uint<
                    64,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.createdAtBlock,
                    out,
                );
                <alloy::sol_types::sol_data::Uint<
                    64,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.confirmedAtBlock,
                    out,
                );
                <EdgeStatus as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.status,
                    out,
                );
                <alloy::sol_types::sol_data::Uint<
                    8,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.level,
                    out,
                );
                <alloy::sol_types::sol_data::Bool as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.refunded,
                    out,
                );
                <alloy::sol_types::sol_data::Uint<
                    64,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.totalTimeUnrivaledCache,
                    out,
                );
            }
            #[inline]
            fn encode_topic(
                rust: &Self::RustType,
            ) -> alloy_sol_types::abi::token::WordToken {
                let mut out = alloy_sol_types::private::Vec::new();
                <Self as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    rust,
                    &mut out,
                );
                alloy_sol_types::abi::token::WordToken(
                    alloy_sol_types::private::keccak256(out),
                )
            }
        }
    };
    /**Custom error with signature `ChildrenAlreadySet(bytes32,bytes32,bytes32)` and selector `0x8b0e71d0`.
```solidity
error ChildrenAlreadySet(bytes32 edgeId, bytes32 lowerChildId, bytes32 upperChildId);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct ChildrenAlreadySet {
        #[allow(missing_docs)]
        pub edgeId: alloy::sol_types::private::FixedBytes<32>,
        #[allow(missing_docs)]
        pub lowerChildId: alloy::sol_types::private::FixedBytes<32>,
        #[allow(missing_docs)]
        pub upperChildId: alloy::sol_types::private::FixedBytes<32>,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = (
            alloy::sol_types::sol_data::FixedBytes<32>,
            alloy::sol_types::sol_data::FixedBytes<32>,
            alloy::sol_types::sol_data::FixedBytes<32>,
        );
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = (
            alloy::sol_types::private::FixedBytes<32>,
            alloy::sol_types::private::FixedBytes<32>,
            alloy::sol_types::private::FixedBytes<32>,
        );
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<ChildrenAlreadySet> for UnderlyingRustTuple<'_> {
            fn from(value: ChildrenAlreadySet) -> Self {
                (value.edgeId, value.lowerChildId, value.upperChildId)
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for ChildrenAlreadySet {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self {
                    edgeId: tuple.0,
                    lowerChildId: tuple.1,
                    upperChildId: tuple.2,
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for ChildrenAlreadySet {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "ChildrenAlreadySet(bytes32,bytes32,bytes32)";
            const SELECTOR: [u8; 4] = [139u8, 14u8, 113u8, 208u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.edgeId),
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.lowerChildId),
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.upperChildId),
                )
            }
        }
    };
    /**Custom error with signature `EdgeAlreadyRefunded(bytes32)` and selector `0x307f7669`.
```solidity
error EdgeAlreadyRefunded(bytes32 edgeId);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct EdgeAlreadyRefunded {
        #[allow(missing_docs)]
        pub edgeId: alloy::sol_types::private::FixedBytes<32>,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::FixedBytes<32>,);
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = (alloy::sol_types::private::FixedBytes<32>,);
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<EdgeAlreadyRefunded> for UnderlyingRustTuple<'_> {
            fn from(value: EdgeAlreadyRefunded) -> Self {
                (value.edgeId,)
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for EdgeAlreadyRefunded {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self { edgeId: tuple.0 }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for EdgeAlreadyRefunded {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "EdgeAlreadyRefunded(bytes32)";
            const SELECTOR: [u8; 4] = [48u8, 127u8, 118u8, 105u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.edgeId),
                )
            }
        }
    };
    /**Custom error with signature `EdgeNotConfirmed(bytes32,uint8)` and selector `0xef1267b4`.
```solidity
error EdgeNotConfirmed(bytes32 edgeId, EdgeStatus);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct EdgeNotConfirmed {
        #[allow(missing_docs)]
        pub edgeId: alloy::sol_types::private::FixedBytes<32>,
        #[allow(missing_docs)]
        pub _1: <EdgeStatus as alloy::sol_types::SolType>::RustType,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = (
            alloy::sol_types::sol_data::FixedBytes<32>,
            EdgeStatus,
        );
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = (
            alloy::sol_types::private::FixedBytes<32>,
            <EdgeStatus as alloy::sol_types::SolType>::RustType,
        );
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<EdgeNotConfirmed> for UnderlyingRustTuple<'_> {
            fn from(value: EdgeNotConfirmed) -> Self {
                (value.edgeId, value._1)
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for EdgeNotConfirmed {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self {
                    edgeId: tuple.0,
                    _1: tuple.1,
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for EdgeNotConfirmed {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "EdgeNotConfirmed(bytes32,uint8)";
            const SELECTOR: [u8; 4] = [239u8, 18u8, 103u8, 180u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.edgeId),
                    <EdgeStatus as alloy_sol_types::SolType>::tokenize(&self._1),
                )
            }
        }
    };
    /**Custom error with signature `EdgeNotExists(bytes32)` and selector `0x00a7b02b`.
```solidity
error EdgeNotExists(bytes32 edgeId);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct EdgeNotExists {
        #[allow(missing_docs)]
        pub edgeId: alloy::sol_types::private::FixedBytes<32>,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::FixedBytes<32>,);
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = (alloy::sol_types::private::FixedBytes<32>,);
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<EdgeNotExists> for UnderlyingRustTuple<'_> {
            fn from(value: EdgeNotExists) -> Self {
                (value.edgeId,)
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for EdgeNotExists {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self { edgeId: tuple.0 }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for EdgeNotExists {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "EdgeNotExists(bytes32)";
            const SELECTOR: [u8; 4] = [0u8, 167u8, 176u8, 43u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.edgeId),
                )
            }
        }
    };
    /**Custom error with signature `EdgeNotLayerZero(bytes32,address,bytes32)` and selector `0xe58c8308`.
```solidity
error EdgeNotLayerZero(bytes32 edgeId, address staker, bytes32 claimId);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct EdgeNotLayerZero {
        #[allow(missing_docs)]
        pub edgeId: alloy::sol_types::private::FixedBytes<32>,
        #[allow(missing_docs)]
        pub staker: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub claimId: alloy::sol_types::private::FixedBytes<32>,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = (
            alloy::sol_types::sol_data::FixedBytes<32>,
            alloy::sol_types::sol_data::Address,
            alloy::sol_types::sol_data::FixedBytes<32>,
        );
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = (
            alloy::sol_types::private::FixedBytes<32>,
            alloy::sol_types::private::Address,
            alloy::sol_types::private::FixedBytes<32>,
        );
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<EdgeNotLayerZero> for UnderlyingRustTuple<'_> {
            fn from(value: EdgeNotLayerZero) -> Self {
                (value.edgeId, value.staker, value.claimId)
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for EdgeNotLayerZero {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self {
                    edgeId: tuple.0,
                    staker: tuple.1,
                    claimId: tuple.2,
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for EdgeNotLayerZero {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "EdgeNotLayerZero(bytes32,address,bytes32)";
            const SELECTOR: [u8; 4] = [229u8, 140u8, 131u8, 8u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.edgeId),
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.staker,
                    ),
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.claimId),
                )
            }
        }
    };
    /**Custom error with signature `EdgeNotPending(bytes32,uint8)` and selector `0x23f8405d`.
```solidity
error EdgeNotPending(bytes32 edgeId, EdgeStatus status);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct EdgeNotPending {
        #[allow(missing_docs)]
        pub edgeId: alloy::sol_types::private::FixedBytes<32>,
        #[allow(missing_docs)]
        pub status: <EdgeStatus as alloy::sol_types::SolType>::RustType,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = (
            alloy::sol_types::sol_data::FixedBytes<32>,
            EdgeStatus,
        );
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = (
            alloy::sol_types::private::FixedBytes<32>,
            <EdgeStatus as alloy::sol_types::SolType>::RustType,
        );
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<EdgeNotPending> for UnderlyingRustTuple<'_> {
            fn from(value: EdgeNotPending) -> Self {
                (value.edgeId, value.status)
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for EdgeNotPending {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self {
                    edgeId: tuple.0,
                    status: tuple.1,
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for EdgeNotPending {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "EdgeNotPending(bytes32,uint8)";
            const SELECTOR: [u8; 4] = [35u8, 248u8, 64u8, 93u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.edgeId),
                    <EdgeStatus as alloy_sol_types::SolType>::tokenize(&self.status),
                )
            }
        }
    };
    /**Custom error with signature `EmptyClaimId()` and selector `0x6932bcfd`.
```solidity
error EmptyClaimId();
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct EmptyClaimId {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = ();
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = ();
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<EmptyClaimId> for UnderlyingRustTuple<'_> {
            fn from(value: EmptyClaimId) -> Self {
                ()
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for EmptyClaimId {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self {}
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for EmptyClaimId {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "EmptyClaimId()";
            const SELECTOR: [u8; 4] = [105u8, 50u8, 188u8, 253u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
        }
    };
    /**Custom error with signature `EmptyEndRoot()` and selector `0x5cb6e5bb`.
```solidity
error EmptyEndRoot();
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct EmptyEndRoot {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = ();
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = ();
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<EmptyEndRoot> for UnderlyingRustTuple<'_> {
            fn from(value: EmptyEndRoot) -> Self {
                ()
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for EmptyEndRoot {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self {}
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for EmptyEndRoot {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "EmptyEndRoot()";
            const SELECTOR: [u8; 4] = [92u8, 182u8, 229u8, 187u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
        }
    };
    /**Custom error with signature `EmptyOriginId()` and selector `0x8d79dbbc`.
```solidity
error EmptyOriginId();
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct EmptyOriginId {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = ();
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = ();
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<EmptyOriginId> for UnderlyingRustTuple<'_> {
            fn from(value: EmptyOriginId) -> Self {
                ()
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for EmptyOriginId {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self {}
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for EmptyOriginId {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "EmptyOriginId()";
            const SELECTOR: [u8; 4] = [141u8, 121u8, 219u8, 188u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
        }
    };
    /**Custom error with signature `EmptyStaker()` and selector `0xf289e657`.
```solidity
error EmptyStaker();
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct EmptyStaker {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = ();
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = ();
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<EmptyStaker> for UnderlyingRustTuple<'_> {
            fn from(value: EmptyStaker) -> Self {
                ()
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for EmptyStaker {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self {}
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for EmptyStaker {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "EmptyStaker()";
            const SELECTOR: [u8; 4] = [242u8, 137u8, 230u8, 87u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
        }
    };
    /**Custom error with signature `EmptyStartRoot()` and selector `0x83c683e4`.
```solidity
error EmptyStartRoot();
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct EmptyStartRoot {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = ();
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = ();
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<EmptyStartRoot> for UnderlyingRustTuple<'_> {
            fn from(value: EmptyStartRoot) -> Self {
                ()
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for EmptyStartRoot {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self {}
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for EmptyStartRoot {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "EmptyStartRoot()";
            const SELECTOR: [u8; 4] = [131u8, 198u8, 131u8, 228u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
        }
    };
    /**Custom error with signature `InvalidHeights(uint256,uint256)` and selector `0x2060faf4`.
```solidity
error InvalidHeights(uint256 start, uint256 end);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct InvalidHeights {
        #[allow(missing_docs)]
        pub start: alloy::sol_types::private::primitives::aliases::U256,
        #[allow(missing_docs)]
        pub end: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = (
            alloy::sol_types::sol_data::Uint<256>,
            alloy::sol_types::sol_data::Uint<256>,
        );
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = (
            alloy::sol_types::private::primitives::aliases::U256,
            alloy::sol_types::private::primitives::aliases::U256,
        );
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<InvalidHeights> for UnderlyingRustTuple<'_> {
            fn from(value: InvalidHeights) -> Self {
                (value.start, value.end)
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for InvalidHeights {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self {
                    start: tuple.0,
                    end: tuple.1,
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for InvalidHeights {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "InvalidHeights(uint256,uint256)";
            const SELECTOR: [u8; 4] = [32u8, 96u8, 250u8, 244u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.start),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.end),
                )
            }
        }
    };
    /**Custom error with signature `LevelTooHigh(uint8,uint8)` and selector `0xae0da578`.
```solidity
error LevelTooHigh(uint8 level, uint8 numBigStepLevels);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct LevelTooHigh {
        #[allow(missing_docs)]
        pub level: u8,
        #[allow(missing_docs)]
        pub numBigStepLevels: u8,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = (
            alloy::sol_types::sol_data::Uint<8>,
            alloy::sol_types::sol_data::Uint<8>,
        );
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = (u8, u8);
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<LevelTooHigh> for UnderlyingRustTuple<'_> {
            fn from(value: LevelTooHigh) -> Self {
                (value.level, value.numBigStepLevels)
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for LevelTooHigh {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self {
                    level: tuple.0,
                    numBigStepLevels: tuple.1,
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for LevelTooHigh {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "LevelTooHigh(uint8,uint8)";
            const SELECTOR: [u8; 4] = [174u8, 13u8, 165u8, 120u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        8,
                    > as alloy_sol_types::SolType>::tokenize(&self.level),
                    <alloy::sol_types::sol_data::Uint<
                        8,
                    > as alloy_sol_types::SolType>::tokenize(&self.numBigStepLevels),
                )
            }
        }
    };
    /**Function with signature `deleteChallengeEdge()` and selector `0xaf77dddc`.
```solidity
function deleteChallengeEdge() external;
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct deleteChallengeEdgeCall {}
    ///Container type for the return parameters of the [`deleteChallengeEdge()`](deleteChallengeEdgeCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct deleteChallengeEdgeReturn {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<deleteChallengeEdgeCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: deleteChallengeEdgeCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for deleteChallengeEdgeCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<deleteChallengeEdgeReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: deleteChallengeEdgeReturn) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for deleteChallengeEdgeReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for deleteChallengeEdgeCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = deleteChallengeEdgeReturn;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "deleteChallengeEdge()";
            const SELECTOR: [u8; 4] = [175u8, 119u8, 221u8, 220u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `exists()` and selector `0x267c4ae4`.
```solidity
function exists() external view returns (bool);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct existsCall {}
    ///Container type for the return parameters of the [`exists()`](existsCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct existsReturn {
        #[allow(missing_docs)]
        pub _0: bool,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<existsCall> for UnderlyingRustTuple<'_> {
                fn from(value: existsCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for existsCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Bool,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (bool,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<existsReturn> for UnderlyingRustTuple<'_> {
                fn from(value: existsReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for existsReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for existsCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = existsReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Bool,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "exists()";
            const SELECTOR: [u8; 4] = [38u8, 124u8, 74u8, 228u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `getChallengeEdge()` and selector `0x9689d175`.
```solidity
function getChallengeEdge() external view returns (ChallengeEdge memory);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct getChallengeEdgeCall {}
    ///Container type for the return parameters of the [`getChallengeEdge()`](getChallengeEdgeCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct getChallengeEdgeReturn {
        #[allow(missing_docs)]
        pub _0: <ChallengeEdge as alloy::sol_types::SolType>::RustType,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<getChallengeEdgeCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: getChallengeEdgeCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for getChallengeEdgeCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (ChallengeEdge,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                <ChallengeEdge as alloy::sol_types::SolType>::RustType,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<getChallengeEdgeReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: getChallengeEdgeReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for getChallengeEdgeReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for getChallengeEdgeCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = getChallengeEdgeReturn;
            type ReturnTuple<'a> = (ChallengeEdge,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "getChallengeEdge()";
            const SELECTOR: [u8; 4] = [150u8, 137u8, 209u8, 117u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `id()` and selector `0xaf640d0f`.
```solidity
function id() external view returns (bytes32);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct idCall {}
    ///Container type for the return parameters of the [`id()`](idCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct idReturn {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::FixedBytes<32>,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<idCall> for UnderlyingRustTuple<'_> {
                fn from(value: idCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for idCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::FixedBytes<32>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::FixedBytes<32>,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<idReturn> for UnderlyingRustTuple<'_> {
                fn from(value: idReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for idReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for idCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = idReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::FixedBytes<32>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "id()";
            const SELECTOR: [u8; 4] = [175u8, 100u8, 13u8, 15u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `idComponent(uint8,bytes32,uint256,bytes32,uint256,bytes32)` and selector `0x6af3eca8`.
```solidity
function idComponent(uint8 level, bytes32 originId, uint256 startHeight, bytes32 startHistoryRoot, uint256 endHeight, bytes32 endHistoryRoot) external pure returns (bytes32);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct idComponentCall {
        #[allow(missing_docs)]
        pub level: u8,
        #[allow(missing_docs)]
        pub originId: alloy::sol_types::private::FixedBytes<32>,
        #[allow(missing_docs)]
        pub startHeight: alloy::sol_types::private::primitives::aliases::U256,
        #[allow(missing_docs)]
        pub startHistoryRoot: alloy::sol_types::private::FixedBytes<32>,
        #[allow(missing_docs)]
        pub endHeight: alloy::sol_types::private::primitives::aliases::U256,
        #[allow(missing_docs)]
        pub endHistoryRoot: alloy::sol_types::private::FixedBytes<32>,
    }
    ///Container type for the return parameters of the [`idComponent(uint8,bytes32,uint256,bytes32,uint256,bytes32)`](idComponentCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct idComponentReturn {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::FixedBytes<32>,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::Uint<8>,
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::FixedBytes<32>,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                u8,
                alloy::sol_types::private::FixedBytes<32>,
                alloy::sol_types::private::primitives::aliases::U256,
                alloy::sol_types::private::FixedBytes<32>,
                alloy::sol_types::private::primitives::aliases::U256,
                alloy::sol_types::private::FixedBytes<32>,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<idComponentCall> for UnderlyingRustTuple<'_> {
                fn from(value: idComponentCall) -> Self {
                    (
                        value.level,
                        value.originId,
                        value.startHeight,
                        value.startHistoryRoot,
                        value.endHeight,
                        value.endHistoryRoot,
                    )
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for idComponentCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        level: tuple.0,
                        originId: tuple.1,
                        startHeight: tuple.2,
                        startHistoryRoot: tuple.3,
                        endHeight: tuple.4,
                        endHistoryRoot: tuple.5,
                    }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::FixedBytes<32>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::FixedBytes<32>,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<idComponentReturn> for UnderlyingRustTuple<'_> {
                fn from(value: idComponentReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for idComponentReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for idComponentCall {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::Uint<8>,
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::FixedBytes<32>,
            );
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = idComponentReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::FixedBytes<32>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "idComponent(uint8,bytes32,uint256,bytes32,uint256,bytes32)";
            const SELECTOR: [u8; 4] = [106u8, 243u8, 236u8, 168u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        8,
                    > as alloy_sol_types::SolType>::tokenize(&self.level),
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.originId),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.startHeight),
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.startHistoryRoot),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.endHeight),
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.endHistoryRoot),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `idMem((bytes32,bytes32,uint256,bytes32,uint256,bytes32,bytes32,bytes32,address,uint64,uint64,uint8,uint8,bool,uint64))` and selector `0x8bc53485`.
```solidity
function idMem(ChallengeEdge memory edge) external pure returns (bytes32);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct idMemCall {
        #[allow(missing_docs)]
        pub edge: <ChallengeEdge as alloy::sol_types::SolType>::RustType,
    }
    ///Container type for the return parameters of the [`idMem((bytes32,bytes32,uint256,bytes32,uint256,bytes32,bytes32,bytes32,address,uint64,uint64,uint8,uint8,bool,uint64))`](idMemCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct idMemReturn {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::FixedBytes<32>,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (ChallengeEdge,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                <ChallengeEdge as alloy::sol_types::SolType>::RustType,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<idMemCall> for UnderlyingRustTuple<'_> {
                fn from(value: idMemCall) -> Self {
                    (value.edge,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for idMemCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { edge: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::FixedBytes<32>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::FixedBytes<32>,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<idMemReturn> for UnderlyingRustTuple<'_> {
                fn from(value: idMemReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for idMemReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for idMemCall {
            type Parameters<'a> = (ChallengeEdge,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = idMemReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::FixedBytes<32>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "idMem((bytes32,bytes32,uint256,bytes32,uint256,bytes32,bytes32,bytes32,address,uint64,uint64,uint8,uint8,bool,uint64))";
            const SELECTOR: [u8; 4] = [139u8, 197u8, 52u8, 133u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (<ChallengeEdge as alloy_sol_types::SolType>::tokenize(&self.edge),)
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `isLayerZero()` and selector `0x878b5f1c`.
```solidity
function isLayerZero() external view returns (bool);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct isLayerZeroCall {}
    ///Container type for the return parameters of the [`isLayerZero()`](isLayerZeroCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct isLayerZeroReturn {
        #[allow(missing_docs)]
        pub _0: bool,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<isLayerZeroCall> for UnderlyingRustTuple<'_> {
                fn from(value: isLayerZeroCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for isLayerZeroCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Bool,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (bool,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<isLayerZeroReturn> for UnderlyingRustTuple<'_> {
                fn from(value: isLayerZeroReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for isLayerZeroReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for isLayerZeroCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = isLayerZeroReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Bool,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "isLayerZero()";
            const SELECTOR: [u8; 4] = [135u8, 139u8, 95u8, 28u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `length()` and selector `0x1f7b6d32`.
```solidity
function length() external view returns (uint256);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct lengthCall {}
    ///Container type for the return parameters of the [`length()`](lengthCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct lengthReturn {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<lengthCall> for UnderlyingRustTuple<'_> {
                fn from(value: lengthCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for lengthCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<lengthReturn> for UnderlyingRustTuple<'_> {
                fn from(value: lengthReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for lengthReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for lengthCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = lengthReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "length()";
            const SELECTOR: [u8; 4] = [31u8, 123u8, 109u8, 50u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `levelToType(uint8,uint8)` and selector `0xa7d00249`.
```solidity
function levelToType(uint8 level, uint8 numBigStepLevels) external pure returns (EdgeType eType);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct levelToTypeCall {
        #[allow(missing_docs)]
        pub level: u8,
        #[allow(missing_docs)]
        pub numBigStepLevels: u8,
    }
    ///Container type for the return parameters of the [`levelToType(uint8,uint8)`](levelToTypeCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct levelToTypeReturn {
        #[allow(missing_docs)]
        pub eType: <EdgeType as alloy::sol_types::SolType>::RustType,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::Uint<8>,
                alloy::sol_types::sol_data::Uint<8>,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (u8, u8);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<levelToTypeCall> for UnderlyingRustTuple<'_> {
                fn from(value: levelToTypeCall) -> Self {
                    (value.level, value.numBigStepLevels)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for levelToTypeCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        level: tuple.0,
                        numBigStepLevels: tuple.1,
                    }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (EdgeType,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                <EdgeType as alloy::sol_types::SolType>::RustType,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<levelToTypeReturn> for UnderlyingRustTuple<'_> {
                fn from(value: levelToTypeReturn) -> Self {
                    (value.eType,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for levelToTypeReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { eType: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for levelToTypeCall {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::Uint<8>,
                alloy::sol_types::sol_data::Uint<8>,
            );
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = levelToTypeReturn;
            type ReturnTuple<'a> = (EdgeType,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "levelToType(uint8,uint8)";
            const SELECTOR: [u8; 4] = [167u8, 208u8, 2u8, 73u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        8,
                    > as alloy_sol_types::SolType>::tokenize(&self.level),
                    <alloy::sol_types::sol_data::Uint<
                        8,
                    > as alloy_sol_types::SolType>::tokenize(&self.numBigStepLevels),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `mutualId()` and selector `0xb845b499`.
```solidity
function mutualId() external view returns (bytes32);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct mutualIdCall {}
    ///Container type for the return parameters of the [`mutualId()`](mutualIdCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct mutualIdReturn {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::FixedBytes<32>,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<mutualIdCall> for UnderlyingRustTuple<'_> {
                fn from(value: mutualIdCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for mutualIdCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::FixedBytes<32>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::FixedBytes<32>,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<mutualIdReturn> for UnderlyingRustTuple<'_> {
                fn from(value: mutualIdReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for mutualIdReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for mutualIdCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = mutualIdReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::FixedBytes<32>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "mutualId()";
            const SELECTOR: [u8; 4] = [184u8, 69u8, 180u8, 153u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `mutualIdComponent(uint8,bytes32,uint256,bytes32,uint256)` and selector `0x07eae6d7`.
```solidity
function mutualIdComponent(uint8 level, bytes32 originId, uint256 startHeight, bytes32 startHistoryRoot, uint256 endHeight) external pure returns (bytes32);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct mutualIdComponentCall {
        #[allow(missing_docs)]
        pub level: u8,
        #[allow(missing_docs)]
        pub originId: alloy::sol_types::private::FixedBytes<32>,
        #[allow(missing_docs)]
        pub startHeight: alloy::sol_types::private::primitives::aliases::U256,
        #[allow(missing_docs)]
        pub startHistoryRoot: alloy::sol_types::private::FixedBytes<32>,
        #[allow(missing_docs)]
        pub endHeight: alloy::sol_types::private::primitives::aliases::U256,
    }
    ///Container type for the return parameters of the [`mutualIdComponent(uint8,bytes32,uint256,bytes32,uint256)`](mutualIdComponentCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct mutualIdComponentReturn {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::FixedBytes<32>,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::Uint<8>,
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Uint<256>,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                u8,
                alloy::sol_types::private::FixedBytes<32>,
                alloy::sol_types::private::primitives::aliases::U256,
                alloy::sol_types::private::FixedBytes<32>,
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<mutualIdComponentCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: mutualIdComponentCall) -> Self {
                    (
                        value.level,
                        value.originId,
                        value.startHeight,
                        value.startHistoryRoot,
                        value.endHeight,
                    )
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for mutualIdComponentCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        level: tuple.0,
                        originId: tuple.1,
                        startHeight: tuple.2,
                        startHistoryRoot: tuple.3,
                        endHeight: tuple.4,
                    }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::FixedBytes<32>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::FixedBytes<32>,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<mutualIdComponentReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: mutualIdComponentReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for mutualIdComponentReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for mutualIdComponentCall {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::Uint<8>,
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Uint<256>,
            );
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = mutualIdComponentReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::FixedBytes<32>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "mutualIdComponent(uint8,bytes32,uint256,bytes32,uint256)";
            const SELECTOR: [u8; 4] = [7u8, 234u8, 230u8, 215u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        8,
                    > as alloy_sol_types::SolType>::tokenize(&self.level),
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.originId),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.startHeight),
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.startHistoryRoot),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.endHeight),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `mutualIdMem((bytes32,bytes32,uint256,bytes32,uint256,bytes32,bytes32,bytes32,address,uint64,uint64,uint8,uint8,bool,uint64))` and selector `0x012e9a6f`.
```solidity
function mutualIdMem(ChallengeEdge memory ce) external pure returns (bytes32);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct mutualIdMemCall {
        #[allow(missing_docs)]
        pub ce: <ChallengeEdge as alloy::sol_types::SolType>::RustType,
    }
    ///Container type for the return parameters of the [`mutualIdMem((bytes32,bytes32,uint256,bytes32,uint256,bytes32,bytes32,bytes32,address,uint64,uint64,uint8,uint8,bool,uint64))`](mutualIdMemCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct mutualIdMemReturn {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::FixedBytes<32>,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (ChallengeEdge,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                <ChallengeEdge as alloy::sol_types::SolType>::RustType,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<mutualIdMemCall> for UnderlyingRustTuple<'_> {
                fn from(value: mutualIdMemCall) -> Self {
                    (value.ce,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for mutualIdMemCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { ce: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::FixedBytes<32>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::FixedBytes<32>,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<mutualIdMemReturn> for UnderlyingRustTuple<'_> {
                fn from(value: mutualIdMemReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for mutualIdMemReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for mutualIdMemCall {
            type Parameters<'a> = (ChallengeEdge,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = mutualIdMemReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::FixedBytes<32>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "mutualIdMem((bytes32,bytes32,uint256,bytes32,uint256,bytes32,bytes32,bytes32,address,uint64,uint64,uint8,uint8,bool,uint64))";
            const SELECTOR: [u8; 4] = [1u8, 46u8, 154u8, 111u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (<ChallengeEdge as alloy_sol_types::SolType>::tokenize(&self.ce),)
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `newChildEdge(bytes32,bytes32,uint256,bytes32,uint256,uint8)` and selector `0x8cb30f2d`.
```solidity
function newChildEdge(bytes32 originId, bytes32 startHistoryRoot, uint256 startHeight, bytes32 endHistoryRoot, uint256 endHeight, uint8 level) external view returns (ChallengeEdge memory);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct newChildEdgeCall {
        #[allow(missing_docs)]
        pub originId: alloy::sol_types::private::FixedBytes<32>,
        #[allow(missing_docs)]
        pub startHistoryRoot: alloy::sol_types::private::FixedBytes<32>,
        #[allow(missing_docs)]
        pub startHeight: alloy::sol_types::private::primitives::aliases::U256,
        #[allow(missing_docs)]
        pub endHistoryRoot: alloy::sol_types::private::FixedBytes<32>,
        #[allow(missing_docs)]
        pub endHeight: alloy::sol_types::private::primitives::aliases::U256,
        #[allow(missing_docs)]
        pub level: u8,
    }
    ///Container type for the return parameters of the [`newChildEdge(bytes32,bytes32,uint256,bytes32,uint256,uint8)`](newChildEdgeCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct newChildEdgeReturn {
        #[allow(missing_docs)]
        pub _0: <ChallengeEdge as alloy::sol_types::SolType>::RustType,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Uint<8>,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::FixedBytes<32>,
                alloy::sol_types::private::FixedBytes<32>,
                alloy::sol_types::private::primitives::aliases::U256,
                alloy::sol_types::private::FixedBytes<32>,
                alloy::sol_types::private::primitives::aliases::U256,
                u8,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<newChildEdgeCall> for UnderlyingRustTuple<'_> {
                fn from(value: newChildEdgeCall) -> Self {
                    (
                        value.originId,
                        value.startHistoryRoot,
                        value.startHeight,
                        value.endHistoryRoot,
                        value.endHeight,
                        value.level,
                    )
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for newChildEdgeCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        originId: tuple.0,
                        startHistoryRoot: tuple.1,
                        startHeight: tuple.2,
                        endHistoryRoot: tuple.3,
                        endHeight: tuple.4,
                        level: tuple.5,
                    }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (ChallengeEdge,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                <ChallengeEdge as alloy::sol_types::SolType>::RustType,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<newChildEdgeReturn> for UnderlyingRustTuple<'_> {
                fn from(value: newChildEdgeReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for newChildEdgeReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for newChildEdgeCall {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Uint<8>,
            );
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = newChildEdgeReturn;
            type ReturnTuple<'a> = (ChallengeEdge,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "newChildEdge(bytes32,bytes32,uint256,bytes32,uint256,uint8)";
            const SELECTOR: [u8; 4] = [140u8, 179u8, 15u8, 45u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.originId),
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.startHistoryRoot),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.startHeight),
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.endHistoryRoot),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.endHeight),
                    <alloy::sol_types::sol_data::Uint<
                        8,
                    > as alloy_sol_types::SolType>::tokenize(&self.level),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `newEdgeChecks(bytes32,bytes32,uint256,bytes32,uint256)` and selector `0x20cb1457`.
```solidity
function newEdgeChecks(bytes32 originId, bytes32 startHistoryRoot, uint256 startHeight, bytes32 endHistoryRoot, uint256 endHeight) external pure;
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct newEdgeChecksCall {
        #[allow(missing_docs)]
        pub originId: alloy::sol_types::private::FixedBytes<32>,
        #[allow(missing_docs)]
        pub startHistoryRoot: alloy::sol_types::private::FixedBytes<32>,
        #[allow(missing_docs)]
        pub startHeight: alloy::sol_types::private::primitives::aliases::U256,
        #[allow(missing_docs)]
        pub endHistoryRoot: alloy::sol_types::private::FixedBytes<32>,
        #[allow(missing_docs)]
        pub endHeight: alloy::sol_types::private::primitives::aliases::U256,
    }
    ///Container type for the return parameters of the [`newEdgeChecks(bytes32,bytes32,uint256,bytes32,uint256)`](newEdgeChecksCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct newEdgeChecksReturn {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Uint<256>,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::FixedBytes<32>,
                alloy::sol_types::private::FixedBytes<32>,
                alloy::sol_types::private::primitives::aliases::U256,
                alloy::sol_types::private::FixedBytes<32>,
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<newEdgeChecksCall> for UnderlyingRustTuple<'_> {
                fn from(value: newEdgeChecksCall) -> Self {
                    (
                        value.originId,
                        value.startHistoryRoot,
                        value.startHeight,
                        value.endHistoryRoot,
                        value.endHeight,
                    )
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for newEdgeChecksCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        originId: tuple.0,
                        startHistoryRoot: tuple.1,
                        startHeight: tuple.2,
                        endHistoryRoot: tuple.3,
                        endHeight: tuple.4,
                    }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<newEdgeChecksReturn> for UnderlyingRustTuple<'_> {
                fn from(value: newEdgeChecksReturn) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for newEdgeChecksReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for newEdgeChecksCall {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Uint<256>,
            );
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = newEdgeChecksReturn;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "newEdgeChecks(bytes32,bytes32,uint256,bytes32,uint256)";
            const SELECTOR: [u8; 4] = [32u8, 203u8, 20u8, 87u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.originId),
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.startHistoryRoot),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.startHeight),
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.endHistoryRoot),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.endHeight),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `newLayerZeroEdge(bytes32,bytes32,uint256,bytes32,uint256,bytes32,address,uint8)` and selector `0x786ac408`.
```solidity
function newLayerZeroEdge(bytes32 originId, bytes32 startHistoryRoot, uint256 startHeight, bytes32 endHistoryRoot, uint256 endHeight, bytes32 claimId, address staker, uint8 level) external view returns (ChallengeEdge memory);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct newLayerZeroEdgeCall {
        #[allow(missing_docs)]
        pub originId: alloy::sol_types::private::FixedBytes<32>,
        #[allow(missing_docs)]
        pub startHistoryRoot: alloy::sol_types::private::FixedBytes<32>,
        #[allow(missing_docs)]
        pub startHeight: alloy::sol_types::private::primitives::aliases::U256,
        #[allow(missing_docs)]
        pub endHistoryRoot: alloy::sol_types::private::FixedBytes<32>,
        #[allow(missing_docs)]
        pub endHeight: alloy::sol_types::private::primitives::aliases::U256,
        #[allow(missing_docs)]
        pub claimId: alloy::sol_types::private::FixedBytes<32>,
        #[allow(missing_docs)]
        pub staker: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub level: u8,
    }
    ///Container type for the return parameters of the [`newLayerZeroEdge(bytes32,bytes32,uint256,bytes32,uint256,bytes32,address,uint8)`](newLayerZeroEdgeCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct newLayerZeroEdgeReturn {
        #[allow(missing_docs)]
        pub _0: <ChallengeEdge as alloy::sol_types::SolType>::RustType,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Uint<8>,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::FixedBytes<32>,
                alloy::sol_types::private::FixedBytes<32>,
                alloy::sol_types::private::primitives::aliases::U256,
                alloy::sol_types::private::FixedBytes<32>,
                alloy::sol_types::private::primitives::aliases::U256,
                alloy::sol_types::private::FixedBytes<32>,
                alloy::sol_types::private::Address,
                u8,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<newLayerZeroEdgeCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: newLayerZeroEdgeCall) -> Self {
                    (
                        value.originId,
                        value.startHistoryRoot,
                        value.startHeight,
                        value.endHistoryRoot,
                        value.endHeight,
                        value.claimId,
                        value.staker,
                        value.level,
                    )
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for newLayerZeroEdgeCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        originId: tuple.0,
                        startHistoryRoot: tuple.1,
                        startHeight: tuple.2,
                        endHistoryRoot: tuple.3,
                        endHeight: tuple.4,
                        claimId: tuple.5,
                        staker: tuple.6,
                        level: tuple.7,
                    }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (ChallengeEdge,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                <ChallengeEdge as alloy::sol_types::SolType>::RustType,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<newLayerZeroEdgeReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: newLayerZeroEdgeReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for newLayerZeroEdgeReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for newLayerZeroEdgeCall {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Uint<8>,
            );
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = newLayerZeroEdgeReturn;
            type ReturnTuple<'a> = (ChallengeEdge,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "newLayerZeroEdge(bytes32,bytes32,uint256,bytes32,uint256,bytes32,address,uint8)";
            const SELECTOR: [u8; 4] = [120u8, 106u8, 196u8, 8u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.originId),
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.startHistoryRoot),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.startHeight),
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.endHistoryRoot),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.endHeight),
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.claimId),
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.staker,
                    ),
                    <alloy::sol_types::sol_data::Uint<
                        8,
                    > as alloy_sol_types::SolType>::tokenize(&self.level),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `setChallengeEdge((bytes32,bytes32,uint256,bytes32,uint256,bytes32,bytes32,bytes32,address,uint64,uint64,uint8,uint8,bool,uint64))` and selector `0x43e06f29`.
```solidity
function setChallengeEdge(ChallengeEdge memory edge) external;
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct setChallengeEdgeCall {
        #[allow(missing_docs)]
        pub edge: <ChallengeEdge as alloy::sol_types::SolType>::RustType,
    }
    ///Container type for the return parameters of the [`setChallengeEdge((bytes32,bytes32,uint256,bytes32,uint256,bytes32,bytes32,bytes32,address,uint64,uint64,uint8,uint8,bool,uint64))`](setChallengeEdgeCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct setChallengeEdgeReturn {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (ChallengeEdge,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                <ChallengeEdge as alloy::sol_types::SolType>::RustType,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<setChallengeEdgeCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: setChallengeEdgeCall) -> Self {
                    (value.edge,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for setChallengeEdgeCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { edge: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<setChallengeEdgeReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: setChallengeEdgeReturn) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for setChallengeEdgeReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for setChallengeEdgeCall {
            type Parameters<'a> = (ChallengeEdge,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = setChallengeEdgeReturn;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "setChallengeEdge((bytes32,bytes32,uint256,bytes32,uint256,bytes32,bytes32,bytes32,address,uint64,uint64,uint8,uint8,bool,uint64))";
            const SELECTOR: [u8; 4] = [67u8, 224u8, 111u8, 41u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (<ChallengeEdge as alloy_sol_types::SolType>::tokenize(&self.edge),)
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `setChildren(bytes32,bytes32)` and selector `0x5b6d1377`.
```solidity
function setChildren(bytes32 lowerChildId, bytes32 upperChildId) external;
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct setChildrenCall {
        #[allow(missing_docs)]
        pub lowerChildId: alloy::sol_types::private::FixedBytes<32>,
        #[allow(missing_docs)]
        pub upperChildId: alloy::sol_types::private::FixedBytes<32>,
    }
    ///Container type for the return parameters of the [`setChildren(bytes32,bytes32)`](setChildrenCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct setChildrenReturn {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<32>,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::FixedBytes<32>,
                alloy::sol_types::private::FixedBytes<32>,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<setChildrenCall> for UnderlyingRustTuple<'_> {
                fn from(value: setChildrenCall) -> Self {
                    (value.lowerChildId, value.upperChildId)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for setChildrenCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        lowerChildId: tuple.0,
                        upperChildId: tuple.1,
                    }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<setChildrenReturn> for UnderlyingRustTuple<'_> {
                fn from(value: setChildrenReturn) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for setChildrenReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for setChildrenCall {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<32>,
            );
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = setChildrenReturn;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "setChildren(bytes32,bytes32)";
            const SELECTOR: [u8; 4] = [91u8, 109u8, 19u8, 119u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.lowerChildId),
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.upperChildId),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `setConfirmed()` and selector `0x41b98aa1`.
```solidity
function setConfirmed() external;
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct setConfirmedCall {}
    ///Container type for the return parameters of the [`setConfirmed()`](setConfirmedCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct setConfirmedReturn {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<setConfirmedCall> for UnderlyingRustTuple<'_> {
                fn from(value: setConfirmedCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for setConfirmedCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<setConfirmedReturn> for UnderlyingRustTuple<'_> {
                fn from(value: setConfirmedReturn) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for setConfirmedReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for setConfirmedCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = setConfirmedReturn;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "setConfirmed()";
            const SELECTOR: [u8; 4] = [65u8, 185u8, 138u8, 161u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `setRefunded()` and selector `0xe35b755c`.
```solidity
function setRefunded() external;
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct setRefundedCall {}
    ///Container type for the return parameters of the [`setRefunded()`](setRefundedCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct setRefundedReturn {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<setRefundedCall> for UnderlyingRustTuple<'_> {
                fn from(value: setRefundedCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for setRefundedCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<setRefundedReturn> for UnderlyingRustTuple<'_> {
                fn from(value: setRefundedReturn) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for setRefundedReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for setRefundedCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = setRefundedReturn;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "setRefunded()";
            const SELECTOR: [u8; 4] = [227u8, 91u8, 117u8, 92u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    ///Container for all the [`ChallengeEdgeLibAccess`](self) function calls.
    pub enum ChallengeEdgeLibAccessCalls {
        #[allow(missing_docs)]
        deleteChallengeEdge(deleteChallengeEdgeCall),
        #[allow(missing_docs)]
        exists(existsCall),
        #[allow(missing_docs)]
        getChallengeEdge(getChallengeEdgeCall),
        #[allow(missing_docs)]
        id(idCall),
        #[allow(missing_docs)]
        idComponent(idComponentCall),
        #[allow(missing_docs)]
        idMem(idMemCall),
        #[allow(missing_docs)]
        isLayerZero(isLayerZeroCall),
        #[allow(missing_docs)]
        length(lengthCall),
        #[allow(missing_docs)]
        levelToType(levelToTypeCall),
        #[allow(missing_docs)]
        mutualId(mutualIdCall),
        #[allow(missing_docs)]
        mutualIdComponent(mutualIdComponentCall),
        #[allow(missing_docs)]
        mutualIdMem(mutualIdMemCall),
        #[allow(missing_docs)]
        newChildEdge(newChildEdgeCall),
        #[allow(missing_docs)]
        newEdgeChecks(newEdgeChecksCall),
        #[allow(missing_docs)]
        newLayerZeroEdge(newLayerZeroEdgeCall),
        #[allow(missing_docs)]
        setChallengeEdge(setChallengeEdgeCall),
        #[allow(missing_docs)]
        setChildren(setChildrenCall),
        #[allow(missing_docs)]
        setConfirmed(setConfirmedCall),
        #[allow(missing_docs)]
        setRefunded(setRefundedCall),
    }
    #[automatically_derived]
    impl ChallengeEdgeLibAccessCalls {
        /// All the selectors of this enum.
        ///
        /// Note that the selectors might not be in the same order as the variants.
        /// No guarantees are made about the order of the selectors.
        ///
        /// Prefer using `SolInterface` methods instead.
        pub const SELECTORS: &'static [[u8; 4usize]] = &[
            [1u8, 46u8, 154u8, 111u8],
            [7u8, 234u8, 230u8, 215u8],
            [31u8, 123u8, 109u8, 50u8],
            [32u8, 203u8, 20u8, 87u8],
            [38u8, 124u8, 74u8, 228u8],
            [65u8, 185u8, 138u8, 161u8],
            [67u8, 224u8, 111u8, 41u8],
            [91u8, 109u8, 19u8, 119u8],
            [106u8, 243u8, 236u8, 168u8],
            [120u8, 106u8, 196u8, 8u8],
            [135u8, 139u8, 95u8, 28u8],
            [139u8, 197u8, 52u8, 133u8],
            [140u8, 179u8, 15u8, 45u8],
            [150u8, 137u8, 209u8, 117u8],
            [167u8, 208u8, 2u8, 73u8],
            [175u8, 100u8, 13u8, 15u8],
            [175u8, 119u8, 221u8, 220u8],
            [184u8, 69u8, 180u8, 153u8],
            [227u8, 91u8, 117u8, 92u8],
        ];
    }
    #[automatically_derived]
    impl alloy_sol_types::SolInterface for ChallengeEdgeLibAccessCalls {
        const NAME: &'static str = "ChallengeEdgeLibAccessCalls";
        const MIN_DATA_LENGTH: usize = 0usize;
        const COUNT: usize = 19usize;
        #[inline]
        fn selector(&self) -> [u8; 4] {
            match self {
                Self::deleteChallengeEdge(_) => {
                    <deleteChallengeEdgeCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::exists(_) => <existsCall as alloy_sol_types::SolCall>::SELECTOR,
                Self::getChallengeEdge(_) => {
                    <getChallengeEdgeCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::id(_) => <idCall as alloy_sol_types::SolCall>::SELECTOR,
                Self::idComponent(_) => {
                    <idComponentCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::idMem(_) => <idMemCall as alloy_sol_types::SolCall>::SELECTOR,
                Self::isLayerZero(_) => {
                    <isLayerZeroCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::length(_) => <lengthCall as alloy_sol_types::SolCall>::SELECTOR,
                Self::levelToType(_) => {
                    <levelToTypeCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::mutualId(_) => <mutualIdCall as alloy_sol_types::SolCall>::SELECTOR,
                Self::mutualIdComponent(_) => {
                    <mutualIdComponentCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::mutualIdMem(_) => {
                    <mutualIdMemCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::newChildEdge(_) => {
                    <newChildEdgeCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::newEdgeChecks(_) => {
                    <newEdgeChecksCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::newLayerZeroEdge(_) => {
                    <newLayerZeroEdgeCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::setChallengeEdge(_) => {
                    <setChallengeEdgeCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::setChildren(_) => {
                    <setChildrenCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::setConfirmed(_) => {
                    <setConfirmedCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::setRefunded(_) => {
                    <setRefundedCall as alloy_sol_types::SolCall>::SELECTOR
                }
            }
        }
        #[inline]
        fn selector_at(i: usize) -> ::core::option::Option<[u8; 4]> {
            Self::SELECTORS.get(i).copied()
        }
        #[inline]
        fn valid_selector(selector: [u8; 4]) -> bool {
            Self::SELECTORS.binary_search(&selector).is_ok()
        }
        #[inline]
        #[allow(non_snake_case)]
        fn abi_decode_raw(
            selector: [u8; 4],
            data: &[u8],
            validate: bool,
        ) -> alloy_sol_types::Result<Self> {
            static DECODE_SHIMS: &[fn(
                &[u8],
                bool,
            ) -> alloy_sol_types::Result<ChallengeEdgeLibAccessCalls>] = &[
                {
                    fn mutualIdMem(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<ChallengeEdgeLibAccessCalls> {
                        <mutualIdMemCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(ChallengeEdgeLibAccessCalls::mutualIdMem)
                    }
                    mutualIdMem
                },
                {
                    fn mutualIdComponent(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<ChallengeEdgeLibAccessCalls> {
                        <mutualIdComponentCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(ChallengeEdgeLibAccessCalls::mutualIdComponent)
                    }
                    mutualIdComponent
                },
                {
                    fn length(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<ChallengeEdgeLibAccessCalls> {
                        <lengthCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(ChallengeEdgeLibAccessCalls::length)
                    }
                    length
                },
                {
                    fn newEdgeChecks(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<ChallengeEdgeLibAccessCalls> {
                        <newEdgeChecksCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(ChallengeEdgeLibAccessCalls::newEdgeChecks)
                    }
                    newEdgeChecks
                },
                {
                    fn exists(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<ChallengeEdgeLibAccessCalls> {
                        <existsCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(ChallengeEdgeLibAccessCalls::exists)
                    }
                    exists
                },
                {
                    fn setConfirmed(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<ChallengeEdgeLibAccessCalls> {
                        <setConfirmedCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(ChallengeEdgeLibAccessCalls::setConfirmed)
                    }
                    setConfirmed
                },
                {
                    fn setChallengeEdge(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<ChallengeEdgeLibAccessCalls> {
                        <setChallengeEdgeCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(ChallengeEdgeLibAccessCalls::setChallengeEdge)
                    }
                    setChallengeEdge
                },
                {
                    fn setChildren(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<ChallengeEdgeLibAccessCalls> {
                        <setChildrenCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(ChallengeEdgeLibAccessCalls::setChildren)
                    }
                    setChildren
                },
                {
                    fn idComponent(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<ChallengeEdgeLibAccessCalls> {
                        <idComponentCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(ChallengeEdgeLibAccessCalls::idComponent)
                    }
                    idComponent
                },
                {
                    fn newLayerZeroEdge(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<ChallengeEdgeLibAccessCalls> {
                        <newLayerZeroEdgeCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(ChallengeEdgeLibAccessCalls::newLayerZeroEdge)
                    }
                    newLayerZeroEdge
                },
                {
                    fn isLayerZero(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<ChallengeEdgeLibAccessCalls> {
                        <isLayerZeroCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(ChallengeEdgeLibAccessCalls::isLayerZero)
                    }
                    isLayerZero
                },
                {
                    fn idMem(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<ChallengeEdgeLibAccessCalls> {
                        <idMemCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(ChallengeEdgeLibAccessCalls::idMem)
                    }
                    idMem
                },
                {
                    fn newChildEdge(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<ChallengeEdgeLibAccessCalls> {
                        <newChildEdgeCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(ChallengeEdgeLibAccessCalls::newChildEdge)
                    }
                    newChildEdge
                },
                {
                    fn getChallengeEdge(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<ChallengeEdgeLibAccessCalls> {
                        <getChallengeEdgeCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(ChallengeEdgeLibAccessCalls::getChallengeEdge)
                    }
                    getChallengeEdge
                },
                {
                    fn levelToType(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<ChallengeEdgeLibAccessCalls> {
                        <levelToTypeCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(ChallengeEdgeLibAccessCalls::levelToType)
                    }
                    levelToType
                },
                {
                    fn id(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<ChallengeEdgeLibAccessCalls> {
                        <idCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(ChallengeEdgeLibAccessCalls::id)
                    }
                    id
                },
                {
                    fn deleteChallengeEdge(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<ChallengeEdgeLibAccessCalls> {
                        <deleteChallengeEdgeCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(ChallengeEdgeLibAccessCalls::deleteChallengeEdge)
                    }
                    deleteChallengeEdge
                },
                {
                    fn mutualId(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<ChallengeEdgeLibAccessCalls> {
                        <mutualIdCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(ChallengeEdgeLibAccessCalls::mutualId)
                    }
                    mutualId
                },
                {
                    fn setRefunded(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<ChallengeEdgeLibAccessCalls> {
                        <setRefundedCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(ChallengeEdgeLibAccessCalls::setRefunded)
                    }
                    setRefunded
                },
            ];
            let Ok(idx) = Self::SELECTORS.binary_search(&selector) else {
                return Err(
                    alloy_sol_types::Error::unknown_selector(
                        <Self as alloy_sol_types::SolInterface>::NAME,
                        selector,
                    ),
                );
            };
            DECODE_SHIMS[idx](data, validate)
        }
        #[inline]
        fn abi_encoded_size(&self) -> usize {
            match self {
                Self::deleteChallengeEdge(inner) => {
                    <deleteChallengeEdgeCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::exists(inner) => {
                    <existsCall as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::getChallengeEdge(inner) => {
                    <getChallengeEdgeCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::id(inner) => {
                    <idCall as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::idComponent(inner) => {
                    <idComponentCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::idMem(inner) => {
                    <idMemCall as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::isLayerZero(inner) => {
                    <isLayerZeroCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::length(inner) => {
                    <lengthCall as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::levelToType(inner) => {
                    <levelToTypeCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::mutualId(inner) => {
                    <mutualIdCall as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::mutualIdComponent(inner) => {
                    <mutualIdComponentCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::mutualIdMem(inner) => {
                    <mutualIdMemCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::newChildEdge(inner) => {
                    <newChildEdgeCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::newEdgeChecks(inner) => {
                    <newEdgeChecksCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::newLayerZeroEdge(inner) => {
                    <newLayerZeroEdgeCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::setChallengeEdge(inner) => {
                    <setChallengeEdgeCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::setChildren(inner) => {
                    <setChildrenCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::setConfirmed(inner) => {
                    <setConfirmedCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::setRefunded(inner) => {
                    <setRefundedCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
            }
        }
        #[inline]
        fn abi_encode_raw(&self, out: &mut alloy_sol_types::private::Vec<u8>) {
            match self {
                Self::deleteChallengeEdge(inner) => {
                    <deleteChallengeEdgeCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::exists(inner) => {
                    <existsCall as alloy_sol_types::SolCall>::abi_encode_raw(inner, out)
                }
                Self::getChallengeEdge(inner) => {
                    <getChallengeEdgeCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::id(inner) => {
                    <idCall as alloy_sol_types::SolCall>::abi_encode_raw(inner, out)
                }
                Self::idComponent(inner) => {
                    <idComponentCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::idMem(inner) => {
                    <idMemCall as alloy_sol_types::SolCall>::abi_encode_raw(inner, out)
                }
                Self::isLayerZero(inner) => {
                    <isLayerZeroCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::length(inner) => {
                    <lengthCall as alloy_sol_types::SolCall>::abi_encode_raw(inner, out)
                }
                Self::levelToType(inner) => {
                    <levelToTypeCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::mutualId(inner) => {
                    <mutualIdCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::mutualIdComponent(inner) => {
                    <mutualIdComponentCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::mutualIdMem(inner) => {
                    <mutualIdMemCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::newChildEdge(inner) => {
                    <newChildEdgeCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::newEdgeChecks(inner) => {
                    <newEdgeChecksCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::newLayerZeroEdge(inner) => {
                    <newLayerZeroEdgeCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::setChallengeEdge(inner) => {
                    <setChallengeEdgeCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::setChildren(inner) => {
                    <setChildrenCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::setConfirmed(inner) => {
                    <setConfirmedCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::setRefunded(inner) => {
                    <setRefundedCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
            }
        }
    }
    ///Container for all the [`ChallengeEdgeLibAccess`](self) custom errors.
    pub enum ChallengeEdgeLibAccessErrors {
        #[allow(missing_docs)]
        ChildrenAlreadySet(ChildrenAlreadySet),
        #[allow(missing_docs)]
        EdgeAlreadyRefunded(EdgeAlreadyRefunded),
        #[allow(missing_docs)]
        EdgeNotConfirmed(EdgeNotConfirmed),
        #[allow(missing_docs)]
        EdgeNotExists(EdgeNotExists),
        #[allow(missing_docs)]
        EdgeNotLayerZero(EdgeNotLayerZero),
        #[allow(missing_docs)]
        EdgeNotPending(EdgeNotPending),
        #[allow(missing_docs)]
        EmptyClaimId(EmptyClaimId),
        #[allow(missing_docs)]
        EmptyEndRoot(EmptyEndRoot),
        #[allow(missing_docs)]
        EmptyOriginId(EmptyOriginId),
        #[allow(missing_docs)]
        EmptyStaker(EmptyStaker),
        #[allow(missing_docs)]
        EmptyStartRoot(EmptyStartRoot),
        #[allow(missing_docs)]
        InvalidHeights(InvalidHeights),
        #[allow(missing_docs)]
        LevelTooHigh(LevelTooHigh),
    }
    #[automatically_derived]
    impl ChallengeEdgeLibAccessErrors {
        /// All the selectors of this enum.
        ///
        /// Note that the selectors might not be in the same order as the variants.
        /// No guarantees are made about the order of the selectors.
        ///
        /// Prefer using `SolInterface` methods instead.
        pub const SELECTORS: &'static [[u8; 4usize]] = &[
            [0u8, 167u8, 176u8, 43u8],
            [32u8, 96u8, 250u8, 244u8],
            [35u8, 248u8, 64u8, 93u8],
            [48u8, 127u8, 118u8, 105u8],
            [92u8, 182u8, 229u8, 187u8],
            [105u8, 50u8, 188u8, 253u8],
            [131u8, 198u8, 131u8, 228u8],
            [139u8, 14u8, 113u8, 208u8],
            [141u8, 121u8, 219u8, 188u8],
            [174u8, 13u8, 165u8, 120u8],
            [229u8, 140u8, 131u8, 8u8],
            [239u8, 18u8, 103u8, 180u8],
            [242u8, 137u8, 230u8, 87u8],
        ];
    }
    #[automatically_derived]
    impl alloy_sol_types::SolInterface for ChallengeEdgeLibAccessErrors {
        const NAME: &'static str = "ChallengeEdgeLibAccessErrors";
        const MIN_DATA_LENGTH: usize = 0usize;
        const COUNT: usize = 13usize;
        #[inline]
        fn selector(&self) -> [u8; 4] {
            match self {
                Self::ChildrenAlreadySet(_) => {
                    <ChildrenAlreadySet as alloy_sol_types::SolError>::SELECTOR
                }
                Self::EdgeAlreadyRefunded(_) => {
                    <EdgeAlreadyRefunded as alloy_sol_types::SolError>::SELECTOR
                }
                Self::EdgeNotConfirmed(_) => {
                    <EdgeNotConfirmed as alloy_sol_types::SolError>::SELECTOR
                }
                Self::EdgeNotExists(_) => {
                    <EdgeNotExists as alloy_sol_types::SolError>::SELECTOR
                }
                Self::EdgeNotLayerZero(_) => {
                    <EdgeNotLayerZero as alloy_sol_types::SolError>::SELECTOR
                }
                Self::EdgeNotPending(_) => {
                    <EdgeNotPending as alloy_sol_types::SolError>::SELECTOR
                }
                Self::EmptyClaimId(_) => {
                    <EmptyClaimId as alloy_sol_types::SolError>::SELECTOR
                }
                Self::EmptyEndRoot(_) => {
                    <EmptyEndRoot as alloy_sol_types::SolError>::SELECTOR
                }
                Self::EmptyOriginId(_) => {
                    <EmptyOriginId as alloy_sol_types::SolError>::SELECTOR
                }
                Self::EmptyStaker(_) => {
                    <EmptyStaker as alloy_sol_types::SolError>::SELECTOR
                }
                Self::EmptyStartRoot(_) => {
                    <EmptyStartRoot as alloy_sol_types::SolError>::SELECTOR
                }
                Self::InvalidHeights(_) => {
                    <InvalidHeights as alloy_sol_types::SolError>::SELECTOR
                }
                Self::LevelTooHigh(_) => {
                    <LevelTooHigh as alloy_sol_types::SolError>::SELECTOR
                }
            }
        }
        #[inline]
        fn selector_at(i: usize) -> ::core::option::Option<[u8; 4]> {
            Self::SELECTORS.get(i).copied()
        }
        #[inline]
        fn valid_selector(selector: [u8; 4]) -> bool {
            Self::SELECTORS.binary_search(&selector).is_ok()
        }
        #[inline]
        #[allow(non_snake_case)]
        fn abi_decode_raw(
            selector: [u8; 4],
            data: &[u8],
            validate: bool,
        ) -> alloy_sol_types::Result<Self> {
            static DECODE_SHIMS: &[fn(
                &[u8],
                bool,
            ) -> alloy_sol_types::Result<ChallengeEdgeLibAccessErrors>] = &[
                {
                    fn EdgeNotExists(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<ChallengeEdgeLibAccessErrors> {
                        <EdgeNotExists as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(ChallengeEdgeLibAccessErrors::EdgeNotExists)
                    }
                    EdgeNotExists
                },
                {
                    fn InvalidHeights(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<ChallengeEdgeLibAccessErrors> {
                        <InvalidHeights as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(ChallengeEdgeLibAccessErrors::InvalidHeights)
                    }
                    InvalidHeights
                },
                {
                    fn EdgeNotPending(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<ChallengeEdgeLibAccessErrors> {
                        <EdgeNotPending as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(ChallengeEdgeLibAccessErrors::EdgeNotPending)
                    }
                    EdgeNotPending
                },
                {
                    fn EdgeAlreadyRefunded(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<ChallengeEdgeLibAccessErrors> {
                        <EdgeAlreadyRefunded as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(ChallengeEdgeLibAccessErrors::EdgeAlreadyRefunded)
                    }
                    EdgeAlreadyRefunded
                },
                {
                    fn EmptyEndRoot(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<ChallengeEdgeLibAccessErrors> {
                        <EmptyEndRoot as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(ChallengeEdgeLibAccessErrors::EmptyEndRoot)
                    }
                    EmptyEndRoot
                },
                {
                    fn EmptyClaimId(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<ChallengeEdgeLibAccessErrors> {
                        <EmptyClaimId as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(ChallengeEdgeLibAccessErrors::EmptyClaimId)
                    }
                    EmptyClaimId
                },
                {
                    fn EmptyStartRoot(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<ChallengeEdgeLibAccessErrors> {
                        <EmptyStartRoot as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(ChallengeEdgeLibAccessErrors::EmptyStartRoot)
                    }
                    EmptyStartRoot
                },
                {
                    fn ChildrenAlreadySet(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<ChallengeEdgeLibAccessErrors> {
                        <ChildrenAlreadySet as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(ChallengeEdgeLibAccessErrors::ChildrenAlreadySet)
                    }
                    ChildrenAlreadySet
                },
                {
                    fn EmptyOriginId(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<ChallengeEdgeLibAccessErrors> {
                        <EmptyOriginId as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(ChallengeEdgeLibAccessErrors::EmptyOriginId)
                    }
                    EmptyOriginId
                },
                {
                    fn LevelTooHigh(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<ChallengeEdgeLibAccessErrors> {
                        <LevelTooHigh as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(ChallengeEdgeLibAccessErrors::LevelTooHigh)
                    }
                    LevelTooHigh
                },
                {
                    fn EdgeNotLayerZero(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<ChallengeEdgeLibAccessErrors> {
                        <EdgeNotLayerZero as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(ChallengeEdgeLibAccessErrors::EdgeNotLayerZero)
                    }
                    EdgeNotLayerZero
                },
                {
                    fn EdgeNotConfirmed(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<ChallengeEdgeLibAccessErrors> {
                        <EdgeNotConfirmed as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(ChallengeEdgeLibAccessErrors::EdgeNotConfirmed)
                    }
                    EdgeNotConfirmed
                },
                {
                    fn EmptyStaker(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<ChallengeEdgeLibAccessErrors> {
                        <EmptyStaker as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(ChallengeEdgeLibAccessErrors::EmptyStaker)
                    }
                    EmptyStaker
                },
            ];
            let Ok(idx) = Self::SELECTORS.binary_search(&selector) else {
                return Err(
                    alloy_sol_types::Error::unknown_selector(
                        <Self as alloy_sol_types::SolInterface>::NAME,
                        selector,
                    ),
                );
            };
            DECODE_SHIMS[idx](data, validate)
        }
        #[inline]
        fn abi_encoded_size(&self) -> usize {
            match self {
                Self::ChildrenAlreadySet(inner) => {
                    <ChildrenAlreadySet as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::EdgeAlreadyRefunded(inner) => {
                    <EdgeAlreadyRefunded as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::EdgeNotConfirmed(inner) => {
                    <EdgeNotConfirmed as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::EdgeNotExists(inner) => {
                    <EdgeNotExists as alloy_sol_types::SolError>::abi_encoded_size(inner)
                }
                Self::EdgeNotLayerZero(inner) => {
                    <EdgeNotLayerZero as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::EdgeNotPending(inner) => {
                    <EdgeNotPending as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::EmptyClaimId(inner) => {
                    <EmptyClaimId as alloy_sol_types::SolError>::abi_encoded_size(inner)
                }
                Self::EmptyEndRoot(inner) => {
                    <EmptyEndRoot as alloy_sol_types::SolError>::abi_encoded_size(inner)
                }
                Self::EmptyOriginId(inner) => {
                    <EmptyOriginId as alloy_sol_types::SolError>::abi_encoded_size(inner)
                }
                Self::EmptyStaker(inner) => {
                    <EmptyStaker as alloy_sol_types::SolError>::abi_encoded_size(inner)
                }
                Self::EmptyStartRoot(inner) => {
                    <EmptyStartRoot as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::InvalidHeights(inner) => {
                    <InvalidHeights as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::LevelTooHigh(inner) => {
                    <LevelTooHigh as alloy_sol_types::SolError>::abi_encoded_size(inner)
                }
            }
        }
        #[inline]
        fn abi_encode_raw(&self, out: &mut alloy_sol_types::private::Vec<u8>) {
            match self {
                Self::ChildrenAlreadySet(inner) => {
                    <ChildrenAlreadySet as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::EdgeAlreadyRefunded(inner) => {
                    <EdgeAlreadyRefunded as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::EdgeNotConfirmed(inner) => {
                    <EdgeNotConfirmed as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::EdgeNotExists(inner) => {
                    <EdgeNotExists as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::EdgeNotLayerZero(inner) => {
                    <EdgeNotLayerZero as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::EdgeNotPending(inner) => {
                    <EdgeNotPending as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::EmptyClaimId(inner) => {
                    <EmptyClaimId as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::EmptyEndRoot(inner) => {
                    <EmptyEndRoot as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::EmptyOriginId(inner) => {
                    <EmptyOriginId as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::EmptyStaker(inner) => {
                    <EmptyStaker as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::EmptyStartRoot(inner) => {
                    <EmptyStartRoot as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::InvalidHeights(inner) => {
                    <InvalidHeights as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::LevelTooHigh(inner) => {
                    <LevelTooHigh as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
            }
        }
    }
    use alloy::contract as alloy_contract;
    /**Creates a new wrapper around an on-chain [`ChallengeEdgeLibAccess`](self) contract instance.

See the [wrapper's documentation](`ChallengeEdgeLibAccessInstance`) for more details.*/
    #[inline]
    pub const fn new<
        T: alloy_contract::private::Transport + ::core::clone::Clone,
        P: alloy_contract::private::Provider<T, N>,
        N: alloy_contract::private::Network,
    >(
        address: alloy_sol_types::private::Address,
        provider: P,
    ) -> ChallengeEdgeLibAccessInstance<T, P, N> {
        ChallengeEdgeLibAccessInstance::<T, P, N>::new(address, provider)
    }
    /**Deploys this contract using the given `provider` and constructor arguments, if any.

Returns a new instance of the contract, if the deployment was successful.

For more fine-grained control over the deployment process, use [`deploy_builder`] instead.*/
    #[inline]
    pub fn deploy<
        T: alloy_contract::private::Transport + ::core::clone::Clone,
        P: alloy_contract::private::Provider<T, N>,
        N: alloy_contract::private::Network,
    >(
        provider: P,
    ) -> impl ::core::future::Future<
        Output = alloy_contract::Result<ChallengeEdgeLibAccessInstance<T, P, N>>,
    > {
        ChallengeEdgeLibAccessInstance::<T, P, N>::deploy(provider)
    }
    /**Creates a `RawCallBuilder` for deploying this contract using the given `provider`
and constructor arguments, if any.

This is a simple wrapper around creating a `RawCallBuilder` with the data set to
the bytecode concatenated with the constructor's ABI-encoded arguments.*/
    #[inline]
    pub fn deploy_builder<
        T: alloy_contract::private::Transport + ::core::clone::Clone,
        P: alloy_contract::private::Provider<T, N>,
        N: alloy_contract::private::Network,
    >(provider: P) -> alloy_contract::RawCallBuilder<T, P, N> {
        ChallengeEdgeLibAccessInstance::<T, P, N>::deploy_builder(provider)
    }
    /**A [`ChallengeEdgeLibAccess`](self) instance.

Contains type-safe methods for interacting with an on-chain instance of the
[`ChallengeEdgeLibAccess`](self) contract located at a given `address`, using a given
provider `P`.

If the contract bytecode is available (see the [`sol!`](alloy_sol_types::sol!)
documentation on how to provide it), the `deploy` and `deploy_builder` methods can
be used to deploy a new instance of the contract.

See the [module-level documentation](self) for all the available methods.*/
    #[derive(Clone)]
    pub struct ChallengeEdgeLibAccessInstance<
        T,
        P,
        N = alloy_contract::private::Ethereum,
    > {
        address: alloy_sol_types::private::Address,
        provider: P,
        _network_transport: ::core::marker::PhantomData<(N, T)>,
    }
    #[automatically_derived]
    impl<T, P, N> ::core::fmt::Debug for ChallengeEdgeLibAccessInstance<T, P, N> {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
            f.debug_tuple("ChallengeEdgeLibAccessInstance").field(&self.address).finish()
        }
    }
    /// Instantiation and getters/setters.
    #[automatically_derived]
    impl<
        T: alloy_contract::private::Transport + ::core::clone::Clone,
        P: alloy_contract::private::Provider<T, N>,
        N: alloy_contract::private::Network,
    > ChallengeEdgeLibAccessInstance<T, P, N> {
        /**Creates a new wrapper around an on-chain [`ChallengeEdgeLibAccess`](self) contract instance.

See the [wrapper's documentation](`ChallengeEdgeLibAccessInstance`) for more details.*/
        #[inline]
        pub const fn new(
            address: alloy_sol_types::private::Address,
            provider: P,
        ) -> Self {
            Self {
                address,
                provider,
                _network_transport: ::core::marker::PhantomData,
            }
        }
        /**Deploys this contract using the given `provider` and constructor arguments, if any.

Returns a new instance of the contract, if the deployment was successful.

For more fine-grained control over the deployment process, use [`deploy_builder`] instead.*/
        #[inline]
        pub async fn deploy(
            provider: P,
        ) -> alloy_contract::Result<ChallengeEdgeLibAccessInstance<T, P, N>> {
            let call_builder = Self::deploy_builder(provider);
            let contract_address = call_builder.deploy().await?;
            Ok(Self::new(contract_address, call_builder.provider))
        }
        /**Creates a `RawCallBuilder` for deploying this contract using the given `provider`
and constructor arguments, if any.

This is a simple wrapper around creating a `RawCallBuilder` with the data set to
the bytecode concatenated with the constructor's ABI-encoded arguments.*/
        #[inline]
        pub fn deploy_builder(provider: P) -> alloy_contract::RawCallBuilder<T, P, N> {
            alloy_contract::RawCallBuilder::new_raw_deploy(
                provider,
                ::core::clone::Clone::clone(&BYTECODE),
            )
        }
        /// Returns a reference to the address.
        #[inline]
        pub const fn address(&self) -> &alloy_sol_types::private::Address {
            &self.address
        }
        /// Sets the address.
        #[inline]
        pub fn set_address(&mut self, address: alloy_sol_types::private::Address) {
            self.address = address;
        }
        /// Sets the address and returns `self`.
        pub fn at(mut self, address: alloy_sol_types::private::Address) -> Self {
            self.set_address(address);
            self
        }
        /// Returns a reference to the provider.
        #[inline]
        pub const fn provider(&self) -> &P {
            &self.provider
        }
    }
    impl<T, P: ::core::clone::Clone, N> ChallengeEdgeLibAccessInstance<T, &P, N> {
        /// Clones the provider and returns a new instance with the cloned provider.
        #[inline]
        pub fn with_cloned_provider(self) -> ChallengeEdgeLibAccessInstance<T, P, N> {
            ChallengeEdgeLibAccessInstance {
                address: self.address,
                provider: ::core::clone::Clone::clone(&self.provider),
                _network_transport: ::core::marker::PhantomData,
            }
        }
    }
    /// Function calls.
    #[automatically_derived]
    impl<
        T: alloy_contract::private::Transport + ::core::clone::Clone,
        P: alloy_contract::private::Provider<T, N>,
        N: alloy_contract::private::Network,
    > ChallengeEdgeLibAccessInstance<T, P, N> {
        /// Creates a new call builder using this contract instance's provider and address.
        ///
        /// Note that the call can be any function call, not just those defined in this
        /// contract. Prefer using the other methods for building type-safe contract calls.
        pub fn call_builder<C: alloy_sol_types::SolCall>(
            &self,
            call: &C,
        ) -> alloy_contract::SolCallBuilder<T, &P, C, N> {
            alloy_contract::SolCallBuilder::new_sol(&self.provider, &self.address, call)
        }
        ///Creates a new call builder for the [`deleteChallengeEdge`] function.
        pub fn deleteChallengeEdge(
            &self,
        ) -> alloy_contract::SolCallBuilder<T, &P, deleteChallengeEdgeCall, N> {
            self.call_builder(&deleteChallengeEdgeCall {})
        }
        ///Creates a new call builder for the [`exists`] function.
        pub fn exists(&self) -> alloy_contract::SolCallBuilder<T, &P, existsCall, N> {
            self.call_builder(&existsCall {})
        }
        ///Creates a new call builder for the [`getChallengeEdge`] function.
        pub fn getChallengeEdge(
            &self,
        ) -> alloy_contract::SolCallBuilder<T, &P, getChallengeEdgeCall, N> {
            self.call_builder(&getChallengeEdgeCall {})
        }
        ///Creates a new call builder for the [`id`] function.
        pub fn id(&self) -> alloy_contract::SolCallBuilder<T, &P, idCall, N> {
            self.call_builder(&idCall {})
        }
        ///Creates a new call builder for the [`idComponent`] function.
        pub fn idComponent(
            &self,
            level: u8,
            originId: alloy::sol_types::private::FixedBytes<32>,
            startHeight: alloy::sol_types::private::primitives::aliases::U256,
            startHistoryRoot: alloy::sol_types::private::FixedBytes<32>,
            endHeight: alloy::sol_types::private::primitives::aliases::U256,
            endHistoryRoot: alloy::sol_types::private::FixedBytes<32>,
        ) -> alloy_contract::SolCallBuilder<T, &P, idComponentCall, N> {
            self.call_builder(
                &idComponentCall {
                    level,
                    originId,
                    startHeight,
                    startHistoryRoot,
                    endHeight,
                    endHistoryRoot,
                },
            )
        }
        ///Creates a new call builder for the [`idMem`] function.
        pub fn idMem(
            &self,
            edge: <ChallengeEdge as alloy::sol_types::SolType>::RustType,
        ) -> alloy_contract::SolCallBuilder<T, &P, idMemCall, N> {
            self.call_builder(&idMemCall { edge })
        }
        ///Creates a new call builder for the [`isLayerZero`] function.
        pub fn isLayerZero(
            &self,
        ) -> alloy_contract::SolCallBuilder<T, &P, isLayerZeroCall, N> {
            self.call_builder(&isLayerZeroCall {})
        }
        ///Creates a new call builder for the [`length`] function.
        pub fn length(&self) -> alloy_contract::SolCallBuilder<T, &P, lengthCall, N> {
            self.call_builder(&lengthCall {})
        }
        ///Creates a new call builder for the [`levelToType`] function.
        pub fn levelToType(
            &self,
            level: u8,
            numBigStepLevels: u8,
        ) -> alloy_contract::SolCallBuilder<T, &P, levelToTypeCall, N> {
            self.call_builder(
                &levelToTypeCall {
                    level,
                    numBigStepLevels,
                },
            )
        }
        ///Creates a new call builder for the [`mutualId`] function.
        pub fn mutualId(
            &self,
        ) -> alloy_contract::SolCallBuilder<T, &P, mutualIdCall, N> {
            self.call_builder(&mutualIdCall {})
        }
        ///Creates a new call builder for the [`mutualIdComponent`] function.
        pub fn mutualIdComponent(
            &self,
            level: u8,
            originId: alloy::sol_types::private::FixedBytes<32>,
            startHeight: alloy::sol_types::private::primitives::aliases::U256,
            startHistoryRoot: alloy::sol_types::private::FixedBytes<32>,
            endHeight: alloy::sol_types::private::primitives::aliases::U256,
        ) -> alloy_contract::SolCallBuilder<T, &P, mutualIdComponentCall, N> {
            self.call_builder(
                &mutualIdComponentCall {
                    level,
                    originId,
                    startHeight,
                    startHistoryRoot,
                    endHeight,
                },
            )
        }
        ///Creates a new call builder for the [`mutualIdMem`] function.
        pub fn mutualIdMem(
            &self,
            ce: <ChallengeEdge as alloy::sol_types::SolType>::RustType,
        ) -> alloy_contract::SolCallBuilder<T, &P, mutualIdMemCall, N> {
            self.call_builder(&mutualIdMemCall { ce })
        }
        ///Creates a new call builder for the [`newChildEdge`] function.
        pub fn newChildEdge(
            &self,
            originId: alloy::sol_types::private::FixedBytes<32>,
            startHistoryRoot: alloy::sol_types::private::FixedBytes<32>,
            startHeight: alloy::sol_types::private::primitives::aliases::U256,
            endHistoryRoot: alloy::sol_types::private::FixedBytes<32>,
            endHeight: alloy::sol_types::private::primitives::aliases::U256,
            level: u8,
        ) -> alloy_contract::SolCallBuilder<T, &P, newChildEdgeCall, N> {
            self.call_builder(
                &newChildEdgeCall {
                    originId,
                    startHistoryRoot,
                    startHeight,
                    endHistoryRoot,
                    endHeight,
                    level,
                },
            )
        }
        ///Creates a new call builder for the [`newEdgeChecks`] function.
        pub fn newEdgeChecks(
            &self,
            originId: alloy::sol_types::private::FixedBytes<32>,
            startHistoryRoot: alloy::sol_types::private::FixedBytes<32>,
            startHeight: alloy::sol_types::private::primitives::aliases::U256,
            endHistoryRoot: alloy::sol_types::private::FixedBytes<32>,
            endHeight: alloy::sol_types::private::primitives::aliases::U256,
        ) -> alloy_contract::SolCallBuilder<T, &P, newEdgeChecksCall, N> {
            self.call_builder(
                &newEdgeChecksCall {
                    originId,
                    startHistoryRoot,
                    startHeight,
                    endHistoryRoot,
                    endHeight,
                },
            )
        }
        ///Creates a new call builder for the [`newLayerZeroEdge`] function.
        pub fn newLayerZeroEdge(
            &self,
            originId: alloy::sol_types::private::FixedBytes<32>,
            startHistoryRoot: alloy::sol_types::private::FixedBytes<32>,
            startHeight: alloy::sol_types::private::primitives::aliases::U256,
            endHistoryRoot: alloy::sol_types::private::FixedBytes<32>,
            endHeight: alloy::sol_types::private::primitives::aliases::U256,
            claimId: alloy::sol_types::private::FixedBytes<32>,
            staker: alloy::sol_types::private::Address,
            level: u8,
        ) -> alloy_contract::SolCallBuilder<T, &P, newLayerZeroEdgeCall, N> {
            self.call_builder(
                &newLayerZeroEdgeCall {
                    originId,
                    startHistoryRoot,
                    startHeight,
                    endHistoryRoot,
                    endHeight,
                    claimId,
                    staker,
                    level,
                },
            )
        }
        ///Creates a new call builder for the [`setChallengeEdge`] function.
        pub fn setChallengeEdge(
            &self,
            edge: <ChallengeEdge as alloy::sol_types::SolType>::RustType,
        ) -> alloy_contract::SolCallBuilder<T, &P, setChallengeEdgeCall, N> {
            self.call_builder(&setChallengeEdgeCall { edge })
        }
        ///Creates a new call builder for the [`setChildren`] function.
        pub fn setChildren(
            &self,
            lowerChildId: alloy::sol_types::private::FixedBytes<32>,
            upperChildId: alloy::sol_types::private::FixedBytes<32>,
        ) -> alloy_contract::SolCallBuilder<T, &P, setChildrenCall, N> {
            self.call_builder(
                &setChildrenCall {
                    lowerChildId,
                    upperChildId,
                },
            )
        }
        ///Creates a new call builder for the [`setConfirmed`] function.
        pub fn setConfirmed(
            &self,
        ) -> alloy_contract::SolCallBuilder<T, &P, setConfirmedCall, N> {
            self.call_builder(&setConfirmedCall {})
        }
        ///Creates a new call builder for the [`setRefunded`] function.
        pub fn setRefunded(
            &self,
        ) -> alloy_contract::SolCallBuilder<T, &P, setRefundedCall, N> {
            self.call_builder(&setRefundedCall {})
        }
    }
    /// Event filters.
    #[automatically_derived]
    impl<
        T: alloy_contract::private::Transport + ::core::clone::Clone,
        P: alloy_contract::private::Provider<T, N>,
        N: alloy_contract::private::Network,
    > ChallengeEdgeLibAccessInstance<T, P, N> {
        /// Creates a new event filter using this contract instance's provider and address.
        ///
        /// Note that the type can be any event, not just those defined in this contract.
        /// Prefer using the other methods for building type-safe event filters.
        pub fn event_filter<E: alloy_sol_types::SolEvent>(
            &self,
        ) -> alloy_contract::Event<T, &P, E, N> {
            alloy_contract::Event::new_sol(&self.provider, &self.address)
        }
    }
}
