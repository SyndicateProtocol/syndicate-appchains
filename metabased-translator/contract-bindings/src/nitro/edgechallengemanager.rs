/**

Generated by the following Solidity interface...
```solidity
interface EdgeChallengeManager {
    type EdgeStatus is uint8;
    type EdgeType is uint8;
    type MachineStatus is uint8;
    struct AssertionState {
        GlobalState globalState;
        MachineStatus machineStatus;
        bytes32 endHistoryRoot;
    }
    struct AssertionStateData {
        AssertionState assertionState;
        bytes32 prevAssertionHash;
        bytes32 inboxAcc;
    }
    struct ChallengeEdge {
        bytes32 originId;
        bytes32 startHistoryRoot;
        uint256 startHeight;
        bytes32 endHistoryRoot;
        uint256 endHeight;
        bytes32 lowerChildId;
        bytes32 upperChildId;
        bytes32 claimId;
        address staker;
        uint64 createdAtBlock;
        uint64 confirmedAtBlock;
        EdgeStatus status;
        uint8 level;
        bool refunded;
        uint64 totalTimeUnrivaledCache;
    }
    struct ConfigData {
        bytes32 wasmModuleRoot;
        uint256 requiredStake;
        address challengeManager;
        uint64 confirmPeriodBlocks;
        uint64 nextInboxPosition;
    }
    struct CreateEdgeArgs {
        uint8 level;
        bytes32 endHistoryRoot;
        uint256 endHeight;
        bytes32 claimId;
        bytes prefixProof;
        bytes proof;
    }
    struct GlobalState {
        bytes32[2] bytes32Vals;
        uint64[2] u64Vals;
    }
    struct OneStepData {
        bytes32 beforeHash;
        bytes proof;
    }

    error AccountHasMadeLayerZeroRival(address account, bytes32 mutualId);
    error AssertionHashEmpty();
    error AssertionHashMismatch(bytes32 h1, bytes32 h2);
    error AssertionNoSibling();
    error AssertionNotPending();
    error BigStepLevelsTooMany(uint8 levels);
    error CachedTimeSufficient(uint256 actual, uint256 expected);
    error ChildrenAlreadySet(bytes32 edgeId, bytes32 lowerChildId, bytes32 upperChildId);
    error ClaimEdgeInvalidLevel(uint8 argLevel, uint8 claimLevel);
    error ClaimEdgeNotLengthOneRival(bytes32 claimId);
    error ClaimEdgeNotPending();
    error EdgeAlreadyExists(bytes32 edgeId);
    error EdgeAlreadyRefunded(bytes32 edgeId);
    error EdgeClaimMismatch(bytes32 edgeId, bytes32 claimingEdgeId);
    error EdgeLevelInvalid(bytes32 edgeId1, bytes32 edgeId2, uint8 level1, uint8 level2);
    error EdgeNotConfirmed(bytes32 edgeId, EdgeStatus);
    error EdgeNotExists(bytes32 edgeId);
    error EdgeNotLayerZero(bytes32 edgeId, address staker, bytes32 claimId);
    error EdgeNotLengthOne(uint256 length);
    error EdgeNotPending(bytes32 edgeId, EdgeStatus status);
    error EdgeTypeNotSmallStep(uint8 level);
    error EdgeUnrivaled(bytes32 edgeId);
    error EmptyArray();
    error EmptyAssertionChain();
    error EmptyChallengePeriod();
    error EmptyClaimId();
    error EmptyEdgeSpecificProof();
    error EmptyEndMachineStatus();
    error EmptyEndRoot();
    error EmptyFirstRival();
    error EmptyOneStepProofEntry();
    error EmptyOriginId();
    error EmptyPrefixProof();
    error EmptyStakeReceiver();
    error EmptyStaker();
    error EmptyStartMachineStatus();
    error EmptyStartRoot();
    error EndHistoryRootMismatch(bytes32 endHistoryRoot, bytes32 assertionEndRoot);
    error HeightDiffLtTwo(uint256 h1, uint256 h2);
    error InsufficientConfirmationBlocks(uint256 totalBlocks, uint256 thresholdBlocks);
    error InvalidEdgeType(EdgeType edgeType);
    error InvalidEndHeight(uint256 actualHeight, uint256 expectedHeight);
    error InvalidHeights(uint256 start, uint256 end);
    error LevelTooHigh(uint8 level, uint8 numBigStepLevels);
    error MerkleProofTooLong(uint256 actualLength, uint256 maxProofLength);
    error NotPowerOfTwo(uint256 val);
    error NotValidator(address account);
    error OriginIdMutualIdMismatch(bytes32 mutualId, bytes32 originId);
    error RivalEdgeConfirmed(bytes32 edgeId, bytes32 confirmedRivalId);
    error StakeAmountsMismatch(uint256 stakeLevels, uint256 numLevels);
    error ZeroBigStepLevels();

    event EdgeAdded(bytes32 indexed edgeId, bytes32 indexed mutualId, bytes32 indexed originId, bytes32 claimId, uint256 length, uint8 level, bool hasRival, bool isLayerZero);
    event EdgeBisected(bytes32 indexed edgeId, bytes32 indexed lowerChildId, bytes32 indexed upperChildId, bool lowerChildAlreadyExists);
    event EdgeConfirmedByOneStepProof(bytes32 indexed edgeId, bytes32 indexed mutualId);
    event EdgeConfirmedByTime(bytes32 indexed edgeId, bytes32 indexed mutualId, uint256 totalTimeUnrivaled);
    event EdgeRefunded(bytes32 indexed edgeId, bytes32 indexed mutualId, address stakeToken, uint256 stakeAmount);
    event Initialized(uint8 version);
    event TimerCacheUpdated(bytes32 indexed edgeId, uint256 newValue);

    constructor();

    function LAYERZERO_BIGSTEPEDGE_HEIGHT() external view returns (uint256);
    function LAYERZERO_BLOCKEDGE_HEIGHT() external view returns (uint256);
    function LAYERZERO_SMALLSTEPEDGE_HEIGHT() external view returns (uint256);
    function NUM_BIGSTEP_LEVEL() external view returns (uint8);
    function assertionChain() external view returns (address);
    function bisectEdge(bytes32 edgeId, bytes32 bisectionHistoryRoot, bytes memory prefixProof) external returns (bytes32, bytes32);
    function calculateEdgeId(uint8 level, bytes32 originId, uint256 startHeight, bytes32 startHistoryRoot, uint256 endHeight, bytes32 endHistoryRoot) external pure returns (bytes32);
    function calculateMutualId(uint8 level, bytes32 originId, uint256 startHeight, bytes32 startHistoryRoot, uint256 endHeight) external pure returns (bytes32);
    function challengePeriodBlocks() external view returns (uint64);
    function confirmEdgeByOneStepProof(bytes32 edgeId, OneStepData memory oneStepData, ConfigData memory prevConfig, bytes32[] memory beforeHistoryInclusionProof, bytes32[] memory afterHistoryInclusionProof) external;
    function confirmEdgeByTime(bytes32 edgeId, AssertionStateData memory claimStateData) external;
    function confirmedRival(bytes32 mutualId) external view returns (bytes32);
    function createLayerZeroEdge(CreateEdgeArgs memory args) external returns (bytes32);
    function edgeExists(bytes32 edgeId) external view returns (bool);
    function edgeLength(bytes32 edgeId) external view returns (uint256);
    function excessStakeReceiver() external view returns (address);
    function firstRival(bytes32 mutualId) external view returns (bytes32);
    function getEdge(bytes32 edgeId) external view returns (ChallengeEdge memory);
    function getLayerZeroEndHeight(EdgeType eType) external view returns (uint256);
    function getPrevAssertionHash(bytes32 edgeId) external view returns (bytes32);
    function hasLengthOneRival(bytes32 edgeId) external view returns (bool);
    function hasMadeLayerZeroRival(address account, bytes32 mutualId) external view returns (bool);
    function hasRival(bytes32 edgeId) external view returns (bool);
    function initialize(address _assertionChain, uint64 _challengePeriodBlocks, address _oneStepProofEntry, uint256 layerZeroBlockEdgeHeight, uint256 layerZeroBigStepEdgeHeight, uint256 layerZeroSmallStepEdgeHeight, address _stakeToken, address _excessStakeReceiver, uint8 _numBigStepLevel, uint256[] memory _stakeAmounts) external;
    function multiUpdateTimeCacheByChildren(bytes32[] memory edgeIds, uint256 maximumCachedTime) external;
    function oneStepProofEntry() external view returns (address);
    function refundStake(bytes32 edgeId) external;
    function stakeAmounts(uint256) external view returns (uint256);
    function stakeToken() external view returns (address);
    function timeUnrivaled(bytes32 edgeId) external view returns (uint256);
    function updateTimerCacheByChildren(bytes32 edgeId, uint256 maximumCachedTime) external;
    function updateTimerCacheByClaim(bytes32 edgeId, bytes32 claimingEdgeId, uint256 maximumCachedTime) external;
}
```

...which was generated by the following JSON ABI:
```json
[
  {
    "type": "constructor",
    "inputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "LAYERZERO_BIGSTEPEDGE_HEIGHT",
    "inputs": [],
    "outputs": [
      {
        "name": "",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "LAYERZERO_BLOCKEDGE_HEIGHT",
    "inputs": [],
    "outputs": [
      {
        "name": "",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "LAYERZERO_SMALLSTEPEDGE_HEIGHT",
    "inputs": [],
    "outputs": [
      {
        "name": "",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "NUM_BIGSTEP_LEVEL",
    "inputs": [],
    "outputs": [
      {
        "name": "",
        "type": "uint8",
        "internalType": "uint8"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "assertionChain",
    "inputs": [],
    "outputs": [
      {
        "name": "",
        "type": "address",
        "internalType": "contract IAssertionChain"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "bisectEdge",
    "inputs": [
      {
        "name": "edgeId",
        "type": "bytes32",
        "internalType": "bytes32"
      },
      {
        "name": "bisectionHistoryRoot",
        "type": "bytes32",
        "internalType": "bytes32"
      },
      {
        "name": "prefixProof",
        "type": "bytes",
        "internalType": "bytes"
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "bytes32",
        "internalType": "bytes32"
      },
      {
        "name": "",
        "type": "bytes32",
        "internalType": "bytes32"
      }
    ],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "calculateEdgeId",
    "inputs": [
      {
        "name": "level",
        "type": "uint8",
        "internalType": "uint8"
      },
      {
        "name": "originId",
        "type": "bytes32",
        "internalType": "bytes32"
      },
      {
        "name": "startHeight",
        "type": "uint256",
        "internalType": "uint256"
      },
      {
        "name": "startHistoryRoot",
        "type": "bytes32",
        "internalType": "bytes32"
      },
      {
        "name": "endHeight",
        "type": "uint256",
        "internalType": "uint256"
      },
      {
        "name": "endHistoryRoot",
        "type": "bytes32",
        "internalType": "bytes32"
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "bytes32",
        "internalType": "bytes32"
      }
    ],
    "stateMutability": "pure"
  },
  {
    "type": "function",
    "name": "calculateMutualId",
    "inputs": [
      {
        "name": "level",
        "type": "uint8",
        "internalType": "uint8"
      },
      {
        "name": "originId",
        "type": "bytes32",
        "internalType": "bytes32"
      },
      {
        "name": "startHeight",
        "type": "uint256",
        "internalType": "uint256"
      },
      {
        "name": "startHistoryRoot",
        "type": "bytes32",
        "internalType": "bytes32"
      },
      {
        "name": "endHeight",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "bytes32",
        "internalType": "bytes32"
      }
    ],
    "stateMutability": "pure"
  },
  {
    "type": "function",
    "name": "challengePeriodBlocks",
    "inputs": [],
    "outputs": [
      {
        "name": "",
        "type": "uint64",
        "internalType": "uint64"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "confirmEdgeByOneStepProof",
    "inputs": [
      {
        "name": "edgeId",
        "type": "bytes32",
        "internalType": "bytes32"
      },
      {
        "name": "oneStepData",
        "type": "tuple",
        "internalType": "struct OneStepData",
        "components": [
          {
            "name": "beforeHash",
            "type": "bytes32",
            "internalType": "bytes32"
          },
          {
            "name": "proof",
            "type": "bytes",
            "internalType": "bytes"
          }
        ]
      },
      {
        "name": "prevConfig",
        "type": "tuple",
        "internalType": "struct ConfigData",
        "components": [
          {
            "name": "wasmModuleRoot",
            "type": "bytes32",
            "internalType": "bytes32"
          },
          {
            "name": "requiredStake",
            "type": "uint256",
            "internalType": "uint256"
          },
          {
            "name": "challengeManager",
            "type": "address",
            "internalType": "address"
          },
          {
            "name": "confirmPeriodBlocks",
            "type": "uint64",
            "internalType": "uint64"
          },
          {
            "name": "nextInboxPosition",
            "type": "uint64",
            "internalType": "uint64"
          }
        ]
      },
      {
        "name": "beforeHistoryInclusionProof",
        "type": "bytes32[]",
        "internalType": "bytes32[]"
      },
      {
        "name": "afterHistoryInclusionProof",
        "type": "bytes32[]",
        "internalType": "bytes32[]"
      }
    ],
    "outputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "confirmEdgeByTime",
    "inputs": [
      {
        "name": "edgeId",
        "type": "bytes32",
        "internalType": "bytes32"
      },
      {
        "name": "claimStateData",
        "type": "tuple",
        "internalType": "struct AssertionStateData",
        "components": [
          {
            "name": "assertionState",
            "type": "tuple",
            "internalType": "struct AssertionState",
            "components": [
              {
                "name": "globalState",
                "type": "tuple",
                "internalType": "struct GlobalState",
                "components": [
                  {
                    "name": "bytes32Vals",
                    "type": "bytes32[2]",
                    "internalType": "bytes32[2]"
                  },
                  {
                    "name": "u64Vals",
                    "type": "uint64[2]",
                    "internalType": "uint64[2]"
                  }
                ]
              },
              {
                "name": "machineStatus",
                "type": "uint8",
                "internalType": "enum MachineStatus"
              },
              {
                "name": "endHistoryRoot",
                "type": "bytes32",
                "internalType": "bytes32"
              }
            ]
          },
          {
            "name": "prevAssertionHash",
            "type": "bytes32",
            "internalType": "bytes32"
          },
          {
            "name": "inboxAcc",
            "type": "bytes32",
            "internalType": "bytes32"
          }
        ]
      }
    ],
    "outputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "confirmedRival",
    "inputs": [
      {
        "name": "mutualId",
        "type": "bytes32",
        "internalType": "bytes32"
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "bytes32",
        "internalType": "bytes32"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "createLayerZeroEdge",
    "inputs": [
      {
        "name": "args",
        "type": "tuple",
        "internalType": "struct CreateEdgeArgs",
        "components": [
          {
            "name": "level",
            "type": "uint8",
            "internalType": "uint8"
          },
          {
            "name": "endHistoryRoot",
            "type": "bytes32",
            "internalType": "bytes32"
          },
          {
            "name": "endHeight",
            "type": "uint256",
            "internalType": "uint256"
          },
          {
            "name": "claimId",
            "type": "bytes32",
            "internalType": "bytes32"
          },
          {
            "name": "prefixProof",
            "type": "bytes",
            "internalType": "bytes"
          },
          {
            "name": "proof",
            "type": "bytes",
            "internalType": "bytes"
          }
        ]
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "bytes32",
        "internalType": "bytes32"
      }
    ],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "edgeExists",
    "inputs": [
      {
        "name": "edgeId",
        "type": "bytes32",
        "internalType": "bytes32"
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "bool",
        "internalType": "bool"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "edgeLength",
    "inputs": [
      {
        "name": "edgeId",
        "type": "bytes32",
        "internalType": "bytes32"
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "excessStakeReceiver",
    "inputs": [],
    "outputs": [
      {
        "name": "",
        "type": "address",
        "internalType": "address"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "firstRival",
    "inputs": [
      {
        "name": "mutualId",
        "type": "bytes32",
        "internalType": "bytes32"
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "bytes32",
        "internalType": "bytes32"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "getEdge",
    "inputs": [
      {
        "name": "edgeId",
        "type": "bytes32",
        "internalType": "bytes32"
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "tuple",
        "internalType": "struct ChallengeEdge",
        "components": [
          {
            "name": "originId",
            "type": "bytes32",
            "internalType": "bytes32"
          },
          {
            "name": "startHistoryRoot",
            "type": "bytes32",
            "internalType": "bytes32"
          },
          {
            "name": "startHeight",
            "type": "uint256",
            "internalType": "uint256"
          },
          {
            "name": "endHistoryRoot",
            "type": "bytes32",
            "internalType": "bytes32"
          },
          {
            "name": "endHeight",
            "type": "uint256",
            "internalType": "uint256"
          },
          {
            "name": "lowerChildId",
            "type": "bytes32",
            "internalType": "bytes32"
          },
          {
            "name": "upperChildId",
            "type": "bytes32",
            "internalType": "bytes32"
          },
          {
            "name": "claimId",
            "type": "bytes32",
            "internalType": "bytes32"
          },
          {
            "name": "staker",
            "type": "address",
            "internalType": "address"
          },
          {
            "name": "createdAtBlock",
            "type": "uint64",
            "internalType": "uint64"
          },
          {
            "name": "confirmedAtBlock",
            "type": "uint64",
            "internalType": "uint64"
          },
          {
            "name": "status",
            "type": "uint8",
            "internalType": "enum EdgeStatus"
          },
          {
            "name": "level",
            "type": "uint8",
            "internalType": "uint8"
          },
          {
            "name": "refunded",
            "type": "bool",
            "internalType": "bool"
          },
          {
            "name": "totalTimeUnrivaledCache",
            "type": "uint64",
            "internalType": "uint64"
          }
        ]
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "getLayerZeroEndHeight",
    "inputs": [
      {
        "name": "eType",
        "type": "uint8",
        "internalType": "enum EdgeType"
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "getPrevAssertionHash",
    "inputs": [
      {
        "name": "edgeId",
        "type": "bytes32",
        "internalType": "bytes32"
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "bytes32",
        "internalType": "bytes32"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "hasLengthOneRival",
    "inputs": [
      {
        "name": "edgeId",
        "type": "bytes32",
        "internalType": "bytes32"
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "bool",
        "internalType": "bool"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "hasMadeLayerZeroRival",
    "inputs": [
      {
        "name": "account",
        "type": "address",
        "internalType": "address"
      },
      {
        "name": "mutualId",
        "type": "bytes32",
        "internalType": "bytes32"
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "bool",
        "internalType": "bool"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "hasRival",
    "inputs": [
      {
        "name": "edgeId",
        "type": "bytes32",
        "internalType": "bytes32"
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "bool",
        "internalType": "bool"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "initialize",
    "inputs": [
      {
        "name": "_assertionChain",
        "type": "address",
        "internalType": "contract IAssertionChain"
      },
      {
        "name": "_challengePeriodBlocks",
        "type": "uint64",
        "internalType": "uint64"
      },
      {
        "name": "_oneStepProofEntry",
        "type": "address",
        "internalType": "contract IOneStepProofEntry"
      },
      {
        "name": "layerZeroBlockEdgeHeight",
        "type": "uint256",
        "internalType": "uint256"
      },
      {
        "name": "layerZeroBigStepEdgeHeight",
        "type": "uint256",
        "internalType": "uint256"
      },
      {
        "name": "layerZeroSmallStepEdgeHeight",
        "type": "uint256",
        "internalType": "uint256"
      },
      {
        "name": "_stakeToken",
        "type": "address",
        "internalType": "contract IERC20"
      },
      {
        "name": "_excessStakeReceiver",
        "type": "address",
        "internalType": "address"
      },
      {
        "name": "_numBigStepLevel",
        "type": "uint8",
        "internalType": "uint8"
      },
      {
        "name": "_stakeAmounts",
        "type": "uint256[]",
        "internalType": "uint256[]"
      }
    ],
    "outputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "multiUpdateTimeCacheByChildren",
    "inputs": [
      {
        "name": "edgeIds",
        "type": "bytes32[]",
        "internalType": "bytes32[]"
      },
      {
        "name": "maximumCachedTime",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "outputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "oneStepProofEntry",
    "inputs": [],
    "outputs": [
      {
        "name": "",
        "type": "address",
        "internalType": "contract IOneStepProofEntry"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "refundStake",
    "inputs": [
      {
        "name": "edgeId",
        "type": "bytes32",
        "internalType": "bytes32"
      }
    ],
    "outputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "stakeAmounts",
    "inputs": [
      {
        "name": "",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "stakeToken",
    "inputs": [],
    "outputs": [
      {
        "name": "",
        "type": "address",
        "internalType": "contract IERC20"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "timeUnrivaled",
    "inputs": [
      {
        "name": "edgeId",
        "type": "bytes32",
        "internalType": "bytes32"
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "updateTimerCacheByChildren",
    "inputs": [
      {
        "name": "edgeId",
        "type": "bytes32",
        "internalType": "bytes32"
      },
      {
        "name": "maximumCachedTime",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "outputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "updateTimerCacheByClaim",
    "inputs": [
      {
        "name": "edgeId",
        "type": "bytes32",
        "internalType": "bytes32"
      },
      {
        "name": "claimingEdgeId",
        "type": "bytes32",
        "internalType": "bytes32"
      },
      {
        "name": "maximumCachedTime",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "outputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "event",
    "name": "EdgeAdded",
    "inputs": [
      {
        "name": "edgeId",
        "type": "bytes32",
        "indexed": true,
        "internalType": "bytes32"
      },
      {
        "name": "mutualId",
        "type": "bytes32",
        "indexed": true,
        "internalType": "bytes32"
      },
      {
        "name": "originId",
        "type": "bytes32",
        "indexed": true,
        "internalType": "bytes32"
      },
      {
        "name": "claimId",
        "type": "bytes32",
        "indexed": false,
        "internalType": "bytes32"
      },
      {
        "name": "length",
        "type": "uint256",
        "indexed": false,
        "internalType": "uint256"
      },
      {
        "name": "level",
        "type": "uint8",
        "indexed": false,
        "internalType": "uint8"
      },
      {
        "name": "hasRival",
        "type": "bool",
        "indexed": false,
        "internalType": "bool"
      },
      {
        "name": "isLayerZero",
        "type": "bool",
        "indexed": false,
        "internalType": "bool"
      }
    ],
    "anonymous": false
  },
  {
    "type": "event",
    "name": "EdgeBisected",
    "inputs": [
      {
        "name": "edgeId",
        "type": "bytes32",
        "indexed": true,
        "internalType": "bytes32"
      },
      {
        "name": "lowerChildId",
        "type": "bytes32",
        "indexed": true,
        "internalType": "bytes32"
      },
      {
        "name": "upperChildId",
        "type": "bytes32",
        "indexed": true,
        "internalType": "bytes32"
      },
      {
        "name": "lowerChildAlreadyExists",
        "type": "bool",
        "indexed": false,
        "internalType": "bool"
      }
    ],
    "anonymous": false
  },
  {
    "type": "event",
    "name": "EdgeConfirmedByOneStepProof",
    "inputs": [
      {
        "name": "edgeId",
        "type": "bytes32",
        "indexed": true,
        "internalType": "bytes32"
      },
      {
        "name": "mutualId",
        "type": "bytes32",
        "indexed": true,
        "internalType": "bytes32"
      }
    ],
    "anonymous": false
  },
  {
    "type": "event",
    "name": "EdgeConfirmedByTime",
    "inputs": [
      {
        "name": "edgeId",
        "type": "bytes32",
        "indexed": true,
        "internalType": "bytes32"
      },
      {
        "name": "mutualId",
        "type": "bytes32",
        "indexed": true,
        "internalType": "bytes32"
      },
      {
        "name": "totalTimeUnrivaled",
        "type": "uint256",
        "indexed": false,
        "internalType": "uint256"
      }
    ],
    "anonymous": false
  },
  {
    "type": "event",
    "name": "EdgeRefunded",
    "inputs": [
      {
        "name": "edgeId",
        "type": "bytes32",
        "indexed": true,
        "internalType": "bytes32"
      },
      {
        "name": "mutualId",
        "type": "bytes32",
        "indexed": true,
        "internalType": "bytes32"
      },
      {
        "name": "stakeToken",
        "type": "address",
        "indexed": false,
        "internalType": "address"
      },
      {
        "name": "stakeAmount",
        "type": "uint256",
        "indexed": false,
        "internalType": "uint256"
      }
    ],
    "anonymous": false
  },
  {
    "type": "event",
    "name": "Initialized",
    "inputs": [
      {
        "name": "version",
        "type": "uint8",
        "indexed": false,
        "internalType": "uint8"
      }
    ],
    "anonymous": false
  },
  {
    "type": "event",
    "name": "TimerCacheUpdated",
    "inputs": [
      {
        "name": "edgeId",
        "type": "bytes32",
        "indexed": true,
        "internalType": "bytes32"
      },
      {
        "name": "newValue",
        "type": "uint256",
        "indexed": false,
        "internalType": "uint256"
      }
    ],
    "anonymous": false
  },
  {
    "type": "error",
    "name": "AccountHasMadeLayerZeroRival",
    "inputs": [
      {
        "name": "account",
        "type": "address",
        "internalType": "address"
      },
      {
        "name": "mutualId",
        "type": "bytes32",
        "internalType": "bytes32"
      }
    ]
  },
  {
    "type": "error",
    "name": "AssertionHashEmpty",
    "inputs": []
  },
  {
    "type": "error",
    "name": "AssertionHashMismatch",
    "inputs": [
      {
        "name": "h1",
        "type": "bytes32",
        "internalType": "bytes32"
      },
      {
        "name": "h2",
        "type": "bytes32",
        "internalType": "bytes32"
      }
    ]
  },
  {
    "type": "error",
    "name": "AssertionNoSibling",
    "inputs": []
  },
  {
    "type": "error",
    "name": "AssertionNotPending",
    "inputs": []
  },
  {
    "type": "error",
    "name": "BigStepLevelsTooMany",
    "inputs": [
      {
        "name": "levels",
        "type": "uint8",
        "internalType": "uint8"
      }
    ]
  },
  {
    "type": "error",
    "name": "CachedTimeSufficient",
    "inputs": [
      {
        "name": "actual",
        "type": "uint256",
        "internalType": "uint256"
      },
      {
        "name": "expected",
        "type": "uint256",
        "internalType": "uint256"
      }
    ]
  },
  {
    "type": "error",
    "name": "ChildrenAlreadySet",
    "inputs": [
      {
        "name": "edgeId",
        "type": "bytes32",
        "internalType": "bytes32"
      },
      {
        "name": "lowerChildId",
        "type": "bytes32",
        "internalType": "bytes32"
      },
      {
        "name": "upperChildId",
        "type": "bytes32",
        "internalType": "bytes32"
      }
    ]
  },
  {
    "type": "error",
    "name": "ClaimEdgeInvalidLevel",
    "inputs": [
      {
        "name": "argLevel",
        "type": "uint8",
        "internalType": "uint8"
      },
      {
        "name": "claimLevel",
        "type": "uint8",
        "internalType": "uint8"
      }
    ]
  },
  {
    "type": "error",
    "name": "ClaimEdgeNotLengthOneRival",
    "inputs": [
      {
        "name": "claimId",
        "type": "bytes32",
        "internalType": "bytes32"
      }
    ]
  },
  {
    "type": "error",
    "name": "ClaimEdgeNotPending",
    "inputs": []
  },
  {
    "type": "error",
    "name": "EdgeAlreadyExists",
    "inputs": [
      {
        "name": "edgeId",
        "type": "bytes32",
        "internalType": "bytes32"
      }
    ]
  },
  {
    "type": "error",
    "name": "EdgeAlreadyRefunded",
    "inputs": [
      {
        "name": "edgeId",
        "type": "bytes32",
        "internalType": "bytes32"
      }
    ]
  },
  {
    "type": "error",
    "name": "EdgeClaimMismatch",
    "inputs": [
      {
        "name": "edgeId",
        "type": "bytes32",
        "internalType": "bytes32"
      },
      {
        "name": "claimingEdgeId",
        "type": "bytes32",
        "internalType": "bytes32"
      }
    ]
  },
  {
    "type": "error",
    "name": "EdgeLevelInvalid",
    "inputs": [
      {
        "name": "edgeId1",
        "type": "bytes32",
        "internalType": "bytes32"
      },
      {
        "name": "edgeId2",
        "type": "bytes32",
        "internalType": "bytes32"
      },
      {
        "name": "level1",
        "type": "uint8",
        "internalType": "uint8"
      },
      {
        "name": "level2",
        "type": "uint8",
        "internalType": "uint8"
      }
    ]
  },
  {
    "type": "error",
    "name": "EdgeNotConfirmed",
    "inputs": [
      {
        "name": "edgeId",
        "type": "bytes32",
        "internalType": "bytes32"
      },
      {
        "name": "",
        "type": "uint8",
        "internalType": "enum EdgeStatus"
      }
    ]
  },
  {
    "type": "error",
    "name": "EdgeNotExists",
    "inputs": [
      {
        "name": "edgeId",
        "type": "bytes32",
        "internalType": "bytes32"
      }
    ]
  },
  {
    "type": "error",
    "name": "EdgeNotLayerZero",
    "inputs": [
      {
        "name": "edgeId",
        "type": "bytes32",
        "internalType": "bytes32"
      },
      {
        "name": "staker",
        "type": "address",
        "internalType": "address"
      },
      {
        "name": "claimId",
        "type": "bytes32",
        "internalType": "bytes32"
      }
    ]
  },
  {
    "type": "error",
    "name": "EdgeNotLengthOne",
    "inputs": [
      {
        "name": "length",
        "type": "uint256",
        "internalType": "uint256"
      }
    ]
  },
  {
    "type": "error",
    "name": "EdgeNotPending",
    "inputs": [
      {
        "name": "edgeId",
        "type": "bytes32",
        "internalType": "bytes32"
      },
      {
        "name": "status",
        "type": "uint8",
        "internalType": "enum EdgeStatus"
      }
    ]
  },
  {
    "type": "error",
    "name": "EdgeTypeNotSmallStep",
    "inputs": [
      {
        "name": "level",
        "type": "uint8",
        "internalType": "uint8"
      }
    ]
  },
  {
    "type": "error",
    "name": "EdgeUnrivaled",
    "inputs": [
      {
        "name": "edgeId",
        "type": "bytes32",
        "internalType": "bytes32"
      }
    ]
  },
  {
    "type": "error",
    "name": "EmptyArray",
    "inputs": []
  },
  {
    "type": "error",
    "name": "EmptyAssertionChain",
    "inputs": []
  },
  {
    "type": "error",
    "name": "EmptyChallengePeriod",
    "inputs": []
  },
  {
    "type": "error",
    "name": "EmptyClaimId",
    "inputs": []
  },
  {
    "type": "error",
    "name": "EmptyEdgeSpecificProof",
    "inputs": []
  },
  {
    "type": "error",
    "name": "EmptyEndMachineStatus",
    "inputs": []
  },
  {
    "type": "error",
    "name": "EmptyEndRoot",
    "inputs": []
  },
  {
    "type": "error",
    "name": "EmptyFirstRival",
    "inputs": []
  },
  {
    "type": "error",
    "name": "EmptyOneStepProofEntry",
    "inputs": []
  },
  {
    "type": "error",
    "name": "EmptyOriginId",
    "inputs": []
  },
  {
    "type": "error",
    "name": "EmptyPrefixProof",
    "inputs": []
  },
  {
    "type": "error",
    "name": "EmptyStakeReceiver",
    "inputs": []
  },
  {
    "type": "error",
    "name": "EmptyStaker",
    "inputs": []
  },
  {
    "type": "error",
    "name": "EmptyStartMachineStatus",
    "inputs": []
  },
  {
    "type": "error",
    "name": "EmptyStartRoot",
    "inputs": []
  },
  {
    "type": "error",
    "name": "EndHistoryRootMismatch",
    "inputs": [
      {
        "name": "endHistoryRoot",
        "type": "bytes32",
        "internalType": "bytes32"
      },
      {
        "name": "assertionEndRoot",
        "type": "bytes32",
        "internalType": "bytes32"
      }
    ]
  },
  {
    "type": "error",
    "name": "HeightDiffLtTwo",
    "inputs": [
      {
        "name": "h1",
        "type": "uint256",
        "internalType": "uint256"
      },
      {
        "name": "h2",
        "type": "uint256",
        "internalType": "uint256"
      }
    ]
  },
  {
    "type": "error",
    "name": "InsufficientConfirmationBlocks",
    "inputs": [
      {
        "name": "totalBlocks",
        "type": "uint256",
        "internalType": "uint256"
      },
      {
        "name": "thresholdBlocks",
        "type": "uint256",
        "internalType": "uint256"
      }
    ]
  },
  {
    "type": "error",
    "name": "InvalidEdgeType",
    "inputs": [
      {
        "name": "edgeType",
        "type": "uint8",
        "internalType": "enum EdgeType"
      }
    ]
  },
  {
    "type": "error",
    "name": "InvalidEndHeight",
    "inputs": [
      {
        "name": "actualHeight",
        "type": "uint256",
        "internalType": "uint256"
      },
      {
        "name": "expectedHeight",
        "type": "uint256",
        "internalType": "uint256"
      }
    ]
  },
  {
    "type": "error",
    "name": "InvalidHeights",
    "inputs": [
      {
        "name": "start",
        "type": "uint256",
        "internalType": "uint256"
      },
      {
        "name": "end",
        "type": "uint256",
        "internalType": "uint256"
      }
    ]
  },
  {
    "type": "error",
    "name": "LevelTooHigh",
    "inputs": [
      {
        "name": "level",
        "type": "uint8",
        "internalType": "uint8"
      },
      {
        "name": "numBigStepLevels",
        "type": "uint8",
        "internalType": "uint8"
      }
    ]
  },
  {
    "type": "error",
    "name": "MerkleProofTooLong",
    "inputs": [
      {
        "name": "actualLength",
        "type": "uint256",
        "internalType": "uint256"
      },
      {
        "name": "maxProofLength",
        "type": "uint256",
        "internalType": "uint256"
      }
    ]
  },
  {
    "type": "error",
    "name": "NotPowerOfTwo",
    "inputs": [
      {
        "name": "val",
        "type": "uint256",
        "internalType": "uint256"
      }
    ]
  },
  {
    "type": "error",
    "name": "NotValidator",
    "inputs": [
      {
        "name": "account",
        "type": "address",
        "internalType": "address"
      }
    ]
  },
  {
    "type": "error",
    "name": "OriginIdMutualIdMismatch",
    "inputs": [
      {
        "name": "mutualId",
        "type": "bytes32",
        "internalType": "bytes32"
      },
      {
        "name": "originId",
        "type": "bytes32",
        "internalType": "bytes32"
      }
    ]
  },
  {
    "type": "error",
    "name": "RivalEdgeConfirmed",
    "inputs": [
      {
        "name": "edgeId",
        "type": "bytes32",
        "internalType": "bytes32"
      },
      {
        "name": "confirmedRivalId",
        "type": "bytes32",
        "internalType": "bytes32"
      }
    ]
  },
  {
    "type": "error",
    "name": "StakeAmountsMismatch",
    "inputs": [
      {
        "name": "stakeLevels",
        "type": "uint256",
        "internalType": "uint256"
      },
      {
        "name": "numLevels",
        "type": "uint256",
        "internalType": "uint256"
      }
    ]
  },
  {
    "type": "error",
    "name": "ZeroBigStepLevels",
    "inputs": []
  }
]
```*/
#[allow(
    non_camel_case_types,
    non_snake_case,
    clippy::pub_underscore_fields,
    clippy::style,
    clippy::empty_structs_with_brackets
)]
pub mod EdgeChallengeManager {
    use super::*;
    use alloy::sol_types as alloy_sol_types;
    /// The creation / init bytecode of the contract.
    ///
    /// ```text
    ///0x6080604052348015600e575f80fd5b5060156019565b60d4565b5f54610100900460ff161560835760405162461bcd60e51b815260206004820152602760248201527f496e697469616c697a61626c653a20636f6e747261637420697320696e697469604482015266616c697a696e6760c81b606482015260840160405180910390fd5b5f5460ff908116101560d2575f805460ff191660ff9081179091556040519081527f7f26b83ff96e1f2b6a682f133852f6798a09c465da95921460cefb38474024989060200160405180910390a15b565b616702806100e15f395ff3fe608060405234801561000f575f80fd5b50600436106101e6575f3560e01c8063655b42f311610109578063c32d8c631161009e578063eae0328b1161006e578063eae0328b146104a6578063edaab54a146104b9578063f8ee77d6146104cc578063fda2892e146104d5575f80fd5b8063c32d8c6314610439578063c8bc4e431461044c578063e5b123da14610474578063e94e051e14610493575f80fd5b80638c1b3a40116100d95780638c1b3a40146103e1578063908517e9146103f4578063b2a1408e14610407578063bce6f54f1461041a575f80fd5b8063655b42f314610370578063748926f3146103a8578063750e0c0f146103bb5780638826a370146103ce575f80fd5b8063432bb78a1161017f57806351ed6a301161014f57806351ed6a301461030857806354b641511461031b5780635a48e0f41461033e5780635d9e244414610351575f80fd5b8063432bb78a1461028357806346c2781a1461029657806348923bc5146102c357806348dd2924146102ee575f80fd5b80631dce5166116101ba5780631dce51661461024b5780633e35f5e814610254578063416e66571461026757806342e1aaa814610270575f80fd5b80624d8efe146101ea57806305fae141146102105780631a72d54c146102235780631c1b4f3a14610238575b5f80fd5b6101fd6101f8366004615767565b6104f5565b6040519081526020015b60405180910390f35b6101fd61021e3660046157ad565b610577565b610236610231366004615858565b610bb1565b005b6101fd610246366004615924565b61101e565b6101fd600a5481565b6101fd610262366004615924565b61103d565b6101fd600b5481565b6101fd61027e366004615952565b61104f565b61023661029136600461596d565b6110eb565b6008546102aa9067ffffffffffffffff1681565b60405167ffffffffffffffff9091168152602001610207565b6009546102d6906001600160a01b031681565b6040516001600160a01b039091168152602001610207565b6008546102d690600160401b90046001600160a01b031681565b6006546102d6906001600160a01b031681565b61032e610329366004615924565b611192565b6040519015158152602001610207565b6101fd61034c366004615924565b61119e565b600d5461035e9060ff1681565b60405160ff9091168152602001610207565b61032e61037e3660046159b5565b6001600160a01b03919091165f908152600460209081526040808320938352929052205460ff1690565b6102366103b6366004615924565b6111aa565b61032e6103c9366004615924565b611299565b6102366103dc3660046159df565b6112c2565b6102366103ef366004615a08565b611329565b61032e610402366004615924565b6114e8565b610236610415366004615ae5565b6114f4565b6101fd610428366004615924565b5f9081526002602052604090205490565b6101fd610447366004615b1c565b61186d565b61045f61045a366004615b5a565b6118ca565b60408051928352602083019190915201610207565b6101fd610482366004615924565b5f9081526003602052604090205490565b6005546102d6906001600160a01b031681565b6101fd6104b4366004615924565b611a80565b6102366104c7366004615bd3565b611a94565b6101fd600c5481565b6104e86104e3366004615924565b611aec565b6040516102079190615c1b565b6040805160f888901b6001600160f81b03191660208083019190915260218201889052604182018790526061820186905260818083018690528351808403909101815260a18301845280519082012060c183015260e18083018590528351808403909101815261010190920190925280519101205f905b979650505050505050565b5f8060088054906101000a90046001600160a01b03166001600160a01b03166312ab3d3b6040518163ffffffff1660e01b8152600401602060405180830381865afa1580156105c8573d5f803e3d5ffd5b505050506040513d601f19601f820116820180604052508101906105ec9190615d05565b15905080801561068257506008546040517ffacd743b000000000000000000000000000000000000000000000000000000008152336004820152600160401b9091046001600160a01b03169063facd743b90602401602060405180830381865afa15801561065c573d5f803e3d5ffd5b505050506040513d601f19601f820116820180604052508101906106809190615d05565b155b156106c0576040517fed3db8ac0000000000000000000000000000000000000000000000000000000081523360048201526024015b60405180910390fd5b60408051610100810182525f80825260208201819052918101829052606081018290526080810182905260a0810182905260c0810182905260e08101919091525f61071c6107116020870187615d24565b600d5460ff16611c8c565b90505f6107288261104f565b905061073261563c565b5f83600281111561074557610745615bf3565b03610a645761075760a0880188615d3d565b90505f0361077857604051630c9ccac560e41b815260040160405180910390fd5b5f8061078760a08a018a615d3d565b8101906107949190615fe5565b925092505060088054906101000a90046001600160a01b03166001600160a01b031663e51019a68a60600135835f0151846020015185604001516040518563ffffffff1660e01b81526004016107ed94939291906160b5565b5f6040518083038186803b158015610803575f80fd5b505afa158015610815573d5f803e3d5ffd5b505060085460208481015186519187015160408089015190517fe51019a6000000000000000000000000000000000000000000000000000000008152600160401b9095046001600160a01b0316965063e51019a6955061087a949293926004016160b5565b5f6040518083038186803b158015610890575f80fd5b505afa1580156108a2573d5f803e3d5ffd5b50505050805f0151604001518960200135146108ff57805160409081015190517f3a63e99a00000000000000000000000000000000000000000000000000000000815260208b0135600482015260248101919091526044016106b7565b6040805160c08101825260608b01358082526020848101519083015260085483517fe531d8c700000000000000000000000000000000000000000000000000000000815260048101929092529192830191600160401b90046001600160a01b03169063e531d8c790602401602060405180830381865afa158015610985573d5f803e3d5ffd5b505050506040513d601f19601f820116820180604052508101906109a99190615d05565b151581526008546020848101516040517f56bbc9e600000000000000000000000000000000000000000000000000000000815260048101919091529201915f91600160401b90046001600160a01b0316906356bbc9e690602401602060405180830381865afa158015610a1e573d5f803e3d5ffd5b505050506040513d601f19601f82011682018060405250810190610a429190616101565b67ffffffffffffffff1611815292516020840152905160409092019190915290505b600954600d54610a8c916001918a9185916001600160a01b0390911690879060ff168b611d11565b6006549094506001600160a01b03165f6007610aab60208b018b615d24565b60ff1681548110610abe57610abe61611c565b5f9182526020909120015490506001600160a01b03821615801590610ae257508015155b15610b1d575f8660c00151610af75730610b04565b6005546001600160a01b03165b9050610b1b6001600160a01b038416338385611e31565b505b85604001518660200151875f01517faa4b66b1ce938c06e2a3f8466bae10ef62e747630e3859889f4719fc6427b5a489606001518a608001518b60a001518c60c001518d60e00151604051610b9b959493929190948552602085019390935260ff919091166040840152151560608301521515608082015260a00190565b60405180910390a4505092519695505050505050565b5f54610100900460ff1615808015610bcf57505f54600160ff909116105b80610be85750303b158015610be857505f5460ff166001145b610c5a5760405162461bcd60e51b815260206004820152602e60248201527f496e697469616c697a61626c653a20636f6e747261637420697320616c72656160448201527f647920696e697469616c697a656400000000000000000000000000000000000060648201526084016106b7565b5f805460ff191660011790558015610c7b575f805461ff0019166101001790555b6001600160a01b038c16610cbb576040517fc83e086200000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b600880546001600160a01b03808f16600160401b027fffffffff0000000000000000000000000000000000000000ffffffffffffffff909216919091179091558a16610d33576040517ffb60b0ef00000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b6009805473ffffffffffffffffffffffffffffffffffffffff19166001600160a01b038c1617905567ffffffffffffffff8b165f03610d9e576040517f8a0eedcc00000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b6008805467ffffffffffffffff191667ffffffffffffffff8d161790556006805473ffffffffffffffffffffffffffffffffffffffff19166001600160a01b03888116919091179091558516610e20576040517f0f0ec8a800000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b6005805473ffffffffffffffffffffffffffffffffffffffff19166001600160a01b038716179055610e5189611ee2565b610e7157604051633abfb6ff60e21b8152600481018a90526024016106b7565b600a899055610e7f88611ee2565b610e9f57604051633abfb6ff60e21b8152600481018990526024016106b7565b600b889055610ead87611ee2565b610ecd57604051633abfb6ff60e21b8152600481018890526024016106b7565b600c87905560ff84165f03610f0e576040517fa863d6e400000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b60fd8460ff161115610f51576040517f40d23bf000000000000000000000000000000000000000000000000000000000815260ff851660048201526024016106b7565b600d805460ff191660ff861617905581610f6c856002616144565b60ff1614610fbe5781610f80856002616144565b6040517f0aece9c0000000000000000000000000000000000000000000000000000000008152600481019290925260ff1660248201526044016106b7565b610fca6007848461567d565b508015611010575f805461ff0019169055604051600181527f7f26b83ff96e1f2b6a682f133852f6798a09c465da95921460cefb38474024989060200160405180910390a15b505050505050505050505050565b6007818154811061102d575f80fd5b5f91825260209091200154905081565b5f611049600183611f08565b92915050565b5f8082600281111561106357611063615bf3565b03611070575050600a5490565b600182600281111561108457611084615bf3565b03611091575050600b5490565b60028260028111156110a5576110a5615bf3565b036110b2575050600c5490565b816040517f3bf2e1ec0000000000000000000000000000000000000000000000000000000081526004016106b7919061615d565b919050565b5f829003611125576040517f521299a900000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b6111568383611135600182616170565b8181106111445761114461611c565b600192602090910201359050836120be565b505f5b8281101561118c576111848484838181106111765761117661611c565b905060200201355f19611a94565b600101611159565b50505050565b5f611049600183612135565b5f611049600183612167565b5f6111b66001836121b6565b90506111c181612209565b6006546009820154600780546001600160a01b03909316925f92600160481b900460ff169081106111f4576111f461611c565b5f9182526020909120015490506001600160a01b0382161580159061121857508015155b15611239576008830154611239906001600160a01b03848116911683612313565b5f84815260016020526040902061124f90612361565b604080516001600160a01b03851681526020810184905286917fa635398959ddb5ce3b14537edfc25b2e671274c9b8cad0f4bd634752e69007b6910160405180910390a350505050565b5f81815260016020526040812060080154600160a01b900467ffffffffffffffff161515611049565b600d545f9081906112dd906001908790879060ff16876123d7565b91509150811561132257847fbe17755d8d836ad67bfaf8e5b3869aedb4cba03f295a167c5547feddd9ef50ad8260405161131991815260200190565b60405180910390a25b5050505050565b5f611335600189612167565b6008546040517f04972af9000000000000000000000000000000000000000000000000000000008152919250600160401b90046001600160a01b0316906304972af9906113889084908a90600401616183565b5f6040518083038186803b15801561139e575f80fd5b505afa1580156113b0573d5f803e3d5ffd5b505050505f60405180606001604052808860800160208101906113d391906161fc565b67ffffffffffffffff16815260200160088054906101000a90046001600160a01b03166001600160a01b031663e78cea926040518163ffffffff1660e01b8152600401602060405180830381865afa158015611431573d5f803e3d5ffd5b505050506040513d601f19601f820116820180604052508101906114559190616217565b6001600160a01b0390811682528935602090920191909152600954600d54600b54600c5494955061149d946001948f9416928e9288928e928e928e928e9260ff169190612444565b5f8981526001602052604090206114b390612361565b6040518a907fe11db4b27bc8c6ea5943ecbb205ae1ca8d56c42c719717aaf8a53d43d0cee7c2905f90a3505050505050505050565b5f6110496001836127d6565b5f6115006001846121b6565b905061150b816128b3565b61156d57611518816128d6565b600882015460078301546040517fe58c830800000000000000000000000000000000000000000000000000000000815260048101939093526001600160a01b03909116602483015260448201526064016106b7565b5f80806009840154600d5461158f9160ff600160481b90910481169116611c8c565b60028111156115a0576115a0615bf3565b14905080801561163b575060085460078401546040517f308362280000000000000000000000000000000000000000000000000000000081526004810191909152600160401b9091046001600160a01b031690633083622890602401602060405180830381865afa158015611617573d5f803e3d5ffd5b505050506040513d601f19601f8201168201806040525081019061163b9190615d05565b156117f35760085460078401546040517fe51019a6000000000000000000000000000000000000000000000000000000008152600160401b9092046001600160a01b03169163e51019a6916116a091889060c08201359060e083013590600401616232565b5f6040518083038186803b1580156116b6575f80fd5b505afa1580156116c8573d5f803e3d5ffd5b50506008546040517f1171558500000000000000000000000000000000000000000000000000000000815260c08801356004820152600160401b9091046001600160a01b0316925063117155859150602401602060405180830381865afa158015611735573d5f803e3d5ffd5b505050506040513d601f19601f820116820180604052508101906117599190616101565b6008546040517f56bbc9e600000000000000000000000000000000000000000000000000000000815260c08701356004820152600160401b9091046001600160a01b0316906356bbc9e690602401602060405180830381865afa1580156117c2573d5f803e3d5ffd5b505050506040513d601f19601f820116820180604052508101906117e69190616101565b6117f091906162bf565b91505b6008545f90611812906001908890869067ffffffffffffffff16612976565b5f87815260016020526040902090915061182b90612361565b867f2e0808830a22204cb3fb8f8d784b28bc97e9ce2e39d2f9cde2860de0957d68eb8360405161185d91815260200190565b60405180910390a3505050505050565b6040805160f887901b6001600160f81b03191660208083019190915260218201879052604182018690526061820185905260818083018590528351808403909101815260a190920190925280519101205f905b9695505050505050565b5f805f805f611915898989898080601f0160208091040260200160405190810160405280939291908181526020018383808284375f920191909152506001959493925050612a5a9050565b8151929550909350915015806119ac5782604001518360200151845f01517faa4b66b1ce938c06e2a3f8466bae10ef62e747630e3859889f4719fc6427b5a4866060015187608001518860a001518960c001518a60e001516040516119a3959493929190948552602085019390935260ff919091166040840152151560608301521515608082015260a00190565b60405180910390a45b81604001518260200151835f01517faa4b66b1ce938c06e2a3f8466bae10ef62e747630e3859889f4719fc6427b5a4856060015186608001518760a001518860c001518960e00151604051611a2a959493929190948552602085019390935260ff919091166040840152151560608301521515608082015260a00190565b60405180910390a48151604051821515815285908c907f7340510d24b7ec9b5c100f5500d93429d80d00d46f0d18e4e85d0c4cc22b99249060200160405180910390a45051919350909150505b94509492505050565b5f611049611a8f6001846121b6565b612e76565b5f80611aa260018585612eb9565b91509150811561118c57837fbe17755d8d836ad67bfaf8e5b3869aedb4cba03f295a167c5547feddd9ef50ad82604051611ade91815260200190565b60405180910390a250505050565b604080516101e0810182525f80825260208201819052918101829052606081018290526080810182905260a0810182905260c0810182905260e08101829052610100810182905261012081018290526101408101829052610160810182905261018081018290526101a081018290526101c0810191909152611b6f6001836121b6565b604080516101e0810182528254815260018084015460208301526002840154928201929092526003830154606082015260048301546080820152600583015460a0820152600683015460c0820152600783015460e082015260088301546001600160a01b038116610100830152600160a01b900467ffffffffffffffff9081166101208301526009840154908116610140830152909291610160840191600160401b900460ff1690811115611c2657611c26615bf3565b6001811115611c3757611c37615bf3565b81526009919091015460ff600160481b8204811660208401526a01000000000000000000008204161515604083015267ffffffffffffffff6b0100000000000000000000009091041660609091015292915050565b5f8260ff165f03611c9e57505f611049565b8160ff168360ff1611611cb357506001611049565b611cbe826001616144565b60ff168360ff1603611cd257506002611049565b6040517fae0da57800000000000000000000000000000000000000000000000000000000815260ff8085166004830152831660248201526044016106b7565b60408051610100810182525f80825260208201819052918101829052606081018290526080810182905260a0810182905260c0810182905260e081018290529080611d5f8a8a8a8a89612edc565b915091505f611d6f838b8961342a565b90505f611d7d83838d61356c565b90508515611e17575f611d8f8261360e565b335f90815260038f016020908152604080832084845290915290205490915060ff1615611df1576040517f5a46ac3a000000000000000000000000000000000000000000000000000000008152336004820152602481018290526044016106b7565b335f90815260038e016020908152604080832093835292905220805460ff191660011790555b611e218c8261367b565b9c9b505050505050505050505050565b6040516001600160a01b038085166024830152831660448201526064810182905261118c9085907f23b872dd00000000000000000000000000000000000000000000000000000000906084015b60408051601f198184030181529190526020810180517bffffffffffffffffffffffffffffffffffffffffffffffffffffffff167fffffffff0000000000000000000000000000000000000000000000000000000090931692909217909152613a56565b5f815f03611ef157505f919050565b5f611efd600184616170565b929092161592915050565b5f81815260208390526040812060080154600160a01b900467ffffffffffffffff16611f495760405162a7b02b60e01b8152600481018390526024016106b7565b5f828152602084905260408120611f5f90612361565b5f818152600186016020526040812054919250819003611fab576040517fda10f67c00000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b6040516815539492559053115160ba1b6020820152602901604051602081830303815290604052805190602001208103612014575f8481526020869052604090206008015461200b90600160a01b900467ffffffffffffffff1643616170565b92505050611049565b5f81815260208690526040902060080154600160a01b900467ffffffffffffffff166120555760405162a7b02b60e01b8152600481018290526024016106b7565b5f81815260208690526040808220600890810154878452919092209091015467ffffffffffffffff600160a01b9283900481169290910416808211156120aa5761209f8183616170565b945050505050611049565b5f945050505050611049565b505092915050565b5f828152602084905260408120600901546b010000000000000000000000900467ffffffffffffffff1682811061212b576040517fd1f5928100000000000000000000000000000000000000000000000000000000815260048101829052602481018490526044016106b7565b90505b9392505050565b5f61214083836127d6565b801561212e57505f82815260208490526040902061215d90612e76565b6001149392505050565b5f8061217384846121b6565b90505b6009810154600160481b900460ff16156121ae5780545f9081526001850160205260409020546121a685826121b6565b915050612176565b549392505050565b5f81815260208390526040812060080154600160a01b900467ffffffffffffffff166121f75760405162a7b02b60e01b8152600481018390526024016106b7565b505f9081526020919091526040902090565b60016009820154600160401b900460ff16600181111561222b5761222b615bf3565b1461227c57612239816128d6565b60098201546040517fef1267b40000000000000000000000000000000000000000000000000000000081526106b79291600160401b900460ff16906004016162e0565b612285816128b3565b61229257611518816128d6565b60098101546a0100000000000000000000900460ff1615156001036122ef576122ba816128d6565b6040517f307f76690000000000000000000000000000000000000000000000000000000081526004016106b791815260200190565b60090180546aff0000000000000000000019166a0100000000000000000000179055565b6040516001600160a01b03831660248201526044810182905261235c9084907fa9059cbb0000000000000000000000000000000000000000000000000000000090606401611e7e565b505050565b6009810154815460028301546001840154600485015460408051600160481b90960460f81b6001600160f81b0319166020808801919091526021870195909552604186019390935260618501919091526081808501919091528151808503909101815260a1909301905281519101205f90611049565b5f805f6123e48888611f08565b90506123f288888888613b3a565b5f86815260208990526040902060090154612426906b010000000000000000000000900467ffffffffffffffff16826162f4565b905061243488888387613cf4565b92509250505b9550959350505050565b5f8b815260208d90526040902060080154600160a01b900467ffffffffffffffff166124855760405162a7b02b60e01b8152600481018c90526024016106b7565b60025f8c815260208e905260409020600901546124ac90600160481b900460ff1685611c8c565b60028111156124bd576124bd615bf3565b14612512575f8b815260208d90526040908190206009015490517f348aefdf000000000000000000000000000000000000000000000000000000008152600160481b90910460ff1660048201526024016106b7565b5f8b815260208d90526040902061252890612e76565b60011461257a575f8b815260208d90526040902061254590612e76565b6040517f6b595e500000000000000000000000000000000000000000000000000000000081526004016106b791815260200190565b5f8b815260208d905260409020600201548b825b60018f5f015f8481526020019081526020015f2060090160099054906101000a900460ff1660ff161115612629575f8f5f015f8481526020019081526020015f205f015490508f6001015f8281526020019081526020015f205492508f5f015f8481526020019081526020015f20600201548261260b9190616307565b61261590856162f4565b93506126218683616307565b91505061258e565b50506126818d5f015f8e81526020019081526020015f20600101548b5f0135838b8b808060200260200160405190810160405280939291908181526020018383602002808284375f92019190915250613d8992505050565b5f8b6001600160a01b031663b5112fd28b848e5f01358f80602001906126a79190615d3d565b6040518663ffffffff1660e01b81526004016126c795949392919061631e565b602060405180830381865afa1580156126e2573d5f803e3d5ffd5b505050506040513d601f19601f82011682018060405250810190612706919061637f565b90506127678e5f015f8f81526020019081526020015f20600301548284600161272f91906162f4565b8a8a808060200260200160405190810160405280939291908181526020018383602002808284375f92019190915250613d8992505050565b5f8d815260208f90526040902061277d90613e0e565b6127878e8e613ea9565b5050505f998a5250505060209790975250506040909320600901805472ffffffffffffffff0000000000000000000000191672ffffffffffffffff000000000000000000000017905550505050565b5f81815260208390526040812060080154600160a01b900467ffffffffffffffff166128175760405162a7b02b60e01b8152600481018390526024016106b7565b5f82815260208490526040812061282d90612361565b5f818152600186016020526040812054919250819003612879576040517fda10f67c00000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b6040516815539492559053115160ba1b602082015260290160408051601f1981840301815291905280516020909101201415949350505050565b60078101545f9015801590611049575050600801546001600160a01b0316151590565b60098101548154600283015460018401546004850154600386015460408051600160481b90970460f81b6001600160f81b0319166020808901919091526021880196909652604187019490945260618601929092526081808601919091528251808603909101815260a18501835280519084012060c185015260e18085019190915281518085039091018152610101909301905281519101205f90611049565b5f83815260208590526040812060080154600160a01b900467ffffffffffffffff166129b75760405162a7b02b60e01b8152600481018590526024016106b7565b5f6129c28686613f29565b90506129d867ffffffffffffffff8516826162f4565b90508267ffffffffffffffff16811015612a31576040517f11a8d4d00000000000000000000000000000000000000000000000000000000081526004810182905267ffffffffffffffff841660248201526044016106b7565b5f858152602087905260409020612a4790613e0e565b612a518686613ea9565b95945050505050565b60408051610100810182525f80825260208201819052918101829052606081018290526080810182905260a0810182905260c0810182905260e0810182905260408051610100810182525f80825260208201819052918101829052606081018290526080810182905260a0810182905260c0810182905260e08101919091525f8087815260208990526040902060090154600160401b900460ff166001811115612b0657612b06615bf3565b14612b5d575f86815260208890526040908190206009015490517f23f8405d0000000000000000000000000000000000000000000000000000000081526106b7918891600160401b90910460ff16906004016162e0565b612b6787876127d6565b612ba0576040517f80e07e45000000000000000000000000000000000000000000000000000000008152600481018790526024016106b7565b5f868152602088905260408120604080516101e0810182528254815260018084015460208301526002840154928201929092526003830154606082015260048301546080820152600583015460a0820152600683015460c0820152600783015460e082015260088301546001600160a01b038116610100830152600160a01b900467ffffffffffffffff9081166101208301526009840154908116610140830152909291610160840191600160401b900460ff1690811115612c6457612c64615bf3565b6001811115612c7557612c75615bf3565b815260099190910154600160481b810460ff90811660208401526a010000000000000000000082041615156040808401919091526b01000000000000000000000090910467ffffffffffffffff1660609092019190915281015160808201519192505f91612ce39190613fb4565b90505f8087806020019051810190612cfb91906163f2565b9092509050612d2b89612d0f8560016162f4565b60608701516080880151612d249060016162f4565b868661405d565b505060408051610100810182525f80825260208201819052918101829052606081018290526080810182905260a0810182905260c0810182905260e081018290525f612d8b855f0151866020015187604001518d888a610180015161437b565b9050612d9681614483565b5f81815260208e90526040902060080154909350600160a01b900467ffffffffffffffff16612dcc57612dc98c8261367b565b91505b5060408051610100810182525f80825260208201819052918101829052606081018290526080810182905260a0810182905260c0810182905260e08101919091525f612e2c865f01518c8789606001518a608001518b610180015161437b565b9050612e388d8261367b565b915050612e6483825f01518e5f015f8f81526020019081526020015f2061451a9092919063ffffffff16565b919b909a509098509650505050505050565b5f8082600201548360040154612e8c9190616170565b9050805f0361104957612e9e836128d6565b60405162a7b02b60e01b81526004016106b791815260200190565b5f80612ed08585612eca8888613f29565b86613cf4565b91509150935093915050565b60408051606080820183525f8083526020830152918101919091525f80612f0f612f096020890189615d24565b85611c8c565b6002811115612f2057612f20615bf3565b0361323457602085015185515f03612f64576040517fe96bc61a00000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b8551606088013514612fb25785516040517f5b177a3c0000000000000000000000000000000000000000000000000000000081526004810191909152606088013560248201526044016106b7565b8560400151612fed576040517fc169243600000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b8560600151613028576040517fb45d1c3a00000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b61303560a0880188615d3d565b90505f0361305657604051630c9ccac560e41b815260040160405180910390fd5b5f61306460a0890189615d3d565b8101906130719190615fe5565b509091505f9050876080015160200151600281111561309257613092615bf3565b036130c9576040517f46365e5200000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b5f8760a001516020015160028111156130e4576130e4615bf3565b0361311b576040517f8999857d00000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b5f866001600160a01b031663c39619c46131388a6080015161459a565b6040518263ffffffff1660e01b81526004016131549190616452565b602060405180830381865afa15801561316f573d5f803e3d5ffd5b505050506040513d601f19601f82011682018060405250810190613193919061637f565b90505f876001600160a01b031663c39619c46131b28b60a0015161459a565b6040518263ffffffff1660e01b81526004016131ce9190616452565b602060405180830381865afa1580156131e9573d5f803e3d5ffd5b505050506040513d601f19601f8201168201806040525081019061320d919061637f565b604080516060810182529384526020840191909152820192909252935090915061243a9050565b613242878760600135612135565b61327e576040517fff6d9bd7000000000000000000000000000000000000000000000000000000008152606087013560048201526024016106b7565b60608601355f9081526020889052604081209061329a82612361565b90505f6009830154600160401b900460ff1660018111156132bd576132bd615bf3565b146132f4576040517f12459ffd00000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b600982015461330d90600160481b900460ff16866145d4565b60ff1661331d60208a018a615d24565b60ff161461337f576133326020890189615d24565b60098301546040517fac9e611600000000000000000000000000000000000000000000000000000000815260ff9283166004820152600160481b90910490911660248201526044016106b7565b61338c60a0890189615d3d565b90505f036133ad57604051630c9ccac560e41b815260040160405180910390fd5b5f808080806133bf60a08e018e615d3d565b8101906133cc919061647f565b945094509450945094506133ea876001015486896002015486613d89565b6133fe876003015485896004015485613d89565b60405180606001604052808681526020018581526020018281525086985098505050505050505061243a565b604080515f80825260208201909252819061344f9061344a9087516145f5565b61462a565b905061345a83611ee2565b61347a57604051633abfb6ff60e21b8152600481018490526024016106b7565b828460400135146134c457604080517fdfcc62bc000000000000000000000000000000000000000000000000000000008152908501356004820152602481018490526044016106b7565b6134e08460200135866020015186604001358860400151613d89565b6134ed6080850185615d3d565b90505f03613527576040517f342a075200000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b5f806135366080870187615d3d565b8101906135439190616514565b90925090506135618360016020890135612d2460408b0135836162f4565b509095945050505050565b604080516101e0810182525f80825260208201819052918101829052606081018290526080810182905260a0810182905260c0810182905260e08101829052610100810182905261012081018290526101408101829052610160810182905261018081018290526101a081018290526101c081019190915261212b84845f602086018035906040880135906060890135903390613609908b615d24565b6147ba565b61018081015181516040808401516020808601516080870151845160f89790971b6001600160f81b031916878401526021870195909552604186019290925260618501919091526081808501939093528151808503909301835260a1909301905280519101205f90611049565b60408051610100810182525f80825260208201819052918101829052606081018290526080810182905260a0810182905260c0810182905260e08101829052906136c483614483565b5f81815260208690526040902060080154909150600160a01b900467ffffffffffffffff1615613723576040517fbcedf3de000000000000000000000000000000000000000000000000000000008152600481018290526024016106b7565b5f81815260208581526040918290208551815590850151600180830191909155918501516002820155606085015160038201556080850151600482015560a0850151600582015560c0850151600682015560e0850151600782015561010085015160088201805461012088015167ffffffffffffffff908116600160a01b027fffffffff000000000000000000000000000000000000000000000000000000009092166001600160a01b03909416939093171790556101408601516009830180549190921667ffffffffffffffff19821681178355610160880151889590939268ffffffffffffffffff191690911790600160401b90849081111561382a5761382a615bf3565b02179055506101808281015160099290920180546101a08501516101c09095015167ffffffffffffffff166b0100000000000000000000000272ffffffffffffffff0000000000000000000000199515156a0100000000000000000000026aff000000000000000000001960ff909616600160481b02959095167fffffffffffffffffffffffffffffffffffffffffff0000ffffffffffffffffff909216919091179390931793909316919091179091558301518351604080860151602080880151608089015184516001600160f81b031960f89890981b97909716878401526021870195909552604186019290925260618501919091526081808501939093528151808503909301835260a1909301905280519101205f905f8181526001870160205260408120549192508190036139a0576040516815539492559053115160ba1b602082015260290160408051601f1981840301815291815281516020928301205f85815260018a019093529120556139e7565b6040516815539492559053115160ba1b60208201526029016040516020818303038152906040528051906020012081036139e7575f82815260018701602052604090208390555b6040805161010081018252848152602080820185905287518284015260e088015160608301525f86815290899052919091206080820190613a2790612e76565b815261018087015160ff166020820152911515604083015260e090950151151560609091015250919392505050565b5f613aaa826040518060400160405280602081526020017f5361666545524332303a206c6f772d6c6576656c2063616c6c206661696c6564815250856001600160a01b03166149619092919063ffffffff16565b80519091501561235c5780806020019051810190613ac89190615d05565b61235c5760405162461bcd60e51b815260206004820152602a60248201527f5361666545524332303a204552433230206f7065726174696f6e20646964206e60448201527f6f7420737563636565640000000000000000000000000000000000000000000060648201526084016106b7565b5f828152602085905260409020600701548314613ba0575f82815260208590526040908190206007015490517fc2adc3e80000000000000000000000000000000000000000000000000000000081526106b7918591600401918252602082015260400190565b5f82815260208590526040808220548583529120613bbd90612361565b14613c22575f838152602085905260409020613bd890612361565b5f83815260208690526040908190205490517fe2e27f87000000000000000000000000000000000000000000000000000000008152600481019290925260248201526044016106b7565b5f82815260208590526040808220600990810154868452919092209091015460ff600160481b92839004811692613c5b920416836145d4565b60ff161461118c575f8381526020859052604090206009015483908390613c8c90600160481b900460ff16846145d4565b5f85815260208890526040908190206009015490517f7e726d150000000000000000000000000000000000000000000000000000000081526004810194909452602484019290925260ff9081166044840152600160481b9091041660648201526084016106b7565b5f805f613d028787866120be565b905067ffffffffffffffff8511613d195784613d23565b67ffffffffffffffff5b945080851115613d7c575050505f838152602085905260409020600901805472ffffffffffffffff000000000000000000000019166b01000000000000000000000067ffffffffffffffff851602179055600182611a77565b5f97909650945050505050565b5f613dbd828486604051602001613da291815260200190565b6040516020818303038152906040528051906020012061496f565b90508085146113225760405162461bcd60e51b815260206004820152601760248201527f496e76616c696420696e636c7573696f6e2070726f6f6600000000000000000060448201526064016106b7565b5f6009820154600160401b900460ff166001811115613e2f57613e2f615bf3565b14613e8057613e3d816128d6565b60098201546040517f23f8405d0000000000000000000000000000000000000000000000000000000081526106b79291600160401b900460ff16906004016162e0565b600901805467ffffffffffffffff431668ffffffffffffffffff1990911617600160401b179055565b5f818152602083905260408120613ebf90612361565b5f8181526002850160205260409020549091508015613f14576040517fdd7028f000000000000000000000000000000000000000000000000000000000815260048101849052602481018290526044016106b7565b505f9081526002909201602052604090912055565b5f80613f358484611f08565b5f848152602086905260409020600501549091501561212e575f8381526020859052604080822060058101548352818320600990810154600690920154845291909220015467ffffffffffffffff6b0100000000000000000000009283900481169290910416808210613fa85780613faa565b815b6118c090846162f4565b5f6002613fc18484616170565b1015614003576040517f9029859400000000000000000000000000000000000000000000000000000000815260048101849052602481018390526044016106b7565b61400d8383616170565b6002036140265761401f8360016162f4565b9050611049565b5f83614033600185616170565b1890505f61404082614a22565b90505f19811b80614052600187616170565b169695505050505050565b5f85116140ac5760405162461bcd60e51b815260206004820152601460248201527f5072652d73697a652063616e6e6f74206265203000000000000000000000000060448201526064016106b7565b856140b68361462a565b146141035760405162461bcd60e51b815260206004820152601b60248201527f50726520657870616e73696f6e20726f6f74206d69736d61746368000000000060448201526064016106b7565b8461410d83614b5c565b146141805760405162461bcd60e51b815260206004820152602160248201527f5072652073697a6520646f6573206e6f74206d6174636820657870616e73696f60448201527f6e0000000000000000000000000000000000000000000000000000000000000060648201526084016106b7565b8285106141cf5760405162461bcd60e51b815260206004820181905260248201527f5072652073697a65206e6f74206c657373207468616e20706f73742073697a6560448201526064016106b7565b5f8590505f806141e1855f8751614bab565b90505b858310156142a3575f6141f78488614d1f565b9050845183106142495760405162461bcd60e51b815260206004820152601260248201527f496e646578206f7574206f662072616e6765000000000000000000000000000060448201526064016106b7565b61426d82828786815181106142605761426061611c565b6020026020010151614e06565b91506001811b61427d81866162f4565b94508785111561428f5761428f61656a565b836142998161657e565b94505050506141e4565b866142ad8261462a565b146143205760405162461bcd60e51b815260206004820152602260248201527f506f737420657870616e73696f6e20726f6f74206e6f7420657175616c20706f60448201527f737400000000000000000000000000000000000000000000000000000000000060648201526084016106b7565b835182146143705760405162461bcd60e51b815260206004820152601660248201527f496e636f6d706c6574652070726f6f662075736167650000000000000000000060448201526064016106b7565b505050505050505050565b604080516101e0810182525f80825260208201819052918101829052606081018290526080810182905260a0810182905260c0810182905260e08101829052610100810182905261012081018290526101408101829052610160810182905261018081018290526101a081018290526101c0810191909152614400878787878761536e565b50604080516101e081018252968752602087019590955293850192909252606084015260808301525f60a0830181905260c0830181905260e08301819052610100830181905267ffffffffffffffff43166101208401526101408301819052610160830181905260ff9091166101808301526101a082018190526101c082015290565b610180810151815160408084015160208086015160808701516060880151855160f89890981b6001600160f81b031916888501526021880196909652604187019390935260618601526081808601929092528251808603909201825260a18501835281519181019190912060c185015260e18085019390935281518085039093018352610101909301905280519101205f90611049565b600583015415158061452f5750600683015415155b1561458a5761453d836128d6565b600584015460068501546040517f8b0e71d00000000000000000000000000000000000000000000000000000000081526004810193909352602483019190915260448201526064016106b7565b6005830191909155600690910155565b6145a26156c6565b6040518060400160405280835f01518152602001836020015160028111156145cc576145cc615bf3565b905292915050565b5f806145e1846001616144565b90506145ed8184611c8c565b509392505050565b606061212e835f8460405160200161460f91815260200190565b60405160208183030381529060405280519060200120614e06565b5f8082511161467b5760405162461bcd60e51b815260206004820152601660248201527f456d707479206d65726b6c6520657870616e73696f6e0000000000000000000060448201526064016106b7565b6040825111156146cd5760405162461bcd60e51b815260206004820152601a60248201527f4d65726b6c6520657870616e73696f6e20746f6f206c6172676500000000000060448201526064016106b7565b5f805b83518110156147b3575f8482815181106146ec576146ec61611c565b60200260200101519050825f801b0361475657801561475157809250600185516147169190616170565b8214614751576040516147389084905f90602001918252602082015260400190565b6040516020818303038152906040528051906020012092505b6147aa565b8015614775576040805160208101839052908101849052606001614738565b6040516147919084905f90602001918252602082015260400190565b6040516020818303038152906040528051906020012092505b506001016146d0565b5092915050565b604080516101e0810182525f80825260208201819052918101829052606081018290526080810182905260a0810182905260c0810182905260e08101829052610100810182905261012081018290526101408101829052610160810182905261018081018290526101a081018290526101c08101919091526001600160a01b038316614872576040517ff289e65700000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b5f8490036148ac576040517f6932bcfd00000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b6148b9898989898961536e565b604051806101e001604052808a81526020018981526020018881526020018781526020018681526020015f801b81526020015f801b8152602001858152602001846001600160a01b031681526020014367ffffffffffffffff1681526020015f67ffffffffffffffff1681526020015f600181111561493a5761493a615bf3565b815260ff841660208201525f60408201819052606090910152905098975050505050505050565b606061212b84845f8561545f565b82515f906101008111156149ba576040517ffdac331e0000000000000000000000000000000000000000000000000000000081526004810182905261010060248201526044016106b7565b825f5b82811015614a18575f8782815181106149d8576149d861611c565b60200260200101519050816001901b87165f03614a0157825f528060205260405f209250614a0f565b805f528260205260405f2092505b506001016149bd565b5095945050505050565b5f815f03614a725760405162461bcd60e51b815260206004820152601c60248201527f5a65726f20686173206e6f207369676e69666963616e7420626974730000000060448201526064016106b7565b7001000000000000000000000000000000008210614a9d57608091821c91614a9a90826162f4565b90505b600160401b8210614abb57604091821c91614ab890826162f4565b90505b6401000000008210614ada57602091821c91614ad790826162f4565b90505b620100008210614af757601091821c91614af490826162f4565b90505b6101008210614b1357600891821c91614b1090826162f4565b90505b60108210614b2e57600491821c91614b2b90826162f4565b90505b60048210614b4957600291821c91614b4690826162f4565b90505b600282106110e6576110496001826162f4565b5f80805b83518110156147b357838181518110614b7b57614b7b61611c565b60200260200101515f801b14614ba357614b96816002616676565b614ba090836162f4565b91505b600101614b60565b6060818310614bfc5760405162461bcd60e51b815260206004820152601760248201527f5374617274206e6f74206c657373207468616e20656e6400000000000000000060448201526064016106b7565b8351821115614c735760405162461bcd60e51b815260206004820152602160248201527f456e64206e6f74206c657373206f7220657175616c207468616e206c656e677460448201527f680000000000000000000000000000000000000000000000000000000000000060648201526084016106b7565b5f614c7e8484616170565b67ffffffffffffffff811115614c9657614c96615d9e565b604051908082528060200260200182016040528015614cbf578160200160208202803683370190505b509050835b83811015614d1657858181518110614cde57614cde61611c565b6020026020010151828683614cf39190616170565b81518110614d0357614d0361611c565b6020908102919091010152600101614cc4565b50949350505050565b5f818310614d6f5760405162461bcd60e51b815260206004820152601760248201527f5374617274206e6f74206c657373207468616e20656e6400000000000000000060448201526064016106b7565b5f614d7b838518614a22565b90505f6001614d8a83826162f4565b6001901b614d989190616170565b90508481168482168115614daf5761209f82615598565b8015614dbe5761209f81614a22565b60405162461bcd60e51b815260206004820152601b60248201527f426f7468207920616e64207a2063616e6e6f74206265207a65726f000000000060448201526064016106b7565b606060408310614e585760405162461bcd60e51b815260206004820152600e60248201527f4c6576656c20746f6f206869676800000000000000000000000000000000000060448201526064016106b7565b5f829003614ea85760405162461bcd60e51b815260206004820152601b60248201527f43616e6e6f7420617070656e6420656d7074792073756274726565000000000060448201526064016106b7565b604084511115614efa5760405162461bcd60e51b815260206004820152601a60248201527f4d65726b6c6520657870616e73696f6e20746f6f206c6172676500000000000060448201526064016106b7565b83515f03614f77575f614f0e8460016162f4565b67ffffffffffffffff811115614f2657614f26615d9e565b604051908082528060200260200182016040528015614f4f578160200160208202803683370190505b50905082818581518110614f6557614f6561611c565b6020908102919091010152905061212e565b83518310614fed5760405162461bcd60e51b815260206004820152603560248201527f4c6576656c2067726561746572207468616e2068696768657374206c6576656c60448201527f206f662063757272656e7420657870616e73696f6e000000000000000000000060648201526084016106b7565b815f614ff886614b5c565b90505f615006866002616676565b61501090836162f4565b90505f61501c83614a22565b61502583614a22565b1161507357875167ffffffffffffffff81111561504457615044615d9e565b60405190808252806020026020018201604052801561506d578160200160208202803683370190505b506150c3565b87516150809060016162f4565b67ffffffffffffffff81111561509857615098615d9e565b6040519080825280602002602001820160405280156150c1578160200160208202803683370190505b505b90506040815111156151175760405162461bcd60e51b815260206004820152601c60248201527f417070656e642063726561746573206f76657273697a6520747265650000000060448201526064016106b7565b5f5b88518110156152c357878110156151bf5788818151811061513c5761513c61611c565b60200260200101515f801b146151ba5760405162461bcd60e51b815260206004820152602260248201527f417070656e642061626f7665206c65617374207369676e69666963616e74206260448201527f697400000000000000000000000000000000000000000000000000000000000060648201526084016106b7565b6152bb565b5f859003615204578881815181106151d9576151d961611c565b60200260200101518282815181106151f3576151f361611c565b6020026020010181815250506152bb565b8881815181106152165761521661611c565b60200260200101515f801b0361524c57848282815181106152395761523961611c565b60209081029190910101525f94506152bb565b5f801b8282815181106152615761526161611c565b60200260200101818152505088818151811061527f5761527f61611c565b6020026020010151856040516020016152a2929190918252602082015260400190565b6040516020818303038152906040528051906020012094505b600101615119565b5083156152f7578381600183516152da9190616170565b815181106152ea576152ea61611c565b6020026020010181815250505b80600182516153069190616170565b815181106153165761531661611c565b60200260200101515f801b0361056c5760405162461bcd60e51b815260206004820152600f60248201527f4c61737420656e747279207a65726f000000000000000000000000000000000060448201526064016106b7565b5f8590036153a8576040517f8d79dbbc00000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b8281116153eb576040517f2060faf400000000000000000000000000000000000000000000000000000000815260048101849052602481018290526044016106b7565b5f849003615425576040517f83c683e400000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b5f829003611322576040517f5cb6e5bb00000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b6060824710156154d75760405162461bcd60e51b815260206004820152602660248201527f416464726573733a20696e73756666696369656e742062616c616e636520666f60448201527f722063616c6c000000000000000000000000000000000000000000000000000060648201526084016106b7565b6001600160a01b0385163b61552e5760405162461bcd60e51b815260206004820152601d60248201527f416464726573733a2063616c6c20746f206e6f6e2d636f6e747261637400000060448201526064016106b7565b5f80866001600160a01b031685876040516155499190616681565b5f6040518083038185875af1925050503d805f8114615583576040519150601f19603f3d011682016040523d82523d5f602084013e615588565b606091505b509150915061056c828286615603565b5f8082116155e85760405162461bcd60e51b815260206004820152601c60248201527f5a65726f20686173206e6f207369676e69666963616e7420626974730000000060448201526064016106b7565b5f82806155f6600182616170565b1618905061212e81614a22565b6060831561561257508161212e565b8251156156225782518084602001fd5b8160405162461bcd60e51b81526004016106b79190616697565b6040805160c0810182525f8082526020820181905291810182905260608101919091526080810161566b6156e4565b81526020016156786156e4565b905290565b828054828255905f5260205f209081019282156156b6579160200282015b828111156156b657823582559160200191906001019061569b565b506156c2929150615709565b5090565b60405180604001604052806156d961571d565b81526020015f905290565b60405180606001604052806156f761571d565b81526020015f81525f60209091015290565b5b808211156156c2575f815560010161570a565b6040518060400160405280615730615739565b81526020016156785b60405180604001604052806002906020820280368337509192915050565b803560ff811681146110e6575f80fd5b5f805f805f8060c0878903121561577c575f80fd5b61578587615757565b9860208801359850604088013597606081013597506080810135965060a00135945092505050565b5f602082840312156157bd575f80fd5b813567ffffffffffffffff8111156157d3575f80fd5b820160c0818503121561212e575f80fd5b6001600160a01b03811681146157f8575f80fd5b50565b67ffffffffffffffff811681146157f8575f80fd5b5f8083601f840112615820575f80fd5b50813567ffffffffffffffff811115615837575f80fd5b6020830191508360208260051b8501011115615851575f80fd5b9250929050565b5f805f805f805f805f805f6101408c8e031215615873575f80fd5b8b3561587e816157e4565b9a5060208c013561588e816157fb565b995060408c013561589e816157e4565b985060608c0135975060808c0135965060a08c0135955060c08c01356158c3816157e4565b945060e08c01356158d3816157e4565b93506158e26101008d01615757565b92506101208c013567ffffffffffffffff8111156158fe575f80fd5b61590a8e828f01615810565b915080935050809150509295989b509295989b9093969950565b5f60208284031215615934575f80fd5b5035919050565b600381106157f8575f80fd5b80356110e68161593b565b5f60208284031215615962575f80fd5b813561212e8161593b565b5f805f6040848603121561597f575f80fd5b833567ffffffffffffffff811115615995575f80fd5b6159a186828701615810565b909790965060209590950135949350505050565b5f80604083850312156159c6575f80fd5b82356159d1816157e4565b946020939093013593505050565b5f805f606084860312156159f1575f80fd5b505081359360208301359350604090920135919050565b5f805f805f805f878903610120811215615a20575f80fd5b88359750602089013567ffffffffffffffff80821115615a3e575f80fd5b908a01906040828d031215615a51575f80fd5b81985060a07fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc084011215615a83575f80fd5b60408b01975060e08b0135925080831115615a9c575f80fd5b615aa88c848d01615810565b90975095506101008b0135925086915080831115615ac4575f80fd5b5050615ad28a828b01615810565b989b979a50959850939692959293505050565b5f80828403610120811215615af8575f80fd5b83359250610100601f1982011215615b0e575f80fd5b506020830190509250929050565b5f805f805f60a08688031215615b30575f80fd5b615b3986615757565b97602087013597506040870135966060810135965060800135945092505050565b5f805f8060608587031215615b6d575f80fd5b8435935060208501359250604085013567ffffffffffffffff80821115615b92575f80fd5b818701915087601f830112615ba5575f80fd5b813581811115615bb3575f80fd5b886020828501011115615bc4575f80fd5b95989497505060200194505050565b5f8060408385031215615be4575f80fd5b50508035926020909101359150565b634e487b7160e01b5f52602160045260245ffd5b60028110615c1757615c17615bf3565b9052565b5f6101e082019050825182526020830151602083015260408301516040830152606083015160608301526080830151608083015260a083015160a083015260c083015160c083015260e083015160e083015261010080840151615c88828501826001600160a01b03169052565b50506101208381015167ffffffffffffffff81168483015250506101408381015167ffffffffffffffff811684830152505061016080840151615ccd82850182615c07565b50506101808381015160ff16908301526101a0808401511515908301526101c08084015167ffffffffffffffff8116828501526120b6565b5f60208284031215615d15575f80fd5b8151801515811461212e575f80fd5b5f60208284031215615d34575f80fd5b61212e82615757565b5f8083357fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe1843603018112615d70575f80fd5b83018035915067ffffffffffffffff821115615d8a575f80fd5b602001915036819003821315615851575f80fd5b634e487b7160e01b5f52604160045260245ffd5b6040516060810167ffffffffffffffff81118282101715615dd557615dd5615d9e565b60405290565b6040805190810167ffffffffffffffff81118282101715615dd557615dd5615d9e565b604051601f8201601f1916810167ffffffffffffffff81118282101715615e2757615e27615d9e565b604052919050565b5f67ffffffffffffffff821115615e4857615e48615d9e565b5060051b60200190565b5f82601f830112615e61575f80fd5b81356020615e76615e7183615e2f565b615dfe565b8083825260208201915060208460051b870101935086841115615e97575f80fd5b602086015b84811015615eb35780358352918301918301615e9c565b509695505050505050565b5f82601f830112615ecd575f80fd5b615ed5615ddb565b806040840185811115615ee6575f80fd5b845b81811015613561578035615efb816157fb565b845260209384019301615ee8565b5f818303610100811215615f1b575f80fd5b615f23615db2565b915060c0811215615f32575f80fd5b615f3a615db2565b6080821215615f47575f80fd5b615f4f615ddb565b915084601f850112615f5f575f80fd5b615f67615ddb565b806040860187811115615f78575f80fd5b865b81811015615f92578035845260209384019301615f7a565b50818552615fa08882615ebe565b6020860152505050818152615fb760808501615947565b602082015260a08401356040820152808352505060c0820135602082015260e0820135604082015292915050565b5f805f6102208486031215615ff8575f80fd5b833567ffffffffffffffff81111561600e575f80fd5b61601a86828701615e52565b93505061602a8560208601615f09565b915061603a856101208601615f09565b90509250925092565b8051825f5b6002811015616067578251825260209283019290910190600101616048565b505050602080820151604084015f5b600281101561609d57825167ffffffffffffffff1682529183019190830190600101616076565b505050505050565b600381106157f8576157f8615bf3565b5f610120820190508582526160ce602083018651616043565b60208501516160dc816160a5565b60a08301526040949094015160c082015260e081019290925261010090910152919050565b5f60208284031215616111575f80fd5b815161212e816157fb565b634e487b7160e01b5f52603260045260245ffd5b634e487b7160e01b5f52601160045260245ffd5b60ff818116838216019081111561104957611049616130565b6020810161616a836160a5565b91905290565b8181038181111561104957611049616130565b5f60c082019050838252823560208301526020830135604083015260408301356161ac816157e4565b6001600160a01b03811660608401525060608301356161ca816157fb565b67ffffffffffffffff8082166080850152608085013591506161eb826157fb565b80821660a085015250509392505050565b5f6020828403121561620c575f80fd5b813561212e816157fb565b5f60208284031215616227575f80fd5b815161212e816157e4565b848152610120810160206040868285013760608301604087015f5b600281101561627d578135616261816157fb565b67ffffffffffffffff168352918301919083019060010161624d565b50505050608085013561628f8161593b565b616298816160a5565b8060a08401525060a085013560c08301528360e08301528261010083015295945050505050565b67ffffffffffffffff8281168282160390808211156147b3576147b3616130565b8281526040810161212e6020830184615c07565b8082018082111561104957611049616130565b808202811582820484141761104957611049616130565b855181526001600160a01b0360208701511660208201526040860151604082015284606082015283608082015260c060a08201528160c0820152818360e08301375f81830160e090810191909152601f909201601f19160101949350505050565b5f6020828403121561638f575f80fd5b5051919050565b5f82601f8301126163a5575f80fd5b815160206163b5615e7183615e2f565b8083825260208201915060208460051b8701019350868411156163d6575f80fd5b602086015b84811015615eb357805183529183019183016163db565b5f8060408385031215616403575f80fd5b825167ffffffffffffffff8082111561641a575f80fd5b61642686838701616396565b9350602085015191508082111561643b575f80fd5b5061644885828601616396565b9150509250929050565b5f60a082019050616464828451616043565b6020830151616472816160a5565b8060808401525092915050565b5f805f805f60a08688031215616493575f80fd5b8535945060208601359350604086013567ffffffffffffffff808211156164b8575f80fd5b6164c489838a01615e52565b945060608801359150808211156164d9575f80fd5b6164e589838a01615e52565b935060808801359150808211156164fa575f80fd5b5061650788828901615e52565b9150509295509295909350565b5f8060408385031215616525575f80fd5b823567ffffffffffffffff8082111561653c575f80fd5b61654886838701615e52565b9350602085013591508082111561655d575f80fd5b5061644885828601615e52565b634e487b7160e01b5f52600160045260245ffd5b5f5f19820361658f5761658f616130565b5060010190565b600181815b808511156165d057815f19048211156165b6576165b6616130565b808516156165c357918102915b93841c939080029061659b565b509250929050565b5f826165e657506001611049565b816165f257505f611049565b816001811461660857600281146166125761662e565b6001915050611049565b60ff84111561662357616623616130565b50506001821b611049565b5060208310610133831016604e8410600b8410161715616651575081810a611049565b61665b8383616596565b805f190482111561666e5761666e616130565b029392505050565b5f61212e83836165d8565b5f82518060208501845e5f920191825250919050565b602081525f82518060208401528060208501604085015e5f604082850101526040601f19601f8301168401019150509291505056fea2646970667358221220240de4a00f4b4dbe239023d97f9eb59c9ae61e457f231a82c1f1892dbd1a3cfb64736f6c63430008190033
    /// ```
    #[rustfmt::skip]
    #[allow(clippy::all)]
    pub static BYTECODE: alloy_sol_types::private::Bytes = alloy_sol_types::private::Bytes::from_static(
        b"`\x80`@R4\x80\x15`\x0EW_\x80\xFD[P`\x15`\x19V[`\xD4V[_Ta\x01\0\x90\x04`\xFF\x16\x15`\x83W`@QbF\x1B\xCD`\xE5\x1B\x81R` `\x04\x82\x01R`'`$\x82\x01R\x7FInitializable: contract is initi`D\x82\x01Rfalizing`\xC8\x1B`d\x82\x01R`\x84\x01`@Q\x80\x91\x03\x90\xFD[_T`\xFF\x90\x81\x16\x10\x15`\xD2W_\x80T`\xFF\x19\x16`\xFF\x90\x81\x17\x90\x91U`@Q\x90\x81R\x7F\x7F&\xB8?\xF9n\x1F+jh/\x138R\xF6y\x8A\t\xC4e\xDA\x95\x92\x14`\xCE\xFB8G@$\x98\x90` \x01`@Q\x80\x91\x03\x90\xA1[V[ag\x02\x80a\0\xE1_9_\xF3\xFE`\x80`@R4\x80\x15a\0\x0FW_\x80\xFD[P`\x046\x10a\x01\xE6W_5`\xE0\x1C\x80ce[B\xF3\x11a\x01\tW\x80c\xC3-\x8Cc\x11a\0\x9EW\x80c\xEA\xE02\x8B\x11a\0nW\x80c\xEA\xE02\x8B\x14a\x04\xA6W\x80c\xED\xAA\xB5J\x14a\x04\xB9W\x80c\xF8\xEEw\xD6\x14a\x04\xCCW\x80c\xFD\xA2\x89.\x14a\x04\xD5W_\x80\xFD[\x80c\xC3-\x8Cc\x14a\x049W\x80c\xC8\xBCNC\x14a\x04LW\x80c\xE5\xB1#\xDA\x14a\x04tW\x80c\xE9N\x05\x1E\x14a\x04\x93W_\x80\xFD[\x80c\x8C\x1B:@\x11a\0\xD9W\x80c\x8C\x1B:@\x14a\x03\xE1W\x80c\x90\x85\x17\xE9\x14a\x03\xF4W\x80c\xB2\xA1@\x8E\x14a\x04\x07W\x80c\xBC\xE6\xF5O\x14a\x04\x1AW_\x80\xFD[\x80ce[B\xF3\x14a\x03pW\x80ct\x89&\xF3\x14a\x03\xA8W\x80cu\x0E\x0C\x0F\x14a\x03\xBBW\x80c\x88&\xA3p\x14a\x03\xCEW_\x80\xFD[\x80cC+\xB7\x8A\x11a\x01\x7FW\x80cQ\xEDj0\x11a\x01OW\x80cQ\xEDj0\x14a\x03\x08W\x80cT\xB6AQ\x14a\x03\x1BW\x80cZH\xE0\xF4\x14a\x03>W\x80c]\x9E$D\x14a\x03QW_\x80\xFD[\x80cC+\xB7\x8A\x14a\x02\x83W\x80cF\xC2x\x1A\x14a\x02\x96W\x80cH\x92;\xC5\x14a\x02\xC3W\x80cH\xDD)$\x14a\x02\xEEW_\x80\xFD[\x80c\x1D\xCEQf\x11a\x01\xBAW\x80c\x1D\xCEQf\x14a\x02KW\x80c>5\xF5\xE8\x14a\x02TW\x80cAnfW\x14a\x02gW\x80cB\xE1\xAA\xA8\x14a\x02pW_\x80\xFD[\x80bM\x8E\xFE\x14a\x01\xEAW\x80c\x05\xFA\xE1A\x14a\x02\x10W\x80c\x1Ar\xD5L\x14a\x02#W\x80c\x1C\x1BO:\x14a\x028W[_\x80\xFD[a\x01\xFDa\x01\xF86`\x04aWgV[a\x04\xF5V[`@Q\x90\x81R` \x01[`@Q\x80\x91\x03\x90\xF3[a\x01\xFDa\x02\x1E6`\x04aW\xADV[a\x05wV[a\x026a\x0216`\x04aXXV[a\x0B\xB1V[\0[a\x01\xFDa\x02F6`\x04aY$V[a\x10\x1EV[a\x01\xFD`\nT\x81V[a\x01\xFDa\x02b6`\x04aY$V[a\x10=V[a\x01\xFD`\x0BT\x81V[a\x01\xFDa\x02~6`\x04aYRV[a\x10OV[a\x026a\x02\x916`\x04aYmV[a\x10\xEBV[`\x08Ta\x02\xAA\x90g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x81V[`@Qg\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x90\x91\x16\x81R` \x01a\x02\x07V[`\tTa\x02\xD6\x90`\x01`\x01`\xA0\x1B\x03\x16\x81V[`@Q`\x01`\x01`\xA0\x1B\x03\x90\x91\x16\x81R` \x01a\x02\x07V[`\x08Ta\x02\xD6\x90`\x01`@\x1B\x90\x04`\x01`\x01`\xA0\x1B\x03\x16\x81V[`\x06Ta\x02\xD6\x90`\x01`\x01`\xA0\x1B\x03\x16\x81V[a\x03.a\x03)6`\x04aY$V[a\x11\x92V[`@Q\x90\x15\x15\x81R` \x01a\x02\x07V[a\x01\xFDa\x03L6`\x04aY$V[a\x11\x9EV[`\rTa\x03^\x90`\xFF\x16\x81V[`@Q`\xFF\x90\x91\x16\x81R` \x01a\x02\x07V[a\x03.a\x03~6`\x04aY\xB5V[`\x01`\x01`\xA0\x1B\x03\x91\x90\x91\x16_\x90\x81R`\x04` \x90\x81R`@\x80\x83 \x93\x83R\x92\x90R T`\xFF\x16\x90V[a\x026a\x03\xB66`\x04aY$V[a\x11\xAAV[a\x03.a\x03\xC96`\x04aY$V[a\x12\x99V[a\x026a\x03\xDC6`\x04aY\xDFV[a\x12\xC2V[a\x026a\x03\xEF6`\x04aZ\x08V[a\x13)V[a\x03.a\x04\x026`\x04aY$V[a\x14\xE8V[a\x026a\x04\x156`\x04aZ\xE5V[a\x14\xF4V[a\x01\xFDa\x04(6`\x04aY$V[_\x90\x81R`\x02` R`@\x90 T\x90V[a\x01\xFDa\x04G6`\x04a[\x1CV[a\x18mV[a\x04_a\x04Z6`\x04a[ZV[a\x18\xCAV[`@\x80Q\x92\x83R` \x83\x01\x91\x90\x91R\x01a\x02\x07V[a\x01\xFDa\x04\x826`\x04aY$V[_\x90\x81R`\x03` R`@\x90 T\x90V[`\x05Ta\x02\xD6\x90`\x01`\x01`\xA0\x1B\x03\x16\x81V[a\x01\xFDa\x04\xB46`\x04aY$V[a\x1A\x80V[a\x026a\x04\xC76`\x04a[\xD3V[a\x1A\x94V[a\x01\xFD`\x0CT\x81V[a\x04\xE8a\x04\xE36`\x04aY$V[a\x1A\xECV[`@Qa\x02\x07\x91\x90a\\\x1BV[`@\x80Q`\xF8\x88\x90\x1B`\x01`\x01`\xF8\x1B\x03\x19\x16` \x80\x83\x01\x91\x90\x91R`!\x82\x01\x88\x90R`A\x82\x01\x87\x90R`a\x82\x01\x86\x90R`\x81\x80\x83\x01\x86\x90R\x83Q\x80\x84\x03\x90\x91\x01\x81R`\xA1\x83\x01\x84R\x80Q\x90\x82\x01 `\xC1\x83\x01R`\xE1\x80\x83\x01\x85\x90R\x83Q\x80\x84\x03\x90\x91\x01\x81Ra\x01\x01\x90\x92\x01\x90\x92R\x80Q\x91\x01 _\x90[\x97\x96PPPPPPPV[_\x80`\x08\x80T\x90a\x01\0\n\x90\x04`\x01`\x01`\xA0\x1B\x03\x16`\x01`\x01`\xA0\x1B\x03\x16c\x12\xAB=;`@Q\x81c\xFF\xFF\xFF\xFF\x16`\xE0\x1B\x81R`\x04\x01` `@Q\x80\x83\x03\x81\x86Z\xFA\x15\x80\x15a\x05\xC8W=_\x80>=_\xFD[PPPP`@Q=`\x1F\x19`\x1F\x82\x01\x16\x82\x01\x80`@RP\x81\x01\x90a\x05\xEC\x91\x90a]\x05V[\x15\x90P\x80\x80\x15a\x06\x82WP`\x08T`@Q\x7F\xFA\xCDt;\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R3`\x04\x82\x01R`\x01`@\x1B\x90\x91\x04`\x01`\x01`\xA0\x1B\x03\x16\x90c\xFA\xCDt;\x90`$\x01` `@Q\x80\x83\x03\x81\x86Z\xFA\x15\x80\x15a\x06\\W=_\x80>=_\xFD[PPPP`@Q=`\x1F\x19`\x1F\x82\x01\x16\x82\x01\x80`@RP\x81\x01\x90a\x06\x80\x91\x90a]\x05V[\x15[\x15a\x06\xC0W`@Q\x7F\xED=\xB8\xAC\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R3`\x04\x82\x01R`$\x01[`@Q\x80\x91\x03\x90\xFD[`@\x80Qa\x01\0\x81\x01\x82R_\x80\x82R` \x82\x01\x81\x90R\x91\x81\x01\x82\x90R``\x81\x01\x82\x90R`\x80\x81\x01\x82\x90R`\xA0\x81\x01\x82\x90R`\xC0\x81\x01\x82\x90R`\xE0\x81\x01\x91\x90\x91R_a\x07\x1Ca\x07\x11` \x87\x01\x87a]$V[`\rT`\xFF\x16a\x1C\x8CV[\x90P_a\x07(\x82a\x10OV[\x90Pa\x072aV<V[_\x83`\x02\x81\x11\x15a\x07EWa\x07Ea[\xF3V[\x03a\ndWa\x07W`\xA0\x88\x01\x88a]=V[\x90P_\x03a\x07xW`@Qc\x0C\x9C\xCA\xC5`\xE4\x1B\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[_\x80a\x07\x87`\xA0\x8A\x01\x8Aa]=V[\x81\x01\x90a\x07\x94\x91\x90a_\xE5V[\x92P\x92PP`\x08\x80T\x90a\x01\0\n\x90\x04`\x01`\x01`\xA0\x1B\x03\x16`\x01`\x01`\xA0\x1B\x03\x16c\xE5\x10\x19\xA6\x8A``\x015\x83_\x01Q\x84` \x01Q\x85`@\x01Q`@Q\x85c\xFF\xFF\xFF\xFF\x16`\xE0\x1B\x81R`\x04\x01a\x07\xED\x94\x93\x92\x91\x90a`\xB5V[_`@Q\x80\x83\x03\x81\x86\x80;\x15\x80\x15a\x08\x03W_\x80\xFD[PZ\xFA\x15\x80\x15a\x08\x15W=_\x80>=_\xFD[PP`\x08T` \x84\x81\x01Q\x86Q\x91\x87\x01Q`@\x80\x89\x01Q\x90Q\x7F\xE5\x10\x19\xA6\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x01`@\x1B\x90\x95\x04`\x01`\x01`\xA0\x1B\x03\x16\x96Pc\xE5\x10\x19\xA6\x95Pa\x08z\x94\x92\x93\x92`\x04\x01a`\xB5V[_`@Q\x80\x83\x03\x81\x86\x80;\x15\x80\x15a\x08\x90W_\x80\xFD[PZ\xFA\x15\x80\x15a\x08\xA2W=_\x80>=_\xFD[PPPP\x80_\x01Q`@\x01Q\x89` \x015\x14a\x08\xFFW\x80Q`@\x90\x81\x01Q\x90Q\x7F:c\xE9\x9A\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R` \x8B\x015`\x04\x82\x01R`$\x81\x01\x91\x90\x91R`D\x01a\x06\xB7V[`@\x80Q`\xC0\x81\x01\x82R``\x8B\x015\x80\x82R` \x84\x81\x01Q\x90\x83\x01R`\x08T\x83Q\x7F\xE51\xD8\xC7\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x81\x01\x92\x90\x92R\x91\x92\x83\x01\x91`\x01`@\x1B\x90\x04`\x01`\x01`\xA0\x1B\x03\x16\x90c\xE51\xD8\xC7\x90`$\x01` `@Q\x80\x83\x03\x81\x86Z\xFA\x15\x80\x15a\t\x85W=_\x80>=_\xFD[PPPP`@Q=`\x1F\x19`\x1F\x82\x01\x16\x82\x01\x80`@RP\x81\x01\x90a\t\xA9\x91\x90a]\x05V[\x15\x15\x81R`\x08T` \x84\x81\x01Q`@Q\x7FV\xBB\xC9\xE6\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x81\x01\x91\x90\x91R\x92\x01\x91_\x91`\x01`@\x1B\x90\x04`\x01`\x01`\xA0\x1B\x03\x16\x90cV\xBB\xC9\xE6\x90`$\x01` `@Q\x80\x83\x03\x81\x86Z\xFA\x15\x80\x15a\n\x1EW=_\x80>=_\xFD[PPPP`@Q=`\x1F\x19`\x1F\x82\x01\x16\x82\x01\x80`@RP\x81\x01\x90a\nB\x91\x90aa\x01V[g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x11\x81R\x92Q` \x84\x01R\x90Q`@\x90\x92\x01\x91\x90\x91R\x90P[`\tT`\rTa\n\x8C\x91`\x01\x91\x8A\x91\x85\x91`\x01`\x01`\xA0\x1B\x03\x90\x91\x16\x90\x87\x90`\xFF\x16\x8Ba\x1D\x11V[`\x06T\x90\x94P`\x01`\x01`\xA0\x1B\x03\x16_`\x07a\n\xAB` \x8B\x01\x8Ba]$V[`\xFF\x16\x81T\x81\x10a\n\xBEWa\n\xBEaa\x1CV[_\x91\x82R` \x90\x91 \x01T\x90P`\x01`\x01`\xA0\x1B\x03\x82\x16\x15\x80\x15\x90a\n\xE2WP\x80\x15\x15[\x15a\x0B\x1DW_\x86`\xC0\x01Qa\n\xF7W0a\x0B\x04V[`\x05T`\x01`\x01`\xA0\x1B\x03\x16[\x90Pa\x0B\x1B`\x01`\x01`\xA0\x1B\x03\x84\x163\x83\x85a\x1E1V[P[\x85`@\x01Q\x86` \x01Q\x87_\x01Q\x7F\xAAKf\xB1\xCE\x93\x8C\x06\xE2\xA3\xF8Fk\xAE\x10\xEFb\xE7Gc\x0E8Y\x88\x9FG\x19\xFCd'\xB5\xA4\x89``\x01Q\x8A`\x80\x01Q\x8B`\xA0\x01Q\x8C`\xC0\x01Q\x8D`\xE0\x01Q`@Qa\x0B\x9B\x95\x94\x93\x92\x91\x90\x94\x85R` \x85\x01\x93\x90\x93R`\xFF\x91\x90\x91\x16`@\x84\x01R\x15\x15``\x83\x01R\x15\x15`\x80\x82\x01R`\xA0\x01\x90V[`@Q\x80\x91\x03\x90\xA4PP\x92Q\x96\x95PPPPPPV[_Ta\x01\0\x90\x04`\xFF\x16\x15\x80\x80\x15a\x0B\xCFWP_T`\x01`\xFF\x90\x91\x16\x10[\x80a\x0B\xE8WP0;\x15\x80\x15a\x0B\xE8WP_T`\xFF\x16`\x01\x14[a\x0CZW`@QbF\x1B\xCD`\xE5\x1B\x81R` `\x04\x82\x01R`.`$\x82\x01R\x7FInitializable: contract is alrea`D\x82\x01R\x7Fdy initialized\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0`d\x82\x01R`\x84\x01a\x06\xB7V[_\x80T`\xFF\x19\x16`\x01\x17\x90U\x80\x15a\x0C{W_\x80Ta\xFF\0\x19\x16a\x01\0\x17\x90U[`\x01`\x01`\xA0\x1B\x03\x8C\x16a\x0C\xBBW`@Q\x7F\xC8>\x08b\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[`\x08\x80T`\x01`\x01`\xA0\x1B\x03\x80\x8F\x16`\x01`@\x1B\x02\x7F\xFF\xFF\xFF\xFF\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x90\x92\x16\x91\x90\x91\x17\x90\x91U\x8A\x16a\r3W`@Q\x7F\xFB`\xB0\xEF\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[`\t\x80Ts\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x19\x16`\x01`\x01`\xA0\x1B\x03\x8C\x16\x17\x90Ug\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x8B\x16_\x03a\r\x9EW`@Q\x7F\x8A\x0E\xED\xCC\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[`\x08\x80Tg\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x19\x16g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x8D\x16\x17\x90U`\x06\x80Ts\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x19\x16`\x01`\x01`\xA0\x1B\x03\x88\x81\x16\x91\x90\x91\x17\x90\x91U\x85\x16a\x0E W`@Q\x7F\x0F\x0E\xC8\xA8\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[`\x05\x80Ts\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x19\x16`\x01`\x01`\xA0\x1B\x03\x87\x16\x17\x90Ua\x0EQ\x89a\x1E\xE2V[a\x0EqW`@Qc:\xBF\xB6\xFF`\xE2\x1B\x81R`\x04\x81\x01\x8A\x90R`$\x01a\x06\xB7V[`\n\x89\x90Ua\x0E\x7F\x88a\x1E\xE2V[a\x0E\x9FW`@Qc:\xBF\xB6\xFF`\xE2\x1B\x81R`\x04\x81\x01\x89\x90R`$\x01a\x06\xB7V[`\x0B\x88\x90Ua\x0E\xAD\x87a\x1E\xE2V[a\x0E\xCDW`@Qc:\xBF\xB6\xFF`\xE2\x1B\x81R`\x04\x81\x01\x88\x90R`$\x01a\x06\xB7V[`\x0C\x87\x90U`\xFF\x84\x16_\x03a\x0F\x0EW`@Q\x7F\xA8c\xD6\xE4\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[`\xFD\x84`\xFF\x16\x11\x15a\x0FQW`@Q\x7F@\xD2;\xF0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\xFF\x85\x16`\x04\x82\x01R`$\x01a\x06\xB7V[`\r\x80T`\xFF\x19\x16`\xFF\x86\x16\x17\x90U\x81a\x0Fl\x85`\x02aaDV[`\xFF\x16\x14a\x0F\xBEW\x81a\x0F\x80\x85`\x02aaDV[`@Q\x7F\n\xEC\xE9\xC0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x81\x01\x92\x90\x92R`\xFF\x16`$\x82\x01R`D\x01a\x06\xB7V[a\x0F\xCA`\x07\x84\x84aV}V[P\x80\x15a\x10\x10W_\x80Ta\xFF\0\x19\x16\x90U`@Q`\x01\x81R\x7F\x7F&\xB8?\xF9n\x1F+jh/\x138R\xF6y\x8A\t\xC4e\xDA\x95\x92\x14`\xCE\xFB8G@$\x98\x90` \x01`@Q\x80\x91\x03\x90\xA1[PPPPPPPPPPPPV[`\x07\x81\x81T\x81\x10a\x10-W_\x80\xFD[_\x91\x82R` \x90\x91 \x01T\x90P\x81V[_a\x10I`\x01\x83a\x1F\x08V[\x92\x91PPV[_\x80\x82`\x02\x81\x11\x15a\x10cWa\x10ca[\xF3V[\x03a\x10pWPP`\nT\x90V[`\x01\x82`\x02\x81\x11\x15a\x10\x84Wa\x10\x84a[\xF3V[\x03a\x10\x91WPP`\x0BT\x90V[`\x02\x82`\x02\x81\x11\x15a\x10\xA5Wa\x10\xA5a[\xF3V[\x03a\x10\xB2WPP`\x0CT\x90V[\x81`@Q\x7F;\xF2\xE1\xEC\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01a\x06\xB7\x91\x90aa]V[\x91\x90PV[_\x82\x90\x03a\x11%W`@Q\x7FR\x12\x99\xA9\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[a\x11V\x83\x83a\x115`\x01\x82aapV[\x81\x81\x10a\x11DWa\x11Daa\x1CV[`\x01\x92` \x90\x91\x02\x015\x90P\x83a \xBEV[P_[\x82\x81\x10\x15a\x11\x8CWa\x11\x84\x84\x84\x83\x81\x81\x10a\x11vWa\x11vaa\x1CV[\x90P` \x02\x015_\x19a\x1A\x94V[`\x01\x01a\x11YV[PPPPV[_a\x10I`\x01\x83a!5V[_a\x10I`\x01\x83a!gV[_a\x11\xB6`\x01\x83a!\xB6V[\x90Pa\x11\xC1\x81a\"\tV[`\x06T`\t\x82\x01T`\x07\x80T`\x01`\x01`\xA0\x1B\x03\x90\x93\x16\x92_\x92`\x01`H\x1B\x90\x04`\xFF\x16\x90\x81\x10a\x11\xF4Wa\x11\xF4aa\x1CV[_\x91\x82R` \x90\x91 \x01T\x90P`\x01`\x01`\xA0\x1B\x03\x82\x16\x15\x80\x15\x90a\x12\x18WP\x80\x15\x15[\x15a\x129W`\x08\x83\x01Ta\x129\x90`\x01`\x01`\xA0\x1B\x03\x84\x81\x16\x91\x16\x83a#\x13V[_\x84\x81R`\x01` R`@\x90 a\x12O\x90a#aV[`@\x80Q`\x01`\x01`\xA0\x1B\x03\x85\x16\x81R` \x81\x01\x84\x90R\x86\x91\x7F\xA659\x89Y\xDD\xB5\xCE;\x14S~\xDF\xC2[.g\x12t\xC9\xB8\xCA\xD0\xF4\xBDcGR\xE6\x90\x07\xB6\x91\x01`@Q\x80\x91\x03\x90\xA3PPPPV[_\x81\x81R`\x01` R`@\x81 `\x08\x01T`\x01`\xA0\x1B\x90\x04g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x15\x15a\x10IV[`\rT_\x90\x81\x90a\x12\xDD\x90`\x01\x90\x87\x90\x87\x90`\xFF\x16\x87a#\xD7V[\x91P\x91P\x81\x15a\x13\"W\x84\x7F\xBE\x17u]\x8D\x83j\xD6{\xFA\xF8\xE5\xB3\x86\x9A\xED\xB4\xCB\xA0?)Z\x16|UG\xFE\xDD\xD9\xEFP\xAD\x82`@Qa\x13\x19\x91\x81R` \x01\x90V[`@Q\x80\x91\x03\x90\xA2[PPPPPV[_a\x135`\x01\x89a!gV[`\x08T`@Q\x7F\x04\x97*\xF9\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R\x91\x92P`\x01`@\x1B\x90\x04`\x01`\x01`\xA0\x1B\x03\x16\x90c\x04\x97*\xF9\x90a\x13\x88\x90\x84\x90\x8A\x90`\x04\x01aa\x83V[_`@Q\x80\x83\x03\x81\x86\x80;\x15\x80\x15a\x13\x9EW_\x80\xFD[PZ\xFA\x15\x80\x15a\x13\xB0W=_\x80>=_\xFD[PPPP_`@Q\x80``\x01`@R\x80\x88`\x80\x01` \x81\x01\x90a\x13\xD3\x91\x90aa\xFCV[g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x81R` \x01`\x08\x80T\x90a\x01\0\n\x90\x04`\x01`\x01`\xA0\x1B\x03\x16`\x01`\x01`\xA0\x1B\x03\x16c\xE7\x8C\xEA\x92`@Q\x81c\xFF\xFF\xFF\xFF\x16`\xE0\x1B\x81R`\x04\x01` `@Q\x80\x83\x03\x81\x86Z\xFA\x15\x80\x15a\x141W=_\x80>=_\xFD[PPPP`@Q=`\x1F\x19`\x1F\x82\x01\x16\x82\x01\x80`@RP\x81\x01\x90a\x14U\x91\x90ab\x17V[`\x01`\x01`\xA0\x1B\x03\x90\x81\x16\x82R\x895` \x90\x92\x01\x91\x90\x91R`\tT`\rT`\x0BT`\x0CT\x94\x95Pa\x14\x9D\x94`\x01\x94\x8F\x94\x16\x92\x8E\x92\x88\x92\x8E\x92\x8E\x92\x8E\x92\x8E\x92`\xFF\x16\x91\x90a$DV[_\x89\x81R`\x01` R`@\x90 a\x14\xB3\x90a#aV[`@Q\x8A\x90\x7F\xE1\x1D\xB4\xB2{\xC8\xC6\xEAYC\xEC\xBB Z\xE1\xCA\x8DV\xC4,q\x97\x17\xAA\xF8\xA5=C\xD0\xCE\xE7\xC2\x90_\x90\xA3PPPPPPPPPV[_a\x10I`\x01\x83a'\xD6V[_a\x15\0`\x01\x84a!\xB6V[\x90Pa\x15\x0B\x81a(\xB3V[a\x15mWa\x15\x18\x81a(\xD6V[`\x08\x82\x01T`\x07\x83\x01T`@Q\x7F\xE5\x8C\x83\x08\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x81\x01\x93\x90\x93R`\x01`\x01`\xA0\x1B\x03\x90\x91\x16`$\x83\x01R`D\x82\x01R`d\x01a\x06\xB7V[_\x80\x80`\t\x84\x01T`\rTa\x15\x8F\x91`\xFF`\x01`H\x1B\x90\x91\x04\x81\x16\x91\x16a\x1C\x8CV[`\x02\x81\x11\x15a\x15\xA0Wa\x15\xA0a[\xF3V[\x14\x90P\x80\x80\x15a\x16;WP`\x08T`\x07\x84\x01T`@Q\x7F0\x83b(\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x81\x01\x91\x90\x91R`\x01`@\x1B\x90\x91\x04`\x01`\x01`\xA0\x1B\x03\x16\x90c0\x83b(\x90`$\x01` `@Q\x80\x83\x03\x81\x86Z\xFA\x15\x80\x15a\x16\x17W=_\x80>=_\xFD[PPPP`@Q=`\x1F\x19`\x1F\x82\x01\x16\x82\x01\x80`@RP\x81\x01\x90a\x16;\x91\x90a]\x05V[\x15a\x17\xF3W`\x08T`\x07\x84\x01T`@Q\x7F\xE5\x10\x19\xA6\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x01`@\x1B\x90\x92\x04`\x01`\x01`\xA0\x1B\x03\x16\x91c\xE5\x10\x19\xA6\x91a\x16\xA0\x91\x88\x90`\xC0\x82\x015\x90`\xE0\x83\x015\x90`\x04\x01ab2V[_`@Q\x80\x83\x03\x81\x86\x80;\x15\x80\x15a\x16\xB6W_\x80\xFD[PZ\xFA\x15\x80\x15a\x16\xC8W=_\x80>=_\xFD[PP`\x08T`@Q\x7F\x11qU\x85\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\xC0\x88\x015`\x04\x82\x01R`\x01`@\x1B\x90\x91\x04`\x01`\x01`\xA0\x1B\x03\x16\x92Pc\x11qU\x85\x91P`$\x01` `@Q\x80\x83\x03\x81\x86Z\xFA\x15\x80\x15a\x175W=_\x80>=_\xFD[PPPP`@Q=`\x1F\x19`\x1F\x82\x01\x16\x82\x01\x80`@RP\x81\x01\x90a\x17Y\x91\x90aa\x01V[`\x08T`@Q\x7FV\xBB\xC9\xE6\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\xC0\x87\x015`\x04\x82\x01R`\x01`@\x1B\x90\x91\x04`\x01`\x01`\xA0\x1B\x03\x16\x90cV\xBB\xC9\xE6\x90`$\x01` `@Q\x80\x83\x03\x81\x86Z\xFA\x15\x80\x15a\x17\xC2W=_\x80>=_\xFD[PPPP`@Q=`\x1F\x19`\x1F\x82\x01\x16\x82\x01\x80`@RP\x81\x01\x90a\x17\xE6\x91\x90aa\x01V[a\x17\xF0\x91\x90ab\xBFV[\x91P[`\x08T_\x90a\x18\x12\x90`\x01\x90\x88\x90\x86\x90g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16a)vV[_\x87\x81R`\x01` R`@\x90 \x90\x91Pa\x18+\x90a#aV[\x86\x7F.\x08\x08\x83\n\" L\xB3\xFB\x8F\x8DxK(\xBC\x97\xE9\xCE.9\xD2\xF9\xCD\xE2\x86\r\xE0\x95}h\xEB\x83`@Qa\x18]\x91\x81R` \x01\x90V[`@Q\x80\x91\x03\x90\xA3PPPPPPV[`@\x80Q`\xF8\x87\x90\x1B`\x01`\x01`\xF8\x1B\x03\x19\x16` \x80\x83\x01\x91\x90\x91R`!\x82\x01\x87\x90R`A\x82\x01\x86\x90R`a\x82\x01\x85\x90R`\x81\x80\x83\x01\x85\x90R\x83Q\x80\x84\x03\x90\x91\x01\x81R`\xA1\x90\x92\x01\x90\x92R\x80Q\x91\x01 _\x90[\x96\x95PPPPPPV[_\x80_\x80_a\x19\x15\x89\x89\x89\x89\x80\x80`\x1F\x01` \x80\x91\x04\x02` \x01`@Q\x90\x81\x01`@R\x80\x93\x92\x91\x90\x81\x81R` \x01\x83\x83\x80\x82\x847_\x92\x01\x91\x90\x91RP`\x01\x95\x94\x93\x92PPa*Z\x90PV[\x81Q\x92\x95P\x90\x93P\x91P\x15\x80a\x19\xACW\x82`@\x01Q\x83` \x01Q\x84_\x01Q\x7F\xAAKf\xB1\xCE\x93\x8C\x06\xE2\xA3\xF8Fk\xAE\x10\xEFb\xE7Gc\x0E8Y\x88\x9FG\x19\xFCd'\xB5\xA4\x86``\x01Q\x87`\x80\x01Q\x88`\xA0\x01Q\x89`\xC0\x01Q\x8A`\xE0\x01Q`@Qa\x19\xA3\x95\x94\x93\x92\x91\x90\x94\x85R` \x85\x01\x93\x90\x93R`\xFF\x91\x90\x91\x16`@\x84\x01R\x15\x15``\x83\x01R\x15\x15`\x80\x82\x01R`\xA0\x01\x90V[`@Q\x80\x91\x03\x90\xA4[\x81`@\x01Q\x82` \x01Q\x83_\x01Q\x7F\xAAKf\xB1\xCE\x93\x8C\x06\xE2\xA3\xF8Fk\xAE\x10\xEFb\xE7Gc\x0E8Y\x88\x9FG\x19\xFCd'\xB5\xA4\x85``\x01Q\x86`\x80\x01Q\x87`\xA0\x01Q\x88`\xC0\x01Q\x89`\xE0\x01Q`@Qa\x1A*\x95\x94\x93\x92\x91\x90\x94\x85R` \x85\x01\x93\x90\x93R`\xFF\x91\x90\x91\x16`@\x84\x01R\x15\x15``\x83\x01R\x15\x15`\x80\x82\x01R`\xA0\x01\x90V[`@Q\x80\x91\x03\x90\xA4\x81Q`@Q\x82\x15\x15\x81R\x85\x90\x8C\x90\x7Fs@Q\r$\xB7\xEC\x9B\\\x10\x0FU\0\xD94)\xD8\r\0\xD4o\r\x18\xE4\xE8]\x0CL\xC2+\x99$\x90` \x01`@Q\x80\x91\x03\x90\xA4PQ\x91\x93P\x90\x91PP[\x94P\x94\x92PPPV[_a\x10Ia\x1A\x8F`\x01\x84a!\xB6V[a.vV[_\x80a\x1A\xA2`\x01\x85\x85a.\xB9V[\x91P\x91P\x81\x15a\x11\x8CW\x83\x7F\xBE\x17u]\x8D\x83j\xD6{\xFA\xF8\xE5\xB3\x86\x9A\xED\xB4\xCB\xA0?)Z\x16|UG\xFE\xDD\xD9\xEFP\xAD\x82`@Qa\x1A\xDE\x91\x81R` \x01\x90V[`@Q\x80\x91\x03\x90\xA2PPPPV[`@\x80Qa\x01\xE0\x81\x01\x82R_\x80\x82R` \x82\x01\x81\x90R\x91\x81\x01\x82\x90R``\x81\x01\x82\x90R`\x80\x81\x01\x82\x90R`\xA0\x81\x01\x82\x90R`\xC0\x81\x01\x82\x90R`\xE0\x81\x01\x82\x90Ra\x01\0\x81\x01\x82\x90Ra\x01 \x81\x01\x82\x90Ra\x01@\x81\x01\x82\x90Ra\x01`\x81\x01\x82\x90Ra\x01\x80\x81\x01\x82\x90Ra\x01\xA0\x81\x01\x82\x90Ra\x01\xC0\x81\x01\x91\x90\x91Ra\x1Bo`\x01\x83a!\xB6V[`@\x80Qa\x01\xE0\x81\x01\x82R\x82T\x81R`\x01\x80\x84\x01T` \x83\x01R`\x02\x84\x01T\x92\x82\x01\x92\x90\x92R`\x03\x83\x01T``\x82\x01R`\x04\x83\x01T`\x80\x82\x01R`\x05\x83\x01T`\xA0\x82\x01R`\x06\x83\x01T`\xC0\x82\x01R`\x07\x83\x01T`\xE0\x82\x01R`\x08\x83\x01T`\x01`\x01`\xA0\x1B\x03\x81\x16a\x01\0\x83\x01R`\x01`\xA0\x1B\x90\x04g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x90\x81\x16a\x01 \x83\x01R`\t\x84\x01T\x90\x81\x16a\x01@\x83\x01R\x90\x92\x91a\x01`\x84\x01\x91`\x01`@\x1B\x90\x04`\xFF\x16\x90\x81\x11\x15a\x1C&Wa\x1C&a[\xF3V[`\x01\x81\x11\x15a\x1C7Wa\x1C7a[\xF3V[\x81R`\t\x91\x90\x91\x01T`\xFF`\x01`H\x1B\x82\x04\x81\x16` \x84\x01Rj\x01\0\0\0\0\0\0\0\0\0\0\x82\x04\x16\x15\x15`@\x83\x01Rg\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFFk\x01\0\0\0\0\0\0\0\0\0\0\0\x90\x91\x04\x16``\x90\x91\x01R\x92\x91PPV[_\x82`\xFF\x16_\x03a\x1C\x9EWP_a\x10IV[\x81`\xFF\x16\x83`\xFF\x16\x11a\x1C\xB3WP`\x01a\x10IV[a\x1C\xBE\x82`\x01aaDV[`\xFF\x16\x83`\xFF\x16\x03a\x1C\xD2WP`\x02a\x10IV[`@Q\x7F\xAE\r\xA5x\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\xFF\x80\x85\x16`\x04\x83\x01R\x83\x16`$\x82\x01R`D\x01a\x06\xB7V[`@\x80Qa\x01\0\x81\x01\x82R_\x80\x82R` \x82\x01\x81\x90R\x91\x81\x01\x82\x90R``\x81\x01\x82\x90R`\x80\x81\x01\x82\x90R`\xA0\x81\x01\x82\x90R`\xC0\x81\x01\x82\x90R`\xE0\x81\x01\x82\x90R\x90\x80a\x1D_\x8A\x8A\x8A\x8A\x89a.\xDCV[\x91P\x91P_a\x1Do\x83\x8B\x89a4*V[\x90P_a\x1D}\x83\x83\x8Da5lV[\x90P\x85\x15a\x1E\x17W_a\x1D\x8F\x82a6\x0EV[3_\x90\x81R`\x03\x8F\x01` \x90\x81R`@\x80\x83 \x84\x84R\x90\x91R\x90 T\x90\x91P`\xFF\x16\x15a\x1D\xF1W`@Q\x7FZF\xAC:\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R3`\x04\x82\x01R`$\x81\x01\x82\x90R`D\x01a\x06\xB7V[3_\x90\x81R`\x03\x8E\x01` \x90\x81R`@\x80\x83 \x93\x83R\x92\x90R \x80T`\xFF\x19\x16`\x01\x17\x90U[a\x1E!\x8C\x82a6{V[\x9C\x9BPPPPPPPPPPPPV[`@Q`\x01`\x01`\xA0\x1B\x03\x80\x85\x16`$\x83\x01R\x83\x16`D\x82\x01R`d\x81\x01\x82\x90Ra\x11\x8C\x90\x85\x90\x7F#\xB8r\xDD\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x90`\x84\x01[`@\x80Q`\x1F\x19\x81\x84\x03\x01\x81R\x91\x90R` \x81\x01\x80Q{\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x7F\xFF\xFF\xFF\xFF\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x90\x93\x16\x92\x90\x92\x17\x90\x91Ra:VV[_\x81_\x03a\x1E\xF1WP_\x91\x90PV[_a\x1E\xFD`\x01\x84aapV[\x92\x90\x92\x16\x15\x92\x91PPV[_\x81\x81R` \x83\x90R`@\x81 `\x08\x01T`\x01`\xA0\x1B\x90\x04g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16a\x1FIW`@Qb\xA7\xB0+`\xE0\x1B\x81R`\x04\x81\x01\x83\x90R`$\x01a\x06\xB7V[_\x82\x81R` \x84\x90R`@\x81 a\x1F_\x90a#aV[_\x81\x81R`\x01\x86\x01` R`@\x81 T\x91\x92P\x81\x90\x03a\x1F\xABW`@Q\x7F\xDA\x10\xF6|\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[`@Qh\x15S\x94\x92U\x90S\x11Q`\xBA\x1B` \x82\x01R`)\x01`@Q` \x81\x83\x03\x03\x81R\x90`@R\x80Q\x90` \x01 \x81\x03a \x14W_\x84\x81R` \x86\x90R`@\x90 `\x08\x01Ta \x0B\x90`\x01`\xA0\x1B\x90\x04g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16CaapV[\x92PPPa\x10IV[_\x81\x81R` \x86\x90R`@\x90 `\x08\x01T`\x01`\xA0\x1B\x90\x04g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16a UW`@Qb\xA7\xB0+`\xE0\x1B\x81R`\x04\x81\x01\x82\x90R`$\x01a\x06\xB7V[_\x81\x81R` \x86\x90R`@\x80\x82 `\x08\x90\x81\x01T\x87\x84R\x91\x90\x92 \x90\x91\x01Tg\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF`\x01`\xA0\x1B\x92\x83\x90\x04\x81\x16\x92\x90\x91\x04\x16\x80\x82\x11\x15a \xAAWa \x9F\x81\x83aapV[\x94PPPPPa\x10IV[_\x94PPPPPa\x10IV[PP\x92\x91PPV[_\x82\x81R` \x84\x90R`@\x81 `\t\x01Tk\x01\0\0\0\0\0\0\0\0\0\0\0\x90\x04g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x82\x81\x10a!+W`@Q\x7F\xD1\xF5\x92\x81\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x81\x01\x82\x90R`$\x81\x01\x84\x90R`D\x01a\x06\xB7V[\x90P[\x93\x92PPPV[_a!@\x83\x83a'\xD6V[\x80\x15a!.WP_\x82\x81R` \x84\x90R`@\x90 a!]\x90a.vV[`\x01\x14\x93\x92PPPV[_\x80a!s\x84\x84a!\xB6V[\x90P[`\t\x81\x01T`\x01`H\x1B\x90\x04`\xFF\x16\x15a!\xAEW\x80T_\x90\x81R`\x01\x85\x01` R`@\x90 Ta!\xA6\x85\x82a!\xB6V[\x91PPa!vV[T\x93\x92PPPV[_\x81\x81R` \x83\x90R`@\x81 `\x08\x01T`\x01`\xA0\x1B\x90\x04g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16a!\xF7W`@Qb\xA7\xB0+`\xE0\x1B\x81R`\x04\x81\x01\x83\x90R`$\x01a\x06\xB7V[P_\x90\x81R` \x91\x90\x91R`@\x90 \x90V[`\x01`\t\x82\x01T`\x01`@\x1B\x90\x04`\xFF\x16`\x01\x81\x11\x15a\"+Wa\"+a[\xF3V[\x14a\"|Wa\"9\x81a(\xD6V[`\t\x82\x01T`@Q\x7F\xEF\x12g\xB4\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81Ra\x06\xB7\x92\x91`\x01`@\x1B\x90\x04`\xFF\x16\x90`\x04\x01ab\xE0V[a\"\x85\x81a(\xB3V[a\"\x92Wa\x15\x18\x81a(\xD6V[`\t\x81\x01Tj\x01\0\0\0\0\0\0\0\0\0\0\x90\x04`\xFF\x16\x15\x15`\x01\x03a\"\xEFWa\"\xBA\x81a(\xD6V[`@Q\x7F0\x7Fvi\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01a\x06\xB7\x91\x81R` \x01\x90V[`\t\x01\x80Tj\xFF\0\0\0\0\0\0\0\0\0\0\x19\x16j\x01\0\0\0\0\0\0\0\0\0\0\x17\x90UV[`@Q`\x01`\x01`\xA0\x1B\x03\x83\x16`$\x82\x01R`D\x81\x01\x82\x90Ra#\\\x90\x84\x90\x7F\xA9\x05\x9C\xBB\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x90`d\x01a\x1E~V[PPPV[`\t\x81\x01T\x81T`\x02\x83\x01T`\x01\x84\x01T`\x04\x85\x01T`@\x80Q`\x01`H\x1B\x90\x96\x04`\xF8\x1B`\x01`\x01`\xF8\x1B\x03\x19\x16` \x80\x88\x01\x91\x90\x91R`!\x87\x01\x95\x90\x95R`A\x86\x01\x93\x90\x93R`a\x85\x01\x91\x90\x91R`\x81\x80\x85\x01\x91\x90\x91R\x81Q\x80\x85\x03\x90\x91\x01\x81R`\xA1\x90\x93\x01\x90R\x81Q\x91\x01 _\x90a\x10IV[_\x80_a#\xE4\x88\x88a\x1F\x08V[\x90Pa#\xF2\x88\x88\x88\x88a;:V[_\x86\x81R` \x89\x90R`@\x90 `\t\x01Ta$&\x90k\x01\0\0\0\0\0\0\0\0\0\0\0\x90\x04g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x82ab\xF4V[\x90Pa$4\x88\x88\x83\x87a<\xF4V[\x92P\x92PP[\x95P\x95\x93PPPPV[_\x8B\x81R` \x8D\x90R`@\x90 `\x08\x01T`\x01`\xA0\x1B\x90\x04g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16a$\x85W`@Qb\xA7\xB0+`\xE0\x1B\x81R`\x04\x81\x01\x8C\x90R`$\x01a\x06\xB7V[`\x02_\x8C\x81R` \x8E\x90R`@\x90 `\t\x01Ta$\xAC\x90`\x01`H\x1B\x90\x04`\xFF\x16\x85a\x1C\x8CV[`\x02\x81\x11\x15a$\xBDWa$\xBDa[\xF3V[\x14a%\x12W_\x8B\x81R` \x8D\x90R`@\x90\x81\x90 `\t\x01T\x90Q\x7F4\x8A\xEF\xDF\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x01`H\x1B\x90\x91\x04`\xFF\x16`\x04\x82\x01R`$\x01a\x06\xB7V[_\x8B\x81R` \x8D\x90R`@\x90 a%(\x90a.vV[`\x01\x14a%zW_\x8B\x81R` \x8D\x90R`@\x90 a%E\x90a.vV[`@Q\x7FkY^P\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01a\x06\xB7\x91\x81R` \x01\x90V[_\x8B\x81R` \x8D\x90R`@\x90 `\x02\x01T\x8B\x82[`\x01\x8F_\x01_\x84\x81R` \x01\x90\x81R` \x01_ `\t\x01`\t\x90T\x90a\x01\0\n\x90\x04`\xFF\x16`\xFF\x16\x11\x15a&)W_\x8F_\x01_\x84\x81R` \x01\x90\x81R` \x01_ _\x01T\x90P\x8F`\x01\x01_\x82\x81R` \x01\x90\x81R` \x01_ T\x92P\x8F_\x01_\x84\x81R` \x01\x90\x81R` \x01_ `\x02\x01T\x82a&\x0B\x91\x90ac\x07V[a&\x15\x90\x85ab\xF4V[\x93Pa&!\x86\x83ac\x07V[\x91PPa%\x8EV[PPa&\x81\x8D_\x01_\x8E\x81R` \x01\x90\x81R` \x01_ `\x01\x01T\x8B_\x015\x83\x8B\x8B\x80\x80` \x02` \x01`@Q\x90\x81\x01`@R\x80\x93\x92\x91\x90\x81\x81R` \x01\x83\x83` \x02\x80\x82\x847_\x92\x01\x91\x90\x91RPa=\x89\x92PPPV[_\x8B`\x01`\x01`\xA0\x1B\x03\x16c\xB5\x11/\xD2\x8B\x84\x8E_\x015\x8F\x80` \x01\x90a&\xA7\x91\x90a]=V[`@Q\x86c\xFF\xFF\xFF\xFF\x16`\xE0\x1B\x81R`\x04\x01a&\xC7\x95\x94\x93\x92\x91\x90ac\x1EV[` `@Q\x80\x83\x03\x81\x86Z\xFA\x15\x80\x15a&\xE2W=_\x80>=_\xFD[PPPP`@Q=`\x1F\x19`\x1F\x82\x01\x16\x82\x01\x80`@RP\x81\x01\x90a'\x06\x91\x90ac\x7FV[\x90Pa'g\x8E_\x01_\x8F\x81R` \x01\x90\x81R` \x01_ `\x03\x01T\x82\x84`\x01a'/\x91\x90ab\xF4V[\x8A\x8A\x80\x80` \x02` \x01`@Q\x90\x81\x01`@R\x80\x93\x92\x91\x90\x81\x81R` \x01\x83\x83` \x02\x80\x82\x847_\x92\x01\x91\x90\x91RPa=\x89\x92PPPV[_\x8D\x81R` \x8F\x90R`@\x90 a'}\x90a>\x0EV[a'\x87\x8E\x8Ea>\xA9V[PPP_\x99\x8ARPPP` \x97\x90\x97RPP`@\x90\x93 `\t\x01\x80Tr\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\0\0\0\0\0\0\0\0\0\0\0\x19\x16r\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\0\0\0\0\0\0\0\0\0\0\0\x17\x90UPPPPV[_\x81\x81R` \x83\x90R`@\x81 `\x08\x01T`\x01`\xA0\x1B\x90\x04g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16a(\x17W`@Qb\xA7\xB0+`\xE0\x1B\x81R`\x04\x81\x01\x83\x90R`$\x01a\x06\xB7V[_\x82\x81R` \x84\x90R`@\x81 a(-\x90a#aV[_\x81\x81R`\x01\x86\x01` R`@\x81 T\x91\x92P\x81\x90\x03a(yW`@Q\x7F\xDA\x10\xF6|\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[`@Qh\x15S\x94\x92U\x90S\x11Q`\xBA\x1B` \x82\x01R`)\x01`@\x80Q`\x1F\x19\x81\x84\x03\x01\x81R\x91\x90R\x80Q` \x90\x91\x01 \x14\x15\x94\x93PPPPV[`\x07\x81\x01T_\x90\x15\x80\x15\x90a\x10IWPP`\x08\x01T`\x01`\x01`\xA0\x1B\x03\x16\x15\x15\x90V[`\t\x81\x01T\x81T`\x02\x83\x01T`\x01\x84\x01T`\x04\x85\x01T`\x03\x86\x01T`@\x80Q`\x01`H\x1B\x90\x97\x04`\xF8\x1B`\x01`\x01`\xF8\x1B\x03\x19\x16` \x80\x89\x01\x91\x90\x91R`!\x88\x01\x96\x90\x96R`A\x87\x01\x94\x90\x94R`a\x86\x01\x92\x90\x92R`\x81\x80\x86\x01\x91\x90\x91R\x82Q\x80\x86\x03\x90\x91\x01\x81R`\xA1\x85\x01\x83R\x80Q\x90\x84\x01 `\xC1\x85\x01R`\xE1\x80\x85\x01\x91\x90\x91R\x81Q\x80\x85\x03\x90\x91\x01\x81Ra\x01\x01\x90\x93\x01\x90R\x81Q\x91\x01 _\x90a\x10IV[_\x83\x81R` \x85\x90R`@\x81 `\x08\x01T`\x01`\xA0\x1B\x90\x04g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16a)\xB7W`@Qb\xA7\xB0+`\xE0\x1B\x81R`\x04\x81\x01\x85\x90R`$\x01a\x06\xB7V[_a)\xC2\x86\x86a?)V[\x90Pa)\xD8g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x85\x16\x82ab\xF4V[\x90P\x82g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x81\x10\x15a*1W`@Q\x7F\x11\xA8\xD4\xD0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x81\x01\x82\x90Rg\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x84\x16`$\x82\x01R`D\x01a\x06\xB7V[_\x85\x81R` \x87\x90R`@\x90 a*G\x90a>\x0EV[a*Q\x86\x86a>\xA9V[\x95\x94PPPPPV[`@\x80Qa\x01\0\x81\x01\x82R_\x80\x82R` \x82\x01\x81\x90R\x91\x81\x01\x82\x90R``\x81\x01\x82\x90R`\x80\x81\x01\x82\x90R`\xA0\x81\x01\x82\x90R`\xC0\x81\x01\x82\x90R`\xE0\x81\x01\x82\x90R`@\x80Qa\x01\0\x81\x01\x82R_\x80\x82R` \x82\x01\x81\x90R\x91\x81\x01\x82\x90R``\x81\x01\x82\x90R`\x80\x81\x01\x82\x90R`\xA0\x81\x01\x82\x90R`\xC0\x81\x01\x82\x90R`\xE0\x81\x01\x91\x90\x91R_\x80\x87\x81R` \x89\x90R`@\x90 `\t\x01T`\x01`@\x1B\x90\x04`\xFF\x16`\x01\x81\x11\x15a+\x06Wa+\x06a[\xF3V[\x14a+]W_\x86\x81R` \x88\x90R`@\x90\x81\x90 `\t\x01T\x90Q\x7F#\xF8@]\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81Ra\x06\xB7\x91\x88\x91`\x01`@\x1B\x90\x91\x04`\xFF\x16\x90`\x04\x01ab\xE0V[a+g\x87\x87a'\xD6V[a+\xA0W`@Q\x7F\x80\xE0~E\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x81\x01\x87\x90R`$\x01a\x06\xB7V[_\x86\x81R` \x88\x90R`@\x81 `@\x80Qa\x01\xE0\x81\x01\x82R\x82T\x81R`\x01\x80\x84\x01T` \x83\x01R`\x02\x84\x01T\x92\x82\x01\x92\x90\x92R`\x03\x83\x01T``\x82\x01R`\x04\x83\x01T`\x80\x82\x01R`\x05\x83\x01T`\xA0\x82\x01R`\x06\x83\x01T`\xC0\x82\x01R`\x07\x83\x01T`\xE0\x82\x01R`\x08\x83\x01T`\x01`\x01`\xA0\x1B\x03\x81\x16a\x01\0\x83\x01R`\x01`\xA0\x1B\x90\x04g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x90\x81\x16a\x01 \x83\x01R`\t\x84\x01T\x90\x81\x16a\x01@\x83\x01R\x90\x92\x91a\x01`\x84\x01\x91`\x01`@\x1B\x90\x04`\xFF\x16\x90\x81\x11\x15a,dWa,da[\xF3V[`\x01\x81\x11\x15a,uWa,ua[\xF3V[\x81R`\t\x91\x90\x91\x01T`\x01`H\x1B\x81\x04`\xFF\x90\x81\x16` \x84\x01Rj\x01\0\0\0\0\0\0\0\0\0\0\x82\x04\x16\x15\x15`@\x80\x84\x01\x91\x90\x91Rk\x01\0\0\0\0\0\0\0\0\0\0\0\x90\x91\x04g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16``\x90\x92\x01\x91\x90\x91R\x81\x01Q`\x80\x82\x01Q\x91\x92P_\x91a,\xE3\x91\x90a?\xB4V[\x90P_\x80\x87\x80` \x01\x90Q\x81\x01\x90a,\xFB\x91\x90ac\xF2V[\x90\x92P\x90Pa-+\x89a-\x0F\x85`\x01ab\xF4V[``\x87\x01Q`\x80\x88\x01Qa-$\x90`\x01ab\xF4V[\x86\x86a@]V[PP`@\x80Qa\x01\0\x81\x01\x82R_\x80\x82R` \x82\x01\x81\x90R\x91\x81\x01\x82\x90R``\x81\x01\x82\x90R`\x80\x81\x01\x82\x90R`\xA0\x81\x01\x82\x90R`\xC0\x81\x01\x82\x90R`\xE0\x81\x01\x82\x90R_a-\x8B\x85_\x01Q\x86` \x01Q\x87`@\x01Q\x8D\x88\x8Aa\x01\x80\x01QaC{V[\x90Pa-\x96\x81aD\x83V[_\x81\x81R` \x8E\x90R`@\x90 `\x08\x01T\x90\x93P`\x01`\xA0\x1B\x90\x04g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16a-\xCCWa-\xC9\x8C\x82a6{V[\x91P[P`@\x80Qa\x01\0\x81\x01\x82R_\x80\x82R` \x82\x01\x81\x90R\x91\x81\x01\x82\x90R``\x81\x01\x82\x90R`\x80\x81\x01\x82\x90R`\xA0\x81\x01\x82\x90R`\xC0\x81\x01\x82\x90R`\xE0\x81\x01\x91\x90\x91R_a.,\x86_\x01Q\x8C\x87\x89``\x01Q\x8A`\x80\x01Q\x8Ba\x01\x80\x01QaC{V[\x90Pa.8\x8D\x82a6{V[\x91PPa.d\x83\x82_\x01Q\x8E_\x01_\x8F\x81R` \x01\x90\x81R` \x01_ aE\x1A\x90\x92\x91\x90c\xFF\xFF\xFF\xFF\x16V[\x91\x9B\x90\x9AP\x90\x98P\x96PPPPPPPV[_\x80\x82`\x02\x01T\x83`\x04\x01Ta.\x8C\x91\x90aapV[\x90P\x80_\x03a\x10IWa.\x9E\x83a(\xD6V[`@Qb\xA7\xB0+`\xE0\x1B\x81R`\x04\x01a\x06\xB7\x91\x81R` \x01\x90V[_\x80a.\xD0\x85\x85a.\xCA\x88\x88a?)V[\x86a<\xF4V[\x91P\x91P\x93P\x93\x91PPV[`@\x80Q``\x80\x82\x01\x83R_\x80\x83R` \x83\x01R\x91\x81\x01\x91\x90\x91R_\x80a/\x0Fa/\t` \x89\x01\x89a]$V[\x85a\x1C\x8CV[`\x02\x81\x11\x15a/ Wa/ a[\xF3V[\x03a24W` \x85\x01Q\x85Q_\x03a/dW`@Q\x7F\xE9k\xC6\x1A\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[\x85Q``\x88\x015\x14a/\xB2W\x85Q`@Q\x7F[\x17z<\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x81\x01\x91\x90\x91R``\x88\x015`$\x82\x01R`D\x01a\x06\xB7V[\x85`@\x01Qa/\xEDW`@Q\x7F\xC1i$6\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[\x85``\x01Qa0(W`@Q\x7F\xB4]\x1C:\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[a05`\xA0\x88\x01\x88a]=V[\x90P_\x03a0VW`@Qc\x0C\x9C\xCA\xC5`\xE4\x1B\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[_a0d`\xA0\x89\x01\x89a]=V[\x81\x01\x90a0q\x91\x90a_\xE5V[P\x90\x91P_\x90P\x87`\x80\x01Q` \x01Q`\x02\x81\x11\x15a0\x92Wa0\x92a[\xF3V[\x03a0\xC9W`@Q\x7FF6^R\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[_\x87`\xA0\x01Q` \x01Q`\x02\x81\x11\x15a0\xE4Wa0\xE4a[\xF3V[\x03a1\x1BW`@Q\x7F\x89\x99\x85}\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[_\x86`\x01`\x01`\xA0\x1B\x03\x16c\xC3\x96\x19\xC4a18\x8A`\x80\x01QaE\x9AV[`@Q\x82c\xFF\xFF\xFF\xFF\x16`\xE0\x1B\x81R`\x04\x01a1T\x91\x90adRV[` `@Q\x80\x83\x03\x81\x86Z\xFA\x15\x80\x15a1oW=_\x80>=_\xFD[PPPP`@Q=`\x1F\x19`\x1F\x82\x01\x16\x82\x01\x80`@RP\x81\x01\x90a1\x93\x91\x90ac\x7FV[\x90P_\x87`\x01`\x01`\xA0\x1B\x03\x16c\xC3\x96\x19\xC4a1\xB2\x8B`\xA0\x01QaE\x9AV[`@Q\x82c\xFF\xFF\xFF\xFF\x16`\xE0\x1B\x81R`\x04\x01a1\xCE\x91\x90adRV[` `@Q\x80\x83\x03\x81\x86Z\xFA\x15\x80\x15a1\xE9W=_\x80>=_\xFD[PPPP`@Q=`\x1F\x19`\x1F\x82\x01\x16\x82\x01\x80`@RP\x81\x01\x90a2\r\x91\x90ac\x7FV[`@\x80Q``\x81\x01\x82R\x93\x84R` \x84\x01\x91\x90\x91R\x82\x01\x92\x90\x92R\x93P\x90\x91Pa$:\x90PV[a2B\x87\x87``\x015a!5V[a2~W`@Q\x7F\xFFm\x9B\xD7\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R``\x87\x015`\x04\x82\x01R`$\x01a\x06\xB7V[``\x86\x015_\x90\x81R` \x88\x90R`@\x81 \x90a2\x9A\x82a#aV[\x90P_`\t\x83\x01T`\x01`@\x1B\x90\x04`\xFF\x16`\x01\x81\x11\x15a2\xBDWa2\xBDa[\xF3V[\x14a2\xF4W`@Q\x7F\x12E\x9F\xFD\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[`\t\x82\x01Ta3\r\x90`\x01`H\x1B\x90\x04`\xFF\x16\x86aE\xD4V[`\xFF\x16a3\x1D` \x8A\x01\x8Aa]$V[`\xFF\x16\x14a3\x7FWa32` \x89\x01\x89a]$V[`\t\x83\x01T`@Q\x7F\xAC\x9Ea\x16\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\xFF\x92\x83\x16`\x04\x82\x01R`\x01`H\x1B\x90\x91\x04\x90\x91\x16`$\x82\x01R`D\x01a\x06\xB7V[a3\x8C`\xA0\x89\x01\x89a]=V[\x90P_\x03a3\xADW`@Qc\x0C\x9C\xCA\xC5`\xE4\x1B\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[_\x80\x80\x80\x80a3\xBF`\xA0\x8E\x01\x8Ea]=V[\x81\x01\x90a3\xCC\x91\x90ad\x7FV[\x94P\x94P\x94P\x94P\x94Pa3\xEA\x87`\x01\x01T\x86\x89`\x02\x01T\x86a=\x89V[a3\xFE\x87`\x03\x01T\x85\x89`\x04\x01T\x85a=\x89V[`@Q\x80``\x01`@R\x80\x86\x81R` \x01\x85\x81R` \x01\x82\x81RP\x86\x98P\x98PPPPPPPPa$:V[`@\x80Q_\x80\x82R` \x82\x01\x90\x92R\x81\x90a4O\x90a4J\x90\x87QaE\xF5V[aF*V[\x90Pa4Z\x83a\x1E\xE2V[a4zW`@Qc:\xBF\xB6\xFF`\xE2\x1B\x81R`\x04\x81\x01\x84\x90R`$\x01a\x06\xB7V[\x82\x84`@\x015\x14a4\xC4W`@\x80Q\x7F\xDF\xCCb\xBC\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R\x90\x85\x015`\x04\x82\x01R`$\x81\x01\x84\x90R`D\x01a\x06\xB7V[a4\xE0\x84` \x015\x86` \x01Q\x86`@\x015\x88`@\x01Qa=\x89V[a4\xED`\x80\x85\x01\x85a]=V[\x90P_\x03a5'W`@Q\x7F4*\x07R\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[_\x80a56`\x80\x87\x01\x87a]=V[\x81\x01\x90a5C\x91\x90ae\x14V[\x90\x92P\x90Pa5a\x83`\x01` \x89\x015a-$`@\x8B\x015\x83ab\xF4V[P\x90\x95\x94PPPPPV[`@\x80Qa\x01\xE0\x81\x01\x82R_\x80\x82R` \x82\x01\x81\x90R\x91\x81\x01\x82\x90R``\x81\x01\x82\x90R`\x80\x81\x01\x82\x90R`\xA0\x81\x01\x82\x90R`\xC0\x81\x01\x82\x90R`\xE0\x81\x01\x82\x90Ra\x01\0\x81\x01\x82\x90Ra\x01 \x81\x01\x82\x90Ra\x01@\x81\x01\x82\x90Ra\x01`\x81\x01\x82\x90Ra\x01\x80\x81\x01\x82\x90Ra\x01\xA0\x81\x01\x82\x90Ra\x01\xC0\x81\x01\x91\x90\x91Ra!+\x84\x84_` \x86\x01\x805\x90`@\x88\x015\x90``\x89\x015\x903\x90a6\t\x90\x8Ba]$V[aG\xBAV[a\x01\x80\x81\x01Q\x81Q`@\x80\x84\x01Q` \x80\x86\x01Q`\x80\x87\x01Q\x84Q`\xF8\x97\x90\x97\x1B`\x01`\x01`\xF8\x1B\x03\x19\x16\x87\x84\x01R`!\x87\x01\x95\x90\x95R`A\x86\x01\x92\x90\x92R`a\x85\x01\x91\x90\x91R`\x81\x80\x85\x01\x93\x90\x93R\x81Q\x80\x85\x03\x90\x93\x01\x83R`\xA1\x90\x93\x01\x90R\x80Q\x91\x01 _\x90a\x10IV[`@\x80Qa\x01\0\x81\x01\x82R_\x80\x82R` \x82\x01\x81\x90R\x91\x81\x01\x82\x90R``\x81\x01\x82\x90R`\x80\x81\x01\x82\x90R`\xA0\x81\x01\x82\x90R`\xC0\x81\x01\x82\x90R`\xE0\x81\x01\x82\x90R\x90a6\xC4\x83aD\x83V[_\x81\x81R` \x86\x90R`@\x90 `\x08\x01T\x90\x91P`\x01`\xA0\x1B\x90\x04g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x15a7#W`@Q\x7F\xBC\xED\xF3\xDE\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x81\x01\x82\x90R`$\x01a\x06\xB7V[_\x81\x81R` \x85\x81R`@\x91\x82\x90 \x85Q\x81U\x90\x85\x01Q`\x01\x80\x83\x01\x91\x90\x91U\x91\x85\x01Q`\x02\x82\x01U``\x85\x01Q`\x03\x82\x01U`\x80\x85\x01Q`\x04\x82\x01U`\xA0\x85\x01Q`\x05\x82\x01U`\xC0\x85\x01Q`\x06\x82\x01U`\xE0\x85\x01Q`\x07\x82\x01Ua\x01\0\x85\x01Q`\x08\x82\x01\x80Ta\x01 \x88\x01Qg\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x90\x81\x16`\x01`\xA0\x1B\x02\x7F\xFF\xFF\xFF\xFF\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x90\x92\x16`\x01`\x01`\xA0\x1B\x03\x90\x94\x16\x93\x90\x93\x17\x17\x90Ua\x01@\x86\x01Q`\t\x83\x01\x80T\x91\x90\x92\x16g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x19\x82\x16\x81\x17\x83Ua\x01`\x88\x01Q\x88\x95\x90\x93\x92h\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x19\x16\x90\x91\x17\x90`\x01`@\x1B\x90\x84\x90\x81\x11\x15a8*Wa8*a[\xF3V[\x02\x17\x90UPa\x01\x80\x82\x81\x01Q`\t\x92\x90\x92\x01\x80Ta\x01\xA0\x85\x01Qa\x01\xC0\x90\x95\x01Qg\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16k\x01\0\0\0\0\0\0\0\0\0\0\0\x02r\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\0\0\0\0\0\0\0\0\0\0\0\x19\x95\x15\x15j\x01\0\0\0\0\0\0\0\0\0\0\x02j\xFF\0\0\0\0\0\0\0\0\0\0\x19`\xFF\x90\x96\x16`\x01`H\x1B\x02\x95\x90\x95\x16\x7F\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\0\0\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x90\x92\x16\x91\x90\x91\x17\x93\x90\x93\x17\x93\x90\x93\x16\x91\x90\x91\x17\x90\x91U\x83\x01Q\x83Q`@\x80\x86\x01Q` \x80\x88\x01Q`\x80\x89\x01Q\x84Q`\x01`\x01`\xF8\x1B\x03\x19`\xF8\x98\x90\x98\x1B\x97\x90\x97\x16\x87\x84\x01R`!\x87\x01\x95\x90\x95R`A\x86\x01\x92\x90\x92R`a\x85\x01\x91\x90\x91R`\x81\x80\x85\x01\x93\x90\x93R\x81Q\x80\x85\x03\x90\x93\x01\x83R`\xA1\x90\x93\x01\x90R\x80Q\x91\x01 _\x90_\x81\x81R`\x01\x87\x01` R`@\x81 T\x91\x92P\x81\x90\x03a9\xA0W`@Qh\x15S\x94\x92U\x90S\x11Q`\xBA\x1B` \x82\x01R`)\x01`@\x80Q`\x1F\x19\x81\x84\x03\x01\x81R\x91\x81R\x81Q` \x92\x83\x01 _\x85\x81R`\x01\x8A\x01\x90\x93R\x91 Ua9\xE7V[`@Qh\x15S\x94\x92U\x90S\x11Q`\xBA\x1B` \x82\x01R`)\x01`@Q` \x81\x83\x03\x03\x81R\x90`@R\x80Q\x90` \x01 \x81\x03a9\xE7W_\x82\x81R`\x01\x87\x01` R`@\x90 \x83\x90U[`@\x80Qa\x01\0\x81\x01\x82R\x84\x81R` \x80\x82\x01\x85\x90R\x87Q\x82\x84\x01R`\xE0\x88\x01Q``\x83\x01R_\x86\x81R\x90\x89\x90R\x91\x90\x91 `\x80\x82\x01\x90a:'\x90a.vV[\x81Ra\x01\x80\x87\x01Q`\xFF\x16` \x82\x01R\x91\x15\x15`@\x83\x01R`\xE0\x90\x95\x01Q\x15\x15``\x90\x91\x01RP\x91\x93\x92PPPV[_a:\xAA\x82`@Q\x80`@\x01`@R\x80` \x81R` \x01\x7FSafeERC20: low-level call failed\x81RP\x85`\x01`\x01`\xA0\x1B\x03\x16aIa\x90\x92\x91\x90c\xFF\xFF\xFF\xFF\x16V[\x80Q\x90\x91P\x15a#\\W\x80\x80` \x01\x90Q\x81\x01\x90a:\xC8\x91\x90a]\x05V[a#\\W`@QbF\x1B\xCD`\xE5\x1B\x81R` `\x04\x82\x01R`*`$\x82\x01R\x7FSafeERC20: ERC20 operation did n`D\x82\x01R\x7Fot succeed\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0`d\x82\x01R`\x84\x01a\x06\xB7V[_\x82\x81R` \x85\x90R`@\x90 `\x07\x01T\x83\x14a;\xA0W_\x82\x81R` \x85\x90R`@\x90\x81\x90 `\x07\x01T\x90Q\x7F\xC2\xAD\xC3\xE8\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81Ra\x06\xB7\x91\x85\x91`\x04\x01\x91\x82R` \x82\x01R`@\x01\x90V[_\x82\x81R` \x85\x90R`@\x80\x82 T\x85\x83R\x91 a;\xBD\x90a#aV[\x14a<\"W_\x83\x81R` \x85\x90R`@\x90 a;\xD8\x90a#aV[_\x83\x81R` \x86\x90R`@\x90\x81\x90 T\x90Q\x7F\xE2\xE2\x7F\x87\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x81\x01\x92\x90\x92R`$\x82\x01R`D\x01a\x06\xB7V[_\x82\x81R` \x85\x90R`@\x80\x82 `\t\x90\x81\x01T\x86\x84R\x91\x90\x92 \x90\x91\x01T`\xFF`\x01`H\x1B\x92\x83\x90\x04\x81\x16\x92a<[\x92\x04\x16\x83aE\xD4V[`\xFF\x16\x14a\x11\x8CW_\x83\x81R` \x85\x90R`@\x90 `\t\x01T\x83\x90\x83\x90a<\x8C\x90`\x01`H\x1B\x90\x04`\xFF\x16\x84aE\xD4V[_\x85\x81R` \x88\x90R`@\x90\x81\x90 `\t\x01T\x90Q\x7F~rm\x15\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x81\x01\x94\x90\x94R`$\x84\x01\x92\x90\x92R`\xFF\x90\x81\x16`D\x84\x01R`\x01`H\x1B\x90\x91\x04\x16`d\x82\x01R`\x84\x01a\x06\xB7V[_\x80_a=\x02\x87\x87\x86a \xBEV[\x90Pg\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x85\x11a=\x19W\x84a=#V[g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF[\x94P\x80\x85\x11\x15a=|WPPP_\x83\x81R` \x85\x90R`@\x90 `\t\x01\x80Tr\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\0\0\0\0\0\0\0\0\0\0\0\x19\x16k\x01\0\0\0\0\0\0\0\0\0\0\0g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x85\x16\x02\x17\x90U`\x01\x82a\x1AwV[_\x97\x90\x96P\x94PPPPPV[_a=\xBD\x82\x84\x86`@Q` \x01a=\xA2\x91\x81R` \x01\x90V[`@Q` \x81\x83\x03\x03\x81R\x90`@R\x80Q\x90` \x01 aIoV[\x90P\x80\x85\x14a\x13\"W`@QbF\x1B\xCD`\xE5\x1B\x81R` `\x04\x82\x01R`\x17`$\x82\x01R\x7FInvalid inclusion proof\0\0\0\0\0\0\0\0\0`D\x82\x01R`d\x01a\x06\xB7V[_`\t\x82\x01T`\x01`@\x1B\x90\x04`\xFF\x16`\x01\x81\x11\x15a>/Wa>/a[\xF3V[\x14a>\x80Wa>=\x81a(\xD6V[`\t\x82\x01T`@Q\x7F#\xF8@]\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81Ra\x06\xB7\x92\x91`\x01`@\x1B\x90\x04`\xFF\x16\x90`\x04\x01ab\xE0V[`\t\x01\x80Tg\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFFC\x16h\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x19\x90\x91\x16\x17`\x01`@\x1B\x17\x90UV[_\x81\x81R` \x83\x90R`@\x81 a>\xBF\x90a#aV[_\x81\x81R`\x02\x85\x01` R`@\x90 T\x90\x91P\x80\x15a?\x14W`@Q\x7F\xDDp(\xF0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x81\x01\x84\x90R`$\x81\x01\x82\x90R`D\x01a\x06\xB7V[P_\x90\x81R`\x02\x90\x92\x01` R`@\x90\x91 UV[_\x80a?5\x84\x84a\x1F\x08V[_\x84\x81R` \x86\x90R`@\x90 `\x05\x01T\x90\x91P\x15a!.W_\x83\x81R` \x85\x90R`@\x80\x82 `\x05\x81\x01T\x83R\x81\x83 `\t\x90\x81\x01T`\x06\x90\x92\x01T\x84R\x91\x90\x92 \x01Tg\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFFk\x01\0\0\0\0\0\0\0\0\0\0\0\x92\x83\x90\x04\x81\x16\x92\x90\x91\x04\x16\x80\x82\x10a?\xA8W\x80a?\xAAV[\x81[a\x18\xC0\x90\x84ab\xF4V[_`\x02a?\xC1\x84\x84aapV[\x10\x15a@\x03W`@Q\x7F\x90)\x85\x94\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x81\x01\x84\x90R`$\x81\x01\x83\x90R`D\x01a\x06\xB7V[a@\r\x83\x83aapV[`\x02\x03a@&Wa@\x1F\x83`\x01ab\xF4V[\x90Pa\x10IV[_\x83a@3`\x01\x85aapV[\x18\x90P_a@@\x82aJ\"V[\x90P_\x19\x81\x1B\x80a@R`\x01\x87aapV[\x16\x96\x95PPPPPPV[_\x85\x11a@\xACW`@QbF\x1B\xCD`\xE5\x1B\x81R` `\x04\x82\x01R`\x14`$\x82\x01R\x7FPre-size cannot be 0\0\0\0\0\0\0\0\0\0\0\0\0`D\x82\x01R`d\x01a\x06\xB7V[\x85a@\xB6\x83aF*V[\x14aA\x03W`@QbF\x1B\xCD`\xE5\x1B\x81R` `\x04\x82\x01R`\x1B`$\x82\x01R\x7FPre expansion root mismatch\0\0\0\0\0`D\x82\x01R`d\x01a\x06\xB7V[\x84aA\r\x83aK\\V[\x14aA\x80W`@QbF\x1B\xCD`\xE5\x1B\x81R` `\x04\x82\x01R`!`$\x82\x01R\x7FPre size does not match expansio`D\x82\x01R\x7Fn\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0`d\x82\x01R`\x84\x01a\x06\xB7V[\x82\x85\x10aA\xCFW`@QbF\x1B\xCD`\xE5\x1B\x81R` `\x04\x82\x01\x81\x90R`$\x82\x01R\x7FPre size not less than post size`D\x82\x01R`d\x01a\x06\xB7V[_\x85\x90P_\x80aA\xE1\x85_\x87QaK\xABV[\x90P[\x85\x83\x10\x15aB\xA3W_aA\xF7\x84\x88aM\x1FV[\x90P\x84Q\x83\x10aBIW`@QbF\x1B\xCD`\xE5\x1B\x81R` `\x04\x82\x01R`\x12`$\x82\x01R\x7FIndex out of range\0\0\0\0\0\0\0\0\0\0\0\0\0\0`D\x82\x01R`d\x01a\x06\xB7V[aBm\x82\x82\x87\x86\x81Q\x81\x10aB`WaB`aa\x1CV[` \x02` \x01\x01QaN\x06V[\x91P`\x01\x81\x1BaB}\x81\x86ab\xF4V[\x94P\x87\x85\x11\x15aB\x8FWaB\x8FaejV[\x83aB\x99\x81ae~V[\x94PPPPaA\xE4V[\x86aB\xAD\x82aF*V[\x14aC W`@QbF\x1B\xCD`\xE5\x1B\x81R` `\x04\x82\x01R`\"`$\x82\x01R\x7FPost expansion root not equal po`D\x82\x01R\x7Fst\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0`d\x82\x01R`\x84\x01a\x06\xB7V[\x83Q\x82\x14aCpW`@QbF\x1B\xCD`\xE5\x1B\x81R` `\x04\x82\x01R`\x16`$\x82\x01R\x7FIncomplete proof usage\0\0\0\0\0\0\0\0\0\0`D\x82\x01R`d\x01a\x06\xB7V[PPPPPPPPPV[`@\x80Qa\x01\xE0\x81\x01\x82R_\x80\x82R` \x82\x01\x81\x90R\x91\x81\x01\x82\x90R``\x81\x01\x82\x90R`\x80\x81\x01\x82\x90R`\xA0\x81\x01\x82\x90R`\xC0\x81\x01\x82\x90R`\xE0\x81\x01\x82\x90Ra\x01\0\x81\x01\x82\x90Ra\x01 \x81\x01\x82\x90Ra\x01@\x81\x01\x82\x90Ra\x01`\x81\x01\x82\x90Ra\x01\x80\x81\x01\x82\x90Ra\x01\xA0\x81\x01\x82\x90Ra\x01\xC0\x81\x01\x91\x90\x91RaD\0\x87\x87\x87\x87\x87aSnV[P`@\x80Qa\x01\xE0\x81\x01\x82R\x96\x87R` \x87\x01\x95\x90\x95R\x93\x85\x01\x92\x90\x92R``\x84\x01R`\x80\x83\x01R_`\xA0\x83\x01\x81\x90R`\xC0\x83\x01\x81\x90R`\xE0\x83\x01\x81\x90Ra\x01\0\x83\x01\x81\x90Rg\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFFC\x16a\x01 \x84\x01Ra\x01@\x83\x01\x81\x90Ra\x01`\x83\x01\x81\x90R`\xFF\x90\x91\x16a\x01\x80\x83\x01Ra\x01\xA0\x82\x01\x81\x90Ra\x01\xC0\x82\x01R\x90V[a\x01\x80\x81\x01Q\x81Q`@\x80\x84\x01Q` \x80\x86\x01Q`\x80\x87\x01Q``\x88\x01Q\x85Q`\xF8\x98\x90\x98\x1B`\x01`\x01`\xF8\x1B\x03\x19\x16\x88\x85\x01R`!\x88\x01\x96\x90\x96R`A\x87\x01\x93\x90\x93R`a\x86\x01R`\x81\x80\x86\x01\x92\x90\x92R\x82Q\x80\x86\x03\x90\x92\x01\x82R`\xA1\x85\x01\x83R\x81Q\x91\x81\x01\x91\x90\x91 `\xC1\x85\x01R`\xE1\x80\x85\x01\x93\x90\x93R\x81Q\x80\x85\x03\x90\x93\x01\x83Ra\x01\x01\x90\x93\x01\x90R\x80Q\x91\x01 _\x90a\x10IV[`\x05\x83\x01T\x15\x15\x80aE/WP`\x06\x83\x01T\x15\x15[\x15aE\x8AWaE=\x83a(\xD6V[`\x05\x84\x01T`\x06\x85\x01T`@Q\x7F\x8B\x0Eq\xD0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x81\x01\x93\x90\x93R`$\x83\x01\x91\x90\x91R`D\x82\x01R`d\x01a\x06\xB7V[`\x05\x83\x01\x91\x90\x91U`\x06\x90\x91\x01UV[aE\xA2aV\xC6V[`@Q\x80`@\x01`@R\x80\x83_\x01Q\x81R` \x01\x83` \x01Q`\x02\x81\x11\x15aE\xCCWaE\xCCa[\xF3V[\x90R\x92\x91PPV[_\x80aE\xE1\x84`\x01aaDV[\x90PaE\xED\x81\x84a\x1C\x8CV[P\x93\x92PPPV[``a!.\x83_\x84`@Q` \x01aF\x0F\x91\x81R` \x01\x90V[`@Q` \x81\x83\x03\x03\x81R\x90`@R\x80Q\x90` \x01 aN\x06V[_\x80\x82Q\x11aF{W`@QbF\x1B\xCD`\xE5\x1B\x81R` `\x04\x82\x01R`\x16`$\x82\x01R\x7FEmpty merkle expansion\0\0\0\0\0\0\0\0\0\0`D\x82\x01R`d\x01a\x06\xB7V[`@\x82Q\x11\x15aF\xCDW`@QbF\x1B\xCD`\xE5\x1B\x81R` `\x04\x82\x01R`\x1A`$\x82\x01R\x7FMerkle expansion too large\0\0\0\0\0\0`D\x82\x01R`d\x01a\x06\xB7V[_\x80[\x83Q\x81\x10\x15aG\xB3W_\x84\x82\x81Q\x81\x10aF\xECWaF\xECaa\x1CV[` \x02` \x01\x01Q\x90P\x82_\x80\x1B\x03aGVW\x80\x15aGQW\x80\x92P`\x01\x85QaG\x16\x91\x90aapV[\x82\x14aGQW`@QaG8\x90\x84\x90_\x90` \x01\x91\x82R` \x82\x01R`@\x01\x90V[`@Q` \x81\x83\x03\x03\x81R\x90`@R\x80Q\x90` \x01 \x92P[aG\xAAV[\x80\x15aGuW`@\x80Q` \x81\x01\x83\x90R\x90\x81\x01\x84\x90R``\x01aG8V[`@QaG\x91\x90\x84\x90_\x90` \x01\x91\x82R` \x82\x01R`@\x01\x90V[`@Q` \x81\x83\x03\x03\x81R\x90`@R\x80Q\x90` \x01 \x92P[P`\x01\x01aF\xD0V[P\x92\x91PPV[`@\x80Qa\x01\xE0\x81\x01\x82R_\x80\x82R` \x82\x01\x81\x90R\x91\x81\x01\x82\x90R``\x81\x01\x82\x90R`\x80\x81\x01\x82\x90R`\xA0\x81\x01\x82\x90R`\xC0\x81\x01\x82\x90R`\xE0\x81\x01\x82\x90Ra\x01\0\x81\x01\x82\x90Ra\x01 \x81\x01\x82\x90Ra\x01@\x81\x01\x82\x90Ra\x01`\x81\x01\x82\x90Ra\x01\x80\x81\x01\x82\x90Ra\x01\xA0\x81\x01\x82\x90Ra\x01\xC0\x81\x01\x91\x90\x91R`\x01`\x01`\xA0\x1B\x03\x83\x16aHrW`@Q\x7F\xF2\x89\xE6W\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[_\x84\x90\x03aH\xACW`@Q\x7Fi2\xBC\xFD\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[aH\xB9\x89\x89\x89\x89\x89aSnV[`@Q\x80a\x01\xE0\x01`@R\x80\x8A\x81R` \x01\x89\x81R` \x01\x88\x81R` \x01\x87\x81R` \x01\x86\x81R` \x01_\x80\x1B\x81R` \x01_\x80\x1B\x81R` \x01\x85\x81R` \x01\x84`\x01`\x01`\xA0\x1B\x03\x16\x81R` \x01Cg\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x81R` \x01_g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x81R` \x01_`\x01\x81\x11\x15aI:WaI:a[\xF3V[\x81R`\xFF\x84\x16` \x82\x01R_`@\x82\x01\x81\x90R``\x90\x91\x01R\x90P\x98\x97PPPPPPPPV[``a!+\x84\x84_\x85aT_V[\x82Q_\x90a\x01\0\x81\x11\x15aI\xBAW`@Q\x7F\xFD\xAC3\x1E\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x81\x01\x82\x90Ra\x01\0`$\x82\x01R`D\x01a\x06\xB7V[\x82_[\x82\x81\x10\x15aJ\x18W_\x87\x82\x81Q\x81\x10aI\xD8WaI\xD8aa\x1CV[` \x02` \x01\x01Q\x90P\x81`\x01\x90\x1B\x87\x16_\x03aJ\x01W\x82_R\x80` R`@_ \x92PaJ\x0FV[\x80_R\x82` R`@_ \x92P[P`\x01\x01aI\xBDV[P\x95\x94PPPPPV[_\x81_\x03aJrW`@QbF\x1B\xCD`\xE5\x1B\x81R` `\x04\x82\x01R`\x1C`$\x82\x01R\x7FZero has no significant bits\0\0\0\0`D\x82\x01R`d\x01a\x06\xB7V[p\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x82\x10aJ\x9DW`\x80\x91\x82\x1C\x91aJ\x9A\x90\x82ab\xF4V[\x90P[`\x01`@\x1B\x82\x10aJ\xBBW`@\x91\x82\x1C\x91aJ\xB8\x90\x82ab\xF4V[\x90P[d\x01\0\0\0\0\x82\x10aJ\xDAW` \x91\x82\x1C\x91aJ\xD7\x90\x82ab\xF4V[\x90P[b\x01\0\0\x82\x10aJ\xF7W`\x10\x91\x82\x1C\x91aJ\xF4\x90\x82ab\xF4V[\x90P[a\x01\0\x82\x10aK\x13W`\x08\x91\x82\x1C\x91aK\x10\x90\x82ab\xF4V[\x90P[`\x10\x82\x10aK.W`\x04\x91\x82\x1C\x91aK+\x90\x82ab\xF4V[\x90P[`\x04\x82\x10aKIW`\x02\x91\x82\x1C\x91aKF\x90\x82ab\xF4V[\x90P[`\x02\x82\x10a\x10\xE6Wa\x10I`\x01\x82ab\xF4V[_\x80\x80[\x83Q\x81\x10\x15aG\xB3W\x83\x81\x81Q\x81\x10aK{WaK{aa\x1CV[` \x02` \x01\x01Q_\x80\x1B\x14aK\xA3WaK\x96\x81`\x02afvV[aK\xA0\x90\x83ab\xF4V[\x91P[`\x01\x01aK`V[``\x81\x83\x10aK\xFCW`@QbF\x1B\xCD`\xE5\x1B\x81R` `\x04\x82\x01R`\x17`$\x82\x01R\x7FStart not less than end\0\0\0\0\0\0\0\0\0`D\x82\x01R`d\x01a\x06\xB7V[\x83Q\x82\x11\x15aLsW`@QbF\x1B\xCD`\xE5\x1B\x81R` `\x04\x82\x01R`!`$\x82\x01R\x7FEnd not less or equal than lengt`D\x82\x01R\x7Fh\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0`d\x82\x01R`\x84\x01a\x06\xB7V[_aL~\x84\x84aapV[g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x11\x15aL\x96WaL\x96a]\x9EV[`@Q\x90\x80\x82R\x80` \x02` \x01\x82\x01`@R\x80\x15aL\xBFW\x81` \x01` \x82\x02\x806\x837\x01\x90P[P\x90P\x83[\x83\x81\x10\x15aM\x16W\x85\x81\x81Q\x81\x10aL\xDEWaL\xDEaa\x1CV[` \x02` \x01\x01Q\x82\x86\x83aL\xF3\x91\x90aapV[\x81Q\x81\x10aM\x03WaM\x03aa\x1CV[` \x90\x81\x02\x91\x90\x91\x01\x01R`\x01\x01aL\xC4V[P\x94\x93PPPPV[_\x81\x83\x10aMoW`@QbF\x1B\xCD`\xE5\x1B\x81R` `\x04\x82\x01R`\x17`$\x82\x01R\x7FStart not less than end\0\0\0\0\0\0\0\0\0`D\x82\x01R`d\x01a\x06\xB7V[_aM{\x83\x85\x18aJ\"V[\x90P_`\x01aM\x8A\x83\x82ab\xF4V[`\x01\x90\x1BaM\x98\x91\x90aapV[\x90P\x84\x81\x16\x84\x82\x16\x81\x15aM\xAFWa \x9F\x82aU\x98V[\x80\x15aM\xBEWa \x9F\x81aJ\"V[`@QbF\x1B\xCD`\xE5\x1B\x81R` `\x04\x82\x01R`\x1B`$\x82\x01R\x7FBoth y and z cannot be zero\0\0\0\0\0`D\x82\x01R`d\x01a\x06\xB7V[```@\x83\x10aNXW`@QbF\x1B\xCD`\xE5\x1B\x81R` `\x04\x82\x01R`\x0E`$\x82\x01R\x7FLevel too high\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0`D\x82\x01R`d\x01a\x06\xB7V[_\x82\x90\x03aN\xA8W`@QbF\x1B\xCD`\xE5\x1B\x81R` `\x04\x82\x01R`\x1B`$\x82\x01R\x7FCannot append empty subtree\0\0\0\0\0`D\x82\x01R`d\x01a\x06\xB7V[`@\x84Q\x11\x15aN\xFAW`@QbF\x1B\xCD`\xE5\x1B\x81R` `\x04\x82\x01R`\x1A`$\x82\x01R\x7FMerkle expansion too large\0\0\0\0\0\0`D\x82\x01R`d\x01a\x06\xB7V[\x83Q_\x03aOwW_aO\x0E\x84`\x01ab\xF4V[g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x11\x15aO&WaO&a]\x9EV[`@Q\x90\x80\x82R\x80` \x02` \x01\x82\x01`@R\x80\x15aOOW\x81` \x01` \x82\x02\x806\x837\x01\x90P[P\x90P\x82\x81\x85\x81Q\x81\x10aOeWaOeaa\x1CV[` \x90\x81\x02\x91\x90\x91\x01\x01R\x90Pa!.V[\x83Q\x83\x10aO\xEDW`@QbF\x1B\xCD`\xE5\x1B\x81R` `\x04\x82\x01R`5`$\x82\x01R\x7FLevel greater than highest level`D\x82\x01R\x7F of current expansion\0\0\0\0\0\0\0\0\0\0\0`d\x82\x01R`\x84\x01a\x06\xB7V[\x81_aO\xF8\x86aK\\V[\x90P_aP\x06\x86`\x02afvV[aP\x10\x90\x83ab\xF4V[\x90P_aP\x1C\x83aJ\"V[aP%\x83aJ\"V[\x11aPsW\x87Qg\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x11\x15aPDWaPDa]\x9EV[`@Q\x90\x80\x82R\x80` \x02` \x01\x82\x01`@R\x80\x15aPmW\x81` \x01` \x82\x02\x806\x837\x01\x90P[PaP\xC3V[\x87QaP\x80\x90`\x01ab\xF4V[g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x11\x15aP\x98WaP\x98a]\x9EV[`@Q\x90\x80\x82R\x80` \x02` \x01\x82\x01`@R\x80\x15aP\xC1W\x81` \x01` \x82\x02\x806\x837\x01\x90P[P[\x90P`@\x81Q\x11\x15aQ\x17W`@QbF\x1B\xCD`\xE5\x1B\x81R` `\x04\x82\x01R`\x1C`$\x82\x01R\x7FAppend creates oversize tree\0\0\0\0`D\x82\x01R`d\x01a\x06\xB7V[_[\x88Q\x81\x10\x15aR\xC3W\x87\x81\x10\x15aQ\xBFW\x88\x81\x81Q\x81\x10aQ<WaQ<aa\x1CV[` \x02` \x01\x01Q_\x80\x1B\x14aQ\xBAW`@QbF\x1B\xCD`\xE5\x1B\x81R` `\x04\x82\x01R`\"`$\x82\x01R\x7FAppend above least significant b`D\x82\x01R\x7Fit\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0`d\x82\x01R`\x84\x01a\x06\xB7V[aR\xBBV[_\x85\x90\x03aR\x04W\x88\x81\x81Q\x81\x10aQ\xD9WaQ\xD9aa\x1CV[` \x02` \x01\x01Q\x82\x82\x81Q\x81\x10aQ\xF3WaQ\xF3aa\x1CV[` \x02` \x01\x01\x81\x81RPPaR\xBBV[\x88\x81\x81Q\x81\x10aR\x16WaR\x16aa\x1CV[` \x02` \x01\x01Q_\x80\x1B\x03aRLW\x84\x82\x82\x81Q\x81\x10aR9WaR9aa\x1CV[` \x90\x81\x02\x91\x90\x91\x01\x01R_\x94PaR\xBBV[_\x80\x1B\x82\x82\x81Q\x81\x10aRaWaRaaa\x1CV[` \x02` \x01\x01\x81\x81RPP\x88\x81\x81Q\x81\x10aR\x7FWaR\x7Faa\x1CV[` \x02` \x01\x01Q\x85`@Q` \x01aR\xA2\x92\x91\x90\x91\x82R` \x82\x01R`@\x01\x90V[`@Q` \x81\x83\x03\x03\x81R\x90`@R\x80Q\x90` \x01 \x94P[`\x01\x01aQ\x19V[P\x83\x15aR\xF7W\x83\x81`\x01\x83QaR\xDA\x91\x90aapV[\x81Q\x81\x10aR\xEAWaR\xEAaa\x1CV[` \x02` \x01\x01\x81\x81RPP[\x80`\x01\x82QaS\x06\x91\x90aapV[\x81Q\x81\x10aS\x16WaS\x16aa\x1CV[` \x02` \x01\x01Q_\x80\x1B\x03a\x05lW`@QbF\x1B\xCD`\xE5\x1B\x81R` `\x04\x82\x01R`\x0F`$\x82\x01R\x7FLast entry zero\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0`D\x82\x01R`d\x01a\x06\xB7V[_\x85\x90\x03aS\xA8W`@Q\x7F\x8Dy\xDB\xBC\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[\x82\x81\x11aS\xEBW`@Q\x7F `\xFA\xF4\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x81\x01\x84\x90R`$\x81\x01\x82\x90R`D\x01a\x06\xB7V[_\x84\x90\x03aT%W`@Q\x7F\x83\xC6\x83\xE4\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[_\x82\x90\x03a\x13\"W`@Q\x7F\\\xB6\xE5\xBB\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[``\x82G\x10\x15aT\xD7W`@QbF\x1B\xCD`\xE5\x1B\x81R` `\x04\x82\x01R`&`$\x82\x01R\x7FAddress: insufficient balance fo`D\x82\x01R\x7Fr call\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0`d\x82\x01R`\x84\x01a\x06\xB7V[`\x01`\x01`\xA0\x1B\x03\x85\x16;aU.W`@QbF\x1B\xCD`\xE5\x1B\x81R` `\x04\x82\x01R`\x1D`$\x82\x01R\x7FAddress: call to non-contract\0\0\0`D\x82\x01R`d\x01a\x06\xB7V[_\x80\x86`\x01`\x01`\xA0\x1B\x03\x16\x85\x87`@QaUI\x91\x90af\x81V[_`@Q\x80\x83\x03\x81\x85\x87Z\xF1\x92PPP=\x80_\x81\x14aU\x83W`@Q\x91P`\x1F\x19`?=\x01\x16\x82\x01`@R=\x82R=_` \x84\x01>aU\x88V[``\x91P[P\x91P\x91Pa\x05l\x82\x82\x86aV\x03V[_\x80\x82\x11aU\xE8W`@QbF\x1B\xCD`\xE5\x1B\x81R` `\x04\x82\x01R`\x1C`$\x82\x01R\x7FZero has no significant bits\0\0\0\0`D\x82\x01R`d\x01a\x06\xB7V[_\x82\x80aU\xF6`\x01\x82aapV[\x16\x18\x90Pa!.\x81aJ\"V[``\x83\x15aV\x12WP\x81a!.V[\x82Q\x15aV\"W\x82Q\x80\x84` \x01\xFD[\x81`@QbF\x1B\xCD`\xE5\x1B\x81R`\x04\x01a\x06\xB7\x91\x90af\x97V[`@\x80Q`\xC0\x81\x01\x82R_\x80\x82R` \x82\x01\x81\x90R\x91\x81\x01\x82\x90R``\x81\x01\x91\x90\x91R`\x80\x81\x01aVkaV\xE4V[\x81R` \x01aVxaV\xE4V[\x90R\x90V[\x82\x80T\x82\x82U\x90_R` _ \x90\x81\x01\x92\x82\x15aV\xB6W\x91` \x02\x82\x01[\x82\x81\x11\x15aV\xB6W\x825\x82U\x91` \x01\x91\x90`\x01\x01\x90aV\x9BV[PaV\xC2\x92\x91PaW\tV[P\x90V[`@Q\x80`@\x01`@R\x80aV\xD9aW\x1DV[\x81R` \x01_\x90R\x90V[`@Q\x80``\x01`@R\x80aV\xF7aW\x1DV[\x81R` \x01_\x81R_` \x90\x91\x01R\x90V[[\x80\x82\x11\x15aV\xC2W_\x81U`\x01\x01aW\nV[`@Q\x80`@\x01`@R\x80aW0aW9V[\x81R` \x01aVx[`@Q\x80`@\x01`@R\x80`\x02\x90` \x82\x02\x806\x837P\x91\x92\x91PPV[\x805`\xFF\x81\x16\x81\x14a\x10\xE6W_\x80\xFD[_\x80_\x80_\x80`\xC0\x87\x89\x03\x12\x15aW|W_\x80\xFD[aW\x85\x87aWWV[\x98` \x88\x015\x98P`@\x88\x015\x97``\x81\x015\x97P`\x80\x81\x015\x96P`\xA0\x015\x94P\x92PPPV[_` \x82\x84\x03\x12\x15aW\xBDW_\x80\xFD[\x815g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x11\x15aW\xD3W_\x80\xFD[\x82\x01`\xC0\x81\x85\x03\x12\x15a!.W_\x80\xFD[`\x01`\x01`\xA0\x1B\x03\x81\x16\x81\x14aW\xF8W_\x80\xFD[PV[g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x16\x81\x14aW\xF8W_\x80\xFD[_\x80\x83`\x1F\x84\x01\x12aX W_\x80\xFD[P\x815g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x11\x15aX7W_\x80\xFD[` \x83\x01\x91P\x83` \x82`\x05\x1B\x85\x01\x01\x11\x15aXQW_\x80\xFD[\x92P\x92\x90PV[_\x80_\x80_\x80_\x80_\x80_a\x01@\x8C\x8E\x03\x12\x15aXsW_\x80\xFD[\x8B5aX~\x81aW\xE4V[\x9AP` \x8C\x015aX\x8E\x81aW\xFBV[\x99P`@\x8C\x015aX\x9E\x81aW\xE4V[\x98P``\x8C\x015\x97P`\x80\x8C\x015\x96P`\xA0\x8C\x015\x95P`\xC0\x8C\x015aX\xC3\x81aW\xE4V[\x94P`\xE0\x8C\x015aX\xD3\x81aW\xE4V[\x93PaX\xE2a\x01\0\x8D\x01aWWV[\x92Pa\x01 \x8C\x015g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x11\x15aX\xFEW_\x80\xFD[aY\n\x8E\x82\x8F\x01aX\x10V[\x91P\x80\x93PP\x80\x91PP\x92\x95\x98\x9BP\x92\x95\x98\x9B\x90\x93\x96\x99PV[_` \x82\x84\x03\x12\x15aY4W_\x80\xFD[P5\x91\x90PV[`\x03\x81\x10aW\xF8W_\x80\xFD[\x805a\x10\xE6\x81aY;V[_` \x82\x84\x03\x12\x15aYbW_\x80\xFD[\x815a!.\x81aY;V[_\x80_`@\x84\x86\x03\x12\x15aY\x7FW_\x80\xFD[\x835g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x11\x15aY\x95W_\x80\xFD[aY\xA1\x86\x82\x87\x01aX\x10V[\x90\x97\x90\x96P` \x95\x90\x95\x015\x94\x93PPPPV[_\x80`@\x83\x85\x03\x12\x15aY\xC6W_\x80\xFD[\x825aY\xD1\x81aW\xE4V[\x94` \x93\x90\x93\x015\x93PPPV[_\x80_``\x84\x86\x03\x12\x15aY\xF1W_\x80\xFD[PP\x815\x93` \x83\x015\x93P`@\x90\x92\x015\x91\x90PV[_\x80_\x80_\x80_\x87\x89\x03a\x01 \x81\x12\x15aZ W_\x80\xFD[\x885\x97P` \x89\x015g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x80\x82\x11\x15aZ>W_\x80\xFD[\x90\x8A\x01\x90`@\x82\x8D\x03\x12\x15aZQW_\x80\xFD[\x81\x98P`\xA0\x7F\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xC0\x84\x01\x12\x15aZ\x83W_\x80\xFD[`@\x8B\x01\x97P`\xE0\x8B\x015\x92P\x80\x83\x11\x15aZ\x9CW_\x80\xFD[aZ\xA8\x8C\x84\x8D\x01aX\x10V[\x90\x97P\x95Pa\x01\0\x8B\x015\x92P\x86\x91P\x80\x83\x11\x15aZ\xC4W_\x80\xFD[PPaZ\xD2\x8A\x82\x8B\x01aX\x10V[\x98\x9B\x97\x9AP\x95\x98P\x93\x96\x92\x95\x92\x93PPPV[_\x80\x82\x84\x03a\x01 \x81\x12\x15aZ\xF8W_\x80\xFD[\x835\x92Pa\x01\0`\x1F\x19\x82\x01\x12\x15a[\x0EW_\x80\xFD[P` \x83\x01\x90P\x92P\x92\x90PV[_\x80_\x80_`\xA0\x86\x88\x03\x12\x15a[0W_\x80\xFD[a[9\x86aWWV[\x97` \x87\x015\x97P`@\x87\x015\x96``\x81\x015\x96P`\x80\x015\x94P\x92PPPV[_\x80_\x80``\x85\x87\x03\x12\x15a[mW_\x80\xFD[\x845\x93P` \x85\x015\x92P`@\x85\x015g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x80\x82\x11\x15a[\x92W_\x80\xFD[\x81\x87\x01\x91P\x87`\x1F\x83\x01\x12a[\xA5W_\x80\xFD[\x815\x81\x81\x11\x15a[\xB3W_\x80\xFD[\x88` \x82\x85\x01\x01\x11\x15a[\xC4W_\x80\xFD[\x95\x98\x94\x97PP` \x01\x94PPPV[_\x80`@\x83\x85\x03\x12\x15a[\xE4W_\x80\xFD[PP\x805\x92` \x90\x91\x015\x91PV[cNH{q`\xE0\x1B_R`!`\x04R`$_\xFD[`\x02\x81\x10a\\\x17Wa\\\x17a[\xF3V[\x90RV[_a\x01\xE0\x82\x01\x90P\x82Q\x82R` \x83\x01Q` \x83\x01R`@\x83\x01Q`@\x83\x01R``\x83\x01Q``\x83\x01R`\x80\x83\x01Q`\x80\x83\x01R`\xA0\x83\x01Q`\xA0\x83\x01R`\xC0\x83\x01Q`\xC0\x83\x01R`\xE0\x83\x01Q`\xE0\x83\x01Ra\x01\0\x80\x84\x01Qa\\\x88\x82\x85\x01\x82`\x01`\x01`\xA0\x1B\x03\x16\x90RV[PPa\x01 \x83\x81\x01Qg\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x16\x84\x83\x01RPPa\x01@\x83\x81\x01Qg\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x16\x84\x83\x01RPPa\x01`\x80\x84\x01Qa\\\xCD\x82\x85\x01\x82a\\\x07V[PPa\x01\x80\x83\x81\x01Q`\xFF\x16\x90\x83\x01Ra\x01\xA0\x80\x84\x01Q\x15\x15\x90\x83\x01Ra\x01\xC0\x80\x84\x01Qg\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x16\x82\x85\x01Ra \xB6V[_` \x82\x84\x03\x12\x15a]\x15W_\x80\xFD[\x81Q\x80\x15\x15\x81\x14a!.W_\x80\xFD[_` \x82\x84\x03\x12\x15a]4W_\x80\xFD[a!.\x82aWWV[_\x80\x835\x7F\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xE1\x846\x03\x01\x81\x12a]pW_\x80\xFD[\x83\x01\x805\x91Pg\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x82\x11\x15a]\x8AW_\x80\xFD[` \x01\x91P6\x81\x90\x03\x82\x13\x15aXQW_\x80\xFD[cNH{q`\xE0\x1B_R`A`\x04R`$_\xFD[`@Q``\x81\x01g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x11\x82\x82\x10\x17\x15a]\xD5Wa]\xD5a]\x9EV[`@R\x90V[`@\x80Q\x90\x81\x01g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x11\x82\x82\x10\x17\x15a]\xD5Wa]\xD5a]\x9EV[`@Q`\x1F\x82\x01`\x1F\x19\x16\x81\x01g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x11\x82\x82\x10\x17\x15a^'Wa^'a]\x9EV[`@R\x91\x90PV[_g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x82\x11\x15a^HWa^Ha]\x9EV[P`\x05\x1B` \x01\x90V[_\x82`\x1F\x83\x01\x12a^aW_\x80\xFD[\x815` a^va^q\x83a^/V[a]\xFEV[\x80\x83\x82R` \x82\x01\x91P` \x84`\x05\x1B\x87\x01\x01\x93P\x86\x84\x11\x15a^\x97W_\x80\xFD[` \x86\x01[\x84\x81\x10\x15a^\xB3W\x805\x83R\x91\x83\x01\x91\x83\x01a^\x9CV[P\x96\x95PPPPPPV[_\x82`\x1F\x83\x01\x12a^\xCDW_\x80\xFD[a^\xD5a]\xDBV[\x80`@\x84\x01\x85\x81\x11\x15a^\xE6W_\x80\xFD[\x84[\x81\x81\x10\x15a5aW\x805a^\xFB\x81aW\xFBV[\x84R` \x93\x84\x01\x93\x01a^\xE8V[_\x81\x83\x03a\x01\0\x81\x12\x15a_\x1BW_\x80\xFD[a_#a]\xB2V[\x91P`\xC0\x81\x12\x15a_2W_\x80\xFD[a_:a]\xB2V[`\x80\x82\x12\x15a_GW_\x80\xFD[a_Oa]\xDBV[\x91P\x84`\x1F\x85\x01\x12a__W_\x80\xFD[a_ga]\xDBV[\x80`@\x86\x01\x87\x81\x11\x15a_xW_\x80\xFD[\x86[\x81\x81\x10\x15a_\x92W\x805\x84R` \x93\x84\x01\x93\x01a_zV[P\x81\x85Ra_\xA0\x88\x82a^\xBEV[` \x86\x01RPPP\x81\x81Ra_\xB7`\x80\x85\x01aYGV[` \x82\x01R`\xA0\x84\x015`@\x82\x01R\x80\x83RPP`\xC0\x82\x015` \x82\x01R`\xE0\x82\x015`@\x82\x01R\x92\x91PPV[_\x80_a\x02 \x84\x86\x03\x12\x15a_\xF8W_\x80\xFD[\x835g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x11\x15a`\x0EW_\x80\xFD[a`\x1A\x86\x82\x87\x01a^RV[\x93PPa`*\x85` \x86\x01a_\tV[\x91Pa`:\x85a\x01 \x86\x01a_\tV[\x90P\x92P\x92P\x92V[\x80Q\x82_[`\x02\x81\x10\x15a`gW\x82Q\x82R` \x92\x83\x01\x92\x90\x91\x01\x90`\x01\x01a`HV[PPP` \x80\x82\x01Q`@\x84\x01_[`\x02\x81\x10\x15a`\x9DW\x82Qg\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x82R\x91\x83\x01\x91\x90\x83\x01\x90`\x01\x01a`vV[PPPPPPV[`\x03\x81\x10aW\xF8WaW\xF8a[\xF3V[_a\x01 \x82\x01\x90P\x85\x82Ra`\xCE` \x83\x01\x86Qa`CV[` \x85\x01Qa`\xDC\x81a`\xA5V[`\xA0\x83\x01R`@\x94\x90\x94\x01Q`\xC0\x82\x01R`\xE0\x81\x01\x92\x90\x92Ra\x01\0\x90\x91\x01R\x91\x90PV[_` \x82\x84\x03\x12\x15aa\x11W_\x80\xFD[\x81Qa!.\x81aW\xFBV[cNH{q`\xE0\x1B_R`2`\x04R`$_\xFD[cNH{q`\xE0\x1B_R`\x11`\x04R`$_\xFD[`\xFF\x81\x81\x16\x83\x82\x16\x01\x90\x81\x11\x15a\x10IWa\x10Iaa0V[` \x81\x01aaj\x83a`\xA5V[\x91\x90R\x90V[\x81\x81\x03\x81\x81\x11\x15a\x10IWa\x10Iaa0V[_`\xC0\x82\x01\x90P\x83\x82R\x825` \x83\x01R` \x83\x015`@\x83\x01R`@\x83\x015aa\xAC\x81aW\xE4V[`\x01`\x01`\xA0\x1B\x03\x81\x16``\x84\x01RP``\x83\x015aa\xCA\x81aW\xFBV[g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x80\x82\x16`\x80\x85\x01R`\x80\x85\x015\x91Paa\xEB\x82aW\xFBV[\x80\x82\x16`\xA0\x85\x01RPP\x93\x92PPPV[_` \x82\x84\x03\x12\x15ab\x0CW_\x80\xFD[\x815a!.\x81aW\xFBV[_` \x82\x84\x03\x12\x15ab'W_\x80\xFD[\x81Qa!.\x81aW\xE4V[\x84\x81Ra\x01 \x81\x01` `@\x86\x82\x85\x017``\x83\x01`@\x87\x01_[`\x02\x81\x10\x15ab}W\x815aba\x81aW\xFBV[g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x83R\x91\x83\x01\x91\x90\x83\x01\x90`\x01\x01abMV[PPPP`\x80\x85\x015ab\x8F\x81aY;V[ab\x98\x81a`\xA5V[\x80`\xA0\x84\x01RP`\xA0\x85\x015`\xC0\x83\x01R\x83`\xE0\x83\x01R\x82a\x01\0\x83\x01R\x95\x94PPPPPV[g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x82\x81\x16\x82\x82\x16\x03\x90\x80\x82\x11\x15aG\xB3WaG\xB3aa0V[\x82\x81R`@\x81\x01a!.` \x83\x01\x84a\\\x07V[\x80\x82\x01\x80\x82\x11\x15a\x10IWa\x10Iaa0V[\x80\x82\x02\x81\x15\x82\x82\x04\x84\x14\x17a\x10IWa\x10Iaa0V[\x85Q\x81R`\x01`\x01`\xA0\x1B\x03` \x87\x01Q\x16` \x82\x01R`@\x86\x01Q`@\x82\x01R\x84``\x82\x01R\x83`\x80\x82\x01R`\xC0`\xA0\x82\x01R\x81`\xC0\x82\x01R\x81\x83`\xE0\x83\x017_\x81\x83\x01`\xE0\x90\x81\x01\x91\x90\x91R`\x1F\x90\x92\x01`\x1F\x19\x16\x01\x01\x94\x93PPPPV[_` \x82\x84\x03\x12\x15ac\x8FW_\x80\xFD[PQ\x91\x90PV[_\x82`\x1F\x83\x01\x12ac\xA5W_\x80\xFD[\x81Q` ac\xB5a^q\x83a^/V[\x80\x83\x82R` \x82\x01\x91P` \x84`\x05\x1B\x87\x01\x01\x93P\x86\x84\x11\x15ac\xD6W_\x80\xFD[` \x86\x01[\x84\x81\x10\x15a^\xB3W\x80Q\x83R\x91\x83\x01\x91\x83\x01ac\xDBV[_\x80`@\x83\x85\x03\x12\x15ad\x03W_\x80\xFD[\x82Qg\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x80\x82\x11\x15ad\x1AW_\x80\xFD[ad&\x86\x83\x87\x01ac\x96V[\x93P` \x85\x01Q\x91P\x80\x82\x11\x15ad;W_\x80\xFD[PadH\x85\x82\x86\x01ac\x96V[\x91PP\x92P\x92\x90PV[_`\xA0\x82\x01\x90Padd\x82\x84Qa`CV[` \x83\x01Qadr\x81a`\xA5V[\x80`\x80\x84\x01RP\x92\x91PPV[_\x80_\x80_`\xA0\x86\x88\x03\x12\x15ad\x93W_\x80\xFD[\x855\x94P` \x86\x015\x93P`@\x86\x015g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x80\x82\x11\x15ad\xB8W_\x80\xFD[ad\xC4\x89\x83\x8A\x01a^RV[\x94P``\x88\x015\x91P\x80\x82\x11\x15ad\xD9W_\x80\xFD[ad\xE5\x89\x83\x8A\x01a^RV[\x93P`\x80\x88\x015\x91P\x80\x82\x11\x15ad\xFAW_\x80\xFD[Pae\x07\x88\x82\x89\x01a^RV[\x91PP\x92\x95P\x92\x95\x90\x93PV[_\x80`@\x83\x85\x03\x12\x15ae%W_\x80\xFD[\x825g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x80\x82\x11\x15ae<W_\x80\xFD[aeH\x86\x83\x87\x01a^RV[\x93P` \x85\x015\x91P\x80\x82\x11\x15ae]W_\x80\xFD[PadH\x85\x82\x86\x01a^RV[cNH{q`\xE0\x1B_R`\x01`\x04R`$_\xFD[__\x19\x82\x03ae\x8FWae\x8Faa0V[P`\x01\x01\x90V[`\x01\x81\x81[\x80\x85\x11\x15ae\xD0W\x81_\x19\x04\x82\x11\x15ae\xB6Wae\xB6aa0V[\x80\x85\x16\x15ae\xC3W\x91\x81\x02\x91[\x93\x84\x1C\x93\x90\x80\x02\x90ae\x9BV[P\x92P\x92\x90PV[_\x82ae\xE6WP`\x01a\x10IV[\x81ae\xF2WP_a\x10IV[\x81`\x01\x81\x14af\x08W`\x02\x81\x14af\x12Waf.V[`\x01\x91PPa\x10IV[`\xFF\x84\x11\x15af#Waf#aa0V[PP`\x01\x82\x1Ba\x10IV[P` \x83\x10a\x013\x83\x10\x16`N\x84\x10`\x0B\x84\x10\x16\x17\x15afQWP\x81\x81\na\x10IV[af[\x83\x83ae\x96V[\x80_\x19\x04\x82\x11\x15afnWafnaa0V[\x02\x93\x92PPPV[_a!.\x83\x83ae\xD8V[_\x82Q\x80` \x85\x01\x84^_\x92\x01\x91\x82RP\x91\x90PV[` \x81R_\x82Q\x80` \x84\x01R\x80` \x85\x01`@\x85\x01^_`@\x82\x85\x01\x01R`@`\x1F\x19`\x1F\x83\x01\x16\x84\x01\x01\x91PP\x92\x91PPV\xFE\xA2dipfsX\"\x12 $\r\xE4\xA0\x0FKM\xBE#\x90#\xD9\x7F\x9E\xB5\x9C\x9A\xE6\x1EE\x7F#\x1A\x82\xC1\xF1\x89-\xBD\x1A<\xFBdsolcC\0\x08\x19\x003",
    );
    /// The runtime bytecode of the contract, as deployed on the network.
    ///
    /// ```text
    ///0x608060405234801561000f575f80fd5b50600436106101e6575f3560e01c8063655b42f311610109578063c32d8c631161009e578063eae0328b1161006e578063eae0328b146104a6578063edaab54a146104b9578063f8ee77d6146104cc578063fda2892e146104d5575f80fd5b8063c32d8c6314610439578063c8bc4e431461044c578063e5b123da14610474578063e94e051e14610493575f80fd5b80638c1b3a40116100d95780638c1b3a40146103e1578063908517e9146103f4578063b2a1408e14610407578063bce6f54f1461041a575f80fd5b8063655b42f314610370578063748926f3146103a8578063750e0c0f146103bb5780638826a370146103ce575f80fd5b8063432bb78a1161017f57806351ed6a301161014f57806351ed6a301461030857806354b641511461031b5780635a48e0f41461033e5780635d9e244414610351575f80fd5b8063432bb78a1461028357806346c2781a1461029657806348923bc5146102c357806348dd2924146102ee575f80fd5b80631dce5166116101ba5780631dce51661461024b5780633e35f5e814610254578063416e66571461026757806342e1aaa814610270575f80fd5b80624d8efe146101ea57806305fae141146102105780631a72d54c146102235780631c1b4f3a14610238575b5f80fd5b6101fd6101f8366004615767565b6104f5565b6040519081526020015b60405180910390f35b6101fd61021e3660046157ad565b610577565b610236610231366004615858565b610bb1565b005b6101fd610246366004615924565b61101e565b6101fd600a5481565b6101fd610262366004615924565b61103d565b6101fd600b5481565b6101fd61027e366004615952565b61104f565b61023661029136600461596d565b6110eb565b6008546102aa9067ffffffffffffffff1681565b60405167ffffffffffffffff9091168152602001610207565b6009546102d6906001600160a01b031681565b6040516001600160a01b039091168152602001610207565b6008546102d690600160401b90046001600160a01b031681565b6006546102d6906001600160a01b031681565b61032e610329366004615924565b611192565b6040519015158152602001610207565b6101fd61034c366004615924565b61119e565b600d5461035e9060ff1681565b60405160ff9091168152602001610207565b61032e61037e3660046159b5565b6001600160a01b03919091165f908152600460209081526040808320938352929052205460ff1690565b6102366103b6366004615924565b6111aa565b61032e6103c9366004615924565b611299565b6102366103dc3660046159df565b6112c2565b6102366103ef366004615a08565b611329565b61032e610402366004615924565b6114e8565b610236610415366004615ae5565b6114f4565b6101fd610428366004615924565b5f9081526002602052604090205490565b6101fd610447366004615b1c565b61186d565b61045f61045a366004615b5a565b6118ca565b60408051928352602083019190915201610207565b6101fd610482366004615924565b5f9081526003602052604090205490565b6005546102d6906001600160a01b031681565b6101fd6104b4366004615924565b611a80565b6102366104c7366004615bd3565b611a94565b6101fd600c5481565b6104e86104e3366004615924565b611aec565b6040516102079190615c1b565b6040805160f888901b6001600160f81b03191660208083019190915260218201889052604182018790526061820186905260818083018690528351808403909101815260a18301845280519082012060c183015260e18083018590528351808403909101815261010190920190925280519101205f905b979650505050505050565b5f8060088054906101000a90046001600160a01b03166001600160a01b03166312ab3d3b6040518163ffffffff1660e01b8152600401602060405180830381865afa1580156105c8573d5f803e3d5ffd5b505050506040513d601f19601f820116820180604052508101906105ec9190615d05565b15905080801561068257506008546040517ffacd743b000000000000000000000000000000000000000000000000000000008152336004820152600160401b9091046001600160a01b03169063facd743b90602401602060405180830381865afa15801561065c573d5f803e3d5ffd5b505050506040513d601f19601f820116820180604052508101906106809190615d05565b155b156106c0576040517fed3db8ac0000000000000000000000000000000000000000000000000000000081523360048201526024015b60405180910390fd5b60408051610100810182525f80825260208201819052918101829052606081018290526080810182905260a0810182905260c0810182905260e08101919091525f61071c6107116020870187615d24565b600d5460ff16611c8c565b90505f6107288261104f565b905061073261563c565b5f83600281111561074557610745615bf3565b03610a645761075760a0880188615d3d565b90505f0361077857604051630c9ccac560e41b815260040160405180910390fd5b5f8061078760a08a018a615d3d565b8101906107949190615fe5565b925092505060088054906101000a90046001600160a01b03166001600160a01b031663e51019a68a60600135835f0151846020015185604001516040518563ffffffff1660e01b81526004016107ed94939291906160b5565b5f6040518083038186803b158015610803575f80fd5b505afa158015610815573d5f803e3d5ffd5b505060085460208481015186519187015160408089015190517fe51019a6000000000000000000000000000000000000000000000000000000008152600160401b9095046001600160a01b0316965063e51019a6955061087a949293926004016160b5565b5f6040518083038186803b158015610890575f80fd5b505afa1580156108a2573d5f803e3d5ffd5b50505050805f0151604001518960200135146108ff57805160409081015190517f3a63e99a00000000000000000000000000000000000000000000000000000000815260208b0135600482015260248101919091526044016106b7565b6040805160c08101825260608b01358082526020848101519083015260085483517fe531d8c700000000000000000000000000000000000000000000000000000000815260048101929092529192830191600160401b90046001600160a01b03169063e531d8c790602401602060405180830381865afa158015610985573d5f803e3d5ffd5b505050506040513d601f19601f820116820180604052508101906109a99190615d05565b151581526008546020848101516040517f56bbc9e600000000000000000000000000000000000000000000000000000000815260048101919091529201915f91600160401b90046001600160a01b0316906356bbc9e690602401602060405180830381865afa158015610a1e573d5f803e3d5ffd5b505050506040513d601f19601f82011682018060405250810190610a429190616101565b67ffffffffffffffff1611815292516020840152905160409092019190915290505b600954600d54610a8c916001918a9185916001600160a01b0390911690879060ff168b611d11565b6006549094506001600160a01b03165f6007610aab60208b018b615d24565b60ff1681548110610abe57610abe61611c565b5f9182526020909120015490506001600160a01b03821615801590610ae257508015155b15610b1d575f8660c00151610af75730610b04565b6005546001600160a01b03165b9050610b1b6001600160a01b038416338385611e31565b505b85604001518660200151875f01517faa4b66b1ce938c06e2a3f8466bae10ef62e747630e3859889f4719fc6427b5a489606001518a608001518b60a001518c60c001518d60e00151604051610b9b959493929190948552602085019390935260ff919091166040840152151560608301521515608082015260a00190565b60405180910390a4505092519695505050505050565b5f54610100900460ff1615808015610bcf57505f54600160ff909116105b80610be85750303b158015610be857505f5460ff166001145b610c5a5760405162461bcd60e51b815260206004820152602e60248201527f496e697469616c697a61626c653a20636f6e747261637420697320616c72656160448201527f647920696e697469616c697a656400000000000000000000000000000000000060648201526084016106b7565b5f805460ff191660011790558015610c7b575f805461ff0019166101001790555b6001600160a01b038c16610cbb576040517fc83e086200000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b600880546001600160a01b03808f16600160401b027fffffffff0000000000000000000000000000000000000000ffffffffffffffff909216919091179091558a16610d33576040517ffb60b0ef00000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b6009805473ffffffffffffffffffffffffffffffffffffffff19166001600160a01b038c1617905567ffffffffffffffff8b165f03610d9e576040517f8a0eedcc00000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b6008805467ffffffffffffffff191667ffffffffffffffff8d161790556006805473ffffffffffffffffffffffffffffffffffffffff19166001600160a01b03888116919091179091558516610e20576040517f0f0ec8a800000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b6005805473ffffffffffffffffffffffffffffffffffffffff19166001600160a01b038716179055610e5189611ee2565b610e7157604051633abfb6ff60e21b8152600481018a90526024016106b7565b600a899055610e7f88611ee2565b610e9f57604051633abfb6ff60e21b8152600481018990526024016106b7565b600b889055610ead87611ee2565b610ecd57604051633abfb6ff60e21b8152600481018890526024016106b7565b600c87905560ff84165f03610f0e576040517fa863d6e400000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b60fd8460ff161115610f51576040517f40d23bf000000000000000000000000000000000000000000000000000000000815260ff851660048201526024016106b7565b600d805460ff191660ff861617905581610f6c856002616144565b60ff1614610fbe5781610f80856002616144565b6040517f0aece9c0000000000000000000000000000000000000000000000000000000008152600481019290925260ff1660248201526044016106b7565b610fca6007848461567d565b508015611010575f805461ff0019169055604051600181527f7f26b83ff96e1f2b6a682f133852f6798a09c465da95921460cefb38474024989060200160405180910390a15b505050505050505050505050565b6007818154811061102d575f80fd5b5f91825260209091200154905081565b5f611049600183611f08565b92915050565b5f8082600281111561106357611063615bf3565b03611070575050600a5490565b600182600281111561108457611084615bf3565b03611091575050600b5490565b60028260028111156110a5576110a5615bf3565b036110b2575050600c5490565b816040517f3bf2e1ec0000000000000000000000000000000000000000000000000000000081526004016106b7919061615d565b919050565b5f829003611125576040517f521299a900000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b6111568383611135600182616170565b8181106111445761114461611c565b600192602090910201359050836120be565b505f5b8281101561118c576111848484838181106111765761117661611c565b905060200201355f19611a94565b600101611159565b50505050565b5f611049600183612135565b5f611049600183612167565b5f6111b66001836121b6565b90506111c181612209565b6006546009820154600780546001600160a01b03909316925f92600160481b900460ff169081106111f4576111f461611c565b5f9182526020909120015490506001600160a01b0382161580159061121857508015155b15611239576008830154611239906001600160a01b03848116911683612313565b5f84815260016020526040902061124f90612361565b604080516001600160a01b03851681526020810184905286917fa635398959ddb5ce3b14537edfc25b2e671274c9b8cad0f4bd634752e69007b6910160405180910390a350505050565b5f81815260016020526040812060080154600160a01b900467ffffffffffffffff161515611049565b600d545f9081906112dd906001908790879060ff16876123d7565b91509150811561132257847fbe17755d8d836ad67bfaf8e5b3869aedb4cba03f295a167c5547feddd9ef50ad8260405161131991815260200190565b60405180910390a25b5050505050565b5f611335600189612167565b6008546040517f04972af9000000000000000000000000000000000000000000000000000000008152919250600160401b90046001600160a01b0316906304972af9906113889084908a90600401616183565b5f6040518083038186803b15801561139e575f80fd5b505afa1580156113b0573d5f803e3d5ffd5b505050505f60405180606001604052808860800160208101906113d391906161fc565b67ffffffffffffffff16815260200160088054906101000a90046001600160a01b03166001600160a01b031663e78cea926040518163ffffffff1660e01b8152600401602060405180830381865afa158015611431573d5f803e3d5ffd5b505050506040513d601f19601f820116820180604052508101906114559190616217565b6001600160a01b0390811682528935602090920191909152600954600d54600b54600c5494955061149d946001948f9416928e9288928e928e928e928e9260ff169190612444565b5f8981526001602052604090206114b390612361565b6040518a907fe11db4b27bc8c6ea5943ecbb205ae1ca8d56c42c719717aaf8a53d43d0cee7c2905f90a3505050505050505050565b5f6110496001836127d6565b5f6115006001846121b6565b905061150b816128b3565b61156d57611518816128d6565b600882015460078301546040517fe58c830800000000000000000000000000000000000000000000000000000000815260048101939093526001600160a01b03909116602483015260448201526064016106b7565b5f80806009840154600d5461158f9160ff600160481b90910481169116611c8c565b60028111156115a0576115a0615bf3565b14905080801561163b575060085460078401546040517f308362280000000000000000000000000000000000000000000000000000000081526004810191909152600160401b9091046001600160a01b031690633083622890602401602060405180830381865afa158015611617573d5f803e3d5ffd5b505050506040513d601f19601f8201168201806040525081019061163b9190615d05565b156117f35760085460078401546040517fe51019a6000000000000000000000000000000000000000000000000000000008152600160401b9092046001600160a01b03169163e51019a6916116a091889060c08201359060e083013590600401616232565b5f6040518083038186803b1580156116b6575f80fd5b505afa1580156116c8573d5f803e3d5ffd5b50506008546040517f1171558500000000000000000000000000000000000000000000000000000000815260c08801356004820152600160401b9091046001600160a01b0316925063117155859150602401602060405180830381865afa158015611735573d5f803e3d5ffd5b505050506040513d601f19601f820116820180604052508101906117599190616101565b6008546040517f56bbc9e600000000000000000000000000000000000000000000000000000000815260c08701356004820152600160401b9091046001600160a01b0316906356bbc9e690602401602060405180830381865afa1580156117c2573d5f803e3d5ffd5b505050506040513d601f19601f820116820180604052508101906117e69190616101565b6117f091906162bf565b91505b6008545f90611812906001908890869067ffffffffffffffff16612976565b5f87815260016020526040902090915061182b90612361565b867f2e0808830a22204cb3fb8f8d784b28bc97e9ce2e39d2f9cde2860de0957d68eb8360405161185d91815260200190565b60405180910390a3505050505050565b6040805160f887901b6001600160f81b03191660208083019190915260218201879052604182018690526061820185905260818083018590528351808403909101815260a190920190925280519101205f905b9695505050505050565b5f805f805f611915898989898080601f0160208091040260200160405190810160405280939291908181526020018383808284375f920191909152506001959493925050612a5a9050565b8151929550909350915015806119ac5782604001518360200151845f01517faa4b66b1ce938c06e2a3f8466bae10ef62e747630e3859889f4719fc6427b5a4866060015187608001518860a001518960c001518a60e001516040516119a3959493929190948552602085019390935260ff919091166040840152151560608301521515608082015260a00190565b60405180910390a45b81604001518260200151835f01517faa4b66b1ce938c06e2a3f8466bae10ef62e747630e3859889f4719fc6427b5a4856060015186608001518760a001518860c001518960e00151604051611a2a959493929190948552602085019390935260ff919091166040840152151560608301521515608082015260a00190565b60405180910390a48151604051821515815285908c907f7340510d24b7ec9b5c100f5500d93429d80d00d46f0d18e4e85d0c4cc22b99249060200160405180910390a45051919350909150505b94509492505050565b5f611049611a8f6001846121b6565b612e76565b5f80611aa260018585612eb9565b91509150811561118c57837fbe17755d8d836ad67bfaf8e5b3869aedb4cba03f295a167c5547feddd9ef50ad82604051611ade91815260200190565b60405180910390a250505050565b604080516101e0810182525f80825260208201819052918101829052606081018290526080810182905260a0810182905260c0810182905260e08101829052610100810182905261012081018290526101408101829052610160810182905261018081018290526101a081018290526101c0810191909152611b6f6001836121b6565b604080516101e0810182528254815260018084015460208301526002840154928201929092526003830154606082015260048301546080820152600583015460a0820152600683015460c0820152600783015460e082015260088301546001600160a01b038116610100830152600160a01b900467ffffffffffffffff9081166101208301526009840154908116610140830152909291610160840191600160401b900460ff1690811115611c2657611c26615bf3565b6001811115611c3757611c37615bf3565b81526009919091015460ff600160481b8204811660208401526a01000000000000000000008204161515604083015267ffffffffffffffff6b0100000000000000000000009091041660609091015292915050565b5f8260ff165f03611c9e57505f611049565b8160ff168360ff1611611cb357506001611049565b611cbe826001616144565b60ff168360ff1603611cd257506002611049565b6040517fae0da57800000000000000000000000000000000000000000000000000000000815260ff8085166004830152831660248201526044016106b7565b60408051610100810182525f80825260208201819052918101829052606081018290526080810182905260a0810182905260c0810182905260e081018290529080611d5f8a8a8a8a89612edc565b915091505f611d6f838b8961342a565b90505f611d7d83838d61356c565b90508515611e17575f611d8f8261360e565b335f90815260038f016020908152604080832084845290915290205490915060ff1615611df1576040517f5a46ac3a000000000000000000000000000000000000000000000000000000008152336004820152602481018290526044016106b7565b335f90815260038e016020908152604080832093835292905220805460ff191660011790555b611e218c8261367b565b9c9b505050505050505050505050565b6040516001600160a01b038085166024830152831660448201526064810182905261118c9085907f23b872dd00000000000000000000000000000000000000000000000000000000906084015b60408051601f198184030181529190526020810180517bffffffffffffffffffffffffffffffffffffffffffffffffffffffff167fffffffff0000000000000000000000000000000000000000000000000000000090931692909217909152613a56565b5f815f03611ef157505f919050565b5f611efd600184616170565b929092161592915050565b5f81815260208390526040812060080154600160a01b900467ffffffffffffffff16611f495760405162a7b02b60e01b8152600481018390526024016106b7565b5f828152602084905260408120611f5f90612361565b5f818152600186016020526040812054919250819003611fab576040517fda10f67c00000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b6040516815539492559053115160ba1b6020820152602901604051602081830303815290604052805190602001208103612014575f8481526020869052604090206008015461200b90600160a01b900467ffffffffffffffff1643616170565b92505050611049565b5f81815260208690526040902060080154600160a01b900467ffffffffffffffff166120555760405162a7b02b60e01b8152600481018290526024016106b7565b5f81815260208690526040808220600890810154878452919092209091015467ffffffffffffffff600160a01b9283900481169290910416808211156120aa5761209f8183616170565b945050505050611049565b5f945050505050611049565b505092915050565b5f828152602084905260408120600901546b010000000000000000000000900467ffffffffffffffff1682811061212b576040517fd1f5928100000000000000000000000000000000000000000000000000000000815260048101829052602481018490526044016106b7565b90505b9392505050565b5f61214083836127d6565b801561212e57505f82815260208490526040902061215d90612e76565b6001149392505050565b5f8061217384846121b6565b90505b6009810154600160481b900460ff16156121ae5780545f9081526001850160205260409020546121a685826121b6565b915050612176565b549392505050565b5f81815260208390526040812060080154600160a01b900467ffffffffffffffff166121f75760405162a7b02b60e01b8152600481018390526024016106b7565b505f9081526020919091526040902090565b60016009820154600160401b900460ff16600181111561222b5761222b615bf3565b1461227c57612239816128d6565b60098201546040517fef1267b40000000000000000000000000000000000000000000000000000000081526106b79291600160401b900460ff16906004016162e0565b612285816128b3565b61229257611518816128d6565b60098101546a0100000000000000000000900460ff1615156001036122ef576122ba816128d6565b6040517f307f76690000000000000000000000000000000000000000000000000000000081526004016106b791815260200190565b60090180546aff0000000000000000000019166a0100000000000000000000179055565b6040516001600160a01b03831660248201526044810182905261235c9084907fa9059cbb0000000000000000000000000000000000000000000000000000000090606401611e7e565b505050565b6009810154815460028301546001840154600485015460408051600160481b90960460f81b6001600160f81b0319166020808801919091526021870195909552604186019390935260618501919091526081808501919091528151808503909101815260a1909301905281519101205f90611049565b5f805f6123e48888611f08565b90506123f288888888613b3a565b5f86815260208990526040902060090154612426906b010000000000000000000000900467ffffffffffffffff16826162f4565b905061243488888387613cf4565b92509250505b9550959350505050565b5f8b815260208d90526040902060080154600160a01b900467ffffffffffffffff166124855760405162a7b02b60e01b8152600481018c90526024016106b7565b60025f8c815260208e905260409020600901546124ac90600160481b900460ff1685611c8c565b60028111156124bd576124bd615bf3565b14612512575f8b815260208d90526040908190206009015490517f348aefdf000000000000000000000000000000000000000000000000000000008152600160481b90910460ff1660048201526024016106b7565b5f8b815260208d90526040902061252890612e76565b60011461257a575f8b815260208d90526040902061254590612e76565b6040517f6b595e500000000000000000000000000000000000000000000000000000000081526004016106b791815260200190565b5f8b815260208d905260409020600201548b825b60018f5f015f8481526020019081526020015f2060090160099054906101000a900460ff1660ff161115612629575f8f5f015f8481526020019081526020015f205f015490508f6001015f8281526020019081526020015f205492508f5f015f8481526020019081526020015f20600201548261260b9190616307565b61261590856162f4565b93506126218683616307565b91505061258e565b50506126818d5f015f8e81526020019081526020015f20600101548b5f0135838b8b808060200260200160405190810160405280939291908181526020018383602002808284375f92019190915250613d8992505050565b5f8b6001600160a01b031663b5112fd28b848e5f01358f80602001906126a79190615d3d565b6040518663ffffffff1660e01b81526004016126c795949392919061631e565b602060405180830381865afa1580156126e2573d5f803e3d5ffd5b505050506040513d601f19601f82011682018060405250810190612706919061637f565b90506127678e5f015f8f81526020019081526020015f20600301548284600161272f91906162f4565b8a8a808060200260200160405190810160405280939291908181526020018383602002808284375f92019190915250613d8992505050565b5f8d815260208f90526040902061277d90613e0e565b6127878e8e613ea9565b5050505f998a5250505060209790975250506040909320600901805472ffffffffffffffff0000000000000000000000191672ffffffffffffffff000000000000000000000017905550505050565b5f81815260208390526040812060080154600160a01b900467ffffffffffffffff166128175760405162a7b02b60e01b8152600481018390526024016106b7565b5f82815260208490526040812061282d90612361565b5f818152600186016020526040812054919250819003612879576040517fda10f67c00000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b6040516815539492559053115160ba1b602082015260290160408051601f1981840301815291905280516020909101201415949350505050565b60078101545f9015801590611049575050600801546001600160a01b0316151590565b60098101548154600283015460018401546004850154600386015460408051600160481b90970460f81b6001600160f81b0319166020808901919091526021880196909652604187019490945260618601929092526081808601919091528251808603909101815260a18501835280519084012060c185015260e18085019190915281518085039091018152610101909301905281519101205f90611049565b5f83815260208590526040812060080154600160a01b900467ffffffffffffffff166129b75760405162a7b02b60e01b8152600481018590526024016106b7565b5f6129c28686613f29565b90506129d867ffffffffffffffff8516826162f4565b90508267ffffffffffffffff16811015612a31576040517f11a8d4d00000000000000000000000000000000000000000000000000000000081526004810182905267ffffffffffffffff841660248201526044016106b7565b5f858152602087905260409020612a4790613e0e565b612a518686613ea9565b95945050505050565b60408051610100810182525f80825260208201819052918101829052606081018290526080810182905260a0810182905260c0810182905260e0810182905260408051610100810182525f80825260208201819052918101829052606081018290526080810182905260a0810182905260c0810182905260e08101919091525f8087815260208990526040902060090154600160401b900460ff166001811115612b0657612b06615bf3565b14612b5d575f86815260208890526040908190206009015490517f23f8405d0000000000000000000000000000000000000000000000000000000081526106b7918891600160401b90910460ff16906004016162e0565b612b6787876127d6565b612ba0576040517f80e07e45000000000000000000000000000000000000000000000000000000008152600481018790526024016106b7565b5f868152602088905260408120604080516101e0810182528254815260018084015460208301526002840154928201929092526003830154606082015260048301546080820152600583015460a0820152600683015460c0820152600783015460e082015260088301546001600160a01b038116610100830152600160a01b900467ffffffffffffffff9081166101208301526009840154908116610140830152909291610160840191600160401b900460ff1690811115612c6457612c64615bf3565b6001811115612c7557612c75615bf3565b815260099190910154600160481b810460ff90811660208401526a010000000000000000000082041615156040808401919091526b01000000000000000000000090910467ffffffffffffffff1660609092019190915281015160808201519192505f91612ce39190613fb4565b90505f8087806020019051810190612cfb91906163f2565b9092509050612d2b89612d0f8560016162f4565b60608701516080880151612d249060016162f4565b868661405d565b505060408051610100810182525f80825260208201819052918101829052606081018290526080810182905260a0810182905260c0810182905260e081018290525f612d8b855f0151866020015187604001518d888a610180015161437b565b9050612d9681614483565b5f81815260208e90526040902060080154909350600160a01b900467ffffffffffffffff16612dcc57612dc98c8261367b565b91505b5060408051610100810182525f80825260208201819052918101829052606081018290526080810182905260a0810182905260c0810182905260e08101919091525f612e2c865f01518c8789606001518a608001518b610180015161437b565b9050612e388d8261367b565b915050612e6483825f01518e5f015f8f81526020019081526020015f2061451a9092919063ffffffff16565b919b909a509098509650505050505050565b5f8082600201548360040154612e8c9190616170565b9050805f0361104957612e9e836128d6565b60405162a7b02b60e01b81526004016106b791815260200190565b5f80612ed08585612eca8888613f29565b86613cf4565b91509150935093915050565b60408051606080820183525f8083526020830152918101919091525f80612f0f612f096020890189615d24565b85611c8c565b6002811115612f2057612f20615bf3565b0361323457602085015185515f03612f64576040517fe96bc61a00000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b8551606088013514612fb25785516040517f5b177a3c0000000000000000000000000000000000000000000000000000000081526004810191909152606088013560248201526044016106b7565b8560400151612fed576040517fc169243600000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b8560600151613028576040517fb45d1c3a00000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b61303560a0880188615d3d565b90505f0361305657604051630c9ccac560e41b815260040160405180910390fd5b5f61306460a0890189615d3d565b8101906130719190615fe5565b509091505f9050876080015160200151600281111561309257613092615bf3565b036130c9576040517f46365e5200000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b5f8760a001516020015160028111156130e4576130e4615bf3565b0361311b576040517f8999857d00000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b5f866001600160a01b031663c39619c46131388a6080015161459a565b6040518263ffffffff1660e01b81526004016131549190616452565b602060405180830381865afa15801561316f573d5f803e3d5ffd5b505050506040513d601f19601f82011682018060405250810190613193919061637f565b90505f876001600160a01b031663c39619c46131b28b60a0015161459a565b6040518263ffffffff1660e01b81526004016131ce9190616452565b602060405180830381865afa1580156131e9573d5f803e3d5ffd5b505050506040513d601f19601f8201168201806040525081019061320d919061637f565b604080516060810182529384526020840191909152820192909252935090915061243a9050565b613242878760600135612135565b61327e576040517fff6d9bd7000000000000000000000000000000000000000000000000000000008152606087013560048201526024016106b7565b60608601355f9081526020889052604081209061329a82612361565b90505f6009830154600160401b900460ff1660018111156132bd576132bd615bf3565b146132f4576040517f12459ffd00000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b600982015461330d90600160481b900460ff16866145d4565b60ff1661331d60208a018a615d24565b60ff161461337f576133326020890189615d24565b60098301546040517fac9e611600000000000000000000000000000000000000000000000000000000815260ff9283166004820152600160481b90910490911660248201526044016106b7565b61338c60a0890189615d3d565b90505f036133ad57604051630c9ccac560e41b815260040160405180910390fd5b5f808080806133bf60a08e018e615d3d565b8101906133cc919061647f565b945094509450945094506133ea876001015486896002015486613d89565b6133fe876003015485896004015485613d89565b60405180606001604052808681526020018581526020018281525086985098505050505050505061243a565b604080515f80825260208201909252819061344f9061344a9087516145f5565b61462a565b905061345a83611ee2565b61347a57604051633abfb6ff60e21b8152600481018490526024016106b7565b828460400135146134c457604080517fdfcc62bc000000000000000000000000000000000000000000000000000000008152908501356004820152602481018490526044016106b7565b6134e08460200135866020015186604001358860400151613d89565b6134ed6080850185615d3d565b90505f03613527576040517f342a075200000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b5f806135366080870187615d3d565b8101906135439190616514565b90925090506135618360016020890135612d2460408b0135836162f4565b509095945050505050565b604080516101e0810182525f80825260208201819052918101829052606081018290526080810182905260a0810182905260c0810182905260e08101829052610100810182905261012081018290526101408101829052610160810182905261018081018290526101a081018290526101c081019190915261212b84845f602086018035906040880135906060890135903390613609908b615d24565b6147ba565b61018081015181516040808401516020808601516080870151845160f89790971b6001600160f81b031916878401526021870195909552604186019290925260618501919091526081808501939093528151808503909301835260a1909301905280519101205f90611049565b60408051610100810182525f80825260208201819052918101829052606081018290526080810182905260a0810182905260c0810182905260e08101829052906136c483614483565b5f81815260208690526040902060080154909150600160a01b900467ffffffffffffffff1615613723576040517fbcedf3de000000000000000000000000000000000000000000000000000000008152600481018290526024016106b7565b5f81815260208581526040918290208551815590850151600180830191909155918501516002820155606085015160038201556080850151600482015560a0850151600582015560c0850151600682015560e0850151600782015561010085015160088201805461012088015167ffffffffffffffff908116600160a01b027fffffffff000000000000000000000000000000000000000000000000000000009092166001600160a01b03909416939093171790556101408601516009830180549190921667ffffffffffffffff19821681178355610160880151889590939268ffffffffffffffffff191690911790600160401b90849081111561382a5761382a615bf3565b02179055506101808281015160099290920180546101a08501516101c09095015167ffffffffffffffff166b0100000000000000000000000272ffffffffffffffff0000000000000000000000199515156a0100000000000000000000026aff000000000000000000001960ff909616600160481b02959095167fffffffffffffffffffffffffffffffffffffffffff0000ffffffffffffffffff909216919091179390931793909316919091179091558301518351604080860151602080880151608089015184516001600160f81b031960f89890981b97909716878401526021870195909552604186019290925260618501919091526081808501939093528151808503909301835260a1909301905280519101205f905f8181526001870160205260408120549192508190036139a0576040516815539492559053115160ba1b602082015260290160408051601f1981840301815291815281516020928301205f85815260018a019093529120556139e7565b6040516815539492559053115160ba1b60208201526029016040516020818303038152906040528051906020012081036139e7575f82815260018701602052604090208390555b6040805161010081018252848152602080820185905287518284015260e088015160608301525f86815290899052919091206080820190613a2790612e76565b815261018087015160ff166020820152911515604083015260e090950151151560609091015250919392505050565b5f613aaa826040518060400160405280602081526020017f5361666545524332303a206c6f772d6c6576656c2063616c6c206661696c6564815250856001600160a01b03166149619092919063ffffffff16565b80519091501561235c5780806020019051810190613ac89190615d05565b61235c5760405162461bcd60e51b815260206004820152602a60248201527f5361666545524332303a204552433230206f7065726174696f6e20646964206e60448201527f6f7420737563636565640000000000000000000000000000000000000000000060648201526084016106b7565b5f828152602085905260409020600701548314613ba0575f82815260208590526040908190206007015490517fc2adc3e80000000000000000000000000000000000000000000000000000000081526106b7918591600401918252602082015260400190565b5f82815260208590526040808220548583529120613bbd90612361565b14613c22575f838152602085905260409020613bd890612361565b5f83815260208690526040908190205490517fe2e27f87000000000000000000000000000000000000000000000000000000008152600481019290925260248201526044016106b7565b5f82815260208590526040808220600990810154868452919092209091015460ff600160481b92839004811692613c5b920416836145d4565b60ff161461118c575f8381526020859052604090206009015483908390613c8c90600160481b900460ff16846145d4565b5f85815260208890526040908190206009015490517f7e726d150000000000000000000000000000000000000000000000000000000081526004810194909452602484019290925260ff9081166044840152600160481b9091041660648201526084016106b7565b5f805f613d028787866120be565b905067ffffffffffffffff8511613d195784613d23565b67ffffffffffffffff5b945080851115613d7c575050505f838152602085905260409020600901805472ffffffffffffffff000000000000000000000019166b01000000000000000000000067ffffffffffffffff851602179055600182611a77565b5f97909650945050505050565b5f613dbd828486604051602001613da291815260200190565b6040516020818303038152906040528051906020012061496f565b90508085146113225760405162461bcd60e51b815260206004820152601760248201527f496e76616c696420696e636c7573696f6e2070726f6f6600000000000000000060448201526064016106b7565b5f6009820154600160401b900460ff166001811115613e2f57613e2f615bf3565b14613e8057613e3d816128d6565b60098201546040517f23f8405d0000000000000000000000000000000000000000000000000000000081526106b79291600160401b900460ff16906004016162e0565b600901805467ffffffffffffffff431668ffffffffffffffffff1990911617600160401b179055565b5f818152602083905260408120613ebf90612361565b5f8181526002850160205260409020549091508015613f14576040517fdd7028f000000000000000000000000000000000000000000000000000000000815260048101849052602481018290526044016106b7565b505f9081526002909201602052604090912055565b5f80613f358484611f08565b5f848152602086905260409020600501549091501561212e575f8381526020859052604080822060058101548352818320600990810154600690920154845291909220015467ffffffffffffffff6b0100000000000000000000009283900481169290910416808210613fa85780613faa565b815b6118c090846162f4565b5f6002613fc18484616170565b1015614003576040517f9029859400000000000000000000000000000000000000000000000000000000815260048101849052602481018390526044016106b7565b61400d8383616170565b6002036140265761401f8360016162f4565b9050611049565b5f83614033600185616170565b1890505f61404082614a22565b90505f19811b80614052600187616170565b169695505050505050565b5f85116140ac5760405162461bcd60e51b815260206004820152601460248201527f5072652d73697a652063616e6e6f74206265203000000000000000000000000060448201526064016106b7565b856140b68361462a565b146141035760405162461bcd60e51b815260206004820152601b60248201527f50726520657870616e73696f6e20726f6f74206d69736d61746368000000000060448201526064016106b7565b8461410d83614b5c565b146141805760405162461bcd60e51b815260206004820152602160248201527f5072652073697a6520646f6573206e6f74206d6174636820657870616e73696f60448201527f6e0000000000000000000000000000000000000000000000000000000000000060648201526084016106b7565b8285106141cf5760405162461bcd60e51b815260206004820181905260248201527f5072652073697a65206e6f74206c657373207468616e20706f73742073697a6560448201526064016106b7565b5f8590505f806141e1855f8751614bab565b90505b858310156142a3575f6141f78488614d1f565b9050845183106142495760405162461bcd60e51b815260206004820152601260248201527f496e646578206f7574206f662072616e6765000000000000000000000000000060448201526064016106b7565b61426d82828786815181106142605761426061611c565b6020026020010151614e06565b91506001811b61427d81866162f4565b94508785111561428f5761428f61656a565b836142998161657e565b94505050506141e4565b866142ad8261462a565b146143205760405162461bcd60e51b815260206004820152602260248201527f506f737420657870616e73696f6e20726f6f74206e6f7420657175616c20706f60448201527f737400000000000000000000000000000000000000000000000000000000000060648201526084016106b7565b835182146143705760405162461bcd60e51b815260206004820152601660248201527f496e636f6d706c6574652070726f6f662075736167650000000000000000000060448201526064016106b7565b505050505050505050565b604080516101e0810182525f80825260208201819052918101829052606081018290526080810182905260a0810182905260c0810182905260e08101829052610100810182905261012081018290526101408101829052610160810182905261018081018290526101a081018290526101c0810191909152614400878787878761536e565b50604080516101e081018252968752602087019590955293850192909252606084015260808301525f60a0830181905260c0830181905260e08301819052610100830181905267ffffffffffffffff43166101208401526101408301819052610160830181905260ff9091166101808301526101a082018190526101c082015290565b610180810151815160408084015160208086015160808701516060880151855160f89890981b6001600160f81b031916888501526021880196909652604187019390935260618601526081808601929092528251808603909201825260a18501835281519181019190912060c185015260e18085019390935281518085039093018352610101909301905280519101205f90611049565b600583015415158061452f5750600683015415155b1561458a5761453d836128d6565b600584015460068501546040517f8b0e71d00000000000000000000000000000000000000000000000000000000081526004810193909352602483019190915260448201526064016106b7565b6005830191909155600690910155565b6145a26156c6565b6040518060400160405280835f01518152602001836020015160028111156145cc576145cc615bf3565b905292915050565b5f806145e1846001616144565b90506145ed8184611c8c565b509392505050565b606061212e835f8460405160200161460f91815260200190565b60405160208183030381529060405280519060200120614e06565b5f8082511161467b5760405162461bcd60e51b815260206004820152601660248201527f456d707479206d65726b6c6520657870616e73696f6e0000000000000000000060448201526064016106b7565b6040825111156146cd5760405162461bcd60e51b815260206004820152601a60248201527f4d65726b6c6520657870616e73696f6e20746f6f206c6172676500000000000060448201526064016106b7565b5f805b83518110156147b3575f8482815181106146ec576146ec61611c565b60200260200101519050825f801b0361475657801561475157809250600185516147169190616170565b8214614751576040516147389084905f90602001918252602082015260400190565b6040516020818303038152906040528051906020012092505b6147aa565b8015614775576040805160208101839052908101849052606001614738565b6040516147919084905f90602001918252602082015260400190565b6040516020818303038152906040528051906020012092505b506001016146d0565b5092915050565b604080516101e0810182525f80825260208201819052918101829052606081018290526080810182905260a0810182905260c0810182905260e08101829052610100810182905261012081018290526101408101829052610160810182905261018081018290526101a081018290526101c08101919091526001600160a01b038316614872576040517ff289e65700000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b5f8490036148ac576040517f6932bcfd00000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b6148b9898989898961536e565b604051806101e001604052808a81526020018981526020018881526020018781526020018681526020015f801b81526020015f801b8152602001858152602001846001600160a01b031681526020014367ffffffffffffffff1681526020015f67ffffffffffffffff1681526020015f600181111561493a5761493a615bf3565b815260ff841660208201525f60408201819052606090910152905098975050505050505050565b606061212b84845f8561545f565b82515f906101008111156149ba576040517ffdac331e0000000000000000000000000000000000000000000000000000000081526004810182905261010060248201526044016106b7565b825f5b82811015614a18575f8782815181106149d8576149d861611c565b60200260200101519050816001901b87165f03614a0157825f528060205260405f209250614a0f565b805f528260205260405f2092505b506001016149bd565b5095945050505050565b5f815f03614a725760405162461bcd60e51b815260206004820152601c60248201527f5a65726f20686173206e6f207369676e69666963616e7420626974730000000060448201526064016106b7565b7001000000000000000000000000000000008210614a9d57608091821c91614a9a90826162f4565b90505b600160401b8210614abb57604091821c91614ab890826162f4565b90505b6401000000008210614ada57602091821c91614ad790826162f4565b90505b620100008210614af757601091821c91614af490826162f4565b90505b6101008210614b1357600891821c91614b1090826162f4565b90505b60108210614b2e57600491821c91614b2b90826162f4565b90505b60048210614b4957600291821c91614b4690826162f4565b90505b600282106110e6576110496001826162f4565b5f80805b83518110156147b357838181518110614b7b57614b7b61611c565b60200260200101515f801b14614ba357614b96816002616676565b614ba090836162f4565b91505b600101614b60565b6060818310614bfc5760405162461bcd60e51b815260206004820152601760248201527f5374617274206e6f74206c657373207468616e20656e6400000000000000000060448201526064016106b7565b8351821115614c735760405162461bcd60e51b815260206004820152602160248201527f456e64206e6f74206c657373206f7220657175616c207468616e206c656e677460448201527f680000000000000000000000000000000000000000000000000000000000000060648201526084016106b7565b5f614c7e8484616170565b67ffffffffffffffff811115614c9657614c96615d9e565b604051908082528060200260200182016040528015614cbf578160200160208202803683370190505b509050835b83811015614d1657858181518110614cde57614cde61611c565b6020026020010151828683614cf39190616170565b81518110614d0357614d0361611c565b6020908102919091010152600101614cc4565b50949350505050565b5f818310614d6f5760405162461bcd60e51b815260206004820152601760248201527f5374617274206e6f74206c657373207468616e20656e6400000000000000000060448201526064016106b7565b5f614d7b838518614a22565b90505f6001614d8a83826162f4565b6001901b614d989190616170565b90508481168482168115614daf5761209f82615598565b8015614dbe5761209f81614a22565b60405162461bcd60e51b815260206004820152601b60248201527f426f7468207920616e64207a2063616e6e6f74206265207a65726f000000000060448201526064016106b7565b606060408310614e585760405162461bcd60e51b815260206004820152600e60248201527f4c6576656c20746f6f206869676800000000000000000000000000000000000060448201526064016106b7565b5f829003614ea85760405162461bcd60e51b815260206004820152601b60248201527f43616e6e6f7420617070656e6420656d7074792073756274726565000000000060448201526064016106b7565b604084511115614efa5760405162461bcd60e51b815260206004820152601a60248201527f4d65726b6c6520657870616e73696f6e20746f6f206c6172676500000000000060448201526064016106b7565b83515f03614f77575f614f0e8460016162f4565b67ffffffffffffffff811115614f2657614f26615d9e565b604051908082528060200260200182016040528015614f4f578160200160208202803683370190505b50905082818581518110614f6557614f6561611c565b6020908102919091010152905061212e565b83518310614fed5760405162461bcd60e51b815260206004820152603560248201527f4c6576656c2067726561746572207468616e2068696768657374206c6576656c60448201527f206f662063757272656e7420657870616e73696f6e000000000000000000000060648201526084016106b7565b815f614ff886614b5c565b90505f615006866002616676565b61501090836162f4565b90505f61501c83614a22565b61502583614a22565b1161507357875167ffffffffffffffff81111561504457615044615d9e565b60405190808252806020026020018201604052801561506d578160200160208202803683370190505b506150c3565b87516150809060016162f4565b67ffffffffffffffff81111561509857615098615d9e565b6040519080825280602002602001820160405280156150c1578160200160208202803683370190505b505b90506040815111156151175760405162461bcd60e51b815260206004820152601c60248201527f417070656e642063726561746573206f76657273697a6520747265650000000060448201526064016106b7565b5f5b88518110156152c357878110156151bf5788818151811061513c5761513c61611c565b60200260200101515f801b146151ba5760405162461bcd60e51b815260206004820152602260248201527f417070656e642061626f7665206c65617374207369676e69666963616e74206260448201527f697400000000000000000000000000000000000000000000000000000000000060648201526084016106b7565b6152bb565b5f859003615204578881815181106151d9576151d961611c565b60200260200101518282815181106151f3576151f361611c565b6020026020010181815250506152bb565b8881815181106152165761521661611c565b60200260200101515f801b0361524c57848282815181106152395761523961611c565b60209081029190910101525f94506152bb565b5f801b8282815181106152615761526161611c565b60200260200101818152505088818151811061527f5761527f61611c565b6020026020010151856040516020016152a2929190918252602082015260400190565b6040516020818303038152906040528051906020012094505b600101615119565b5083156152f7578381600183516152da9190616170565b815181106152ea576152ea61611c565b6020026020010181815250505b80600182516153069190616170565b815181106153165761531661611c565b60200260200101515f801b0361056c5760405162461bcd60e51b815260206004820152600f60248201527f4c61737420656e747279207a65726f000000000000000000000000000000000060448201526064016106b7565b5f8590036153a8576040517f8d79dbbc00000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b8281116153eb576040517f2060faf400000000000000000000000000000000000000000000000000000000815260048101849052602481018290526044016106b7565b5f849003615425576040517f83c683e400000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b5f829003611322576040517f5cb6e5bb00000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b6060824710156154d75760405162461bcd60e51b815260206004820152602660248201527f416464726573733a20696e73756666696369656e742062616c616e636520666f60448201527f722063616c6c000000000000000000000000000000000000000000000000000060648201526084016106b7565b6001600160a01b0385163b61552e5760405162461bcd60e51b815260206004820152601d60248201527f416464726573733a2063616c6c20746f206e6f6e2d636f6e747261637400000060448201526064016106b7565b5f80866001600160a01b031685876040516155499190616681565b5f6040518083038185875af1925050503d805f8114615583576040519150601f19603f3d011682016040523d82523d5f602084013e615588565b606091505b509150915061056c828286615603565b5f8082116155e85760405162461bcd60e51b815260206004820152601c60248201527f5a65726f20686173206e6f207369676e69666963616e7420626974730000000060448201526064016106b7565b5f82806155f6600182616170565b1618905061212e81614a22565b6060831561561257508161212e565b8251156156225782518084602001fd5b8160405162461bcd60e51b81526004016106b79190616697565b6040805160c0810182525f8082526020820181905291810182905260608101919091526080810161566b6156e4565b81526020016156786156e4565b905290565b828054828255905f5260205f209081019282156156b6579160200282015b828111156156b657823582559160200191906001019061569b565b506156c2929150615709565b5090565b60405180604001604052806156d961571d565b81526020015f905290565b60405180606001604052806156f761571d565b81526020015f81525f60209091015290565b5b808211156156c2575f815560010161570a565b6040518060400160405280615730615739565b81526020016156785b60405180604001604052806002906020820280368337509192915050565b803560ff811681146110e6575f80fd5b5f805f805f8060c0878903121561577c575f80fd5b61578587615757565b9860208801359850604088013597606081013597506080810135965060a00135945092505050565b5f602082840312156157bd575f80fd5b813567ffffffffffffffff8111156157d3575f80fd5b820160c0818503121561212e575f80fd5b6001600160a01b03811681146157f8575f80fd5b50565b67ffffffffffffffff811681146157f8575f80fd5b5f8083601f840112615820575f80fd5b50813567ffffffffffffffff811115615837575f80fd5b6020830191508360208260051b8501011115615851575f80fd5b9250929050565b5f805f805f805f805f805f6101408c8e031215615873575f80fd5b8b3561587e816157e4565b9a5060208c013561588e816157fb565b995060408c013561589e816157e4565b985060608c0135975060808c0135965060a08c0135955060c08c01356158c3816157e4565b945060e08c01356158d3816157e4565b93506158e26101008d01615757565b92506101208c013567ffffffffffffffff8111156158fe575f80fd5b61590a8e828f01615810565b915080935050809150509295989b509295989b9093969950565b5f60208284031215615934575f80fd5b5035919050565b600381106157f8575f80fd5b80356110e68161593b565b5f60208284031215615962575f80fd5b813561212e8161593b565b5f805f6040848603121561597f575f80fd5b833567ffffffffffffffff811115615995575f80fd5b6159a186828701615810565b909790965060209590950135949350505050565b5f80604083850312156159c6575f80fd5b82356159d1816157e4565b946020939093013593505050565b5f805f606084860312156159f1575f80fd5b505081359360208301359350604090920135919050565b5f805f805f805f878903610120811215615a20575f80fd5b88359750602089013567ffffffffffffffff80821115615a3e575f80fd5b908a01906040828d031215615a51575f80fd5b81985060a07fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc084011215615a83575f80fd5b60408b01975060e08b0135925080831115615a9c575f80fd5b615aa88c848d01615810565b90975095506101008b0135925086915080831115615ac4575f80fd5b5050615ad28a828b01615810565b989b979a50959850939692959293505050565b5f80828403610120811215615af8575f80fd5b83359250610100601f1982011215615b0e575f80fd5b506020830190509250929050565b5f805f805f60a08688031215615b30575f80fd5b615b3986615757565b97602087013597506040870135966060810135965060800135945092505050565b5f805f8060608587031215615b6d575f80fd5b8435935060208501359250604085013567ffffffffffffffff80821115615b92575f80fd5b818701915087601f830112615ba5575f80fd5b813581811115615bb3575f80fd5b886020828501011115615bc4575f80fd5b95989497505060200194505050565b5f8060408385031215615be4575f80fd5b50508035926020909101359150565b634e487b7160e01b5f52602160045260245ffd5b60028110615c1757615c17615bf3565b9052565b5f6101e082019050825182526020830151602083015260408301516040830152606083015160608301526080830151608083015260a083015160a083015260c083015160c083015260e083015160e083015261010080840151615c88828501826001600160a01b03169052565b50506101208381015167ffffffffffffffff81168483015250506101408381015167ffffffffffffffff811684830152505061016080840151615ccd82850182615c07565b50506101808381015160ff16908301526101a0808401511515908301526101c08084015167ffffffffffffffff8116828501526120b6565b5f60208284031215615d15575f80fd5b8151801515811461212e575f80fd5b5f60208284031215615d34575f80fd5b61212e82615757565b5f8083357fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe1843603018112615d70575f80fd5b83018035915067ffffffffffffffff821115615d8a575f80fd5b602001915036819003821315615851575f80fd5b634e487b7160e01b5f52604160045260245ffd5b6040516060810167ffffffffffffffff81118282101715615dd557615dd5615d9e565b60405290565b6040805190810167ffffffffffffffff81118282101715615dd557615dd5615d9e565b604051601f8201601f1916810167ffffffffffffffff81118282101715615e2757615e27615d9e565b604052919050565b5f67ffffffffffffffff821115615e4857615e48615d9e565b5060051b60200190565b5f82601f830112615e61575f80fd5b81356020615e76615e7183615e2f565b615dfe565b8083825260208201915060208460051b870101935086841115615e97575f80fd5b602086015b84811015615eb35780358352918301918301615e9c565b509695505050505050565b5f82601f830112615ecd575f80fd5b615ed5615ddb565b806040840185811115615ee6575f80fd5b845b81811015613561578035615efb816157fb565b845260209384019301615ee8565b5f818303610100811215615f1b575f80fd5b615f23615db2565b915060c0811215615f32575f80fd5b615f3a615db2565b6080821215615f47575f80fd5b615f4f615ddb565b915084601f850112615f5f575f80fd5b615f67615ddb565b806040860187811115615f78575f80fd5b865b81811015615f92578035845260209384019301615f7a565b50818552615fa08882615ebe565b6020860152505050818152615fb760808501615947565b602082015260a08401356040820152808352505060c0820135602082015260e0820135604082015292915050565b5f805f6102208486031215615ff8575f80fd5b833567ffffffffffffffff81111561600e575f80fd5b61601a86828701615e52565b93505061602a8560208601615f09565b915061603a856101208601615f09565b90509250925092565b8051825f5b6002811015616067578251825260209283019290910190600101616048565b505050602080820151604084015f5b600281101561609d57825167ffffffffffffffff1682529183019190830190600101616076565b505050505050565b600381106157f8576157f8615bf3565b5f610120820190508582526160ce602083018651616043565b60208501516160dc816160a5565b60a08301526040949094015160c082015260e081019290925261010090910152919050565b5f60208284031215616111575f80fd5b815161212e816157fb565b634e487b7160e01b5f52603260045260245ffd5b634e487b7160e01b5f52601160045260245ffd5b60ff818116838216019081111561104957611049616130565b6020810161616a836160a5565b91905290565b8181038181111561104957611049616130565b5f60c082019050838252823560208301526020830135604083015260408301356161ac816157e4565b6001600160a01b03811660608401525060608301356161ca816157fb565b67ffffffffffffffff8082166080850152608085013591506161eb826157fb565b80821660a085015250509392505050565b5f6020828403121561620c575f80fd5b813561212e816157fb565b5f60208284031215616227575f80fd5b815161212e816157e4565b848152610120810160206040868285013760608301604087015f5b600281101561627d578135616261816157fb565b67ffffffffffffffff168352918301919083019060010161624d565b50505050608085013561628f8161593b565b616298816160a5565b8060a08401525060a085013560c08301528360e08301528261010083015295945050505050565b67ffffffffffffffff8281168282160390808211156147b3576147b3616130565b8281526040810161212e6020830184615c07565b8082018082111561104957611049616130565b808202811582820484141761104957611049616130565b855181526001600160a01b0360208701511660208201526040860151604082015284606082015283608082015260c060a08201528160c0820152818360e08301375f81830160e090810191909152601f909201601f19160101949350505050565b5f6020828403121561638f575f80fd5b5051919050565b5f82601f8301126163a5575f80fd5b815160206163b5615e7183615e2f565b8083825260208201915060208460051b8701019350868411156163d6575f80fd5b602086015b84811015615eb357805183529183019183016163db565b5f8060408385031215616403575f80fd5b825167ffffffffffffffff8082111561641a575f80fd5b61642686838701616396565b9350602085015191508082111561643b575f80fd5b5061644885828601616396565b9150509250929050565b5f60a082019050616464828451616043565b6020830151616472816160a5565b8060808401525092915050565b5f805f805f60a08688031215616493575f80fd5b8535945060208601359350604086013567ffffffffffffffff808211156164b8575f80fd5b6164c489838a01615e52565b945060608801359150808211156164d9575f80fd5b6164e589838a01615e52565b935060808801359150808211156164fa575f80fd5b5061650788828901615e52565b9150509295509295909350565b5f8060408385031215616525575f80fd5b823567ffffffffffffffff8082111561653c575f80fd5b61654886838701615e52565b9350602085013591508082111561655d575f80fd5b5061644885828601615e52565b634e487b7160e01b5f52600160045260245ffd5b5f5f19820361658f5761658f616130565b5060010190565b600181815b808511156165d057815f19048211156165b6576165b6616130565b808516156165c357918102915b93841c939080029061659b565b509250929050565b5f826165e657506001611049565b816165f257505f611049565b816001811461660857600281146166125761662e565b6001915050611049565b60ff84111561662357616623616130565b50506001821b611049565b5060208310610133831016604e8410600b8410161715616651575081810a611049565b61665b8383616596565b805f190482111561666e5761666e616130565b029392505050565b5f61212e83836165d8565b5f82518060208501845e5f920191825250919050565b602081525f82518060208401528060208501604085015e5f604082850101526040601f19601f8301168401019150509291505056fea2646970667358221220240de4a00f4b4dbe239023d97f9eb59c9ae61e457f231a82c1f1892dbd1a3cfb64736f6c63430008190033
    /// ```
    #[rustfmt::skip]
    #[allow(clippy::all)]
    pub static DEPLOYED_BYTECODE: alloy_sol_types::private::Bytes = alloy_sol_types::private::Bytes::from_static(
        b"`\x80`@R4\x80\x15a\0\x0FW_\x80\xFD[P`\x046\x10a\x01\xE6W_5`\xE0\x1C\x80ce[B\xF3\x11a\x01\tW\x80c\xC3-\x8Cc\x11a\0\x9EW\x80c\xEA\xE02\x8B\x11a\0nW\x80c\xEA\xE02\x8B\x14a\x04\xA6W\x80c\xED\xAA\xB5J\x14a\x04\xB9W\x80c\xF8\xEEw\xD6\x14a\x04\xCCW\x80c\xFD\xA2\x89.\x14a\x04\xD5W_\x80\xFD[\x80c\xC3-\x8Cc\x14a\x049W\x80c\xC8\xBCNC\x14a\x04LW\x80c\xE5\xB1#\xDA\x14a\x04tW\x80c\xE9N\x05\x1E\x14a\x04\x93W_\x80\xFD[\x80c\x8C\x1B:@\x11a\0\xD9W\x80c\x8C\x1B:@\x14a\x03\xE1W\x80c\x90\x85\x17\xE9\x14a\x03\xF4W\x80c\xB2\xA1@\x8E\x14a\x04\x07W\x80c\xBC\xE6\xF5O\x14a\x04\x1AW_\x80\xFD[\x80ce[B\xF3\x14a\x03pW\x80ct\x89&\xF3\x14a\x03\xA8W\x80cu\x0E\x0C\x0F\x14a\x03\xBBW\x80c\x88&\xA3p\x14a\x03\xCEW_\x80\xFD[\x80cC+\xB7\x8A\x11a\x01\x7FW\x80cQ\xEDj0\x11a\x01OW\x80cQ\xEDj0\x14a\x03\x08W\x80cT\xB6AQ\x14a\x03\x1BW\x80cZH\xE0\xF4\x14a\x03>W\x80c]\x9E$D\x14a\x03QW_\x80\xFD[\x80cC+\xB7\x8A\x14a\x02\x83W\x80cF\xC2x\x1A\x14a\x02\x96W\x80cH\x92;\xC5\x14a\x02\xC3W\x80cH\xDD)$\x14a\x02\xEEW_\x80\xFD[\x80c\x1D\xCEQf\x11a\x01\xBAW\x80c\x1D\xCEQf\x14a\x02KW\x80c>5\xF5\xE8\x14a\x02TW\x80cAnfW\x14a\x02gW\x80cB\xE1\xAA\xA8\x14a\x02pW_\x80\xFD[\x80bM\x8E\xFE\x14a\x01\xEAW\x80c\x05\xFA\xE1A\x14a\x02\x10W\x80c\x1Ar\xD5L\x14a\x02#W\x80c\x1C\x1BO:\x14a\x028W[_\x80\xFD[a\x01\xFDa\x01\xF86`\x04aWgV[a\x04\xF5V[`@Q\x90\x81R` \x01[`@Q\x80\x91\x03\x90\xF3[a\x01\xFDa\x02\x1E6`\x04aW\xADV[a\x05wV[a\x026a\x0216`\x04aXXV[a\x0B\xB1V[\0[a\x01\xFDa\x02F6`\x04aY$V[a\x10\x1EV[a\x01\xFD`\nT\x81V[a\x01\xFDa\x02b6`\x04aY$V[a\x10=V[a\x01\xFD`\x0BT\x81V[a\x01\xFDa\x02~6`\x04aYRV[a\x10OV[a\x026a\x02\x916`\x04aYmV[a\x10\xEBV[`\x08Ta\x02\xAA\x90g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x81V[`@Qg\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x90\x91\x16\x81R` \x01a\x02\x07V[`\tTa\x02\xD6\x90`\x01`\x01`\xA0\x1B\x03\x16\x81V[`@Q`\x01`\x01`\xA0\x1B\x03\x90\x91\x16\x81R` \x01a\x02\x07V[`\x08Ta\x02\xD6\x90`\x01`@\x1B\x90\x04`\x01`\x01`\xA0\x1B\x03\x16\x81V[`\x06Ta\x02\xD6\x90`\x01`\x01`\xA0\x1B\x03\x16\x81V[a\x03.a\x03)6`\x04aY$V[a\x11\x92V[`@Q\x90\x15\x15\x81R` \x01a\x02\x07V[a\x01\xFDa\x03L6`\x04aY$V[a\x11\x9EV[`\rTa\x03^\x90`\xFF\x16\x81V[`@Q`\xFF\x90\x91\x16\x81R` \x01a\x02\x07V[a\x03.a\x03~6`\x04aY\xB5V[`\x01`\x01`\xA0\x1B\x03\x91\x90\x91\x16_\x90\x81R`\x04` \x90\x81R`@\x80\x83 \x93\x83R\x92\x90R T`\xFF\x16\x90V[a\x026a\x03\xB66`\x04aY$V[a\x11\xAAV[a\x03.a\x03\xC96`\x04aY$V[a\x12\x99V[a\x026a\x03\xDC6`\x04aY\xDFV[a\x12\xC2V[a\x026a\x03\xEF6`\x04aZ\x08V[a\x13)V[a\x03.a\x04\x026`\x04aY$V[a\x14\xE8V[a\x026a\x04\x156`\x04aZ\xE5V[a\x14\xF4V[a\x01\xFDa\x04(6`\x04aY$V[_\x90\x81R`\x02` R`@\x90 T\x90V[a\x01\xFDa\x04G6`\x04a[\x1CV[a\x18mV[a\x04_a\x04Z6`\x04a[ZV[a\x18\xCAV[`@\x80Q\x92\x83R` \x83\x01\x91\x90\x91R\x01a\x02\x07V[a\x01\xFDa\x04\x826`\x04aY$V[_\x90\x81R`\x03` R`@\x90 T\x90V[`\x05Ta\x02\xD6\x90`\x01`\x01`\xA0\x1B\x03\x16\x81V[a\x01\xFDa\x04\xB46`\x04aY$V[a\x1A\x80V[a\x026a\x04\xC76`\x04a[\xD3V[a\x1A\x94V[a\x01\xFD`\x0CT\x81V[a\x04\xE8a\x04\xE36`\x04aY$V[a\x1A\xECV[`@Qa\x02\x07\x91\x90a\\\x1BV[`@\x80Q`\xF8\x88\x90\x1B`\x01`\x01`\xF8\x1B\x03\x19\x16` \x80\x83\x01\x91\x90\x91R`!\x82\x01\x88\x90R`A\x82\x01\x87\x90R`a\x82\x01\x86\x90R`\x81\x80\x83\x01\x86\x90R\x83Q\x80\x84\x03\x90\x91\x01\x81R`\xA1\x83\x01\x84R\x80Q\x90\x82\x01 `\xC1\x83\x01R`\xE1\x80\x83\x01\x85\x90R\x83Q\x80\x84\x03\x90\x91\x01\x81Ra\x01\x01\x90\x92\x01\x90\x92R\x80Q\x91\x01 _\x90[\x97\x96PPPPPPPV[_\x80`\x08\x80T\x90a\x01\0\n\x90\x04`\x01`\x01`\xA0\x1B\x03\x16`\x01`\x01`\xA0\x1B\x03\x16c\x12\xAB=;`@Q\x81c\xFF\xFF\xFF\xFF\x16`\xE0\x1B\x81R`\x04\x01` `@Q\x80\x83\x03\x81\x86Z\xFA\x15\x80\x15a\x05\xC8W=_\x80>=_\xFD[PPPP`@Q=`\x1F\x19`\x1F\x82\x01\x16\x82\x01\x80`@RP\x81\x01\x90a\x05\xEC\x91\x90a]\x05V[\x15\x90P\x80\x80\x15a\x06\x82WP`\x08T`@Q\x7F\xFA\xCDt;\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R3`\x04\x82\x01R`\x01`@\x1B\x90\x91\x04`\x01`\x01`\xA0\x1B\x03\x16\x90c\xFA\xCDt;\x90`$\x01` `@Q\x80\x83\x03\x81\x86Z\xFA\x15\x80\x15a\x06\\W=_\x80>=_\xFD[PPPP`@Q=`\x1F\x19`\x1F\x82\x01\x16\x82\x01\x80`@RP\x81\x01\x90a\x06\x80\x91\x90a]\x05V[\x15[\x15a\x06\xC0W`@Q\x7F\xED=\xB8\xAC\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R3`\x04\x82\x01R`$\x01[`@Q\x80\x91\x03\x90\xFD[`@\x80Qa\x01\0\x81\x01\x82R_\x80\x82R` \x82\x01\x81\x90R\x91\x81\x01\x82\x90R``\x81\x01\x82\x90R`\x80\x81\x01\x82\x90R`\xA0\x81\x01\x82\x90R`\xC0\x81\x01\x82\x90R`\xE0\x81\x01\x91\x90\x91R_a\x07\x1Ca\x07\x11` \x87\x01\x87a]$V[`\rT`\xFF\x16a\x1C\x8CV[\x90P_a\x07(\x82a\x10OV[\x90Pa\x072aV<V[_\x83`\x02\x81\x11\x15a\x07EWa\x07Ea[\xF3V[\x03a\ndWa\x07W`\xA0\x88\x01\x88a]=V[\x90P_\x03a\x07xW`@Qc\x0C\x9C\xCA\xC5`\xE4\x1B\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[_\x80a\x07\x87`\xA0\x8A\x01\x8Aa]=V[\x81\x01\x90a\x07\x94\x91\x90a_\xE5V[\x92P\x92PP`\x08\x80T\x90a\x01\0\n\x90\x04`\x01`\x01`\xA0\x1B\x03\x16`\x01`\x01`\xA0\x1B\x03\x16c\xE5\x10\x19\xA6\x8A``\x015\x83_\x01Q\x84` \x01Q\x85`@\x01Q`@Q\x85c\xFF\xFF\xFF\xFF\x16`\xE0\x1B\x81R`\x04\x01a\x07\xED\x94\x93\x92\x91\x90a`\xB5V[_`@Q\x80\x83\x03\x81\x86\x80;\x15\x80\x15a\x08\x03W_\x80\xFD[PZ\xFA\x15\x80\x15a\x08\x15W=_\x80>=_\xFD[PP`\x08T` \x84\x81\x01Q\x86Q\x91\x87\x01Q`@\x80\x89\x01Q\x90Q\x7F\xE5\x10\x19\xA6\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x01`@\x1B\x90\x95\x04`\x01`\x01`\xA0\x1B\x03\x16\x96Pc\xE5\x10\x19\xA6\x95Pa\x08z\x94\x92\x93\x92`\x04\x01a`\xB5V[_`@Q\x80\x83\x03\x81\x86\x80;\x15\x80\x15a\x08\x90W_\x80\xFD[PZ\xFA\x15\x80\x15a\x08\xA2W=_\x80>=_\xFD[PPPP\x80_\x01Q`@\x01Q\x89` \x015\x14a\x08\xFFW\x80Q`@\x90\x81\x01Q\x90Q\x7F:c\xE9\x9A\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R` \x8B\x015`\x04\x82\x01R`$\x81\x01\x91\x90\x91R`D\x01a\x06\xB7V[`@\x80Q`\xC0\x81\x01\x82R``\x8B\x015\x80\x82R` \x84\x81\x01Q\x90\x83\x01R`\x08T\x83Q\x7F\xE51\xD8\xC7\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x81\x01\x92\x90\x92R\x91\x92\x83\x01\x91`\x01`@\x1B\x90\x04`\x01`\x01`\xA0\x1B\x03\x16\x90c\xE51\xD8\xC7\x90`$\x01` `@Q\x80\x83\x03\x81\x86Z\xFA\x15\x80\x15a\t\x85W=_\x80>=_\xFD[PPPP`@Q=`\x1F\x19`\x1F\x82\x01\x16\x82\x01\x80`@RP\x81\x01\x90a\t\xA9\x91\x90a]\x05V[\x15\x15\x81R`\x08T` \x84\x81\x01Q`@Q\x7FV\xBB\xC9\xE6\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x81\x01\x91\x90\x91R\x92\x01\x91_\x91`\x01`@\x1B\x90\x04`\x01`\x01`\xA0\x1B\x03\x16\x90cV\xBB\xC9\xE6\x90`$\x01` `@Q\x80\x83\x03\x81\x86Z\xFA\x15\x80\x15a\n\x1EW=_\x80>=_\xFD[PPPP`@Q=`\x1F\x19`\x1F\x82\x01\x16\x82\x01\x80`@RP\x81\x01\x90a\nB\x91\x90aa\x01V[g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x11\x81R\x92Q` \x84\x01R\x90Q`@\x90\x92\x01\x91\x90\x91R\x90P[`\tT`\rTa\n\x8C\x91`\x01\x91\x8A\x91\x85\x91`\x01`\x01`\xA0\x1B\x03\x90\x91\x16\x90\x87\x90`\xFF\x16\x8Ba\x1D\x11V[`\x06T\x90\x94P`\x01`\x01`\xA0\x1B\x03\x16_`\x07a\n\xAB` \x8B\x01\x8Ba]$V[`\xFF\x16\x81T\x81\x10a\n\xBEWa\n\xBEaa\x1CV[_\x91\x82R` \x90\x91 \x01T\x90P`\x01`\x01`\xA0\x1B\x03\x82\x16\x15\x80\x15\x90a\n\xE2WP\x80\x15\x15[\x15a\x0B\x1DW_\x86`\xC0\x01Qa\n\xF7W0a\x0B\x04V[`\x05T`\x01`\x01`\xA0\x1B\x03\x16[\x90Pa\x0B\x1B`\x01`\x01`\xA0\x1B\x03\x84\x163\x83\x85a\x1E1V[P[\x85`@\x01Q\x86` \x01Q\x87_\x01Q\x7F\xAAKf\xB1\xCE\x93\x8C\x06\xE2\xA3\xF8Fk\xAE\x10\xEFb\xE7Gc\x0E8Y\x88\x9FG\x19\xFCd'\xB5\xA4\x89``\x01Q\x8A`\x80\x01Q\x8B`\xA0\x01Q\x8C`\xC0\x01Q\x8D`\xE0\x01Q`@Qa\x0B\x9B\x95\x94\x93\x92\x91\x90\x94\x85R` \x85\x01\x93\x90\x93R`\xFF\x91\x90\x91\x16`@\x84\x01R\x15\x15``\x83\x01R\x15\x15`\x80\x82\x01R`\xA0\x01\x90V[`@Q\x80\x91\x03\x90\xA4PP\x92Q\x96\x95PPPPPPV[_Ta\x01\0\x90\x04`\xFF\x16\x15\x80\x80\x15a\x0B\xCFWP_T`\x01`\xFF\x90\x91\x16\x10[\x80a\x0B\xE8WP0;\x15\x80\x15a\x0B\xE8WP_T`\xFF\x16`\x01\x14[a\x0CZW`@QbF\x1B\xCD`\xE5\x1B\x81R` `\x04\x82\x01R`.`$\x82\x01R\x7FInitializable: contract is alrea`D\x82\x01R\x7Fdy initialized\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0`d\x82\x01R`\x84\x01a\x06\xB7V[_\x80T`\xFF\x19\x16`\x01\x17\x90U\x80\x15a\x0C{W_\x80Ta\xFF\0\x19\x16a\x01\0\x17\x90U[`\x01`\x01`\xA0\x1B\x03\x8C\x16a\x0C\xBBW`@Q\x7F\xC8>\x08b\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[`\x08\x80T`\x01`\x01`\xA0\x1B\x03\x80\x8F\x16`\x01`@\x1B\x02\x7F\xFF\xFF\xFF\xFF\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x90\x92\x16\x91\x90\x91\x17\x90\x91U\x8A\x16a\r3W`@Q\x7F\xFB`\xB0\xEF\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[`\t\x80Ts\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x19\x16`\x01`\x01`\xA0\x1B\x03\x8C\x16\x17\x90Ug\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x8B\x16_\x03a\r\x9EW`@Q\x7F\x8A\x0E\xED\xCC\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[`\x08\x80Tg\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x19\x16g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x8D\x16\x17\x90U`\x06\x80Ts\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x19\x16`\x01`\x01`\xA0\x1B\x03\x88\x81\x16\x91\x90\x91\x17\x90\x91U\x85\x16a\x0E W`@Q\x7F\x0F\x0E\xC8\xA8\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[`\x05\x80Ts\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x19\x16`\x01`\x01`\xA0\x1B\x03\x87\x16\x17\x90Ua\x0EQ\x89a\x1E\xE2V[a\x0EqW`@Qc:\xBF\xB6\xFF`\xE2\x1B\x81R`\x04\x81\x01\x8A\x90R`$\x01a\x06\xB7V[`\n\x89\x90Ua\x0E\x7F\x88a\x1E\xE2V[a\x0E\x9FW`@Qc:\xBF\xB6\xFF`\xE2\x1B\x81R`\x04\x81\x01\x89\x90R`$\x01a\x06\xB7V[`\x0B\x88\x90Ua\x0E\xAD\x87a\x1E\xE2V[a\x0E\xCDW`@Qc:\xBF\xB6\xFF`\xE2\x1B\x81R`\x04\x81\x01\x88\x90R`$\x01a\x06\xB7V[`\x0C\x87\x90U`\xFF\x84\x16_\x03a\x0F\x0EW`@Q\x7F\xA8c\xD6\xE4\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[`\xFD\x84`\xFF\x16\x11\x15a\x0FQW`@Q\x7F@\xD2;\xF0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\xFF\x85\x16`\x04\x82\x01R`$\x01a\x06\xB7V[`\r\x80T`\xFF\x19\x16`\xFF\x86\x16\x17\x90U\x81a\x0Fl\x85`\x02aaDV[`\xFF\x16\x14a\x0F\xBEW\x81a\x0F\x80\x85`\x02aaDV[`@Q\x7F\n\xEC\xE9\xC0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x81\x01\x92\x90\x92R`\xFF\x16`$\x82\x01R`D\x01a\x06\xB7V[a\x0F\xCA`\x07\x84\x84aV}V[P\x80\x15a\x10\x10W_\x80Ta\xFF\0\x19\x16\x90U`@Q`\x01\x81R\x7F\x7F&\xB8?\xF9n\x1F+jh/\x138R\xF6y\x8A\t\xC4e\xDA\x95\x92\x14`\xCE\xFB8G@$\x98\x90` \x01`@Q\x80\x91\x03\x90\xA1[PPPPPPPPPPPPV[`\x07\x81\x81T\x81\x10a\x10-W_\x80\xFD[_\x91\x82R` \x90\x91 \x01T\x90P\x81V[_a\x10I`\x01\x83a\x1F\x08V[\x92\x91PPV[_\x80\x82`\x02\x81\x11\x15a\x10cWa\x10ca[\xF3V[\x03a\x10pWPP`\nT\x90V[`\x01\x82`\x02\x81\x11\x15a\x10\x84Wa\x10\x84a[\xF3V[\x03a\x10\x91WPP`\x0BT\x90V[`\x02\x82`\x02\x81\x11\x15a\x10\xA5Wa\x10\xA5a[\xF3V[\x03a\x10\xB2WPP`\x0CT\x90V[\x81`@Q\x7F;\xF2\xE1\xEC\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01a\x06\xB7\x91\x90aa]V[\x91\x90PV[_\x82\x90\x03a\x11%W`@Q\x7FR\x12\x99\xA9\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[a\x11V\x83\x83a\x115`\x01\x82aapV[\x81\x81\x10a\x11DWa\x11Daa\x1CV[`\x01\x92` \x90\x91\x02\x015\x90P\x83a \xBEV[P_[\x82\x81\x10\x15a\x11\x8CWa\x11\x84\x84\x84\x83\x81\x81\x10a\x11vWa\x11vaa\x1CV[\x90P` \x02\x015_\x19a\x1A\x94V[`\x01\x01a\x11YV[PPPPV[_a\x10I`\x01\x83a!5V[_a\x10I`\x01\x83a!gV[_a\x11\xB6`\x01\x83a!\xB6V[\x90Pa\x11\xC1\x81a\"\tV[`\x06T`\t\x82\x01T`\x07\x80T`\x01`\x01`\xA0\x1B\x03\x90\x93\x16\x92_\x92`\x01`H\x1B\x90\x04`\xFF\x16\x90\x81\x10a\x11\xF4Wa\x11\xF4aa\x1CV[_\x91\x82R` \x90\x91 \x01T\x90P`\x01`\x01`\xA0\x1B\x03\x82\x16\x15\x80\x15\x90a\x12\x18WP\x80\x15\x15[\x15a\x129W`\x08\x83\x01Ta\x129\x90`\x01`\x01`\xA0\x1B\x03\x84\x81\x16\x91\x16\x83a#\x13V[_\x84\x81R`\x01` R`@\x90 a\x12O\x90a#aV[`@\x80Q`\x01`\x01`\xA0\x1B\x03\x85\x16\x81R` \x81\x01\x84\x90R\x86\x91\x7F\xA659\x89Y\xDD\xB5\xCE;\x14S~\xDF\xC2[.g\x12t\xC9\xB8\xCA\xD0\xF4\xBDcGR\xE6\x90\x07\xB6\x91\x01`@Q\x80\x91\x03\x90\xA3PPPPV[_\x81\x81R`\x01` R`@\x81 `\x08\x01T`\x01`\xA0\x1B\x90\x04g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x15\x15a\x10IV[`\rT_\x90\x81\x90a\x12\xDD\x90`\x01\x90\x87\x90\x87\x90`\xFF\x16\x87a#\xD7V[\x91P\x91P\x81\x15a\x13\"W\x84\x7F\xBE\x17u]\x8D\x83j\xD6{\xFA\xF8\xE5\xB3\x86\x9A\xED\xB4\xCB\xA0?)Z\x16|UG\xFE\xDD\xD9\xEFP\xAD\x82`@Qa\x13\x19\x91\x81R` \x01\x90V[`@Q\x80\x91\x03\x90\xA2[PPPPPV[_a\x135`\x01\x89a!gV[`\x08T`@Q\x7F\x04\x97*\xF9\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R\x91\x92P`\x01`@\x1B\x90\x04`\x01`\x01`\xA0\x1B\x03\x16\x90c\x04\x97*\xF9\x90a\x13\x88\x90\x84\x90\x8A\x90`\x04\x01aa\x83V[_`@Q\x80\x83\x03\x81\x86\x80;\x15\x80\x15a\x13\x9EW_\x80\xFD[PZ\xFA\x15\x80\x15a\x13\xB0W=_\x80>=_\xFD[PPPP_`@Q\x80``\x01`@R\x80\x88`\x80\x01` \x81\x01\x90a\x13\xD3\x91\x90aa\xFCV[g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x81R` \x01`\x08\x80T\x90a\x01\0\n\x90\x04`\x01`\x01`\xA0\x1B\x03\x16`\x01`\x01`\xA0\x1B\x03\x16c\xE7\x8C\xEA\x92`@Q\x81c\xFF\xFF\xFF\xFF\x16`\xE0\x1B\x81R`\x04\x01` `@Q\x80\x83\x03\x81\x86Z\xFA\x15\x80\x15a\x141W=_\x80>=_\xFD[PPPP`@Q=`\x1F\x19`\x1F\x82\x01\x16\x82\x01\x80`@RP\x81\x01\x90a\x14U\x91\x90ab\x17V[`\x01`\x01`\xA0\x1B\x03\x90\x81\x16\x82R\x895` \x90\x92\x01\x91\x90\x91R`\tT`\rT`\x0BT`\x0CT\x94\x95Pa\x14\x9D\x94`\x01\x94\x8F\x94\x16\x92\x8E\x92\x88\x92\x8E\x92\x8E\x92\x8E\x92\x8E\x92`\xFF\x16\x91\x90a$DV[_\x89\x81R`\x01` R`@\x90 a\x14\xB3\x90a#aV[`@Q\x8A\x90\x7F\xE1\x1D\xB4\xB2{\xC8\xC6\xEAYC\xEC\xBB Z\xE1\xCA\x8DV\xC4,q\x97\x17\xAA\xF8\xA5=C\xD0\xCE\xE7\xC2\x90_\x90\xA3PPPPPPPPPV[_a\x10I`\x01\x83a'\xD6V[_a\x15\0`\x01\x84a!\xB6V[\x90Pa\x15\x0B\x81a(\xB3V[a\x15mWa\x15\x18\x81a(\xD6V[`\x08\x82\x01T`\x07\x83\x01T`@Q\x7F\xE5\x8C\x83\x08\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x81\x01\x93\x90\x93R`\x01`\x01`\xA0\x1B\x03\x90\x91\x16`$\x83\x01R`D\x82\x01R`d\x01a\x06\xB7V[_\x80\x80`\t\x84\x01T`\rTa\x15\x8F\x91`\xFF`\x01`H\x1B\x90\x91\x04\x81\x16\x91\x16a\x1C\x8CV[`\x02\x81\x11\x15a\x15\xA0Wa\x15\xA0a[\xF3V[\x14\x90P\x80\x80\x15a\x16;WP`\x08T`\x07\x84\x01T`@Q\x7F0\x83b(\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x81\x01\x91\x90\x91R`\x01`@\x1B\x90\x91\x04`\x01`\x01`\xA0\x1B\x03\x16\x90c0\x83b(\x90`$\x01` `@Q\x80\x83\x03\x81\x86Z\xFA\x15\x80\x15a\x16\x17W=_\x80>=_\xFD[PPPP`@Q=`\x1F\x19`\x1F\x82\x01\x16\x82\x01\x80`@RP\x81\x01\x90a\x16;\x91\x90a]\x05V[\x15a\x17\xF3W`\x08T`\x07\x84\x01T`@Q\x7F\xE5\x10\x19\xA6\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x01`@\x1B\x90\x92\x04`\x01`\x01`\xA0\x1B\x03\x16\x91c\xE5\x10\x19\xA6\x91a\x16\xA0\x91\x88\x90`\xC0\x82\x015\x90`\xE0\x83\x015\x90`\x04\x01ab2V[_`@Q\x80\x83\x03\x81\x86\x80;\x15\x80\x15a\x16\xB6W_\x80\xFD[PZ\xFA\x15\x80\x15a\x16\xC8W=_\x80>=_\xFD[PP`\x08T`@Q\x7F\x11qU\x85\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\xC0\x88\x015`\x04\x82\x01R`\x01`@\x1B\x90\x91\x04`\x01`\x01`\xA0\x1B\x03\x16\x92Pc\x11qU\x85\x91P`$\x01` `@Q\x80\x83\x03\x81\x86Z\xFA\x15\x80\x15a\x175W=_\x80>=_\xFD[PPPP`@Q=`\x1F\x19`\x1F\x82\x01\x16\x82\x01\x80`@RP\x81\x01\x90a\x17Y\x91\x90aa\x01V[`\x08T`@Q\x7FV\xBB\xC9\xE6\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\xC0\x87\x015`\x04\x82\x01R`\x01`@\x1B\x90\x91\x04`\x01`\x01`\xA0\x1B\x03\x16\x90cV\xBB\xC9\xE6\x90`$\x01` `@Q\x80\x83\x03\x81\x86Z\xFA\x15\x80\x15a\x17\xC2W=_\x80>=_\xFD[PPPP`@Q=`\x1F\x19`\x1F\x82\x01\x16\x82\x01\x80`@RP\x81\x01\x90a\x17\xE6\x91\x90aa\x01V[a\x17\xF0\x91\x90ab\xBFV[\x91P[`\x08T_\x90a\x18\x12\x90`\x01\x90\x88\x90\x86\x90g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16a)vV[_\x87\x81R`\x01` R`@\x90 \x90\x91Pa\x18+\x90a#aV[\x86\x7F.\x08\x08\x83\n\" L\xB3\xFB\x8F\x8DxK(\xBC\x97\xE9\xCE.9\xD2\xF9\xCD\xE2\x86\r\xE0\x95}h\xEB\x83`@Qa\x18]\x91\x81R` \x01\x90V[`@Q\x80\x91\x03\x90\xA3PPPPPPV[`@\x80Q`\xF8\x87\x90\x1B`\x01`\x01`\xF8\x1B\x03\x19\x16` \x80\x83\x01\x91\x90\x91R`!\x82\x01\x87\x90R`A\x82\x01\x86\x90R`a\x82\x01\x85\x90R`\x81\x80\x83\x01\x85\x90R\x83Q\x80\x84\x03\x90\x91\x01\x81R`\xA1\x90\x92\x01\x90\x92R\x80Q\x91\x01 _\x90[\x96\x95PPPPPPV[_\x80_\x80_a\x19\x15\x89\x89\x89\x89\x80\x80`\x1F\x01` \x80\x91\x04\x02` \x01`@Q\x90\x81\x01`@R\x80\x93\x92\x91\x90\x81\x81R` \x01\x83\x83\x80\x82\x847_\x92\x01\x91\x90\x91RP`\x01\x95\x94\x93\x92PPa*Z\x90PV[\x81Q\x92\x95P\x90\x93P\x91P\x15\x80a\x19\xACW\x82`@\x01Q\x83` \x01Q\x84_\x01Q\x7F\xAAKf\xB1\xCE\x93\x8C\x06\xE2\xA3\xF8Fk\xAE\x10\xEFb\xE7Gc\x0E8Y\x88\x9FG\x19\xFCd'\xB5\xA4\x86``\x01Q\x87`\x80\x01Q\x88`\xA0\x01Q\x89`\xC0\x01Q\x8A`\xE0\x01Q`@Qa\x19\xA3\x95\x94\x93\x92\x91\x90\x94\x85R` \x85\x01\x93\x90\x93R`\xFF\x91\x90\x91\x16`@\x84\x01R\x15\x15``\x83\x01R\x15\x15`\x80\x82\x01R`\xA0\x01\x90V[`@Q\x80\x91\x03\x90\xA4[\x81`@\x01Q\x82` \x01Q\x83_\x01Q\x7F\xAAKf\xB1\xCE\x93\x8C\x06\xE2\xA3\xF8Fk\xAE\x10\xEFb\xE7Gc\x0E8Y\x88\x9FG\x19\xFCd'\xB5\xA4\x85``\x01Q\x86`\x80\x01Q\x87`\xA0\x01Q\x88`\xC0\x01Q\x89`\xE0\x01Q`@Qa\x1A*\x95\x94\x93\x92\x91\x90\x94\x85R` \x85\x01\x93\x90\x93R`\xFF\x91\x90\x91\x16`@\x84\x01R\x15\x15``\x83\x01R\x15\x15`\x80\x82\x01R`\xA0\x01\x90V[`@Q\x80\x91\x03\x90\xA4\x81Q`@Q\x82\x15\x15\x81R\x85\x90\x8C\x90\x7Fs@Q\r$\xB7\xEC\x9B\\\x10\x0FU\0\xD94)\xD8\r\0\xD4o\r\x18\xE4\xE8]\x0CL\xC2+\x99$\x90` \x01`@Q\x80\x91\x03\x90\xA4PQ\x91\x93P\x90\x91PP[\x94P\x94\x92PPPV[_a\x10Ia\x1A\x8F`\x01\x84a!\xB6V[a.vV[_\x80a\x1A\xA2`\x01\x85\x85a.\xB9V[\x91P\x91P\x81\x15a\x11\x8CW\x83\x7F\xBE\x17u]\x8D\x83j\xD6{\xFA\xF8\xE5\xB3\x86\x9A\xED\xB4\xCB\xA0?)Z\x16|UG\xFE\xDD\xD9\xEFP\xAD\x82`@Qa\x1A\xDE\x91\x81R` \x01\x90V[`@Q\x80\x91\x03\x90\xA2PPPPV[`@\x80Qa\x01\xE0\x81\x01\x82R_\x80\x82R` \x82\x01\x81\x90R\x91\x81\x01\x82\x90R``\x81\x01\x82\x90R`\x80\x81\x01\x82\x90R`\xA0\x81\x01\x82\x90R`\xC0\x81\x01\x82\x90R`\xE0\x81\x01\x82\x90Ra\x01\0\x81\x01\x82\x90Ra\x01 \x81\x01\x82\x90Ra\x01@\x81\x01\x82\x90Ra\x01`\x81\x01\x82\x90Ra\x01\x80\x81\x01\x82\x90Ra\x01\xA0\x81\x01\x82\x90Ra\x01\xC0\x81\x01\x91\x90\x91Ra\x1Bo`\x01\x83a!\xB6V[`@\x80Qa\x01\xE0\x81\x01\x82R\x82T\x81R`\x01\x80\x84\x01T` \x83\x01R`\x02\x84\x01T\x92\x82\x01\x92\x90\x92R`\x03\x83\x01T``\x82\x01R`\x04\x83\x01T`\x80\x82\x01R`\x05\x83\x01T`\xA0\x82\x01R`\x06\x83\x01T`\xC0\x82\x01R`\x07\x83\x01T`\xE0\x82\x01R`\x08\x83\x01T`\x01`\x01`\xA0\x1B\x03\x81\x16a\x01\0\x83\x01R`\x01`\xA0\x1B\x90\x04g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x90\x81\x16a\x01 \x83\x01R`\t\x84\x01T\x90\x81\x16a\x01@\x83\x01R\x90\x92\x91a\x01`\x84\x01\x91`\x01`@\x1B\x90\x04`\xFF\x16\x90\x81\x11\x15a\x1C&Wa\x1C&a[\xF3V[`\x01\x81\x11\x15a\x1C7Wa\x1C7a[\xF3V[\x81R`\t\x91\x90\x91\x01T`\xFF`\x01`H\x1B\x82\x04\x81\x16` \x84\x01Rj\x01\0\0\0\0\0\0\0\0\0\0\x82\x04\x16\x15\x15`@\x83\x01Rg\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFFk\x01\0\0\0\0\0\0\0\0\0\0\0\x90\x91\x04\x16``\x90\x91\x01R\x92\x91PPV[_\x82`\xFF\x16_\x03a\x1C\x9EWP_a\x10IV[\x81`\xFF\x16\x83`\xFF\x16\x11a\x1C\xB3WP`\x01a\x10IV[a\x1C\xBE\x82`\x01aaDV[`\xFF\x16\x83`\xFF\x16\x03a\x1C\xD2WP`\x02a\x10IV[`@Q\x7F\xAE\r\xA5x\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\xFF\x80\x85\x16`\x04\x83\x01R\x83\x16`$\x82\x01R`D\x01a\x06\xB7V[`@\x80Qa\x01\0\x81\x01\x82R_\x80\x82R` \x82\x01\x81\x90R\x91\x81\x01\x82\x90R``\x81\x01\x82\x90R`\x80\x81\x01\x82\x90R`\xA0\x81\x01\x82\x90R`\xC0\x81\x01\x82\x90R`\xE0\x81\x01\x82\x90R\x90\x80a\x1D_\x8A\x8A\x8A\x8A\x89a.\xDCV[\x91P\x91P_a\x1Do\x83\x8B\x89a4*V[\x90P_a\x1D}\x83\x83\x8Da5lV[\x90P\x85\x15a\x1E\x17W_a\x1D\x8F\x82a6\x0EV[3_\x90\x81R`\x03\x8F\x01` \x90\x81R`@\x80\x83 \x84\x84R\x90\x91R\x90 T\x90\x91P`\xFF\x16\x15a\x1D\xF1W`@Q\x7FZF\xAC:\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R3`\x04\x82\x01R`$\x81\x01\x82\x90R`D\x01a\x06\xB7V[3_\x90\x81R`\x03\x8E\x01` \x90\x81R`@\x80\x83 \x93\x83R\x92\x90R \x80T`\xFF\x19\x16`\x01\x17\x90U[a\x1E!\x8C\x82a6{V[\x9C\x9BPPPPPPPPPPPPV[`@Q`\x01`\x01`\xA0\x1B\x03\x80\x85\x16`$\x83\x01R\x83\x16`D\x82\x01R`d\x81\x01\x82\x90Ra\x11\x8C\x90\x85\x90\x7F#\xB8r\xDD\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x90`\x84\x01[`@\x80Q`\x1F\x19\x81\x84\x03\x01\x81R\x91\x90R` \x81\x01\x80Q{\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x7F\xFF\xFF\xFF\xFF\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x90\x93\x16\x92\x90\x92\x17\x90\x91Ra:VV[_\x81_\x03a\x1E\xF1WP_\x91\x90PV[_a\x1E\xFD`\x01\x84aapV[\x92\x90\x92\x16\x15\x92\x91PPV[_\x81\x81R` \x83\x90R`@\x81 `\x08\x01T`\x01`\xA0\x1B\x90\x04g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16a\x1FIW`@Qb\xA7\xB0+`\xE0\x1B\x81R`\x04\x81\x01\x83\x90R`$\x01a\x06\xB7V[_\x82\x81R` \x84\x90R`@\x81 a\x1F_\x90a#aV[_\x81\x81R`\x01\x86\x01` R`@\x81 T\x91\x92P\x81\x90\x03a\x1F\xABW`@Q\x7F\xDA\x10\xF6|\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[`@Qh\x15S\x94\x92U\x90S\x11Q`\xBA\x1B` \x82\x01R`)\x01`@Q` \x81\x83\x03\x03\x81R\x90`@R\x80Q\x90` \x01 \x81\x03a \x14W_\x84\x81R` \x86\x90R`@\x90 `\x08\x01Ta \x0B\x90`\x01`\xA0\x1B\x90\x04g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16CaapV[\x92PPPa\x10IV[_\x81\x81R` \x86\x90R`@\x90 `\x08\x01T`\x01`\xA0\x1B\x90\x04g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16a UW`@Qb\xA7\xB0+`\xE0\x1B\x81R`\x04\x81\x01\x82\x90R`$\x01a\x06\xB7V[_\x81\x81R` \x86\x90R`@\x80\x82 `\x08\x90\x81\x01T\x87\x84R\x91\x90\x92 \x90\x91\x01Tg\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF`\x01`\xA0\x1B\x92\x83\x90\x04\x81\x16\x92\x90\x91\x04\x16\x80\x82\x11\x15a \xAAWa \x9F\x81\x83aapV[\x94PPPPPa\x10IV[_\x94PPPPPa\x10IV[PP\x92\x91PPV[_\x82\x81R` \x84\x90R`@\x81 `\t\x01Tk\x01\0\0\0\0\0\0\0\0\0\0\0\x90\x04g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x82\x81\x10a!+W`@Q\x7F\xD1\xF5\x92\x81\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x81\x01\x82\x90R`$\x81\x01\x84\x90R`D\x01a\x06\xB7V[\x90P[\x93\x92PPPV[_a!@\x83\x83a'\xD6V[\x80\x15a!.WP_\x82\x81R` \x84\x90R`@\x90 a!]\x90a.vV[`\x01\x14\x93\x92PPPV[_\x80a!s\x84\x84a!\xB6V[\x90P[`\t\x81\x01T`\x01`H\x1B\x90\x04`\xFF\x16\x15a!\xAEW\x80T_\x90\x81R`\x01\x85\x01` R`@\x90 Ta!\xA6\x85\x82a!\xB6V[\x91PPa!vV[T\x93\x92PPPV[_\x81\x81R` \x83\x90R`@\x81 `\x08\x01T`\x01`\xA0\x1B\x90\x04g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16a!\xF7W`@Qb\xA7\xB0+`\xE0\x1B\x81R`\x04\x81\x01\x83\x90R`$\x01a\x06\xB7V[P_\x90\x81R` \x91\x90\x91R`@\x90 \x90V[`\x01`\t\x82\x01T`\x01`@\x1B\x90\x04`\xFF\x16`\x01\x81\x11\x15a\"+Wa\"+a[\xF3V[\x14a\"|Wa\"9\x81a(\xD6V[`\t\x82\x01T`@Q\x7F\xEF\x12g\xB4\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81Ra\x06\xB7\x92\x91`\x01`@\x1B\x90\x04`\xFF\x16\x90`\x04\x01ab\xE0V[a\"\x85\x81a(\xB3V[a\"\x92Wa\x15\x18\x81a(\xD6V[`\t\x81\x01Tj\x01\0\0\0\0\0\0\0\0\0\0\x90\x04`\xFF\x16\x15\x15`\x01\x03a\"\xEFWa\"\xBA\x81a(\xD6V[`@Q\x7F0\x7Fvi\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01a\x06\xB7\x91\x81R` \x01\x90V[`\t\x01\x80Tj\xFF\0\0\0\0\0\0\0\0\0\0\x19\x16j\x01\0\0\0\0\0\0\0\0\0\0\x17\x90UV[`@Q`\x01`\x01`\xA0\x1B\x03\x83\x16`$\x82\x01R`D\x81\x01\x82\x90Ra#\\\x90\x84\x90\x7F\xA9\x05\x9C\xBB\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x90`d\x01a\x1E~V[PPPV[`\t\x81\x01T\x81T`\x02\x83\x01T`\x01\x84\x01T`\x04\x85\x01T`@\x80Q`\x01`H\x1B\x90\x96\x04`\xF8\x1B`\x01`\x01`\xF8\x1B\x03\x19\x16` \x80\x88\x01\x91\x90\x91R`!\x87\x01\x95\x90\x95R`A\x86\x01\x93\x90\x93R`a\x85\x01\x91\x90\x91R`\x81\x80\x85\x01\x91\x90\x91R\x81Q\x80\x85\x03\x90\x91\x01\x81R`\xA1\x90\x93\x01\x90R\x81Q\x91\x01 _\x90a\x10IV[_\x80_a#\xE4\x88\x88a\x1F\x08V[\x90Pa#\xF2\x88\x88\x88\x88a;:V[_\x86\x81R` \x89\x90R`@\x90 `\t\x01Ta$&\x90k\x01\0\0\0\0\0\0\0\0\0\0\0\x90\x04g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x82ab\xF4V[\x90Pa$4\x88\x88\x83\x87a<\xF4V[\x92P\x92PP[\x95P\x95\x93PPPPV[_\x8B\x81R` \x8D\x90R`@\x90 `\x08\x01T`\x01`\xA0\x1B\x90\x04g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16a$\x85W`@Qb\xA7\xB0+`\xE0\x1B\x81R`\x04\x81\x01\x8C\x90R`$\x01a\x06\xB7V[`\x02_\x8C\x81R` \x8E\x90R`@\x90 `\t\x01Ta$\xAC\x90`\x01`H\x1B\x90\x04`\xFF\x16\x85a\x1C\x8CV[`\x02\x81\x11\x15a$\xBDWa$\xBDa[\xF3V[\x14a%\x12W_\x8B\x81R` \x8D\x90R`@\x90\x81\x90 `\t\x01T\x90Q\x7F4\x8A\xEF\xDF\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x01`H\x1B\x90\x91\x04`\xFF\x16`\x04\x82\x01R`$\x01a\x06\xB7V[_\x8B\x81R` \x8D\x90R`@\x90 a%(\x90a.vV[`\x01\x14a%zW_\x8B\x81R` \x8D\x90R`@\x90 a%E\x90a.vV[`@Q\x7FkY^P\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01a\x06\xB7\x91\x81R` \x01\x90V[_\x8B\x81R` \x8D\x90R`@\x90 `\x02\x01T\x8B\x82[`\x01\x8F_\x01_\x84\x81R` \x01\x90\x81R` \x01_ `\t\x01`\t\x90T\x90a\x01\0\n\x90\x04`\xFF\x16`\xFF\x16\x11\x15a&)W_\x8F_\x01_\x84\x81R` \x01\x90\x81R` \x01_ _\x01T\x90P\x8F`\x01\x01_\x82\x81R` \x01\x90\x81R` \x01_ T\x92P\x8F_\x01_\x84\x81R` \x01\x90\x81R` \x01_ `\x02\x01T\x82a&\x0B\x91\x90ac\x07V[a&\x15\x90\x85ab\xF4V[\x93Pa&!\x86\x83ac\x07V[\x91PPa%\x8EV[PPa&\x81\x8D_\x01_\x8E\x81R` \x01\x90\x81R` \x01_ `\x01\x01T\x8B_\x015\x83\x8B\x8B\x80\x80` \x02` \x01`@Q\x90\x81\x01`@R\x80\x93\x92\x91\x90\x81\x81R` \x01\x83\x83` \x02\x80\x82\x847_\x92\x01\x91\x90\x91RPa=\x89\x92PPPV[_\x8B`\x01`\x01`\xA0\x1B\x03\x16c\xB5\x11/\xD2\x8B\x84\x8E_\x015\x8F\x80` \x01\x90a&\xA7\x91\x90a]=V[`@Q\x86c\xFF\xFF\xFF\xFF\x16`\xE0\x1B\x81R`\x04\x01a&\xC7\x95\x94\x93\x92\x91\x90ac\x1EV[` `@Q\x80\x83\x03\x81\x86Z\xFA\x15\x80\x15a&\xE2W=_\x80>=_\xFD[PPPP`@Q=`\x1F\x19`\x1F\x82\x01\x16\x82\x01\x80`@RP\x81\x01\x90a'\x06\x91\x90ac\x7FV[\x90Pa'g\x8E_\x01_\x8F\x81R` \x01\x90\x81R` \x01_ `\x03\x01T\x82\x84`\x01a'/\x91\x90ab\xF4V[\x8A\x8A\x80\x80` \x02` \x01`@Q\x90\x81\x01`@R\x80\x93\x92\x91\x90\x81\x81R` \x01\x83\x83` \x02\x80\x82\x847_\x92\x01\x91\x90\x91RPa=\x89\x92PPPV[_\x8D\x81R` \x8F\x90R`@\x90 a'}\x90a>\x0EV[a'\x87\x8E\x8Ea>\xA9V[PPP_\x99\x8ARPPP` \x97\x90\x97RPP`@\x90\x93 `\t\x01\x80Tr\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\0\0\0\0\0\0\0\0\0\0\0\x19\x16r\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\0\0\0\0\0\0\0\0\0\0\0\x17\x90UPPPPV[_\x81\x81R` \x83\x90R`@\x81 `\x08\x01T`\x01`\xA0\x1B\x90\x04g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16a(\x17W`@Qb\xA7\xB0+`\xE0\x1B\x81R`\x04\x81\x01\x83\x90R`$\x01a\x06\xB7V[_\x82\x81R` \x84\x90R`@\x81 a(-\x90a#aV[_\x81\x81R`\x01\x86\x01` R`@\x81 T\x91\x92P\x81\x90\x03a(yW`@Q\x7F\xDA\x10\xF6|\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[`@Qh\x15S\x94\x92U\x90S\x11Q`\xBA\x1B` \x82\x01R`)\x01`@\x80Q`\x1F\x19\x81\x84\x03\x01\x81R\x91\x90R\x80Q` \x90\x91\x01 \x14\x15\x94\x93PPPPV[`\x07\x81\x01T_\x90\x15\x80\x15\x90a\x10IWPP`\x08\x01T`\x01`\x01`\xA0\x1B\x03\x16\x15\x15\x90V[`\t\x81\x01T\x81T`\x02\x83\x01T`\x01\x84\x01T`\x04\x85\x01T`\x03\x86\x01T`@\x80Q`\x01`H\x1B\x90\x97\x04`\xF8\x1B`\x01`\x01`\xF8\x1B\x03\x19\x16` \x80\x89\x01\x91\x90\x91R`!\x88\x01\x96\x90\x96R`A\x87\x01\x94\x90\x94R`a\x86\x01\x92\x90\x92R`\x81\x80\x86\x01\x91\x90\x91R\x82Q\x80\x86\x03\x90\x91\x01\x81R`\xA1\x85\x01\x83R\x80Q\x90\x84\x01 `\xC1\x85\x01R`\xE1\x80\x85\x01\x91\x90\x91R\x81Q\x80\x85\x03\x90\x91\x01\x81Ra\x01\x01\x90\x93\x01\x90R\x81Q\x91\x01 _\x90a\x10IV[_\x83\x81R` \x85\x90R`@\x81 `\x08\x01T`\x01`\xA0\x1B\x90\x04g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16a)\xB7W`@Qb\xA7\xB0+`\xE0\x1B\x81R`\x04\x81\x01\x85\x90R`$\x01a\x06\xB7V[_a)\xC2\x86\x86a?)V[\x90Pa)\xD8g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x85\x16\x82ab\xF4V[\x90P\x82g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x81\x10\x15a*1W`@Q\x7F\x11\xA8\xD4\xD0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x81\x01\x82\x90Rg\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x84\x16`$\x82\x01R`D\x01a\x06\xB7V[_\x85\x81R` \x87\x90R`@\x90 a*G\x90a>\x0EV[a*Q\x86\x86a>\xA9V[\x95\x94PPPPPV[`@\x80Qa\x01\0\x81\x01\x82R_\x80\x82R` \x82\x01\x81\x90R\x91\x81\x01\x82\x90R``\x81\x01\x82\x90R`\x80\x81\x01\x82\x90R`\xA0\x81\x01\x82\x90R`\xC0\x81\x01\x82\x90R`\xE0\x81\x01\x82\x90R`@\x80Qa\x01\0\x81\x01\x82R_\x80\x82R` \x82\x01\x81\x90R\x91\x81\x01\x82\x90R``\x81\x01\x82\x90R`\x80\x81\x01\x82\x90R`\xA0\x81\x01\x82\x90R`\xC0\x81\x01\x82\x90R`\xE0\x81\x01\x91\x90\x91R_\x80\x87\x81R` \x89\x90R`@\x90 `\t\x01T`\x01`@\x1B\x90\x04`\xFF\x16`\x01\x81\x11\x15a+\x06Wa+\x06a[\xF3V[\x14a+]W_\x86\x81R` \x88\x90R`@\x90\x81\x90 `\t\x01T\x90Q\x7F#\xF8@]\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81Ra\x06\xB7\x91\x88\x91`\x01`@\x1B\x90\x91\x04`\xFF\x16\x90`\x04\x01ab\xE0V[a+g\x87\x87a'\xD6V[a+\xA0W`@Q\x7F\x80\xE0~E\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x81\x01\x87\x90R`$\x01a\x06\xB7V[_\x86\x81R` \x88\x90R`@\x81 `@\x80Qa\x01\xE0\x81\x01\x82R\x82T\x81R`\x01\x80\x84\x01T` \x83\x01R`\x02\x84\x01T\x92\x82\x01\x92\x90\x92R`\x03\x83\x01T``\x82\x01R`\x04\x83\x01T`\x80\x82\x01R`\x05\x83\x01T`\xA0\x82\x01R`\x06\x83\x01T`\xC0\x82\x01R`\x07\x83\x01T`\xE0\x82\x01R`\x08\x83\x01T`\x01`\x01`\xA0\x1B\x03\x81\x16a\x01\0\x83\x01R`\x01`\xA0\x1B\x90\x04g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x90\x81\x16a\x01 \x83\x01R`\t\x84\x01T\x90\x81\x16a\x01@\x83\x01R\x90\x92\x91a\x01`\x84\x01\x91`\x01`@\x1B\x90\x04`\xFF\x16\x90\x81\x11\x15a,dWa,da[\xF3V[`\x01\x81\x11\x15a,uWa,ua[\xF3V[\x81R`\t\x91\x90\x91\x01T`\x01`H\x1B\x81\x04`\xFF\x90\x81\x16` \x84\x01Rj\x01\0\0\0\0\0\0\0\0\0\0\x82\x04\x16\x15\x15`@\x80\x84\x01\x91\x90\x91Rk\x01\0\0\0\0\0\0\0\0\0\0\0\x90\x91\x04g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16``\x90\x92\x01\x91\x90\x91R\x81\x01Q`\x80\x82\x01Q\x91\x92P_\x91a,\xE3\x91\x90a?\xB4V[\x90P_\x80\x87\x80` \x01\x90Q\x81\x01\x90a,\xFB\x91\x90ac\xF2V[\x90\x92P\x90Pa-+\x89a-\x0F\x85`\x01ab\xF4V[``\x87\x01Q`\x80\x88\x01Qa-$\x90`\x01ab\xF4V[\x86\x86a@]V[PP`@\x80Qa\x01\0\x81\x01\x82R_\x80\x82R` \x82\x01\x81\x90R\x91\x81\x01\x82\x90R``\x81\x01\x82\x90R`\x80\x81\x01\x82\x90R`\xA0\x81\x01\x82\x90R`\xC0\x81\x01\x82\x90R`\xE0\x81\x01\x82\x90R_a-\x8B\x85_\x01Q\x86` \x01Q\x87`@\x01Q\x8D\x88\x8Aa\x01\x80\x01QaC{V[\x90Pa-\x96\x81aD\x83V[_\x81\x81R` \x8E\x90R`@\x90 `\x08\x01T\x90\x93P`\x01`\xA0\x1B\x90\x04g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16a-\xCCWa-\xC9\x8C\x82a6{V[\x91P[P`@\x80Qa\x01\0\x81\x01\x82R_\x80\x82R` \x82\x01\x81\x90R\x91\x81\x01\x82\x90R``\x81\x01\x82\x90R`\x80\x81\x01\x82\x90R`\xA0\x81\x01\x82\x90R`\xC0\x81\x01\x82\x90R`\xE0\x81\x01\x91\x90\x91R_a.,\x86_\x01Q\x8C\x87\x89``\x01Q\x8A`\x80\x01Q\x8Ba\x01\x80\x01QaC{V[\x90Pa.8\x8D\x82a6{V[\x91PPa.d\x83\x82_\x01Q\x8E_\x01_\x8F\x81R` \x01\x90\x81R` \x01_ aE\x1A\x90\x92\x91\x90c\xFF\xFF\xFF\xFF\x16V[\x91\x9B\x90\x9AP\x90\x98P\x96PPPPPPPV[_\x80\x82`\x02\x01T\x83`\x04\x01Ta.\x8C\x91\x90aapV[\x90P\x80_\x03a\x10IWa.\x9E\x83a(\xD6V[`@Qb\xA7\xB0+`\xE0\x1B\x81R`\x04\x01a\x06\xB7\x91\x81R` \x01\x90V[_\x80a.\xD0\x85\x85a.\xCA\x88\x88a?)V[\x86a<\xF4V[\x91P\x91P\x93P\x93\x91PPV[`@\x80Q``\x80\x82\x01\x83R_\x80\x83R` \x83\x01R\x91\x81\x01\x91\x90\x91R_\x80a/\x0Fa/\t` \x89\x01\x89a]$V[\x85a\x1C\x8CV[`\x02\x81\x11\x15a/ Wa/ a[\xF3V[\x03a24W` \x85\x01Q\x85Q_\x03a/dW`@Q\x7F\xE9k\xC6\x1A\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[\x85Q``\x88\x015\x14a/\xB2W\x85Q`@Q\x7F[\x17z<\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x81\x01\x91\x90\x91R``\x88\x015`$\x82\x01R`D\x01a\x06\xB7V[\x85`@\x01Qa/\xEDW`@Q\x7F\xC1i$6\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[\x85``\x01Qa0(W`@Q\x7F\xB4]\x1C:\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[a05`\xA0\x88\x01\x88a]=V[\x90P_\x03a0VW`@Qc\x0C\x9C\xCA\xC5`\xE4\x1B\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[_a0d`\xA0\x89\x01\x89a]=V[\x81\x01\x90a0q\x91\x90a_\xE5V[P\x90\x91P_\x90P\x87`\x80\x01Q` \x01Q`\x02\x81\x11\x15a0\x92Wa0\x92a[\xF3V[\x03a0\xC9W`@Q\x7FF6^R\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[_\x87`\xA0\x01Q` \x01Q`\x02\x81\x11\x15a0\xE4Wa0\xE4a[\xF3V[\x03a1\x1BW`@Q\x7F\x89\x99\x85}\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[_\x86`\x01`\x01`\xA0\x1B\x03\x16c\xC3\x96\x19\xC4a18\x8A`\x80\x01QaE\x9AV[`@Q\x82c\xFF\xFF\xFF\xFF\x16`\xE0\x1B\x81R`\x04\x01a1T\x91\x90adRV[` `@Q\x80\x83\x03\x81\x86Z\xFA\x15\x80\x15a1oW=_\x80>=_\xFD[PPPP`@Q=`\x1F\x19`\x1F\x82\x01\x16\x82\x01\x80`@RP\x81\x01\x90a1\x93\x91\x90ac\x7FV[\x90P_\x87`\x01`\x01`\xA0\x1B\x03\x16c\xC3\x96\x19\xC4a1\xB2\x8B`\xA0\x01QaE\x9AV[`@Q\x82c\xFF\xFF\xFF\xFF\x16`\xE0\x1B\x81R`\x04\x01a1\xCE\x91\x90adRV[` `@Q\x80\x83\x03\x81\x86Z\xFA\x15\x80\x15a1\xE9W=_\x80>=_\xFD[PPPP`@Q=`\x1F\x19`\x1F\x82\x01\x16\x82\x01\x80`@RP\x81\x01\x90a2\r\x91\x90ac\x7FV[`@\x80Q``\x81\x01\x82R\x93\x84R` \x84\x01\x91\x90\x91R\x82\x01\x92\x90\x92R\x93P\x90\x91Pa$:\x90PV[a2B\x87\x87``\x015a!5V[a2~W`@Q\x7F\xFFm\x9B\xD7\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R``\x87\x015`\x04\x82\x01R`$\x01a\x06\xB7V[``\x86\x015_\x90\x81R` \x88\x90R`@\x81 \x90a2\x9A\x82a#aV[\x90P_`\t\x83\x01T`\x01`@\x1B\x90\x04`\xFF\x16`\x01\x81\x11\x15a2\xBDWa2\xBDa[\xF3V[\x14a2\xF4W`@Q\x7F\x12E\x9F\xFD\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[`\t\x82\x01Ta3\r\x90`\x01`H\x1B\x90\x04`\xFF\x16\x86aE\xD4V[`\xFF\x16a3\x1D` \x8A\x01\x8Aa]$V[`\xFF\x16\x14a3\x7FWa32` \x89\x01\x89a]$V[`\t\x83\x01T`@Q\x7F\xAC\x9Ea\x16\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\xFF\x92\x83\x16`\x04\x82\x01R`\x01`H\x1B\x90\x91\x04\x90\x91\x16`$\x82\x01R`D\x01a\x06\xB7V[a3\x8C`\xA0\x89\x01\x89a]=V[\x90P_\x03a3\xADW`@Qc\x0C\x9C\xCA\xC5`\xE4\x1B\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[_\x80\x80\x80\x80a3\xBF`\xA0\x8E\x01\x8Ea]=V[\x81\x01\x90a3\xCC\x91\x90ad\x7FV[\x94P\x94P\x94P\x94P\x94Pa3\xEA\x87`\x01\x01T\x86\x89`\x02\x01T\x86a=\x89V[a3\xFE\x87`\x03\x01T\x85\x89`\x04\x01T\x85a=\x89V[`@Q\x80``\x01`@R\x80\x86\x81R` \x01\x85\x81R` \x01\x82\x81RP\x86\x98P\x98PPPPPPPPa$:V[`@\x80Q_\x80\x82R` \x82\x01\x90\x92R\x81\x90a4O\x90a4J\x90\x87QaE\xF5V[aF*V[\x90Pa4Z\x83a\x1E\xE2V[a4zW`@Qc:\xBF\xB6\xFF`\xE2\x1B\x81R`\x04\x81\x01\x84\x90R`$\x01a\x06\xB7V[\x82\x84`@\x015\x14a4\xC4W`@\x80Q\x7F\xDF\xCCb\xBC\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R\x90\x85\x015`\x04\x82\x01R`$\x81\x01\x84\x90R`D\x01a\x06\xB7V[a4\xE0\x84` \x015\x86` \x01Q\x86`@\x015\x88`@\x01Qa=\x89V[a4\xED`\x80\x85\x01\x85a]=V[\x90P_\x03a5'W`@Q\x7F4*\x07R\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[_\x80a56`\x80\x87\x01\x87a]=V[\x81\x01\x90a5C\x91\x90ae\x14V[\x90\x92P\x90Pa5a\x83`\x01` \x89\x015a-$`@\x8B\x015\x83ab\xF4V[P\x90\x95\x94PPPPPV[`@\x80Qa\x01\xE0\x81\x01\x82R_\x80\x82R` \x82\x01\x81\x90R\x91\x81\x01\x82\x90R``\x81\x01\x82\x90R`\x80\x81\x01\x82\x90R`\xA0\x81\x01\x82\x90R`\xC0\x81\x01\x82\x90R`\xE0\x81\x01\x82\x90Ra\x01\0\x81\x01\x82\x90Ra\x01 \x81\x01\x82\x90Ra\x01@\x81\x01\x82\x90Ra\x01`\x81\x01\x82\x90Ra\x01\x80\x81\x01\x82\x90Ra\x01\xA0\x81\x01\x82\x90Ra\x01\xC0\x81\x01\x91\x90\x91Ra!+\x84\x84_` \x86\x01\x805\x90`@\x88\x015\x90``\x89\x015\x903\x90a6\t\x90\x8Ba]$V[aG\xBAV[a\x01\x80\x81\x01Q\x81Q`@\x80\x84\x01Q` \x80\x86\x01Q`\x80\x87\x01Q\x84Q`\xF8\x97\x90\x97\x1B`\x01`\x01`\xF8\x1B\x03\x19\x16\x87\x84\x01R`!\x87\x01\x95\x90\x95R`A\x86\x01\x92\x90\x92R`a\x85\x01\x91\x90\x91R`\x81\x80\x85\x01\x93\x90\x93R\x81Q\x80\x85\x03\x90\x93\x01\x83R`\xA1\x90\x93\x01\x90R\x80Q\x91\x01 _\x90a\x10IV[`@\x80Qa\x01\0\x81\x01\x82R_\x80\x82R` \x82\x01\x81\x90R\x91\x81\x01\x82\x90R``\x81\x01\x82\x90R`\x80\x81\x01\x82\x90R`\xA0\x81\x01\x82\x90R`\xC0\x81\x01\x82\x90R`\xE0\x81\x01\x82\x90R\x90a6\xC4\x83aD\x83V[_\x81\x81R` \x86\x90R`@\x90 `\x08\x01T\x90\x91P`\x01`\xA0\x1B\x90\x04g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x15a7#W`@Q\x7F\xBC\xED\xF3\xDE\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x81\x01\x82\x90R`$\x01a\x06\xB7V[_\x81\x81R` \x85\x81R`@\x91\x82\x90 \x85Q\x81U\x90\x85\x01Q`\x01\x80\x83\x01\x91\x90\x91U\x91\x85\x01Q`\x02\x82\x01U``\x85\x01Q`\x03\x82\x01U`\x80\x85\x01Q`\x04\x82\x01U`\xA0\x85\x01Q`\x05\x82\x01U`\xC0\x85\x01Q`\x06\x82\x01U`\xE0\x85\x01Q`\x07\x82\x01Ua\x01\0\x85\x01Q`\x08\x82\x01\x80Ta\x01 \x88\x01Qg\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x90\x81\x16`\x01`\xA0\x1B\x02\x7F\xFF\xFF\xFF\xFF\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x90\x92\x16`\x01`\x01`\xA0\x1B\x03\x90\x94\x16\x93\x90\x93\x17\x17\x90Ua\x01@\x86\x01Q`\t\x83\x01\x80T\x91\x90\x92\x16g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x19\x82\x16\x81\x17\x83Ua\x01`\x88\x01Q\x88\x95\x90\x93\x92h\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x19\x16\x90\x91\x17\x90`\x01`@\x1B\x90\x84\x90\x81\x11\x15a8*Wa8*a[\xF3V[\x02\x17\x90UPa\x01\x80\x82\x81\x01Q`\t\x92\x90\x92\x01\x80Ta\x01\xA0\x85\x01Qa\x01\xC0\x90\x95\x01Qg\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16k\x01\0\0\0\0\0\0\0\0\0\0\0\x02r\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\0\0\0\0\0\0\0\0\0\0\0\x19\x95\x15\x15j\x01\0\0\0\0\0\0\0\0\0\0\x02j\xFF\0\0\0\0\0\0\0\0\0\0\x19`\xFF\x90\x96\x16`\x01`H\x1B\x02\x95\x90\x95\x16\x7F\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\0\0\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x90\x92\x16\x91\x90\x91\x17\x93\x90\x93\x17\x93\x90\x93\x16\x91\x90\x91\x17\x90\x91U\x83\x01Q\x83Q`@\x80\x86\x01Q` \x80\x88\x01Q`\x80\x89\x01Q\x84Q`\x01`\x01`\xF8\x1B\x03\x19`\xF8\x98\x90\x98\x1B\x97\x90\x97\x16\x87\x84\x01R`!\x87\x01\x95\x90\x95R`A\x86\x01\x92\x90\x92R`a\x85\x01\x91\x90\x91R`\x81\x80\x85\x01\x93\x90\x93R\x81Q\x80\x85\x03\x90\x93\x01\x83R`\xA1\x90\x93\x01\x90R\x80Q\x91\x01 _\x90_\x81\x81R`\x01\x87\x01` R`@\x81 T\x91\x92P\x81\x90\x03a9\xA0W`@Qh\x15S\x94\x92U\x90S\x11Q`\xBA\x1B` \x82\x01R`)\x01`@\x80Q`\x1F\x19\x81\x84\x03\x01\x81R\x91\x81R\x81Q` \x92\x83\x01 _\x85\x81R`\x01\x8A\x01\x90\x93R\x91 Ua9\xE7V[`@Qh\x15S\x94\x92U\x90S\x11Q`\xBA\x1B` \x82\x01R`)\x01`@Q` \x81\x83\x03\x03\x81R\x90`@R\x80Q\x90` \x01 \x81\x03a9\xE7W_\x82\x81R`\x01\x87\x01` R`@\x90 \x83\x90U[`@\x80Qa\x01\0\x81\x01\x82R\x84\x81R` \x80\x82\x01\x85\x90R\x87Q\x82\x84\x01R`\xE0\x88\x01Q``\x83\x01R_\x86\x81R\x90\x89\x90R\x91\x90\x91 `\x80\x82\x01\x90a:'\x90a.vV[\x81Ra\x01\x80\x87\x01Q`\xFF\x16` \x82\x01R\x91\x15\x15`@\x83\x01R`\xE0\x90\x95\x01Q\x15\x15``\x90\x91\x01RP\x91\x93\x92PPPV[_a:\xAA\x82`@Q\x80`@\x01`@R\x80` \x81R` \x01\x7FSafeERC20: low-level call failed\x81RP\x85`\x01`\x01`\xA0\x1B\x03\x16aIa\x90\x92\x91\x90c\xFF\xFF\xFF\xFF\x16V[\x80Q\x90\x91P\x15a#\\W\x80\x80` \x01\x90Q\x81\x01\x90a:\xC8\x91\x90a]\x05V[a#\\W`@QbF\x1B\xCD`\xE5\x1B\x81R` `\x04\x82\x01R`*`$\x82\x01R\x7FSafeERC20: ERC20 operation did n`D\x82\x01R\x7Fot succeed\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0`d\x82\x01R`\x84\x01a\x06\xB7V[_\x82\x81R` \x85\x90R`@\x90 `\x07\x01T\x83\x14a;\xA0W_\x82\x81R` \x85\x90R`@\x90\x81\x90 `\x07\x01T\x90Q\x7F\xC2\xAD\xC3\xE8\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81Ra\x06\xB7\x91\x85\x91`\x04\x01\x91\x82R` \x82\x01R`@\x01\x90V[_\x82\x81R` \x85\x90R`@\x80\x82 T\x85\x83R\x91 a;\xBD\x90a#aV[\x14a<\"W_\x83\x81R` \x85\x90R`@\x90 a;\xD8\x90a#aV[_\x83\x81R` \x86\x90R`@\x90\x81\x90 T\x90Q\x7F\xE2\xE2\x7F\x87\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x81\x01\x92\x90\x92R`$\x82\x01R`D\x01a\x06\xB7V[_\x82\x81R` \x85\x90R`@\x80\x82 `\t\x90\x81\x01T\x86\x84R\x91\x90\x92 \x90\x91\x01T`\xFF`\x01`H\x1B\x92\x83\x90\x04\x81\x16\x92a<[\x92\x04\x16\x83aE\xD4V[`\xFF\x16\x14a\x11\x8CW_\x83\x81R` \x85\x90R`@\x90 `\t\x01T\x83\x90\x83\x90a<\x8C\x90`\x01`H\x1B\x90\x04`\xFF\x16\x84aE\xD4V[_\x85\x81R` \x88\x90R`@\x90\x81\x90 `\t\x01T\x90Q\x7F~rm\x15\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x81\x01\x94\x90\x94R`$\x84\x01\x92\x90\x92R`\xFF\x90\x81\x16`D\x84\x01R`\x01`H\x1B\x90\x91\x04\x16`d\x82\x01R`\x84\x01a\x06\xB7V[_\x80_a=\x02\x87\x87\x86a \xBEV[\x90Pg\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x85\x11a=\x19W\x84a=#V[g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF[\x94P\x80\x85\x11\x15a=|WPPP_\x83\x81R` \x85\x90R`@\x90 `\t\x01\x80Tr\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\0\0\0\0\0\0\0\0\0\0\0\x19\x16k\x01\0\0\0\0\0\0\0\0\0\0\0g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x85\x16\x02\x17\x90U`\x01\x82a\x1AwV[_\x97\x90\x96P\x94PPPPPV[_a=\xBD\x82\x84\x86`@Q` \x01a=\xA2\x91\x81R` \x01\x90V[`@Q` \x81\x83\x03\x03\x81R\x90`@R\x80Q\x90` \x01 aIoV[\x90P\x80\x85\x14a\x13\"W`@QbF\x1B\xCD`\xE5\x1B\x81R` `\x04\x82\x01R`\x17`$\x82\x01R\x7FInvalid inclusion proof\0\0\0\0\0\0\0\0\0`D\x82\x01R`d\x01a\x06\xB7V[_`\t\x82\x01T`\x01`@\x1B\x90\x04`\xFF\x16`\x01\x81\x11\x15a>/Wa>/a[\xF3V[\x14a>\x80Wa>=\x81a(\xD6V[`\t\x82\x01T`@Q\x7F#\xF8@]\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81Ra\x06\xB7\x92\x91`\x01`@\x1B\x90\x04`\xFF\x16\x90`\x04\x01ab\xE0V[`\t\x01\x80Tg\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFFC\x16h\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x19\x90\x91\x16\x17`\x01`@\x1B\x17\x90UV[_\x81\x81R` \x83\x90R`@\x81 a>\xBF\x90a#aV[_\x81\x81R`\x02\x85\x01` R`@\x90 T\x90\x91P\x80\x15a?\x14W`@Q\x7F\xDDp(\xF0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x81\x01\x84\x90R`$\x81\x01\x82\x90R`D\x01a\x06\xB7V[P_\x90\x81R`\x02\x90\x92\x01` R`@\x90\x91 UV[_\x80a?5\x84\x84a\x1F\x08V[_\x84\x81R` \x86\x90R`@\x90 `\x05\x01T\x90\x91P\x15a!.W_\x83\x81R` \x85\x90R`@\x80\x82 `\x05\x81\x01T\x83R\x81\x83 `\t\x90\x81\x01T`\x06\x90\x92\x01T\x84R\x91\x90\x92 \x01Tg\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFFk\x01\0\0\0\0\0\0\0\0\0\0\0\x92\x83\x90\x04\x81\x16\x92\x90\x91\x04\x16\x80\x82\x10a?\xA8W\x80a?\xAAV[\x81[a\x18\xC0\x90\x84ab\xF4V[_`\x02a?\xC1\x84\x84aapV[\x10\x15a@\x03W`@Q\x7F\x90)\x85\x94\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x81\x01\x84\x90R`$\x81\x01\x83\x90R`D\x01a\x06\xB7V[a@\r\x83\x83aapV[`\x02\x03a@&Wa@\x1F\x83`\x01ab\xF4V[\x90Pa\x10IV[_\x83a@3`\x01\x85aapV[\x18\x90P_a@@\x82aJ\"V[\x90P_\x19\x81\x1B\x80a@R`\x01\x87aapV[\x16\x96\x95PPPPPPV[_\x85\x11a@\xACW`@QbF\x1B\xCD`\xE5\x1B\x81R` `\x04\x82\x01R`\x14`$\x82\x01R\x7FPre-size cannot be 0\0\0\0\0\0\0\0\0\0\0\0\0`D\x82\x01R`d\x01a\x06\xB7V[\x85a@\xB6\x83aF*V[\x14aA\x03W`@QbF\x1B\xCD`\xE5\x1B\x81R` `\x04\x82\x01R`\x1B`$\x82\x01R\x7FPre expansion root mismatch\0\0\0\0\0`D\x82\x01R`d\x01a\x06\xB7V[\x84aA\r\x83aK\\V[\x14aA\x80W`@QbF\x1B\xCD`\xE5\x1B\x81R` `\x04\x82\x01R`!`$\x82\x01R\x7FPre size does not match expansio`D\x82\x01R\x7Fn\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0`d\x82\x01R`\x84\x01a\x06\xB7V[\x82\x85\x10aA\xCFW`@QbF\x1B\xCD`\xE5\x1B\x81R` `\x04\x82\x01\x81\x90R`$\x82\x01R\x7FPre size not less than post size`D\x82\x01R`d\x01a\x06\xB7V[_\x85\x90P_\x80aA\xE1\x85_\x87QaK\xABV[\x90P[\x85\x83\x10\x15aB\xA3W_aA\xF7\x84\x88aM\x1FV[\x90P\x84Q\x83\x10aBIW`@QbF\x1B\xCD`\xE5\x1B\x81R` `\x04\x82\x01R`\x12`$\x82\x01R\x7FIndex out of range\0\0\0\0\0\0\0\0\0\0\0\0\0\0`D\x82\x01R`d\x01a\x06\xB7V[aBm\x82\x82\x87\x86\x81Q\x81\x10aB`WaB`aa\x1CV[` \x02` \x01\x01QaN\x06V[\x91P`\x01\x81\x1BaB}\x81\x86ab\xF4V[\x94P\x87\x85\x11\x15aB\x8FWaB\x8FaejV[\x83aB\x99\x81ae~V[\x94PPPPaA\xE4V[\x86aB\xAD\x82aF*V[\x14aC W`@QbF\x1B\xCD`\xE5\x1B\x81R` `\x04\x82\x01R`\"`$\x82\x01R\x7FPost expansion root not equal po`D\x82\x01R\x7Fst\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0`d\x82\x01R`\x84\x01a\x06\xB7V[\x83Q\x82\x14aCpW`@QbF\x1B\xCD`\xE5\x1B\x81R` `\x04\x82\x01R`\x16`$\x82\x01R\x7FIncomplete proof usage\0\0\0\0\0\0\0\0\0\0`D\x82\x01R`d\x01a\x06\xB7V[PPPPPPPPPV[`@\x80Qa\x01\xE0\x81\x01\x82R_\x80\x82R` \x82\x01\x81\x90R\x91\x81\x01\x82\x90R``\x81\x01\x82\x90R`\x80\x81\x01\x82\x90R`\xA0\x81\x01\x82\x90R`\xC0\x81\x01\x82\x90R`\xE0\x81\x01\x82\x90Ra\x01\0\x81\x01\x82\x90Ra\x01 \x81\x01\x82\x90Ra\x01@\x81\x01\x82\x90Ra\x01`\x81\x01\x82\x90Ra\x01\x80\x81\x01\x82\x90Ra\x01\xA0\x81\x01\x82\x90Ra\x01\xC0\x81\x01\x91\x90\x91RaD\0\x87\x87\x87\x87\x87aSnV[P`@\x80Qa\x01\xE0\x81\x01\x82R\x96\x87R` \x87\x01\x95\x90\x95R\x93\x85\x01\x92\x90\x92R``\x84\x01R`\x80\x83\x01R_`\xA0\x83\x01\x81\x90R`\xC0\x83\x01\x81\x90R`\xE0\x83\x01\x81\x90Ra\x01\0\x83\x01\x81\x90Rg\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFFC\x16a\x01 \x84\x01Ra\x01@\x83\x01\x81\x90Ra\x01`\x83\x01\x81\x90R`\xFF\x90\x91\x16a\x01\x80\x83\x01Ra\x01\xA0\x82\x01\x81\x90Ra\x01\xC0\x82\x01R\x90V[a\x01\x80\x81\x01Q\x81Q`@\x80\x84\x01Q` \x80\x86\x01Q`\x80\x87\x01Q``\x88\x01Q\x85Q`\xF8\x98\x90\x98\x1B`\x01`\x01`\xF8\x1B\x03\x19\x16\x88\x85\x01R`!\x88\x01\x96\x90\x96R`A\x87\x01\x93\x90\x93R`a\x86\x01R`\x81\x80\x86\x01\x92\x90\x92R\x82Q\x80\x86\x03\x90\x92\x01\x82R`\xA1\x85\x01\x83R\x81Q\x91\x81\x01\x91\x90\x91 `\xC1\x85\x01R`\xE1\x80\x85\x01\x93\x90\x93R\x81Q\x80\x85\x03\x90\x93\x01\x83Ra\x01\x01\x90\x93\x01\x90R\x80Q\x91\x01 _\x90a\x10IV[`\x05\x83\x01T\x15\x15\x80aE/WP`\x06\x83\x01T\x15\x15[\x15aE\x8AWaE=\x83a(\xD6V[`\x05\x84\x01T`\x06\x85\x01T`@Q\x7F\x8B\x0Eq\xD0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x81\x01\x93\x90\x93R`$\x83\x01\x91\x90\x91R`D\x82\x01R`d\x01a\x06\xB7V[`\x05\x83\x01\x91\x90\x91U`\x06\x90\x91\x01UV[aE\xA2aV\xC6V[`@Q\x80`@\x01`@R\x80\x83_\x01Q\x81R` \x01\x83` \x01Q`\x02\x81\x11\x15aE\xCCWaE\xCCa[\xF3V[\x90R\x92\x91PPV[_\x80aE\xE1\x84`\x01aaDV[\x90PaE\xED\x81\x84a\x1C\x8CV[P\x93\x92PPPV[``a!.\x83_\x84`@Q` \x01aF\x0F\x91\x81R` \x01\x90V[`@Q` \x81\x83\x03\x03\x81R\x90`@R\x80Q\x90` \x01 aN\x06V[_\x80\x82Q\x11aF{W`@QbF\x1B\xCD`\xE5\x1B\x81R` `\x04\x82\x01R`\x16`$\x82\x01R\x7FEmpty merkle expansion\0\0\0\0\0\0\0\0\0\0`D\x82\x01R`d\x01a\x06\xB7V[`@\x82Q\x11\x15aF\xCDW`@QbF\x1B\xCD`\xE5\x1B\x81R` `\x04\x82\x01R`\x1A`$\x82\x01R\x7FMerkle expansion too large\0\0\0\0\0\0`D\x82\x01R`d\x01a\x06\xB7V[_\x80[\x83Q\x81\x10\x15aG\xB3W_\x84\x82\x81Q\x81\x10aF\xECWaF\xECaa\x1CV[` \x02` \x01\x01Q\x90P\x82_\x80\x1B\x03aGVW\x80\x15aGQW\x80\x92P`\x01\x85QaG\x16\x91\x90aapV[\x82\x14aGQW`@QaG8\x90\x84\x90_\x90` \x01\x91\x82R` \x82\x01R`@\x01\x90V[`@Q` \x81\x83\x03\x03\x81R\x90`@R\x80Q\x90` \x01 \x92P[aG\xAAV[\x80\x15aGuW`@\x80Q` \x81\x01\x83\x90R\x90\x81\x01\x84\x90R``\x01aG8V[`@QaG\x91\x90\x84\x90_\x90` \x01\x91\x82R` \x82\x01R`@\x01\x90V[`@Q` \x81\x83\x03\x03\x81R\x90`@R\x80Q\x90` \x01 \x92P[P`\x01\x01aF\xD0V[P\x92\x91PPV[`@\x80Qa\x01\xE0\x81\x01\x82R_\x80\x82R` \x82\x01\x81\x90R\x91\x81\x01\x82\x90R``\x81\x01\x82\x90R`\x80\x81\x01\x82\x90R`\xA0\x81\x01\x82\x90R`\xC0\x81\x01\x82\x90R`\xE0\x81\x01\x82\x90Ra\x01\0\x81\x01\x82\x90Ra\x01 \x81\x01\x82\x90Ra\x01@\x81\x01\x82\x90Ra\x01`\x81\x01\x82\x90Ra\x01\x80\x81\x01\x82\x90Ra\x01\xA0\x81\x01\x82\x90Ra\x01\xC0\x81\x01\x91\x90\x91R`\x01`\x01`\xA0\x1B\x03\x83\x16aHrW`@Q\x7F\xF2\x89\xE6W\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[_\x84\x90\x03aH\xACW`@Q\x7Fi2\xBC\xFD\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[aH\xB9\x89\x89\x89\x89\x89aSnV[`@Q\x80a\x01\xE0\x01`@R\x80\x8A\x81R` \x01\x89\x81R` \x01\x88\x81R` \x01\x87\x81R` \x01\x86\x81R` \x01_\x80\x1B\x81R` \x01_\x80\x1B\x81R` \x01\x85\x81R` \x01\x84`\x01`\x01`\xA0\x1B\x03\x16\x81R` \x01Cg\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x81R` \x01_g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x81R` \x01_`\x01\x81\x11\x15aI:WaI:a[\xF3V[\x81R`\xFF\x84\x16` \x82\x01R_`@\x82\x01\x81\x90R``\x90\x91\x01R\x90P\x98\x97PPPPPPPPV[``a!+\x84\x84_\x85aT_V[\x82Q_\x90a\x01\0\x81\x11\x15aI\xBAW`@Q\x7F\xFD\xAC3\x1E\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x81\x01\x82\x90Ra\x01\0`$\x82\x01R`D\x01a\x06\xB7V[\x82_[\x82\x81\x10\x15aJ\x18W_\x87\x82\x81Q\x81\x10aI\xD8WaI\xD8aa\x1CV[` \x02` \x01\x01Q\x90P\x81`\x01\x90\x1B\x87\x16_\x03aJ\x01W\x82_R\x80` R`@_ \x92PaJ\x0FV[\x80_R\x82` R`@_ \x92P[P`\x01\x01aI\xBDV[P\x95\x94PPPPPV[_\x81_\x03aJrW`@QbF\x1B\xCD`\xE5\x1B\x81R` `\x04\x82\x01R`\x1C`$\x82\x01R\x7FZero has no significant bits\0\0\0\0`D\x82\x01R`d\x01a\x06\xB7V[p\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x82\x10aJ\x9DW`\x80\x91\x82\x1C\x91aJ\x9A\x90\x82ab\xF4V[\x90P[`\x01`@\x1B\x82\x10aJ\xBBW`@\x91\x82\x1C\x91aJ\xB8\x90\x82ab\xF4V[\x90P[d\x01\0\0\0\0\x82\x10aJ\xDAW` \x91\x82\x1C\x91aJ\xD7\x90\x82ab\xF4V[\x90P[b\x01\0\0\x82\x10aJ\xF7W`\x10\x91\x82\x1C\x91aJ\xF4\x90\x82ab\xF4V[\x90P[a\x01\0\x82\x10aK\x13W`\x08\x91\x82\x1C\x91aK\x10\x90\x82ab\xF4V[\x90P[`\x10\x82\x10aK.W`\x04\x91\x82\x1C\x91aK+\x90\x82ab\xF4V[\x90P[`\x04\x82\x10aKIW`\x02\x91\x82\x1C\x91aKF\x90\x82ab\xF4V[\x90P[`\x02\x82\x10a\x10\xE6Wa\x10I`\x01\x82ab\xF4V[_\x80\x80[\x83Q\x81\x10\x15aG\xB3W\x83\x81\x81Q\x81\x10aK{WaK{aa\x1CV[` \x02` \x01\x01Q_\x80\x1B\x14aK\xA3WaK\x96\x81`\x02afvV[aK\xA0\x90\x83ab\xF4V[\x91P[`\x01\x01aK`V[``\x81\x83\x10aK\xFCW`@QbF\x1B\xCD`\xE5\x1B\x81R` `\x04\x82\x01R`\x17`$\x82\x01R\x7FStart not less than end\0\0\0\0\0\0\0\0\0`D\x82\x01R`d\x01a\x06\xB7V[\x83Q\x82\x11\x15aLsW`@QbF\x1B\xCD`\xE5\x1B\x81R` `\x04\x82\x01R`!`$\x82\x01R\x7FEnd not less or equal than lengt`D\x82\x01R\x7Fh\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0`d\x82\x01R`\x84\x01a\x06\xB7V[_aL~\x84\x84aapV[g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x11\x15aL\x96WaL\x96a]\x9EV[`@Q\x90\x80\x82R\x80` \x02` \x01\x82\x01`@R\x80\x15aL\xBFW\x81` \x01` \x82\x02\x806\x837\x01\x90P[P\x90P\x83[\x83\x81\x10\x15aM\x16W\x85\x81\x81Q\x81\x10aL\xDEWaL\xDEaa\x1CV[` \x02` \x01\x01Q\x82\x86\x83aL\xF3\x91\x90aapV[\x81Q\x81\x10aM\x03WaM\x03aa\x1CV[` \x90\x81\x02\x91\x90\x91\x01\x01R`\x01\x01aL\xC4V[P\x94\x93PPPPV[_\x81\x83\x10aMoW`@QbF\x1B\xCD`\xE5\x1B\x81R` `\x04\x82\x01R`\x17`$\x82\x01R\x7FStart not less than end\0\0\0\0\0\0\0\0\0`D\x82\x01R`d\x01a\x06\xB7V[_aM{\x83\x85\x18aJ\"V[\x90P_`\x01aM\x8A\x83\x82ab\xF4V[`\x01\x90\x1BaM\x98\x91\x90aapV[\x90P\x84\x81\x16\x84\x82\x16\x81\x15aM\xAFWa \x9F\x82aU\x98V[\x80\x15aM\xBEWa \x9F\x81aJ\"V[`@QbF\x1B\xCD`\xE5\x1B\x81R` `\x04\x82\x01R`\x1B`$\x82\x01R\x7FBoth y and z cannot be zero\0\0\0\0\0`D\x82\x01R`d\x01a\x06\xB7V[```@\x83\x10aNXW`@QbF\x1B\xCD`\xE5\x1B\x81R` `\x04\x82\x01R`\x0E`$\x82\x01R\x7FLevel too high\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0`D\x82\x01R`d\x01a\x06\xB7V[_\x82\x90\x03aN\xA8W`@QbF\x1B\xCD`\xE5\x1B\x81R` `\x04\x82\x01R`\x1B`$\x82\x01R\x7FCannot append empty subtree\0\0\0\0\0`D\x82\x01R`d\x01a\x06\xB7V[`@\x84Q\x11\x15aN\xFAW`@QbF\x1B\xCD`\xE5\x1B\x81R` `\x04\x82\x01R`\x1A`$\x82\x01R\x7FMerkle expansion too large\0\0\0\0\0\0`D\x82\x01R`d\x01a\x06\xB7V[\x83Q_\x03aOwW_aO\x0E\x84`\x01ab\xF4V[g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x11\x15aO&WaO&a]\x9EV[`@Q\x90\x80\x82R\x80` \x02` \x01\x82\x01`@R\x80\x15aOOW\x81` \x01` \x82\x02\x806\x837\x01\x90P[P\x90P\x82\x81\x85\x81Q\x81\x10aOeWaOeaa\x1CV[` \x90\x81\x02\x91\x90\x91\x01\x01R\x90Pa!.V[\x83Q\x83\x10aO\xEDW`@QbF\x1B\xCD`\xE5\x1B\x81R` `\x04\x82\x01R`5`$\x82\x01R\x7FLevel greater than highest level`D\x82\x01R\x7F of current expansion\0\0\0\0\0\0\0\0\0\0\0`d\x82\x01R`\x84\x01a\x06\xB7V[\x81_aO\xF8\x86aK\\V[\x90P_aP\x06\x86`\x02afvV[aP\x10\x90\x83ab\xF4V[\x90P_aP\x1C\x83aJ\"V[aP%\x83aJ\"V[\x11aPsW\x87Qg\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x11\x15aPDWaPDa]\x9EV[`@Q\x90\x80\x82R\x80` \x02` \x01\x82\x01`@R\x80\x15aPmW\x81` \x01` \x82\x02\x806\x837\x01\x90P[PaP\xC3V[\x87QaP\x80\x90`\x01ab\xF4V[g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x11\x15aP\x98WaP\x98a]\x9EV[`@Q\x90\x80\x82R\x80` \x02` \x01\x82\x01`@R\x80\x15aP\xC1W\x81` \x01` \x82\x02\x806\x837\x01\x90P[P[\x90P`@\x81Q\x11\x15aQ\x17W`@QbF\x1B\xCD`\xE5\x1B\x81R` `\x04\x82\x01R`\x1C`$\x82\x01R\x7FAppend creates oversize tree\0\0\0\0`D\x82\x01R`d\x01a\x06\xB7V[_[\x88Q\x81\x10\x15aR\xC3W\x87\x81\x10\x15aQ\xBFW\x88\x81\x81Q\x81\x10aQ<WaQ<aa\x1CV[` \x02` \x01\x01Q_\x80\x1B\x14aQ\xBAW`@QbF\x1B\xCD`\xE5\x1B\x81R` `\x04\x82\x01R`\"`$\x82\x01R\x7FAppend above least significant b`D\x82\x01R\x7Fit\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0`d\x82\x01R`\x84\x01a\x06\xB7V[aR\xBBV[_\x85\x90\x03aR\x04W\x88\x81\x81Q\x81\x10aQ\xD9WaQ\xD9aa\x1CV[` \x02` \x01\x01Q\x82\x82\x81Q\x81\x10aQ\xF3WaQ\xF3aa\x1CV[` \x02` \x01\x01\x81\x81RPPaR\xBBV[\x88\x81\x81Q\x81\x10aR\x16WaR\x16aa\x1CV[` \x02` \x01\x01Q_\x80\x1B\x03aRLW\x84\x82\x82\x81Q\x81\x10aR9WaR9aa\x1CV[` \x90\x81\x02\x91\x90\x91\x01\x01R_\x94PaR\xBBV[_\x80\x1B\x82\x82\x81Q\x81\x10aRaWaRaaa\x1CV[` \x02` \x01\x01\x81\x81RPP\x88\x81\x81Q\x81\x10aR\x7FWaR\x7Faa\x1CV[` \x02` \x01\x01Q\x85`@Q` \x01aR\xA2\x92\x91\x90\x91\x82R` \x82\x01R`@\x01\x90V[`@Q` \x81\x83\x03\x03\x81R\x90`@R\x80Q\x90` \x01 \x94P[`\x01\x01aQ\x19V[P\x83\x15aR\xF7W\x83\x81`\x01\x83QaR\xDA\x91\x90aapV[\x81Q\x81\x10aR\xEAWaR\xEAaa\x1CV[` \x02` \x01\x01\x81\x81RPP[\x80`\x01\x82QaS\x06\x91\x90aapV[\x81Q\x81\x10aS\x16WaS\x16aa\x1CV[` \x02` \x01\x01Q_\x80\x1B\x03a\x05lW`@QbF\x1B\xCD`\xE5\x1B\x81R` `\x04\x82\x01R`\x0F`$\x82\x01R\x7FLast entry zero\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0`D\x82\x01R`d\x01a\x06\xB7V[_\x85\x90\x03aS\xA8W`@Q\x7F\x8Dy\xDB\xBC\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[\x82\x81\x11aS\xEBW`@Q\x7F `\xFA\xF4\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x81\x01\x84\x90R`$\x81\x01\x82\x90R`D\x01a\x06\xB7V[_\x84\x90\x03aT%W`@Q\x7F\x83\xC6\x83\xE4\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[_\x82\x90\x03a\x13\"W`@Q\x7F\\\xB6\xE5\xBB\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[``\x82G\x10\x15aT\xD7W`@QbF\x1B\xCD`\xE5\x1B\x81R` `\x04\x82\x01R`&`$\x82\x01R\x7FAddress: insufficient balance fo`D\x82\x01R\x7Fr call\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0`d\x82\x01R`\x84\x01a\x06\xB7V[`\x01`\x01`\xA0\x1B\x03\x85\x16;aU.W`@QbF\x1B\xCD`\xE5\x1B\x81R` `\x04\x82\x01R`\x1D`$\x82\x01R\x7FAddress: call to non-contract\0\0\0`D\x82\x01R`d\x01a\x06\xB7V[_\x80\x86`\x01`\x01`\xA0\x1B\x03\x16\x85\x87`@QaUI\x91\x90af\x81V[_`@Q\x80\x83\x03\x81\x85\x87Z\xF1\x92PPP=\x80_\x81\x14aU\x83W`@Q\x91P`\x1F\x19`?=\x01\x16\x82\x01`@R=\x82R=_` \x84\x01>aU\x88V[``\x91P[P\x91P\x91Pa\x05l\x82\x82\x86aV\x03V[_\x80\x82\x11aU\xE8W`@QbF\x1B\xCD`\xE5\x1B\x81R` `\x04\x82\x01R`\x1C`$\x82\x01R\x7FZero has no significant bits\0\0\0\0`D\x82\x01R`d\x01a\x06\xB7V[_\x82\x80aU\xF6`\x01\x82aapV[\x16\x18\x90Pa!.\x81aJ\"V[``\x83\x15aV\x12WP\x81a!.V[\x82Q\x15aV\"W\x82Q\x80\x84` \x01\xFD[\x81`@QbF\x1B\xCD`\xE5\x1B\x81R`\x04\x01a\x06\xB7\x91\x90af\x97V[`@\x80Q`\xC0\x81\x01\x82R_\x80\x82R` \x82\x01\x81\x90R\x91\x81\x01\x82\x90R``\x81\x01\x91\x90\x91R`\x80\x81\x01aVkaV\xE4V[\x81R` \x01aVxaV\xE4V[\x90R\x90V[\x82\x80T\x82\x82U\x90_R` _ \x90\x81\x01\x92\x82\x15aV\xB6W\x91` \x02\x82\x01[\x82\x81\x11\x15aV\xB6W\x825\x82U\x91` \x01\x91\x90`\x01\x01\x90aV\x9BV[PaV\xC2\x92\x91PaW\tV[P\x90V[`@Q\x80`@\x01`@R\x80aV\xD9aW\x1DV[\x81R` \x01_\x90R\x90V[`@Q\x80``\x01`@R\x80aV\xF7aW\x1DV[\x81R` \x01_\x81R_` \x90\x91\x01R\x90V[[\x80\x82\x11\x15aV\xC2W_\x81U`\x01\x01aW\nV[`@Q\x80`@\x01`@R\x80aW0aW9V[\x81R` \x01aVx[`@Q\x80`@\x01`@R\x80`\x02\x90` \x82\x02\x806\x837P\x91\x92\x91PPV[\x805`\xFF\x81\x16\x81\x14a\x10\xE6W_\x80\xFD[_\x80_\x80_\x80`\xC0\x87\x89\x03\x12\x15aW|W_\x80\xFD[aW\x85\x87aWWV[\x98` \x88\x015\x98P`@\x88\x015\x97``\x81\x015\x97P`\x80\x81\x015\x96P`\xA0\x015\x94P\x92PPPV[_` \x82\x84\x03\x12\x15aW\xBDW_\x80\xFD[\x815g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x11\x15aW\xD3W_\x80\xFD[\x82\x01`\xC0\x81\x85\x03\x12\x15a!.W_\x80\xFD[`\x01`\x01`\xA0\x1B\x03\x81\x16\x81\x14aW\xF8W_\x80\xFD[PV[g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x16\x81\x14aW\xF8W_\x80\xFD[_\x80\x83`\x1F\x84\x01\x12aX W_\x80\xFD[P\x815g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x11\x15aX7W_\x80\xFD[` \x83\x01\x91P\x83` \x82`\x05\x1B\x85\x01\x01\x11\x15aXQW_\x80\xFD[\x92P\x92\x90PV[_\x80_\x80_\x80_\x80_\x80_a\x01@\x8C\x8E\x03\x12\x15aXsW_\x80\xFD[\x8B5aX~\x81aW\xE4V[\x9AP` \x8C\x015aX\x8E\x81aW\xFBV[\x99P`@\x8C\x015aX\x9E\x81aW\xE4V[\x98P``\x8C\x015\x97P`\x80\x8C\x015\x96P`\xA0\x8C\x015\x95P`\xC0\x8C\x015aX\xC3\x81aW\xE4V[\x94P`\xE0\x8C\x015aX\xD3\x81aW\xE4V[\x93PaX\xE2a\x01\0\x8D\x01aWWV[\x92Pa\x01 \x8C\x015g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x11\x15aX\xFEW_\x80\xFD[aY\n\x8E\x82\x8F\x01aX\x10V[\x91P\x80\x93PP\x80\x91PP\x92\x95\x98\x9BP\x92\x95\x98\x9B\x90\x93\x96\x99PV[_` \x82\x84\x03\x12\x15aY4W_\x80\xFD[P5\x91\x90PV[`\x03\x81\x10aW\xF8W_\x80\xFD[\x805a\x10\xE6\x81aY;V[_` \x82\x84\x03\x12\x15aYbW_\x80\xFD[\x815a!.\x81aY;V[_\x80_`@\x84\x86\x03\x12\x15aY\x7FW_\x80\xFD[\x835g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x11\x15aY\x95W_\x80\xFD[aY\xA1\x86\x82\x87\x01aX\x10V[\x90\x97\x90\x96P` \x95\x90\x95\x015\x94\x93PPPPV[_\x80`@\x83\x85\x03\x12\x15aY\xC6W_\x80\xFD[\x825aY\xD1\x81aW\xE4V[\x94` \x93\x90\x93\x015\x93PPPV[_\x80_``\x84\x86\x03\x12\x15aY\xF1W_\x80\xFD[PP\x815\x93` \x83\x015\x93P`@\x90\x92\x015\x91\x90PV[_\x80_\x80_\x80_\x87\x89\x03a\x01 \x81\x12\x15aZ W_\x80\xFD[\x885\x97P` \x89\x015g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x80\x82\x11\x15aZ>W_\x80\xFD[\x90\x8A\x01\x90`@\x82\x8D\x03\x12\x15aZQW_\x80\xFD[\x81\x98P`\xA0\x7F\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xC0\x84\x01\x12\x15aZ\x83W_\x80\xFD[`@\x8B\x01\x97P`\xE0\x8B\x015\x92P\x80\x83\x11\x15aZ\x9CW_\x80\xFD[aZ\xA8\x8C\x84\x8D\x01aX\x10V[\x90\x97P\x95Pa\x01\0\x8B\x015\x92P\x86\x91P\x80\x83\x11\x15aZ\xC4W_\x80\xFD[PPaZ\xD2\x8A\x82\x8B\x01aX\x10V[\x98\x9B\x97\x9AP\x95\x98P\x93\x96\x92\x95\x92\x93PPPV[_\x80\x82\x84\x03a\x01 \x81\x12\x15aZ\xF8W_\x80\xFD[\x835\x92Pa\x01\0`\x1F\x19\x82\x01\x12\x15a[\x0EW_\x80\xFD[P` \x83\x01\x90P\x92P\x92\x90PV[_\x80_\x80_`\xA0\x86\x88\x03\x12\x15a[0W_\x80\xFD[a[9\x86aWWV[\x97` \x87\x015\x97P`@\x87\x015\x96``\x81\x015\x96P`\x80\x015\x94P\x92PPPV[_\x80_\x80``\x85\x87\x03\x12\x15a[mW_\x80\xFD[\x845\x93P` \x85\x015\x92P`@\x85\x015g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x80\x82\x11\x15a[\x92W_\x80\xFD[\x81\x87\x01\x91P\x87`\x1F\x83\x01\x12a[\xA5W_\x80\xFD[\x815\x81\x81\x11\x15a[\xB3W_\x80\xFD[\x88` \x82\x85\x01\x01\x11\x15a[\xC4W_\x80\xFD[\x95\x98\x94\x97PP` \x01\x94PPPV[_\x80`@\x83\x85\x03\x12\x15a[\xE4W_\x80\xFD[PP\x805\x92` \x90\x91\x015\x91PV[cNH{q`\xE0\x1B_R`!`\x04R`$_\xFD[`\x02\x81\x10a\\\x17Wa\\\x17a[\xF3V[\x90RV[_a\x01\xE0\x82\x01\x90P\x82Q\x82R` \x83\x01Q` \x83\x01R`@\x83\x01Q`@\x83\x01R``\x83\x01Q``\x83\x01R`\x80\x83\x01Q`\x80\x83\x01R`\xA0\x83\x01Q`\xA0\x83\x01R`\xC0\x83\x01Q`\xC0\x83\x01R`\xE0\x83\x01Q`\xE0\x83\x01Ra\x01\0\x80\x84\x01Qa\\\x88\x82\x85\x01\x82`\x01`\x01`\xA0\x1B\x03\x16\x90RV[PPa\x01 \x83\x81\x01Qg\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x16\x84\x83\x01RPPa\x01@\x83\x81\x01Qg\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x16\x84\x83\x01RPPa\x01`\x80\x84\x01Qa\\\xCD\x82\x85\x01\x82a\\\x07V[PPa\x01\x80\x83\x81\x01Q`\xFF\x16\x90\x83\x01Ra\x01\xA0\x80\x84\x01Q\x15\x15\x90\x83\x01Ra\x01\xC0\x80\x84\x01Qg\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x16\x82\x85\x01Ra \xB6V[_` \x82\x84\x03\x12\x15a]\x15W_\x80\xFD[\x81Q\x80\x15\x15\x81\x14a!.W_\x80\xFD[_` \x82\x84\x03\x12\x15a]4W_\x80\xFD[a!.\x82aWWV[_\x80\x835\x7F\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xE1\x846\x03\x01\x81\x12a]pW_\x80\xFD[\x83\x01\x805\x91Pg\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x82\x11\x15a]\x8AW_\x80\xFD[` \x01\x91P6\x81\x90\x03\x82\x13\x15aXQW_\x80\xFD[cNH{q`\xE0\x1B_R`A`\x04R`$_\xFD[`@Q``\x81\x01g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x11\x82\x82\x10\x17\x15a]\xD5Wa]\xD5a]\x9EV[`@R\x90V[`@\x80Q\x90\x81\x01g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x11\x82\x82\x10\x17\x15a]\xD5Wa]\xD5a]\x9EV[`@Q`\x1F\x82\x01`\x1F\x19\x16\x81\x01g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x11\x82\x82\x10\x17\x15a^'Wa^'a]\x9EV[`@R\x91\x90PV[_g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x82\x11\x15a^HWa^Ha]\x9EV[P`\x05\x1B` \x01\x90V[_\x82`\x1F\x83\x01\x12a^aW_\x80\xFD[\x815` a^va^q\x83a^/V[a]\xFEV[\x80\x83\x82R` \x82\x01\x91P` \x84`\x05\x1B\x87\x01\x01\x93P\x86\x84\x11\x15a^\x97W_\x80\xFD[` \x86\x01[\x84\x81\x10\x15a^\xB3W\x805\x83R\x91\x83\x01\x91\x83\x01a^\x9CV[P\x96\x95PPPPPPV[_\x82`\x1F\x83\x01\x12a^\xCDW_\x80\xFD[a^\xD5a]\xDBV[\x80`@\x84\x01\x85\x81\x11\x15a^\xE6W_\x80\xFD[\x84[\x81\x81\x10\x15a5aW\x805a^\xFB\x81aW\xFBV[\x84R` \x93\x84\x01\x93\x01a^\xE8V[_\x81\x83\x03a\x01\0\x81\x12\x15a_\x1BW_\x80\xFD[a_#a]\xB2V[\x91P`\xC0\x81\x12\x15a_2W_\x80\xFD[a_:a]\xB2V[`\x80\x82\x12\x15a_GW_\x80\xFD[a_Oa]\xDBV[\x91P\x84`\x1F\x85\x01\x12a__W_\x80\xFD[a_ga]\xDBV[\x80`@\x86\x01\x87\x81\x11\x15a_xW_\x80\xFD[\x86[\x81\x81\x10\x15a_\x92W\x805\x84R` \x93\x84\x01\x93\x01a_zV[P\x81\x85Ra_\xA0\x88\x82a^\xBEV[` \x86\x01RPPP\x81\x81Ra_\xB7`\x80\x85\x01aYGV[` \x82\x01R`\xA0\x84\x015`@\x82\x01R\x80\x83RPP`\xC0\x82\x015` \x82\x01R`\xE0\x82\x015`@\x82\x01R\x92\x91PPV[_\x80_a\x02 \x84\x86\x03\x12\x15a_\xF8W_\x80\xFD[\x835g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x11\x15a`\x0EW_\x80\xFD[a`\x1A\x86\x82\x87\x01a^RV[\x93PPa`*\x85` \x86\x01a_\tV[\x91Pa`:\x85a\x01 \x86\x01a_\tV[\x90P\x92P\x92P\x92V[\x80Q\x82_[`\x02\x81\x10\x15a`gW\x82Q\x82R` \x92\x83\x01\x92\x90\x91\x01\x90`\x01\x01a`HV[PPP` \x80\x82\x01Q`@\x84\x01_[`\x02\x81\x10\x15a`\x9DW\x82Qg\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x82R\x91\x83\x01\x91\x90\x83\x01\x90`\x01\x01a`vV[PPPPPPV[`\x03\x81\x10aW\xF8WaW\xF8a[\xF3V[_a\x01 \x82\x01\x90P\x85\x82Ra`\xCE` \x83\x01\x86Qa`CV[` \x85\x01Qa`\xDC\x81a`\xA5V[`\xA0\x83\x01R`@\x94\x90\x94\x01Q`\xC0\x82\x01R`\xE0\x81\x01\x92\x90\x92Ra\x01\0\x90\x91\x01R\x91\x90PV[_` \x82\x84\x03\x12\x15aa\x11W_\x80\xFD[\x81Qa!.\x81aW\xFBV[cNH{q`\xE0\x1B_R`2`\x04R`$_\xFD[cNH{q`\xE0\x1B_R`\x11`\x04R`$_\xFD[`\xFF\x81\x81\x16\x83\x82\x16\x01\x90\x81\x11\x15a\x10IWa\x10Iaa0V[` \x81\x01aaj\x83a`\xA5V[\x91\x90R\x90V[\x81\x81\x03\x81\x81\x11\x15a\x10IWa\x10Iaa0V[_`\xC0\x82\x01\x90P\x83\x82R\x825` \x83\x01R` \x83\x015`@\x83\x01R`@\x83\x015aa\xAC\x81aW\xE4V[`\x01`\x01`\xA0\x1B\x03\x81\x16``\x84\x01RP``\x83\x015aa\xCA\x81aW\xFBV[g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x80\x82\x16`\x80\x85\x01R`\x80\x85\x015\x91Paa\xEB\x82aW\xFBV[\x80\x82\x16`\xA0\x85\x01RPP\x93\x92PPPV[_` \x82\x84\x03\x12\x15ab\x0CW_\x80\xFD[\x815a!.\x81aW\xFBV[_` \x82\x84\x03\x12\x15ab'W_\x80\xFD[\x81Qa!.\x81aW\xE4V[\x84\x81Ra\x01 \x81\x01` `@\x86\x82\x85\x017``\x83\x01`@\x87\x01_[`\x02\x81\x10\x15ab}W\x815aba\x81aW\xFBV[g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x83R\x91\x83\x01\x91\x90\x83\x01\x90`\x01\x01abMV[PPPP`\x80\x85\x015ab\x8F\x81aY;V[ab\x98\x81a`\xA5V[\x80`\xA0\x84\x01RP`\xA0\x85\x015`\xC0\x83\x01R\x83`\xE0\x83\x01R\x82a\x01\0\x83\x01R\x95\x94PPPPPV[g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x82\x81\x16\x82\x82\x16\x03\x90\x80\x82\x11\x15aG\xB3WaG\xB3aa0V[\x82\x81R`@\x81\x01a!.` \x83\x01\x84a\\\x07V[\x80\x82\x01\x80\x82\x11\x15a\x10IWa\x10Iaa0V[\x80\x82\x02\x81\x15\x82\x82\x04\x84\x14\x17a\x10IWa\x10Iaa0V[\x85Q\x81R`\x01`\x01`\xA0\x1B\x03` \x87\x01Q\x16` \x82\x01R`@\x86\x01Q`@\x82\x01R\x84``\x82\x01R\x83`\x80\x82\x01R`\xC0`\xA0\x82\x01R\x81`\xC0\x82\x01R\x81\x83`\xE0\x83\x017_\x81\x83\x01`\xE0\x90\x81\x01\x91\x90\x91R`\x1F\x90\x92\x01`\x1F\x19\x16\x01\x01\x94\x93PPPPV[_` \x82\x84\x03\x12\x15ac\x8FW_\x80\xFD[PQ\x91\x90PV[_\x82`\x1F\x83\x01\x12ac\xA5W_\x80\xFD[\x81Q` ac\xB5a^q\x83a^/V[\x80\x83\x82R` \x82\x01\x91P` \x84`\x05\x1B\x87\x01\x01\x93P\x86\x84\x11\x15ac\xD6W_\x80\xFD[` \x86\x01[\x84\x81\x10\x15a^\xB3W\x80Q\x83R\x91\x83\x01\x91\x83\x01ac\xDBV[_\x80`@\x83\x85\x03\x12\x15ad\x03W_\x80\xFD[\x82Qg\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x80\x82\x11\x15ad\x1AW_\x80\xFD[ad&\x86\x83\x87\x01ac\x96V[\x93P` \x85\x01Q\x91P\x80\x82\x11\x15ad;W_\x80\xFD[PadH\x85\x82\x86\x01ac\x96V[\x91PP\x92P\x92\x90PV[_`\xA0\x82\x01\x90Padd\x82\x84Qa`CV[` \x83\x01Qadr\x81a`\xA5V[\x80`\x80\x84\x01RP\x92\x91PPV[_\x80_\x80_`\xA0\x86\x88\x03\x12\x15ad\x93W_\x80\xFD[\x855\x94P` \x86\x015\x93P`@\x86\x015g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x80\x82\x11\x15ad\xB8W_\x80\xFD[ad\xC4\x89\x83\x8A\x01a^RV[\x94P``\x88\x015\x91P\x80\x82\x11\x15ad\xD9W_\x80\xFD[ad\xE5\x89\x83\x8A\x01a^RV[\x93P`\x80\x88\x015\x91P\x80\x82\x11\x15ad\xFAW_\x80\xFD[Pae\x07\x88\x82\x89\x01a^RV[\x91PP\x92\x95P\x92\x95\x90\x93PV[_\x80`@\x83\x85\x03\x12\x15ae%W_\x80\xFD[\x825g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x80\x82\x11\x15ae<W_\x80\xFD[aeH\x86\x83\x87\x01a^RV[\x93P` \x85\x015\x91P\x80\x82\x11\x15ae]W_\x80\xFD[PadH\x85\x82\x86\x01a^RV[cNH{q`\xE0\x1B_R`\x01`\x04R`$_\xFD[__\x19\x82\x03ae\x8FWae\x8Faa0V[P`\x01\x01\x90V[`\x01\x81\x81[\x80\x85\x11\x15ae\xD0W\x81_\x19\x04\x82\x11\x15ae\xB6Wae\xB6aa0V[\x80\x85\x16\x15ae\xC3W\x91\x81\x02\x91[\x93\x84\x1C\x93\x90\x80\x02\x90ae\x9BV[P\x92P\x92\x90PV[_\x82ae\xE6WP`\x01a\x10IV[\x81ae\xF2WP_a\x10IV[\x81`\x01\x81\x14af\x08W`\x02\x81\x14af\x12Waf.V[`\x01\x91PPa\x10IV[`\xFF\x84\x11\x15af#Waf#aa0V[PP`\x01\x82\x1Ba\x10IV[P` \x83\x10a\x013\x83\x10\x16`N\x84\x10`\x0B\x84\x10\x16\x17\x15afQWP\x81\x81\na\x10IV[af[\x83\x83ae\x96V[\x80_\x19\x04\x82\x11\x15afnWafnaa0V[\x02\x93\x92PPPV[_a!.\x83\x83ae\xD8V[_\x82Q\x80` \x85\x01\x84^_\x92\x01\x91\x82RP\x91\x90PV[` \x81R_\x82Q\x80` \x84\x01R\x80` \x85\x01`@\x85\x01^_`@\x82\x85\x01\x01R`@`\x1F\x19`\x1F\x83\x01\x16\x84\x01\x01\x91PP\x92\x91PPV\xFE\xA2dipfsX\"\x12 $\r\xE4\xA0\x0FKM\xBE#\x90#\xD9\x7F\x9E\xB5\x9C\x9A\xE6\x1EE\x7F#\x1A\x82\xC1\xF1\x89-\xBD\x1A<\xFBdsolcC\0\x08\x19\x003",
    );
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct EdgeStatus(u8);
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[automatically_derived]
        impl alloy_sol_types::private::SolTypeValue<EdgeStatus> for u8 {
            #[inline]
            fn stv_to_tokens(
                &self,
            ) -> <alloy::sol_types::sol_data::Uint<
                8,
            > as alloy_sol_types::SolType>::Token<'_> {
                alloy_sol_types::private::SolTypeValue::<
                    alloy::sol_types::sol_data::Uint<8>,
                >::stv_to_tokens(self)
            }
            #[inline]
            fn stv_eip712_data_word(&self) -> alloy_sol_types::Word {
                <alloy::sol_types::sol_data::Uint<
                    8,
                > as alloy_sol_types::SolType>::tokenize(self)
                    .0
            }
            #[inline]
            fn stv_abi_encode_packed_to(
                &self,
                out: &mut alloy_sol_types::private::Vec<u8>,
            ) {
                <alloy::sol_types::sol_data::Uint<
                    8,
                > as alloy_sol_types::SolType>::abi_encode_packed_to(self, out)
            }
            #[inline]
            fn stv_abi_packed_encoded_size(&self) -> usize {
                <alloy::sol_types::sol_data::Uint<
                    8,
                > as alloy_sol_types::SolType>::abi_encoded_size(self)
            }
        }
        #[automatically_derived]
        impl EdgeStatus {
            /// The Solidity type name.
            pub const NAME: &'static str = stringify!(@ name);
            /// Convert from the underlying value type.
            #[inline]
            pub const fn from(value: u8) -> Self {
                Self(value)
            }
            /// Return the underlying value.
            #[inline]
            pub const fn into(self) -> u8 {
                self.0
            }
            /// Return the single encoding of this value, delegating to the
            /// underlying type.
            #[inline]
            pub fn abi_encode(&self) -> alloy_sol_types::private::Vec<u8> {
                <Self as alloy_sol_types::SolType>::abi_encode(&self.0)
            }
            /// Return the packed encoding of this value, delegating to the
            /// underlying type.
            #[inline]
            pub fn abi_encode_packed(&self) -> alloy_sol_types::private::Vec<u8> {
                <Self as alloy_sol_types::SolType>::abi_encode_packed(&self.0)
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolType for EdgeStatus {
            type RustType = u8;
            type Token<'a> = <alloy::sol_types::sol_data::Uint<
                8,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SOL_NAME: &'static str = Self::NAME;
            const ENCODED_SIZE: Option<usize> = <alloy::sol_types::sol_data::Uint<
                8,
            > as alloy_sol_types::SolType>::ENCODED_SIZE;
            const PACKED_ENCODED_SIZE: Option<usize> = <alloy::sol_types::sol_data::Uint<
                8,
            > as alloy_sol_types::SolType>::PACKED_ENCODED_SIZE;
            #[inline]
            fn valid_token(token: &Self::Token<'_>) -> bool {
                Self::type_check(token).is_ok()
            }
            #[inline]
            fn type_check(token: &Self::Token<'_>) -> alloy_sol_types::Result<()> {
                <alloy::sol_types::sol_data::Uint<
                    8,
                > as alloy_sol_types::SolType>::type_check(token)
            }
            #[inline]
            fn detokenize(token: Self::Token<'_>) -> Self::RustType {
                <alloy::sol_types::sol_data::Uint<
                    8,
                > as alloy_sol_types::SolType>::detokenize(token)
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::EventTopic for EdgeStatus {
            #[inline]
            fn topic_preimage_length(rust: &Self::RustType) -> usize {
                <alloy::sol_types::sol_data::Uint<
                    8,
                > as alloy_sol_types::EventTopic>::topic_preimage_length(rust)
            }
            #[inline]
            fn encode_topic_preimage(
                rust: &Self::RustType,
                out: &mut alloy_sol_types::private::Vec<u8>,
            ) {
                <alloy::sol_types::sol_data::Uint<
                    8,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(rust, out)
            }
            #[inline]
            fn encode_topic(
                rust: &Self::RustType,
            ) -> alloy_sol_types::abi::token::WordToken {
                <alloy::sol_types::sol_data::Uint<
                    8,
                > as alloy_sol_types::EventTopic>::encode_topic(rust)
            }
        }
    };
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct EdgeType(u8);
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[automatically_derived]
        impl alloy_sol_types::private::SolTypeValue<EdgeType> for u8 {
            #[inline]
            fn stv_to_tokens(
                &self,
            ) -> <alloy::sol_types::sol_data::Uint<
                8,
            > as alloy_sol_types::SolType>::Token<'_> {
                alloy_sol_types::private::SolTypeValue::<
                    alloy::sol_types::sol_data::Uint<8>,
                >::stv_to_tokens(self)
            }
            #[inline]
            fn stv_eip712_data_word(&self) -> alloy_sol_types::Word {
                <alloy::sol_types::sol_data::Uint<
                    8,
                > as alloy_sol_types::SolType>::tokenize(self)
                    .0
            }
            #[inline]
            fn stv_abi_encode_packed_to(
                &self,
                out: &mut alloy_sol_types::private::Vec<u8>,
            ) {
                <alloy::sol_types::sol_data::Uint<
                    8,
                > as alloy_sol_types::SolType>::abi_encode_packed_to(self, out)
            }
            #[inline]
            fn stv_abi_packed_encoded_size(&self) -> usize {
                <alloy::sol_types::sol_data::Uint<
                    8,
                > as alloy_sol_types::SolType>::abi_encoded_size(self)
            }
        }
        #[automatically_derived]
        impl EdgeType {
            /// The Solidity type name.
            pub const NAME: &'static str = stringify!(@ name);
            /// Convert from the underlying value type.
            #[inline]
            pub const fn from(value: u8) -> Self {
                Self(value)
            }
            /// Return the underlying value.
            #[inline]
            pub const fn into(self) -> u8 {
                self.0
            }
            /// Return the single encoding of this value, delegating to the
            /// underlying type.
            #[inline]
            pub fn abi_encode(&self) -> alloy_sol_types::private::Vec<u8> {
                <Self as alloy_sol_types::SolType>::abi_encode(&self.0)
            }
            /// Return the packed encoding of this value, delegating to the
            /// underlying type.
            #[inline]
            pub fn abi_encode_packed(&self) -> alloy_sol_types::private::Vec<u8> {
                <Self as alloy_sol_types::SolType>::abi_encode_packed(&self.0)
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolType for EdgeType {
            type RustType = u8;
            type Token<'a> = <alloy::sol_types::sol_data::Uint<
                8,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SOL_NAME: &'static str = Self::NAME;
            const ENCODED_SIZE: Option<usize> = <alloy::sol_types::sol_data::Uint<
                8,
            > as alloy_sol_types::SolType>::ENCODED_SIZE;
            const PACKED_ENCODED_SIZE: Option<usize> = <alloy::sol_types::sol_data::Uint<
                8,
            > as alloy_sol_types::SolType>::PACKED_ENCODED_SIZE;
            #[inline]
            fn valid_token(token: &Self::Token<'_>) -> bool {
                Self::type_check(token).is_ok()
            }
            #[inline]
            fn type_check(token: &Self::Token<'_>) -> alloy_sol_types::Result<()> {
                <alloy::sol_types::sol_data::Uint<
                    8,
                > as alloy_sol_types::SolType>::type_check(token)
            }
            #[inline]
            fn detokenize(token: Self::Token<'_>) -> Self::RustType {
                <alloy::sol_types::sol_data::Uint<
                    8,
                > as alloy_sol_types::SolType>::detokenize(token)
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::EventTopic for EdgeType {
            #[inline]
            fn topic_preimage_length(rust: &Self::RustType) -> usize {
                <alloy::sol_types::sol_data::Uint<
                    8,
                > as alloy_sol_types::EventTopic>::topic_preimage_length(rust)
            }
            #[inline]
            fn encode_topic_preimage(
                rust: &Self::RustType,
                out: &mut alloy_sol_types::private::Vec<u8>,
            ) {
                <alloy::sol_types::sol_data::Uint<
                    8,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(rust, out)
            }
            #[inline]
            fn encode_topic(
                rust: &Self::RustType,
            ) -> alloy_sol_types::abi::token::WordToken {
                <alloy::sol_types::sol_data::Uint<
                    8,
                > as alloy_sol_types::EventTopic>::encode_topic(rust)
            }
        }
    };
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct MachineStatus(u8);
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[automatically_derived]
        impl alloy_sol_types::private::SolTypeValue<MachineStatus> for u8 {
            #[inline]
            fn stv_to_tokens(
                &self,
            ) -> <alloy::sol_types::sol_data::Uint<
                8,
            > as alloy_sol_types::SolType>::Token<'_> {
                alloy_sol_types::private::SolTypeValue::<
                    alloy::sol_types::sol_data::Uint<8>,
                >::stv_to_tokens(self)
            }
            #[inline]
            fn stv_eip712_data_word(&self) -> alloy_sol_types::Word {
                <alloy::sol_types::sol_data::Uint<
                    8,
                > as alloy_sol_types::SolType>::tokenize(self)
                    .0
            }
            #[inline]
            fn stv_abi_encode_packed_to(
                &self,
                out: &mut alloy_sol_types::private::Vec<u8>,
            ) {
                <alloy::sol_types::sol_data::Uint<
                    8,
                > as alloy_sol_types::SolType>::abi_encode_packed_to(self, out)
            }
            #[inline]
            fn stv_abi_packed_encoded_size(&self) -> usize {
                <alloy::sol_types::sol_data::Uint<
                    8,
                > as alloy_sol_types::SolType>::abi_encoded_size(self)
            }
        }
        #[automatically_derived]
        impl MachineStatus {
            /// The Solidity type name.
            pub const NAME: &'static str = stringify!(@ name);
            /// Convert from the underlying value type.
            #[inline]
            pub const fn from(value: u8) -> Self {
                Self(value)
            }
            /// Return the underlying value.
            #[inline]
            pub const fn into(self) -> u8 {
                self.0
            }
            /// Return the single encoding of this value, delegating to the
            /// underlying type.
            #[inline]
            pub fn abi_encode(&self) -> alloy_sol_types::private::Vec<u8> {
                <Self as alloy_sol_types::SolType>::abi_encode(&self.0)
            }
            /// Return the packed encoding of this value, delegating to the
            /// underlying type.
            #[inline]
            pub fn abi_encode_packed(&self) -> alloy_sol_types::private::Vec<u8> {
                <Self as alloy_sol_types::SolType>::abi_encode_packed(&self.0)
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolType for MachineStatus {
            type RustType = u8;
            type Token<'a> = <alloy::sol_types::sol_data::Uint<
                8,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SOL_NAME: &'static str = Self::NAME;
            const ENCODED_SIZE: Option<usize> = <alloy::sol_types::sol_data::Uint<
                8,
            > as alloy_sol_types::SolType>::ENCODED_SIZE;
            const PACKED_ENCODED_SIZE: Option<usize> = <alloy::sol_types::sol_data::Uint<
                8,
            > as alloy_sol_types::SolType>::PACKED_ENCODED_SIZE;
            #[inline]
            fn valid_token(token: &Self::Token<'_>) -> bool {
                Self::type_check(token).is_ok()
            }
            #[inline]
            fn type_check(token: &Self::Token<'_>) -> alloy_sol_types::Result<()> {
                <alloy::sol_types::sol_data::Uint<
                    8,
                > as alloy_sol_types::SolType>::type_check(token)
            }
            #[inline]
            fn detokenize(token: Self::Token<'_>) -> Self::RustType {
                <alloy::sol_types::sol_data::Uint<
                    8,
                > as alloy_sol_types::SolType>::detokenize(token)
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::EventTopic for MachineStatus {
            #[inline]
            fn topic_preimage_length(rust: &Self::RustType) -> usize {
                <alloy::sol_types::sol_data::Uint<
                    8,
                > as alloy_sol_types::EventTopic>::topic_preimage_length(rust)
            }
            #[inline]
            fn encode_topic_preimage(
                rust: &Self::RustType,
                out: &mut alloy_sol_types::private::Vec<u8>,
            ) {
                <alloy::sol_types::sol_data::Uint<
                    8,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(rust, out)
            }
            #[inline]
            fn encode_topic(
                rust: &Self::RustType,
            ) -> alloy_sol_types::abi::token::WordToken {
                <alloy::sol_types::sol_data::Uint<
                    8,
                > as alloy_sol_types::EventTopic>::encode_topic(rust)
            }
        }
    };
    /**```solidity
struct AssertionState { GlobalState globalState; MachineStatus machineStatus; bytes32 endHistoryRoot; }
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct AssertionState {
        pub globalState: <GlobalState as alloy::sol_types::SolType>::RustType,
        pub machineStatus: <MachineStatus as alloy::sol_types::SolType>::RustType,
        pub endHistoryRoot: alloy::sol_types::private::FixedBytes<32>,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = (
            GlobalState,
            MachineStatus,
            alloy::sol_types::sol_data::FixedBytes<32>,
        );
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = (
            <GlobalState as alloy::sol_types::SolType>::RustType,
            <MachineStatus as alloy::sol_types::SolType>::RustType,
            alloy::sol_types::private::FixedBytes<32>,
        );
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<AssertionState> for UnderlyingRustTuple<'_> {
            fn from(value: AssertionState) -> Self {
                (value.globalState, value.machineStatus, value.endHistoryRoot)
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for AssertionState {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self {
                    globalState: tuple.0,
                    machineStatus: tuple.1,
                    endHistoryRoot: tuple.2,
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolValue for AssertionState {
            type SolType = Self;
        }
        #[automatically_derived]
        impl alloy_sol_types::private::SolTypeValue<Self> for AssertionState {
            #[inline]
            fn stv_to_tokens(&self) -> <Self as alloy_sol_types::SolType>::Token<'_> {
                (
                    <GlobalState as alloy_sol_types::SolType>::tokenize(
                        &self.globalState,
                    ),
                    <MachineStatus as alloy_sol_types::SolType>::tokenize(
                        &self.machineStatus,
                    ),
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.endHistoryRoot),
                )
            }
            #[inline]
            fn stv_abi_encoded_size(&self) -> usize {
                if let Some(size) = <Self as alloy_sol_types::SolType>::ENCODED_SIZE {
                    return size;
                }
                let tuple = <UnderlyingRustTuple<
                    '_,
                > as ::core::convert::From<Self>>::from(self.clone());
                <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_encoded_size(&tuple)
            }
            #[inline]
            fn stv_eip712_data_word(&self) -> alloy_sol_types::Word {
                <Self as alloy_sol_types::SolStruct>::eip712_hash_struct(self)
            }
            #[inline]
            fn stv_abi_encode_packed_to(
                &self,
                out: &mut alloy_sol_types::private::Vec<u8>,
            ) {
                let tuple = <UnderlyingRustTuple<
                    '_,
                > as ::core::convert::From<Self>>::from(self.clone());
                <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_encode_packed_to(&tuple, out)
            }
            #[inline]
            fn stv_abi_packed_encoded_size(&self) -> usize {
                if let Some(size) = <Self as alloy_sol_types::SolType>::PACKED_ENCODED_SIZE {
                    return size;
                }
                let tuple = <UnderlyingRustTuple<
                    '_,
                > as ::core::convert::From<Self>>::from(self.clone());
                <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_packed_encoded_size(&tuple)
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolType for AssertionState {
            type RustType = Self;
            type Token<'a> = <UnderlyingSolTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SOL_NAME: &'static str = <Self as alloy_sol_types::SolStruct>::NAME;
            const ENCODED_SIZE: Option<usize> = <UnderlyingSolTuple<
                '_,
            > as alloy_sol_types::SolType>::ENCODED_SIZE;
            const PACKED_ENCODED_SIZE: Option<usize> = <UnderlyingSolTuple<
                '_,
            > as alloy_sol_types::SolType>::PACKED_ENCODED_SIZE;
            #[inline]
            fn valid_token(token: &Self::Token<'_>) -> bool {
                <UnderlyingSolTuple<'_> as alloy_sol_types::SolType>::valid_token(token)
            }
            #[inline]
            fn detokenize(token: Self::Token<'_>) -> Self::RustType {
                let tuple = <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::detokenize(token);
                <Self as ::core::convert::From<UnderlyingRustTuple<'_>>>::from(tuple)
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolStruct for AssertionState {
            const NAME: &'static str = "AssertionState";
            #[inline]
            fn eip712_root_type() -> alloy_sol_types::private::Cow<'static, str> {
                alloy_sol_types::private::Cow::Borrowed(
                    "AssertionState(GlobalState globalState,uint8 machineStatus,bytes32 endHistoryRoot)",
                )
            }
            #[inline]
            fn eip712_components() -> alloy_sol_types::private::Vec<
                alloy_sol_types::private::Cow<'static, str>,
            > {
                let mut components = alloy_sol_types::private::Vec::with_capacity(1);
                components
                    .push(
                        <GlobalState as alloy_sol_types::SolStruct>::eip712_root_type(),
                    );
                components
                    .extend(
                        <GlobalState as alloy_sol_types::SolStruct>::eip712_components(),
                    );
                components
            }
            #[inline]
            fn eip712_encode_data(&self) -> alloy_sol_types::private::Vec<u8> {
                [
                    <GlobalState as alloy_sol_types::SolType>::eip712_data_word(
                            &self.globalState,
                        )
                        .0,
                    <MachineStatus as alloy_sol_types::SolType>::eip712_data_word(
                            &self.machineStatus,
                        )
                        .0,
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::eip712_data_word(
                            &self.endHistoryRoot,
                        )
                        .0,
                ]
                    .concat()
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::EventTopic for AssertionState {
            #[inline]
            fn topic_preimage_length(rust: &Self::RustType) -> usize {
                0usize
                    + <GlobalState as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.globalState,
                    )
                    + <MachineStatus as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.machineStatus,
                    )
                    + <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.endHistoryRoot,
                    )
            }
            #[inline]
            fn encode_topic_preimage(
                rust: &Self::RustType,
                out: &mut alloy_sol_types::private::Vec<u8>,
            ) {
                out.reserve(
                    <Self as alloy_sol_types::EventTopic>::topic_preimage_length(rust),
                );
                <GlobalState as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.globalState,
                    out,
                );
                <MachineStatus as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.machineStatus,
                    out,
                );
                <alloy::sol_types::sol_data::FixedBytes<
                    32,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.endHistoryRoot,
                    out,
                );
            }
            #[inline]
            fn encode_topic(
                rust: &Self::RustType,
            ) -> alloy_sol_types::abi::token::WordToken {
                let mut out = alloy_sol_types::private::Vec::new();
                <Self as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    rust,
                    &mut out,
                );
                alloy_sol_types::abi::token::WordToken(
                    alloy_sol_types::private::keccak256(out),
                )
            }
        }
    };
    /**```solidity
struct AssertionStateData { AssertionState assertionState; bytes32 prevAssertionHash; bytes32 inboxAcc; }
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct AssertionStateData {
        pub assertionState: <AssertionState as alloy::sol_types::SolType>::RustType,
        pub prevAssertionHash: alloy::sol_types::private::FixedBytes<32>,
        pub inboxAcc: alloy::sol_types::private::FixedBytes<32>,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = (
            AssertionState,
            alloy::sol_types::sol_data::FixedBytes<32>,
            alloy::sol_types::sol_data::FixedBytes<32>,
        );
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = (
            <AssertionState as alloy::sol_types::SolType>::RustType,
            alloy::sol_types::private::FixedBytes<32>,
            alloy::sol_types::private::FixedBytes<32>,
        );
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<AssertionStateData> for UnderlyingRustTuple<'_> {
            fn from(value: AssertionStateData) -> Self {
                (value.assertionState, value.prevAssertionHash, value.inboxAcc)
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for AssertionStateData {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self {
                    assertionState: tuple.0,
                    prevAssertionHash: tuple.1,
                    inboxAcc: tuple.2,
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolValue for AssertionStateData {
            type SolType = Self;
        }
        #[automatically_derived]
        impl alloy_sol_types::private::SolTypeValue<Self> for AssertionStateData {
            #[inline]
            fn stv_to_tokens(&self) -> <Self as alloy_sol_types::SolType>::Token<'_> {
                (
                    <AssertionState as alloy_sol_types::SolType>::tokenize(
                        &self.assertionState,
                    ),
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.prevAssertionHash),
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.inboxAcc),
                )
            }
            #[inline]
            fn stv_abi_encoded_size(&self) -> usize {
                if let Some(size) = <Self as alloy_sol_types::SolType>::ENCODED_SIZE {
                    return size;
                }
                let tuple = <UnderlyingRustTuple<
                    '_,
                > as ::core::convert::From<Self>>::from(self.clone());
                <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_encoded_size(&tuple)
            }
            #[inline]
            fn stv_eip712_data_word(&self) -> alloy_sol_types::Word {
                <Self as alloy_sol_types::SolStruct>::eip712_hash_struct(self)
            }
            #[inline]
            fn stv_abi_encode_packed_to(
                &self,
                out: &mut alloy_sol_types::private::Vec<u8>,
            ) {
                let tuple = <UnderlyingRustTuple<
                    '_,
                > as ::core::convert::From<Self>>::from(self.clone());
                <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_encode_packed_to(&tuple, out)
            }
            #[inline]
            fn stv_abi_packed_encoded_size(&self) -> usize {
                if let Some(size) = <Self as alloy_sol_types::SolType>::PACKED_ENCODED_SIZE {
                    return size;
                }
                let tuple = <UnderlyingRustTuple<
                    '_,
                > as ::core::convert::From<Self>>::from(self.clone());
                <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_packed_encoded_size(&tuple)
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolType for AssertionStateData {
            type RustType = Self;
            type Token<'a> = <UnderlyingSolTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SOL_NAME: &'static str = <Self as alloy_sol_types::SolStruct>::NAME;
            const ENCODED_SIZE: Option<usize> = <UnderlyingSolTuple<
                '_,
            > as alloy_sol_types::SolType>::ENCODED_SIZE;
            const PACKED_ENCODED_SIZE: Option<usize> = <UnderlyingSolTuple<
                '_,
            > as alloy_sol_types::SolType>::PACKED_ENCODED_SIZE;
            #[inline]
            fn valid_token(token: &Self::Token<'_>) -> bool {
                <UnderlyingSolTuple<'_> as alloy_sol_types::SolType>::valid_token(token)
            }
            #[inline]
            fn detokenize(token: Self::Token<'_>) -> Self::RustType {
                let tuple = <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::detokenize(token);
                <Self as ::core::convert::From<UnderlyingRustTuple<'_>>>::from(tuple)
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolStruct for AssertionStateData {
            const NAME: &'static str = "AssertionStateData";
            #[inline]
            fn eip712_root_type() -> alloy_sol_types::private::Cow<'static, str> {
                alloy_sol_types::private::Cow::Borrowed(
                    "AssertionStateData(AssertionState assertionState,bytes32 prevAssertionHash,bytes32 inboxAcc)",
                )
            }
            #[inline]
            fn eip712_components() -> alloy_sol_types::private::Vec<
                alloy_sol_types::private::Cow<'static, str>,
            > {
                let mut components = alloy_sol_types::private::Vec::with_capacity(1);
                components
                    .push(
                        <AssertionState as alloy_sol_types::SolStruct>::eip712_root_type(),
                    );
                components
                    .extend(
                        <AssertionState as alloy_sol_types::SolStruct>::eip712_components(),
                    );
                components
            }
            #[inline]
            fn eip712_encode_data(&self) -> alloy_sol_types::private::Vec<u8> {
                [
                    <AssertionState as alloy_sol_types::SolType>::eip712_data_word(
                            &self.assertionState,
                        )
                        .0,
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::eip712_data_word(
                            &self.prevAssertionHash,
                        )
                        .0,
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::eip712_data_word(&self.inboxAcc)
                        .0,
                ]
                    .concat()
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::EventTopic for AssertionStateData {
            #[inline]
            fn topic_preimage_length(rust: &Self::RustType) -> usize {
                0usize
                    + <AssertionState as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.assertionState,
                    )
                    + <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.prevAssertionHash,
                    )
                    + <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.inboxAcc,
                    )
            }
            #[inline]
            fn encode_topic_preimage(
                rust: &Self::RustType,
                out: &mut alloy_sol_types::private::Vec<u8>,
            ) {
                out.reserve(
                    <Self as alloy_sol_types::EventTopic>::topic_preimage_length(rust),
                );
                <AssertionState as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.assertionState,
                    out,
                );
                <alloy::sol_types::sol_data::FixedBytes<
                    32,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.prevAssertionHash,
                    out,
                );
                <alloy::sol_types::sol_data::FixedBytes<
                    32,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.inboxAcc,
                    out,
                );
            }
            #[inline]
            fn encode_topic(
                rust: &Self::RustType,
            ) -> alloy_sol_types::abi::token::WordToken {
                let mut out = alloy_sol_types::private::Vec::new();
                <Self as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    rust,
                    &mut out,
                );
                alloy_sol_types::abi::token::WordToken(
                    alloy_sol_types::private::keccak256(out),
                )
            }
        }
    };
    /**```solidity
struct ChallengeEdge { bytes32 originId; bytes32 startHistoryRoot; uint256 startHeight; bytes32 endHistoryRoot; uint256 endHeight; bytes32 lowerChildId; bytes32 upperChildId; bytes32 claimId; address staker; uint64 createdAtBlock; uint64 confirmedAtBlock; EdgeStatus status; uint8 level; bool refunded; uint64 totalTimeUnrivaledCache; }
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct ChallengeEdge {
        pub originId: alloy::sol_types::private::FixedBytes<32>,
        pub startHistoryRoot: alloy::sol_types::private::FixedBytes<32>,
        pub startHeight: alloy::sol_types::private::primitives::aliases::U256,
        pub endHistoryRoot: alloy::sol_types::private::FixedBytes<32>,
        pub endHeight: alloy::sol_types::private::primitives::aliases::U256,
        pub lowerChildId: alloy::sol_types::private::FixedBytes<32>,
        pub upperChildId: alloy::sol_types::private::FixedBytes<32>,
        pub claimId: alloy::sol_types::private::FixedBytes<32>,
        pub staker: alloy::sol_types::private::Address,
        pub createdAtBlock: u64,
        pub confirmedAtBlock: u64,
        pub status: <EdgeStatus as alloy::sol_types::SolType>::RustType,
        pub level: u8,
        pub refunded: bool,
        pub totalTimeUnrivaledCache: u64,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = (
            alloy::sol_types::sol_data::FixedBytes<32>,
            alloy::sol_types::sol_data::FixedBytes<32>,
            alloy::sol_types::sol_data::Uint<256>,
            alloy::sol_types::sol_data::FixedBytes<32>,
            alloy::sol_types::sol_data::Uint<256>,
            alloy::sol_types::sol_data::FixedBytes<32>,
            alloy::sol_types::sol_data::FixedBytes<32>,
            alloy::sol_types::sol_data::FixedBytes<32>,
            alloy::sol_types::sol_data::Address,
            alloy::sol_types::sol_data::Uint<64>,
            alloy::sol_types::sol_data::Uint<64>,
            EdgeStatus,
            alloy::sol_types::sol_data::Uint<8>,
            alloy::sol_types::sol_data::Bool,
            alloy::sol_types::sol_data::Uint<64>,
        );
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = (
            alloy::sol_types::private::FixedBytes<32>,
            alloy::sol_types::private::FixedBytes<32>,
            alloy::sol_types::private::primitives::aliases::U256,
            alloy::sol_types::private::FixedBytes<32>,
            alloy::sol_types::private::primitives::aliases::U256,
            alloy::sol_types::private::FixedBytes<32>,
            alloy::sol_types::private::FixedBytes<32>,
            alloy::sol_types::private::FixedBytes<32>,
            alloy::sol_types::private::Address,
            u64,
            u64,
            <EdgeStatus as alloy::sol_types::SolType>::RustType,
            u8,
            bool,
            u64,
        );
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<ChallengeEdge> for UnderlyingRustTuple<'_> {
            fn from(value: ChallengeEdge) -> Self {
                (
                    value.originId,
                    value.startHistoryRoot,
                    value.startHeight,
                    value.endHistoryRoot,
                    value.endHeight,
                    value.lowerChildId,
                    value.upperChildId,
                    value.claimId,
                    value.staker,
                    value.createdAtBlock,
                    value.confirmedAtBlock,
                    value.status,
                    value.level,
                    value.refunded,
                    value.totalTimeUnrivaledCache,
                )
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for ChallengeEdge {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self {
                    originId: tuple.0,
                    startHistoryRoot: tuple.1,
                    startHeight: tuple.2,
                    endHistoryRoot: tuple.3,
                    endHeight: tuple.4,
                    lowerChildId: tuple.5,
                    upperChildId: tuple.6,
                    claimId: tuple.7,
                    staker: tuple.8,
                    createdAtBlock: tuple.9,
                    confirmedAtBlock: tuple.10,
                    status: tuple.11,
                    level: tuple.12,
                    refunded: tuple.13,
                    totalTimeUnrivaledCache: tuple.14,
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolValue for ChallengeEdge {
            type SolType = Self;
        }
        #[automatically_derived]
        impl alloy_sol_types::private::SolTypeValue<Self> for ChallengeEdge {
            #[inline]
            fn stv_to_tokens(&self) -> <Self as alloy_sol_types::SolType>::Token<'_> {
                (
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.originId),
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.startHistoryRoot),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.startHeight),
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.endHistoryRoot),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.endHeight),
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.lowerChildId),
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.upperChildId),
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.claimId),
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.staker,
                    ),
                    <alloy::sol_types::sol_data::Uint<
                        64,
                    > as alloy_sol_types::SolType>::tokenize(&self.createdAtBlock),
                    <alloy::sol_types::sol_data::Uint<
                        64,
                    > as alloy_sol_types::SolType>::tokenize(&self.confirmedAtBlock),
                    <EdgeStatus as alloy_sol_types::SolType>::tokenize(&self.status),
                    <alloy::sol_types::sol_data::Uint<
                        8,
                    > as alloy_sol_types::SolType>::tokenize(&self.level),
                    <alloy::sol_types::sol_data::Bool as alloy_sol_types::SolType>::tokenize(
                        &self.refunded,
                    ),
                    <alloy::sol_types::sol_data::Uint<
                        64,
                    > as alloy_sol_types::SolType>::tokenize(
                        &self.totalTimeUnrivaledCache,
                    ),
                )
            }
            #[inline]
            fn stv_abi_encoded_size(&self) -> usize {
                if let Some(size) = <Self as alloy_sol_types::SolType>::ENCODED_SIZE {
                    return size;
                }
                let tuple = <UnderlyingRustTuple<
                    '_,
                > as ::core::convert::From<Self>>::from(self.clone());
                <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_encoded_size(&tuple)
            }
            #[inline]
            fn stv_eip712_data_word(&self) -> alloy_sol_types::Word {
                <Self as alloy_sol_types::SolStruct>::eip712_hash_struct(self)
            }
            #[inline]
            fn stv_abi_encode_packed_to(
                &self,
                out: &mut alloy_sol_types::private::Vec<u8>,
            ) {
                let tuple = <UnderlyingRustTuple<
                    '_,
                > as ::core::convert::From<Self>>::from(self.clone());
                <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_encode_packed_to(&tuple, out)
            }
            #[inline]
            fn stv_abi_packed_encoded_size(&self) -> usize {
                if let Some(size) = <Self as alloy_sol_types::SolType>::PACKED_ENCODED_SIZE {
                    return size;
                }
                let tuple = <UnderlyingRustTuple<
                    '_,
                > as ::core::convert::From<Self>>::from(self.clone());
                <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_packed_encoded_size(&tuple)
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolType for ChallengeEdge {
            type RustType = Self;
            type Token<'a> = <UnderlyingSolTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SOL_NAME: &'static str = <Self as alloy_sol_types::SolStruct>::NAME;
            const ENCODED_SIZE: Option<usize> = <UnderlyingSolTuple<
                '_,
            > as alloy_sol_types::SolType>::ENCODED_SIZE;
            const PACKED_ENCODED_SIZE: Option<usize> = <UnderlyingSolTuple<
                '_,
            > as alloy_sol_types::SolType>::PACKED_ENCODED_SIZE;
            #[inline]
            fn valid_token(token: &Self::Token<'_>) -> bool {
                <UnderlyingSolTuple<'_> as alloy_sol_types::SolType>::valid_token(token)
            }
            #[inline]
            fn detokenize(token: Self::Token<'_>) -> Self::RustType {
                let tuple = <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::detokenize(token);
                <Self as ::core::convert::From<UnderlyingRustTuple<'_>>>::from(tuple)
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolStruct for ChallengeEdge {
            const NAME: &'static str = "ChallengeEdge";
            #[inline]
            fn eip712_root_type() -> alloy_sol_types::private::Cow<'static, str> {
                alloy_sol_types::private::Cow::Borrowed(
                    "ChallengeEdge(bytes32 originId,bytes32 startHistoryRoot,uint256 startHeight,bytes32 endHistoryRoot,uint256 endHeight,bytes32 lowerChildId,bytes32 upperChildId,bytes32 claimId,address staker,uint64 createdAtBlock,uint64 confirmedAtBlock,uint8 status,uint8 level,bool refunded,uint64 totalTimeUnrivaledCache)",
                )
            }
            #[inline]
            fn eip712_components() -> alloy_sol_types::private::Vec<
                alloy_sol_types::private::Cow<'static, str>,
            > {
                alloy_sol_types::private::Vec::new()
            }
            #[inline]
            fn eip712_encode_type() -> alloy_sol_types::private::Cow<'static, str> {
                <Self as alloy_sol_types::SolStruct>::eip712_root_type()
            }
            #[inline]
            fn eip712_encode_data(&self) -> alloy_sol_types::private::Vec<u8> {
                [
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::eip712_data_word(&self.originId)
                        .0,
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::eip712_data_word(
                            &self.startHistoryRoot,
                        )
                        .0,
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::eip712_data_word(&self.startHeight)
                        .0,
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::eip712_data_word(
                            &self.endHistoryRoot,
                        )
                        .0,
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::eip712_data_word(&self.endHeight)
                        .0,
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::eip712_data_word(&self.lowerChildId)
                        .0,
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::eip712_data_word(&self.upperChildId)
                        .0,
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::eip712_data_word(&self.claimId)
                        .0,
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::eip712_data_word(
                            &self.staker,
                        )
                        .0,
                    <alloy::sol_types::sol_data::Uint<
                        64,
                    > as alloy_sol_types::SolType>::eip712_data_word(
                            &self.createdAtBlock,
                        )
                        .0,
                    <alloy::sol_types::sol_data::Uint<
                        64,
                    > as alloy_sol_types::SolType>::eip712_data_word(
                            &self.confirmedAtBlock,
                        )
                        .0,
                    <EdgeStatus as alloy_sol_types::SolType>::eip712_data_word(
                            &self.status,
                        )
                        .0,
                    <alloy::sol_types::sol_data::Uint<
                        8,
                    > as alloy_sol_types::SolType>::eip712_data_word(&self.level)
                        .0,
                    <alloy::sol_types::sol_data::Bool as alloy_sol_types::SolType>::eip712_data_word(
                            &self.refunded,
                        )
                        .0,
                    <alloy::sol_types::sol_data::Uint<
                        64,
                    > as alloy_sol_types::SolType>::eip712_data_word(
                            &self.totalTimeUnrivaledCache,
                        )
                        .0,
                ]
                    .concat()
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::EventTopic for ChallengeEdge {
            #[inline]
            fn topic_preimage_length(rust: &Self::RustType) -> usize {
                0usize
                    + <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.originId,
                    )
                    + <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.startHistoryRoot,
                    )
                    + <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.startHeight,
                    )
                    + <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.endHistoryRoot,
                    )
                    + <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.endHeight,
                    )
                    + <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.lowerChildId,
                    )
                    + <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.upperChildId,
                    )
                    + <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.claimId,
                    )
                    + <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.staker,
                    )
                    + <alloy::sol_types::sol_data::Uint<
                        64,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.createdAtBlock,
                    )
                    + <alloy::sol_types::sol_data::Uint<
                        64,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.confirmedAtBlock,
                    )
                    + <EdgeStatus as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.status,
                    )
                    + <alloy::sol_types::sol_data::Uint<
                        8,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(&rust.level)
                    + <alloy::sol_types::sol_data::Bool as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.refunded,
                    )
                    + <alloy::sol_types::sol_data::Uint<
                        64,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.totalTimeUnrivaledCache,
                    )
            }
            #[inline]
            fn encode_topic_preimage(
                rust: &Self::RustType,
                out: &mut alloy_sol_types::private::Vec<u8>,
            ) {
                out.reserve(
                    <Self as alloy_sol_types::EventTopic>::topic_preimage_length(rust),
                );
                <alloy::sol_types::sol_data::FixedBytes<
                    32,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.originId,
                    out,
                );
                <alloy::sol_types::sol_data::FixedBytes<
                    32,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.startHistoryRoot,
                    out,
                );
                <alloy::sol_types::sol_data::Uint<
                    256,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.startHeight,
                    out,
                );
                <alloy::sol_types::sol_data::FixedBytes<
                    32,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.endHistoryRoot,
                    out,
                );
                <alloy::sol_types::sol_data::Uint<
                    256,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.endHeight,
                    out,
                );
                <alloy::sol_types::sol_data::FixedBytes<
                    32,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.lowerChildId,
                    out,
                );
                <alloy::sol_types::sol_data::FixedBytes<
                    32,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.upperChildId,
                    out,
                );
                <alloy::sol_types::sol_data::FixedBytes<
                    32,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.claimId,
                    out,
                );
                <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.staker,
                    out,
                );
                <alloy::sol_types::sol_data::Uint<
                    64,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.createdAtBlock,
                    out,
                );
                <alloy::sol_types::sol_data::Uint<
                    64,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.confirmedAtBlock,
                    out,
                );
                <EdgeStatus as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.status,
                    out,
                );
                <alloy::sol_types::sol_data::Uint<
                    8,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.level,
                    out,
                );
                <alloy::sol_types::sol_data::Bool as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.refunded,
                    out,
                );
                <alloy::sol_types::sol_data::Uint<
                    64,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.totalTimeUnrivaledCache,
                    out,
                );
            }
            #[inline]
            fn encode_topic(
                rust: &Self::RustType,
            ) -> alloy_sol_types::abi::token::WordToken {
                let mut out = alloy_sol_types::private::Vec::new();
                <Self as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    rust,
                    &mut out,
                );
                alloy_sol_types::abi::token::WordToken(
                    alloy_sol_types::private::keccak256(out),
                )
            }
        }
    };
    /**```solidity
struct ConfigData { bytes32 wasmModuleRoot; uint256 requiredStake; address challengeManager; uint64 confirmPeriodBlocks; uint64 nextInboxPosition; }
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct ConfigData {
        pub wasmModuleRoot: alloy::sol_types::private::FixedBytes<32>,
        pub requiredStake: alloy::sol_types::private::primitives::aliases::U256,
        pub challengeManager: alloy::sol_types::private::Address,
        pub confirmPeriodBlocks: u64,
        pub nextInboxPosition: u64,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = (
            alloy::sol_types::sol_data::FixedBytes<32>,
            alloy::sol_types::sol_data::Uint<256>,
            alloy::sol_types::sol_data::Address,
            alloy::sol_types::sol_data::Uint<64>,
            alloy::sol_types::sol_data::Uint<64>,
        );
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = (
            alloy::sol_types::private::FixedBytes<32>,
            alloy::sol_types::private::primitives::aliases::U256,
            alloy::sol_types::private::Address,
            u64,
            u64,
        );
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<ConfigData> for UnderlyingRustTuple<'_> {
            fn from(value: ConfigData) -> Self {
                (
                    value.wasmModuleRoot,
                    value.requiredStake,
                    value.challengeManager,
                    value.confirmPeriodBlocks,
                    value.nextInboxPosition,
                )
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for ConfigData {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self {
                    wasmModuleRoot: tuple.0,
                    requiredStake: tuple.1,
                    challengeManager: tuple.2,
                    confirmPeriodBlocks: tuple.3,
                    nextInboxPosition: tuple.4,
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolValue for ConfigData {
            type SolType = Self;
        }
        #[automatically_derived]
        impl alloy_sol_types::private::SolTypeValue<Self> for ConfigData {
            #[inline]
            fn stv_to_tokens(&self) -> <Self as alloy_sol_types::SolType>::Token<'_> {
                (
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.wasmModuleRoot),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.requiredStake),
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.challengeManager,
                    ),
                    <alloy::sol_types::sol_data::Uint<
                        64,
                    > as alloy_sol_types::SolType>::tokenize(&self.confirmPeriodBlocks),
                    <alloy::sol_types::sol_data::Uint<
                        64,
                    > as alloy_sol_types::SolType>::tokenize(&self.nextInboxPosition),
                )
            }
            #[inline]
            fn stv_abi_encoded_size(&self) -> usize {
                if let Some(size) = <Self as alloy_sol_types::SolType>::ENCODED_SIZE {
                    return size;
                }
                let tuple = <UnderlyingRustTuple<
                    '_,
                > as ::core::convert::From<Self>>::from(self.clone());
                <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_encoded_size(&tuple)
            }
            #[inline]
            fn stv_eip712_data_word(&self) -> alloy_sol_types::Word {
                <Self as alloy_sol_types::SolStruct>::eip712_hash_struct(self)
            }
            #[inline]
            fn stv_abi_encode_packed_to(
                &self,
                out: &mut alloy_sol_types::private::Vec<u8>,
            ) {
                let tuple = <UnderlyingRustTuple<
                    '_,
                > as ::core::convert::From<Self>>::from(self.clone());
                <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_encode_packed_to(&tuple, out)
            }
            #[inline]
            fn stv_abi_packed_encoded_size(&self) -> usize {
                if let Some(size) = <Self as alloy_sol_types::SolType>::PACKED_ENCODED_SIZE {
                    return size;
                }
                let tuple = <UnderlyingRustTuple<
                    '_,
                > as ::core::convert::From<Self>>::from(self.clone());
                <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_packed_encoded_size(&tuple)
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolType for ConfigData {
            type RustType = Self;
            type Token<'a> = <UnderlyingSolTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SOL_NAME: &'static str = <Self as alloy_sol_types::SolStruct>::NAME;
            const ENCODED_SIZE: Option<usize> = <UnderlyingSolTuple<
                '_,
            > as alloy_sol_types::SolType>::ENCODED_SIZE;
            const PACKED_ENCODED_SIZE: Option<usize> = <UnderlyingSolTuple<
                '_,
            > as alloy_sol_types::SolType>::PACKED_ENCODED_SIZE;
            #[inline]
            fn valid_token(token: &Self::Token<'_>) -> bool {
                <UnderlyingSolTuple<'_> as alloy_sol_types::SolType>::valid_token(token)
            }
            #[inline]
            fn detokenize(token: Self::Token<'_>) -> Self::RustType {
                let tuple = <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::detokenize(token);
                <Self as ::core::convert::From<UnderlyingRustTuple<'_>>>::from(tuple)
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolStruct for ConfigData {
            const NAME: &'static str = "ConfigData";
            #[inline]
            fn eip712_root_type() -> alloy_sol_types::private::Cow<'static, str> {
                alloy_sol_types::private::Cow::Borrowed(
                    "ConfigData(bytes32 wasmModuleRoot,uint256 requiredStake,address challengeManager,uint64 confirmPeriodBlocks,uint64 nextInboxPosition)",
                )
            }
            #[inline]
            fn eip712_components() -> alloy_sol_types::private::Vec<
                alloy_sol_types::private::Cow<'static, str>,
            > {
                alloy_sol_types::private::Vec::new()
            }
            #[inline]
            fn eip712_encode_type() -> alloy_sol_types::private::Cow<'static, str> {
                <Self as alloy_sol_types::SolStruct>::eip712_root_type()
            }
            #[inline]
            fn eip712_encode_data(&self) -> alloy_sol_types::private::Vec<u8> {
                [
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::eip712_data_word(
                            &self.wasmModuleRoot,
                        )
                        .0,
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::eip712_data_word(&self.requiredStake)
                        .0,
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::eip712_data_word(
                            &self.challengeManager,
                        )
                        .0,
                    <alloy::sol_types::sol_data::Uint<
                        64,
                    > as alloy_sol_types::SolType>::eip712_data_word(
                            &self.confirmPeriodBlocks,
                        )
                        .0,
                    <alloy::sol_types::sol_data::Uint<
                        64,
                    > as alloy_sol_types::SolType>::eip712_data_word(
                            &self.nextInboxPosition,
                        )
                        .0,
                ]
                    .concat()
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::EventTopic for ConfigData {
            #[inline]
            fn topic_preimage_length(rust: &Self::RustType) -> usize {
                0usize
                    + <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.wasmModuleRoot,
                    )
                    + <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.requiredStake,
                    )
                    + <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.challengeManager,
                    )
                    + <alloy::sol_types::sol_data::Uint<
                        64,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.confirmPeriodBlocks,
                    )
                    + <alloy::sol_types::sol_data::Uint<
                        64,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.nextInboxPosition,
                    )
            }
            #[inline]
            fn encode_topic_preimage(
                rust: &Self::RustType,
                out: &mut alloy_sol_types::private::Vec<u8>,
            ) {
                out.reserve(
                    <Self as alloy_sol_types::EventTopic>::topic_preimage_length(rust),
                );
                <alloy::sol_types::sol_data::FixedBytes<
                    32,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.wasmModuleRoot,
                    out,
                );
                <alloy::sol_types::sol_data::Uint<
                    256,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.requiredStake,
                    out,
                );
                <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.challengeManager,
                    out,
                );
                <alloy::sol_types::sol_data::Uint<
                    64,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.confirmPeriodBlocks,
                    out,
                );
                <alloy::sol_types::sol_data::Uint<
                    64,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.nextInboxPosition,
                    out,
                );
            }
            #[inline]
            fn encode_topic(
                rust: &Self::RustType,
            ) -> alloy_sol_types::abi::token::WordToken {
                let mut out = alloy_sol_types::private::Vec::new();
                <Self as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    rust,
                    &mut out,
                );
                alloy_sol_types::abi::token::WordToken(
                    alloy_sol_types::private::keccak256(out),
                )
            }
        }
    };
    /**```solidity
struct CreateEdgeArgs { uint8 level; bytes32 endHistoryRoot; uint256 endHeight; bytes32 claimId; bytes prefixProof; bytes proof; }
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct CreateEdgeArgs {
        pub level: u8,
        pub endHistoryRoot: alloy::sol_types::private::FixedBytes<32>,
        pub endHeight: alloy::sol_types::private::primitives::aliases::U256,
        pub claimId: alloy::sol_types::private::FixedBytes<32>,
        pub prefixProof: alloy::sol_types::private::Bytes,
        pub proof: alloy::sol_types::private::Bytes,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = (
            alloy::sol_types::sol_data::Uint<8>,
            alloy::sol_types::sol_data::FixedBytes<32>,
            alloy::sol_types::sol_data::Uint<256>,
            alloy::sol_types::sol_data::FixedBytes<32>,
            alloy::sol_types::sol_data::Bytes,
            alloy::sol_types::sol_data::Bytes,
        );
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = (
            u8,
            alloy::sol_types::private::FixedBytes<32>,
            alloy::sol_types::private::primitives::aliases::U256,
            alloy::sol_types::private::FixedBytes<32>,
            alloy::sol_types::private::Bytes,
            alloy::sol_types::private::Bytes,
        );
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<CreateEdgeArgs> for UnderlyingRustTuple<'_> {
            fn from(value: CreateEdgeArgs) -> Self {
                (
                    value.level,
                    value.endHistoryRoot,
                    value.endHeight,
                    value.claimId,
                    value.prefixProof,
                    value.proof,
                )
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for CreateEdgeArgs {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self {
                    level: tuple.0,
                    endHistoryRoot: tuple.1,
                    endHeight: tuple.2,
                    claimId: tuple.3,
                    prefixProof: tuple.4,
                    proof: tuple.5,
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolValue for CreateEdgeArgs {
            type SolType = Self;
        }
        #[automatically_derived]
        impl alloy_sol_types::private::SolTypeValue<Self> for CreateEdgeArgs {
            #[inline]
            fn stv_to_tokens(&self) -> <Self as alloy_sol_types::SolType>::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        8,
                    > as alloy_sol_types::SolType>::tokenize(&self.level),
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.endHistoryRoot),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.endHeight),
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.claimId),
                    <alloy::sol_types::sol_data::Bytes as alloy_sol_types::SolType>::tokenize(
                        &self.prefixProof,
                    ),
                    <alloy::sol_types::sol_data::Bytes as alloy_sol_types::SolType>::tokenize(
                        &self.proof,
                    ),
                )
            }
            #[inline]
            fn stv_abi_encoded_size(&self) -> usize {
                if let Some(size) = <Self as alloy_sol_types::SolType>::ENCODED_SIZE {
                    return size;
                }
                let tuple = <UnderlyingRustTuple<
                    '_,
                > as ::core::convert::From<Self>>::from(self.clone());
                <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_encoded_size(&tuple)
            }
            #[inline]
            fn stv_eip712_data_word(&self) -> alloy_sol_types::Word {
                <Self as alloy_sol_types::SolStruct>::eip712_hash_struct(self)
            }
            #[inline]
            fn stv_abi_encode_packed_to(
                &self,
                out: &mut alloy_sol_types::private::Vec<u8>,
            ) {
                let tuple = <UnderlyingRustTuple<
                    '_,
                > as ::core::convert::From<Self>>::from(self.clone());
                <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_encode_packed_to(&tuple, out)
            }
            #[inline]
            fn stv_abi_packed_encoded_size(&self) -> usize {
                if let Some(size) = <Self as alloy_sol_types::SolType>::PACKED_ENCODED_SIZE {
                    return size;
                }
                let tuple = <UnderlyingRustTuple<
                    '_,
                > as ::core::convert::From<Self>>::from(self.clone());
                <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_packed_encoded_size(&tuple)
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolType for CreateEdgeArgs {
            type RustType = Self;
            type Token<'a> = <UnderlyingSolTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SOL_NAME: &'static str = <Self as alloy_sol_types::SolStruct>::NAME;
            const ENCODED_SIZE: Option<usize> = <UnderlyingSolTuple<
                '_,
            > as alloy_sol_types::SolType>::ENCODED_SIZE;
            const PACKED_ENCODED_SIZE: Option<usize> = <UnderlyingSolTuple<
                '_,
            > as alloy_sol_types::SolType>::PACKED_ENCODED_SIZE;
            #[inline]
            fn valid_token(token: &Self::Token<'_>) -> bool {
                <UnderlyingSolTuple<'_> as alloy_sol_types::SolType>::valid_token(token)
            }
            #[inline]
            fn detokenize(token: Self::Token<'_>) -> Self::RustType {
                let tuple = <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::detokenize(token);
                <Self as ::core::convert::From<UnderlyingRustTuple<'_>>>::from(tuple)
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolStruct for CreateEdgeArgs {
            const NAME: &'static str = "CreateEdgeArgs";
            #[inline]
            fn eip712_root_type() -> alloy_sol_types::private::Cow<'static, str> {
                alloy_sol_types::private::Cow::Borrowed(
                    "CreateEdgeArgs(uint8 level,bytes32 endHistoryRoot,uint256 endHeight,bytes32 claimId,bytes prefixProof,bytes proof)",
                )
            }
            #[inline]
            fn eip712_components() -> alloy_sol_types::private::Vec<
                alloy_sol_types::private::Cow<'static, str>,
            > {
                alloy_sol_types::private::Vec::new()
            }
            #[inline]
            fn eip712_encode_type() -> alloy_sol_types::private::Cow<'static, str> {
                <Self as alloy_sol_types::SolStruct>::eip712_root_type()
            }
            #[inline]
            fn eip712_encode_data(&self) -> alloy_sol_types::private::Vec<u8> {
                [
                    <alloy::sol_types::sol_data::Uint<
                        8,
                    > as alloy_sol_types::SolType>::eip712_data_word(&self.level)
                        .0,
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::eip712_data_word(
                            &self.endHistoryRoot,
                        )
                        .0,
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::eip712_data_word(&self.endHeight)
                        .0,
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::eip712_data_word(&self.claimId)
                        .0,
                    <alloy::sol_types::sol_data::Bytes as alloy_sol_types::SolType>::eip712_data_word(
                            &self.prefixProof,
                        )
                        .0,
                    <alloy::sol_types::sol_data::Bytes as alloy_sol_types::SolType>::eip712_data_word(
                            &self.proof,
                        )
                        .0,
                ]
                    .concat()
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::EventTopic for CreateEdgeArgs {
            #[inline]
            fn topic_preimage_length(rust: &Self::RustType) -> usize {
                0usize
                    + <alloy::sol_types::sol_data::Uint<
                        8,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(&rust.level)
                    + <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.endHistoryRoot,
                    )
                    + <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.endHeight,
                    )
                    + <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.claimId,
                    )
                    + <alloy::sol_types::sol_data::Bytes as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.prefixProof,
                    )
                    + <alloy::sol_types::sol_data::Bytes as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.proof,
                    )
            }
            #[inline]
            fn encode_topic_preimage(
                rust: &Self::RustType,
                out: &mut alloy_sol_types::private::Vec<u8>,
            ) {
                out.reserve(
                    <Self as alloy_sol_types::EventTopic>::topic_preimage_length(rust),
                );
                <alloy::sol_types::sol_data::Uint<
                    8,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.level,
                    out,
                );
                <alloy::sol_types::sol_data::FixedBytes<
                    32,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.endHistoryRoot,
                    out,
                );
                <alloy::sol_types::sol_data::Uint<
                    256,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.endHeight,
                    out,
                );
                <alloy::sol_types::sol_data::FixedBytes<
                    32,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.claimId,
                    out,
                );
                <alloy::sol_types::sol_data::Bytes as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.prefixProof,
                    out,
                );
                <alloy::sol_types::sol_data::Bytes as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.proof,
                    out,
                );
            }
            #[inline]
            fn encode_topic(
                rust: &Self::RustType,
            ) -> alloy_sol_types::abi::token::WordToken {
                let mut out = alloy_sol_types::private::Vec::new();
                <Self as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    rust,
                    &mut out,
                );
                alloy_sol_types::abi::token::WordToken(
                    alloy_sol_types::private::keccak256(out),
                )
            }
        }
    };
    /**```solidity
struct GlobalState { bytes32[2] bytes32Vals; uint64[2] u64Vals; }
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct GlobalState {
        pub bytes32Vals: [alloy::sol_types::private::FixedBytes<32>; 2usize],
        pub u64Vals: [u64; 2usize],
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = (
            alloy::sol_types::sol_data::FixedArray<
                alloy::sol_types::sol_data::FixedBytes<32>,
                2usize,
            >,
            alloy::sol_types::sol_data::FixedArray<
                alloy::sol_types::sol_data::Uint<64>,
                2usize,
            >,
        );
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = (
            [alloy::sol_types::private::FixedBytes<32>; 2usize],
            [u64; 2usize],
        );
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<GlobalState> for UnderlyingRustTuple<'_> {
            fn from(value: GlobalState) -> Self {
                (value.bytes32Vals, value.u64Vals)
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for GlobalState {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self {
                    bytes32Vals: tuple.0,
                    u64Vals: tuple.1,
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolValue for GlobalState {
            type SolType = Self;
        }
        #[automatically_derived]
        impl alloy_sol_types::private::SolTypeValue<Self> for GlobalState {
            #[inline]
            fn stv_to_tokens(&self) -> <Self as alloy_sol_types::SolType>::Token<'_> {
                (
                    <alloy::sol_types::sol_data::FixedArray<
                        alloy::sol_types::sol_data::FixedBytes<32>,
                        2usize,
                    > as alloy_sol_types::SolType>::tokenize(&self.bytes32Vals),
                    <alloy::sol_types::sol_data::FixedArray<
                        alloy::sol_types::sol_data::Uint<64>,
                        2usize,
                    > as alloy_sol_types::SolType>::tokenize(&self.u64Vals),
                )
            }
            #[inline]
            fn stv_abi_encoded_size(&self) -> usize {
                if let Some(size) = <Self as alloy_sol_types::SolType>::ENCODED_SIZE {
                    return size;
                }
                let tuple = <UnderlyingRustTuple<
                    '_,
                > as ::core::convert::From<Self>>::from(self.clone());
                <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_encoded_size(&tuple)
            }
            #[inline]
            fn stv_eip712_data_word(&self) -> alloy_sol_types::Word {
                <Self as alloy_sol_types::SolStruct>::eip712_hash_struct(self)
            }
            #[inline]
            fn stv_abi_encode_packed_to(
                &self,
                out: &mut alloy_sol_types::private::Vec<u8>,
            ) {
                let tuple = <UnderlyingRustTuple<
                    '_,
                > as ::core::convert::From<Self>>::from(self.clone());
                <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_encode_packed_to(&tuple, out)
            }
            #[inline]
            fn stv_abi_packed_encoded_size(&self) -> usize {
                if let Some(size) = <Self as alloy_sol_types::SolType>::PACKED_ENCODED_SIZE {
                    return size;
                }
                let tuple = <UnderlyingRustTuple<
                    '_,
                > as ::core::convert::From<Self>>::from(self.clone());
                <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_packed_encoded_size(&tuple)
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolType for GlobalState {
            type RustType = Self;
            type Token<'a> = <UnderlyingSolTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SOL_NAME: &'static str = <Self as alloy_sol_types::SolStruct>::NAME;
            const ENCODED_SIZE: Option<usize> = <UnderlyingSolTuple<
                '_,
            > as alloy_sol_types::SolType>::ENCODED_SIZE;
            const PACKED_ENCODED_SIZE: Option<usize> = <UnderlyingSolTuple<
                '_,
            > as alloy_sol_types::SolType>::PACKED_ENCODED_SIZE;
            #[inline]
            fn valid_token(token: &Self::Token<'_>) -> bool {
                <UnderlyingSolTuple<'_> as alloy_sol_types::SolType>::valid_token(token)
            }
            #[inline]
            fn detokenize(token: Self::Token<'_>) -> Self::RustType {
                let tuple = <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::detokenize(token);
                <Self as ::core::convert::From<UnderlyingRustTuple<'_>>>::from(tuple)
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolStruct for GlobalState {
            const NAME: &'static str = "GlobalState";
            #[inline]
            fn eip712_root_type() -> alloy_sol_types::private::Cow<'static, str> {
                alloy_sol_types::private::Cow::Borrowed(
                    "GlobalState(bytes32[2] bytes32Vals,uint64[2] u64Vals)",
                )
            }
            #[inline]
            fn eip712_components() -> alloy_sol_types::private::Vec<
                alloy_sol_types::private::Cow<'static, str>,
            > {
                alloy_sol_types::private::Vec::new()
            }
            #[inline]
            fn eip712_encode_type() -> alloy_sol_types::private::Cow<'static, str> {
                <Self as alloy_sol_types::SolStruct>::eip712_root_type()
            }
            #[inline]
            fn eip712_encode_data(&self) -> alloy_sol_types::private::Vec<u8> {
                [
                    <alloy::sol_types::sol_data::FixedArray<
                        alloy::sol_types::sol_data::FixedBytes<32>,
                        2usize,
                    > as alloy_sol_types::SolType>::eip712_data_word(&self.bytes32Vals)
                        .0,
                    <alloy::sol_types::sol_data::FixedArray<
                        alloy::sol_types::sol_data::Uint<64>,
                        2usize,
                    > as alloy_sol_types::SolType>::eip712_data_word(&self.u64Vals)
                        .0,
                ]
                    .concat()
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::EventTopic for GlobalState {
            #[inline]
            fn topic_preimage_length(rust: &Self::RustType) -> usize {
                0usize
                    + <alloy::sol_types::sol_data::FixedArray<
                        alloy::sol_types::sol_data::FixedBytes<32>,
                        2usize,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.bytes32Vals,
                    )
                    + <alloy::sol_types::sol_data::FixedArray<
                        alloy::sol_types::sol_data::Uint<64>,
                        2usize,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.u64Vals,
                    )
            }
            #[inline]
            fn encode_topic_preimage(
                rust: &Self::RustType,
                out: &mut alloy_sol_types::private::Vec<u8>,
            ) {
                out.reserve(
                    <Self as alloy_sol_types::EventTopic>::topic_preimage_length(rust),
                );
                <alloy::sol_types::sol_data::FixedArray<
                    alloy::sol_types::sol_data::FixedBytes<32>,
                    2usize,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.bytes32Vals,
                    out,
                );
                <alloy::sol_types::sol_data::FixedArray<
                    alloy::sol_types::sol_data::Uint<64>,
                    2usize,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.u64Vals,
                    out,
                );
            }
            #[inline]
            fn encode_topic(
                rust: &Self::RustType,
            ) -> alloy_sol_types::abi::token::WordToken {
                let mut out = alloy_sol_types::private::Vec::new();
                <Self as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    rust,
                    &mut out,
                );
                alloy_sol_types::abi::token::WordToken(
                    alloy_sol_types::private::keccak256(out),
                )
            }
        }
    };
    /**```solidity
struct OneStepData { bytes32 beforeHash; bytes proof; }
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct OneStepData {
        pub beforeHash: alloy::sol_types::private::FixedBytes<32>,
        pub proof: alloy::sol_types::private::Bytes,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = (
            alloy::sol_types::sol_data::FixedBytes<32>,
            alloy::sol_types::sol_data::Bytes,
        );
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = (
            alloy::sol_types::private::FixedBytes<32>,
            alloy::sol_types::private::Bytes,
        );
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<OneStepData> for UnderlyingRustTuple<'_> {
            fn from(value: OneStepData) -> Self {
                (value.beforeHash, value.proof)
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for OneStepData {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self {
                    beforeHash: tuple.0,
                    proof: tuple.1,
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolValue for OneStepData {
            type SolType = Self;
        }
        #[automatically_derived]
        impl alloy_sol_types::private::SolTypeValue<Self> for OneStepData {
            #[inline]
            fn stv_to_tokens(&self) -> <Self as alloy_sol_types::SolType>::Token<'_> {
                (
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.beforeHash),
                    <alloy::sol_types::sol_data::Bytes as alloy_sol_types::SolType>::tokenize(
                        &self.proof,
                    ),
                )
            }
            #[inline]
            fn stv_abi_encoded_size(&self) -> usize {
                if let Some(size) = <Self as alloy_sol_types::SolType>::ENCODED_SIZE {
                    return size;
                }
                let tuple = <UnderlyingRustTuple<
                    '_,
                > as ::core::convert::From<Self>>::from(self.clone());
                <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_encoded_size(&tuple)
            }
            #[inline]
            fn stv_eip712_data_word(&self) -> alloy_sol_types::Word {
                <Self as alloy_sol_types::SolStruct>::eip712_hash_struct(self)
            }
            #[inline]
            fn stv_abi_encode_packed_to(
                &self,
                out: &mut alloy_sol_types::private::Vec<u8>,
            ) {
                let tuple = <UnderlyingRustTuple<
                    '_,
                > as ::core::convert::From<Self>>::from(self.clone());
                <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_encode_packed_to(&tuple, out)
            }
            #[inline]
            fn stv_abi_packed_encoded_size(&self) -> usize {
                if let Some(size) = <Self as alloy_sol_types::SolType>::PACKED_ENCODED_SIZE {
                    return size;
                }
                let tuple = <UnderlyingRustTuple<
                    '_,
                > as ::core::convert::From<Self>>::from(self.clone());
                <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_packed_encoded_size(&tuple)
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolType for OneStepData {
            type RustType = Self;
            type Token<'a> = <UnderlyingSolTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SOL_NAME: &'static str = <Self as alloy_sol_types::SolStruct>::NAME;
            const ENCODED_SIZE: Option<usize> = <UnderlyingSolTuple<
                '_,
            > as alloy_sol_types::SolType>::ENCODED_SIZE;
            const PACKED_ENCODED_SIZE: Option<usize> = <UnderlyingSolTuple<
                '_,
            > as alloy_sol_types::SolType>::PACKED_ENCODED_SIZE;
            #[inline]
            fn valid_token(token: &Self::Token<'_>) -> bool {
                <UnderlyingSolTuple<'_> as alloy_sol_types::SolType>::valid_token(token)
            }
            #[inline]
            fn detokenize(token: Self::Token<'_>) -> Self::RustType {
                let tuple = <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::detokenize(token);
                <Self as ::core::convert::From<UnderlyingRustTuple<'_>>>::from(tuple)
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolStruct for OneStepData {
            const NAME: &'static str = "OneStepData";
            #[inline]
            fn eip712_root_type() -> alloy_sol_types::private::Cow<'static, str> {
                alloy_sol_types::private::Cow::Borrowed(
                    "OneStepData(bytes32 beforeHash,bytes proof)",
                )
            }
            #[inline]
            fn eip712_components() -> alloy_sol_types::private::Vec<
                alloy_sol_types::private::Cow<'static, str>,
            > {
                alloy_sol_types::private::Vec::new()
            }
            #[inline]
            fn eip712_encode_type() -> alloy_sol_types::private::Cow<'static, str> {
                <Self as alloy_sol_types::SolStruct>::eip712_root_type()
            }
            #[inline]
            fn eip712_encode_data(&self) -> alloy_sol_types::private::Vec<u8> {
                [
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::eip712_data_word(&self.beforeHash)
                        .0,
                    <alloy::sol_types::sol_data::Bytes as alloy_sol_types::SolType>::eip712_data_word(
                            &self.proof,
                        )
                        .0,
                ]
                    .concat()
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::EventTopic for OneStepData {
            #[inline]
            fn topic_preimage_length(rust: &Self::RustType) -> usize {
                0usize
                    + <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.beforeHash,
                    )
                    + <alloy::sol_types::sol_data::Bytes as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.proof,
                    )
            }
            #[inline]
            fn encode_topic_preimage(
                rust: &Self::RustType,
                out: &mut alloy_sol_types::private::Vec<u8>,
            ) {
                out.reserve(
                    <Self as alloy_sol_types::EventTopic>::topic_preimage_length(rust),
                );
                <alloy::sol_types::sol_data::FixedBytes<
                    32,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.beforeHash,
                    out,
                );
                <alloy::sol_types::sol_data::Bytes as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.proof,
                    out,
                );
            }
            #[inline]
            fn encode_topic(
                rust: &Self::RustType,
            ) -> alloy_sol_types::abi::token::WordToken {
                let mut out = alloy_sol_types::private::Vec::new();
                <Self as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    rust,
                    &mut out,
                );
                alloy_sol_types::abi::token::WordToken(
                    alloy_sol_types::private::keccak256(out),
                )
            }
        }
    };
    /**Custom error with signature `AccountHasMadeLayerZeroRival(address,bytes32)` and selector `0x5a46ac3a`.
```solidity
error AccountHasMadeLayerZeroRival(address account, bytes32 mutualId);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct AccountHasMadeLayerZeroRival {
        pub account: alloy::sol_types::private::Address,
        pub mutualId: alloy::sol_types::private::FixedBytes<32>,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = (
            alloy::sol_types::sol_data::Address,
            alloy::sol_types::sol_data::FixedBytes<32>,
        );
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = (
            alloy::sol_types::private::Address,
            alloy::sol_types::private::FixedBytes<32>,
        );
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<AccountHasMadeLayerZeroRival>
        for UnderlyingRustTuple<'_> {
            fn from(value: AccountHasMadeLayerZeroRival) -> Self {
                (value.account, value.mutualId)
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>>
        for AccountHasMadeLayerZeroRival {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self {
                    account: tuple.0,
                    mutualId: tuple.1,
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for AccountHasMadeLayerZeroRival {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "AccountHasMadeLayerZeroRival(address,bytes32)";
            const SELECTOR: [u8; 4] = [90u8, 70u8, 172u8, 58u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.account,
                    ),
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.mutualId),
                )
            }
        }
    };
    /**Custom error with signature `AssertionHashEmpty()` and selector `0xe96bc61a`.
```solidity
error AssertionHashEmpty();
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct AssertionHashEmpty {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = ();
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = ();
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<AssertionHashEmpty> for UnderlyingRustTuple<'_> {
            fn from(value: AssertionHashEmpty) -> Self {
                ()
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for AssertionHashEmpty {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self {}
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for AssertionHashEmpty {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "AssertionHashEmpty()";
            const SELECTOR: [u8; 4] = [233u8, 107u8, 198u8, 26u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
        }
    };
    /**Custom error with signature `AssertionHashMismatch(bytes32,bytes32)` and selector `0x5b177a3c`.
```solidity
error AssertionHashMismatch(bytes32 h1, bytes32 h2);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct AssertionHashMismatch {
        pub h1: alloy::sol_types::private::FixedBytes<32>,
        pub h2: alloy::sol_types::private::FixedBytes<32>,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = (
            alloy::sol_types::sol_data::FixedBytes<32>,
            alloy::sol_types::sol_data::FixedBytes<32>,
        );
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = (
            alloy::sol_types::private::FixedBytes<32>,
            alloy::sol_types::private::FixedBytes<32>,
        );
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<AssertionHashMismatch> for UnderlyingRustTuple<'_> {
            fn from(value: AssertionHashMismatch) -> Self {
                (value.h1, value.h2)
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for AssertionHashMismatch {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self { h1: tuple.0, h2: tuple.1 }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for AssertionHashMismatch {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "AssertionHashMismatch(bytes32,bytes32)";
            const SELECTOR: [u8; 4] = [91u8, 23u8, 122u8, 60u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.h1),
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.h2),
                )
            }
        }
    };
    /**Custom error with signature `AssertionNoSibling()` and selector `0xb45d1c3a`.
```solidity
error AssertionNoSibling();
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct AssertionNoSibling {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = ();
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = ();
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<AssertionNoSibling> for UnderlyingRustTuple<'_> {
            fn from(value: AssertionNoSibling) -> Self {
                ()
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for AssertionNoSibling {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self {}
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for AssertionNoSibling {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "AssertionNoSibling()";
            const SELECTOR: [u8; 4] = [180u8, 93u8, 28u8, 58u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
        }
    };
    /**Custom error with signature `AssertionNotPending()` and selector `0xc1692436`.
```solidity
error AssertionNotPending();
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct AssertionNotPending {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = ();
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = ();
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<AssertionNotPending> for UnderlyingRustTuple<'_> {
            fn from(value: AssertionNotPending) -> Self {
                ()
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for AssertionNotPending {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self {}
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for AssertionNotPending {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "AssertionNotPending()";
            const SELECTOR: [u8; 4] = [193u8, 105u8, 36u8, 54u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
        }
    };
    /**Custom error with signature `BigStepLevelsTooMany(uint8)` and selector `0x40d23bf0`.
```solidity
error BigStepLevelsTooMany(uint8 levels);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct BigStepLevelsTooMany {
        pub levels: u8,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<8>,);
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = (u8,);
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<BigStepLevelsTooMany> for UnderlyingRustTuple<'_> {
            fn from(value: BigStepLevelsTooMany) -> Self {
                (value.levels,)
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for BigStepLevelsTooMany {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self { levels: tuple.0 }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for BigStepLevelsTooMany {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "BigStepLevelsTooMany(uint8)";
            const SELECTOR: [u8; 4] = [64u8, 210u8, 59u8, 240u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        8,
                    > as alloy_sol_types::SolType>::tokenize(&self.levels),
                )
            }
        }
    };
    /**Custom error with signature `CachedTimeSufficient(uint256,uint256)` and selector `0xd1f59281`.
```solidity
error CachedTimeSufficient(uint256 actual, uint256 expected);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct CachedTimeSufficient {
        pub actual: alloy::sol_types::private::primitives::aliases::U256,
        pub expected: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = (
            alloy::sol_types::sol_data::Uint<256>,
            alloy::sol_types::sol_data::Uint<256>,
        );
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = (
            alloy::sol_types::private::primitives::aliases::U256,
            alloy::sol_types::private::primitives::aliases::U256,
        );
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<CachedTimeSufficient> for UnderlyingRustTuple<'_> {
            fn from(value: CachedTimeSufficient) -> Self {
                (value.actual, value.expected)
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for CachedTimeSufficient {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self {
                    actual: tuple.0,
                    expected: tuple.1,
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for CachedTimeSufficient {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "CachedTimeSufficient(uint256,uint256)";
            const SELECTOR: [u8; 4] = [209u8, 245u8, 146u8, 129u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.actual),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.expected),
                )
            }
        }
    };
    /**Custom error with signature `ChildrenAlreadySet(bytes32,bytes32,bytes32)` and selector `0x8b0e71d0`.
```solidity
error ChildrenAlreadySet(bytes32 edgeId, bytes32 lowerChildId, bytes32 upperChildId);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct ChildrenAlreadySet {
        pub edgeId: alloy::sol_types::private::FixedBytes<32>,
        pub lowerChildId: alloy::sol_types::private::FixedBytes<32>,
        pub upperChildId: alloy::sol_types::private::FixedBytes<32>,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = (
            alloy::sol_types::sol_data::FixedBytes<32>,
            alloy::sol_types::sol_data::FixedBytes<32>,
            alloy::sol_types::sol_data::FixedBytes<32>,
        );
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = (
            alloy::sol_types::private::FixedBytes<32>,
            alloy::sol_types::private::FixedBytes<32>,
            alloy::sol_types::private::FixedBytes<32>,
        );
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<ChildrenAlreadySet> for UnderlyingRustTuple<'_> {
            fn from(value: ChildrenAlreadySet) -> Self {
                (value.edgeId, value.lowerChildId, value.upperChildId)
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for ChildrenAlreadySet {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self {
                    edgeId: tuple.0,
                    lowerChildId: tuple.1,
                    upperChildId: tuple.2,
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for ChildrenAlreadySet {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "ChildrenAlreadySet(bytes32,bytes32,bytes32)";
            const SELECTOR: [u8; 4] = [139u8, 14u8, 113u8, 208u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.edgeId),
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.lowerChildId),
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.upperChildId),
                )
            }
        }
    };
    /**Custom error with signature `ClaimEdgeInvalidLevel(uint8,uint8)` and selector `0xac9e6116`.
```solidity
error ClaimEdgeInvalidLevel(uint8 argLevel, uint8 claimLevel);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct ClaimEdgeInvalidLevel {
        pub argLevel: u8,
        pub claimLevel: u8,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = (
            alloy::sol_types::sol_data::Uint<8>,
            alloy::sol_types::sol_data::Uint<8>,
        );
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = (u8, u8);
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<ClaimEdgeInvalidLevel> for UnderlyingRustTuple<'_> {
            fn from(value: ClaimEdgeInvalidLevel) -> Self {
                (value.argLevel, value.claimLevel)
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for ClaimEdgeInvalidLevel {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self {
                    argLevel: tuple.0,
                    claimLevel: tuple.1,
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for ClaimEdgeInvalidLevel {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "ClaimEdgeInvalidLevel(uint8,uint8)";
            const SELECTOR: [u8; 4] = [172u8, 158u8, 97u8, 22u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        8,
                    > as alloy_sol_types::SolType>::tokenize(&self.argLevel),
                    <alloy::sol_types::sol_data::Uint<
                        8,
                    > as alloy_sol_types::SolType>::tokenize(&self.claimLevel),
                )
            }
        }
    };
    /**Custom error with signature `ClaimEdgeNotLengthOneRival(bytes32)` and selector `0xff6d9bd7`.
```solidity
error ClaimEdgeNotLengthOneRival(bytes32 claimId);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct ClaimEdgeNotLengthOneRival {
        pub claimId: alloy::sol_types::private::FixedBytes<32>,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::FixedBytes<32>,);
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = (alloy::sol_types::private::FixedBytes<32>,);
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<ClaimEdgeNotLengthOneRival>
        for UnderlyingRustTuple<'_> {
            fn from(value: ClaimEdgeNotLengthOneRival) -> Self {
                (value.claimId,)
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>>
        for ClaimEdgeNotLengthOneRival {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self { claimId: tuple.0 }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for ClaimEdgeNotLengthOneRival {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "ClaimEdgeNotLengthOneRival(bytes32)";
            const SELECTOR: [u8; 4] = [255u8, 109u8, 155u8, 215u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.claimId),
                )
            }
        }
    };
    /**Custom error with signature `ClaimEdgeNotPending()` and selector `0x12459ffd`.
```solidity
error ClaimEdgeNotPending();
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct ClaimEdgeNotPending {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = ();
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = ();
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<ClaimEdgeNotPending> for UnderlyingRustTuple<'_> {
            fn from(value: ClaimEdgeNotPending) -> Self {
                ()
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for ClaimEdgeNotPending {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self {}
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for ClaimEdgeNotPending {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "ClaimEdgeNotPending()";
            const SELECTOR: [u8; 4] = [18u8, 69u8, 159u8, 253u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
        }
    };
    /**Custom error with signature `EdgeAlreadyExists(bytes32)` and selector `0xbcedf3de`.
```solidity
error EdgeAlreadyExists(bytes32 edgeId);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct EdgeAlreadyExists {
        pub edgeId: alloy::sol_types::private::FixedBytes<32>,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::FixedBytes<32>,);
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = (alloy::sol_types::private::FixedBytes<32>,);
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<EdgeAlreadyExists> for UnderlyingRustTuple<'_> {
            fn from(value: EdgeAlreadyExists) -> Self {
                (value.edgeId,)
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for EdgeAlreadyExists {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self { edgeId: tuple.0 }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for EdgeAlreadyExists {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "EdgeAlreadyExists(bytes32)";
            const SELECTOR: [u8; 4] = [188u8, 237u8, 243u8, 222u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.edgeId),
                )
            }
        }
    };
    /**Custom error with signature `EdgeAlreadyRefunded(bytes32)` and selector `0x307f7669`.
```solidity
error EdgeAlreadyRefunded(bytes32 edgeId);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct EdgeAlreadyRefunded {
        pub edgeId: alloy::sol_types::private::FixedBytes<32>,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::FixedBytes<32>,);
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = (alloy::sol_types::private::FixedBytes<32>,);
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<EdgeAlreadyRefunded> for UnderlyingRustTuple<'_> {
            fn from(value: EdgeAlreadyRefunded) -> Self {
                (value.edgeId,)
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for EdgeAlreadyRefunded {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self { edgeId: tuple.0 }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for EdgeAlreadyRefunded {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "EdgeAlreadyRefunded(bytes32)";
            const SELECTOR: [u8; 4] = [48u8, 127u8, 118u8, 105u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.edgeId),
                )
            }
        }
    };
    /**Custom error with signature `EdgeClaimMismatch(bytes32,bytes32)` and selector `0xc2adc3e8`.
```solidity
error EdgeClaimMismatch(bytes32 edgeId, bytes32 claimingEdgeId);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct EdgeClaimMismatch {
        pub edgeId: alloy::sol_types::private::FixedBytes<32>,
        pub claimingEdgeId: alloy::sol_types::private::FixedBytes<32>,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = (
            alloy::sol_types::sol_data::FixedBytes<32>,
            alloy::sol_types::sol_data::FixedBytes<32>,
        );
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = (
            alloy::sol_types::private::FixedBytes<32>,
            alloy::sol_types::private::FixedBytes<32>,
        );
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<EdgeClaimMismatch> for UnderlyingRustTuple<'_> {
            fn from(value: EdgeClaimMismatch) -> Self {
                (value.edgeId, value.claimingEdgeId)
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for EdgeClaimMismatch {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self {
                    edgeId: tuple.0,
                    claimingEdgeId: tuple.1,
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for EdgeClaimMismatch {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "EdgeClaimMismatch(bytes32,bytes32)";
            const SELECTOR: [u8; 4] = [194u8, 173u8, 195u8, 232u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.edgeId),
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.claimingEdgeId),
                )
            }
        }
    };
    /**Custom error with signature `EdgeLevelInvalid(bytes32,bytes32,uint8,uint8)` and selector `0x7e726d15`.
```solidity
error EdgeLevelInvalid(bytes32 edgeId1, bytes32 edgeId2, uint8 level1, uint8 level2);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct EdgeLevelInvalid {
        pub edgeId1: alloy::sol_types::private::FixedBytes<32>,
        pub edgeId2: alloy::sol_types::private::FixedBytes<32>,
        pub level1: u8,
        pub level2: u8,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = (
            alloy::sol_types::sol_data::FixedBytes<32>,
            alloy::sol_types::sol_data::FixedBytes<32>,
            alloy::sol_types::sol_data::Uint<8>,
            alloy::sol_types::sol_data::Uint<8>,
        );
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = (
            alloy::sol_types::private::FixedBytes<32>,
            alloy::sol_types::private::FixedBytes<32>,
            u8,
            u8,
        );
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<EdgeLevelInvalid> for UnderlyingRustTuple<'_> {
            fn from(value: EdgeLevelInvalid) -> Self {
                (value.edgeId1, value.edgeId2, value.level1, value.level2)
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for EdgeLevelInvalid {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self {
                    edgeId1: tuple.0,
                    edgeId2: tuple.1,
                    level1: tuple.2,
                    level2: tuple.3,
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for EdgeLevelInvalid {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "EdgeLevelInvalid(bytes32,bytes32,uint8,uint8)";
            const SELECTOR: [u8; 4] = [126u8, 114u8, 109u8, 21u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.edgeId1),
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.edgeId2),
                    <alloy::sol_types::sol_data::Uint<
                        8,
                    > as alloy_sol_types::SolType>::tokenize(&self.level1),
                    <alloy::sol_types::sol_data::Uint<
                        8,
                    > as alloy_sol_types::SolType>::tokenize(&self.level2),
                )
            }
        }
    };
    /**Custom error with signature `EdgeNotConfirmed(bytes32,uint8)` and selector `0xef1267b4`.
```solidity
error EdgeNotConfirmed(bytes32 edgeId, EdgeStatus);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct EdgeNotConfirmed {
        pub edgeId: alloy::sol_types::private::FixedBytes<32>,
        pub _1: <EdgeStatus as alloy::sol_types::SolType>::RustType,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = (
            alloy::sol_types::sol_data::FixedBytes<32>,
            EdgeStatus,
        );
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = (
            alloy::sol_types::private::FixedBytes<32>,
            <EdgeStatus as alloy::sol_types::SolType>::RustType,
        );
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<EdgeNotConfirmed> for UnderlyingRustTuple<'_> {
            fn from(value: EdgeNotConfirmed) -> Self {
                (value.edgeId, value._1)
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for EdgeNotConfirmed {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self {
                    edgeId: tuple.0,
                    _1: tuple.1,
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for EdgeNotConfirmed {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "EdgeNotConfirmed(bytes32,uint8)";
            const SELECTOR: [u8; 4] = [239u8, 18u8, 103u8, 180u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.edgeId),
                    <EdgeStatus as alloy_sol_types::SolType>::tokenize(&self._1),
                )
            }
        }
    };
    /**Custom error with signature `EdgeNotExists(bytes32)` and selector `0x00a7b02b`.
```solidity
error EdgeNotExists(bytes32 edgeId);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct EdgeNotExists {
        pub edgeId: alloy::sol_types::private::FixedBytes<32>,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::FixedBytes<32>,);
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = (alloy::sol_types::private::FixedBytes<32>,);
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<EdgeNotExists> for UnderlyingRustTuple<'_> {
            fn from(value: EdgeNotExists) -> Self {
                (value.edgeId,)
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for EdgeNotExists {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self { edgeId: tuple.0 }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for EdgeNotExists {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "EdgeNotExists(bytes32)";
            const SELECTOR: [u8; 4] = [0u8, 167u8, 176u8, 43u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.edgeId),
                )
            }
        }
    };
    /**Custom error with signature `EdgeNotLayerZero(bytes32,address,bytes32)` and selector `0xe58c8308`.
```solidity
error EdgeNotLayerZero(bytes32 edgeId, address staker, bytes32 claimId);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct EdgeNotLayerZero {
        pub edgeId: alloy::sol_types::private::FixedBytes<32>,
        pub staker: alloy::sol_types::private::Address,
        pub claimId: alloy::sol_types::private::FixedBytes<32>,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = (
            alloy::sol_types::sol_data::FixedBytes<32>,
            alloy::sol_types::sol_data::Address,
            alloy::sol_types::sol_data::FixedBytes<32>,
        );
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = (
            alloy::sol_types::private::FixedBytes<32>,
            alloy::sol_types::private::Address,
            alloy::sol_types::private::FixedBytes<32>,
        );
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<EdgeNotLayerZero> for UnderlyingRustTuple<'_> {
            fn from(value: EdgeNotLayerZero) -> Self {
                (value.edgeId, value.staker, value.claimId)
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for EdgeNotLayerZero {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self {
                    edgeId: tuple.0,
                    staker: tuple.1,
                    claimId: tuple.2,
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for EdgeNotLayerZero {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "EdgeNotLayerZero(bytes32,address,bytes32)";
            const SELECTOR: [u8; 4] = [229u8, 140u8, 131u8, 8u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.edgeId),
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.staker,
                    ),
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.claimId),
                )
            }
        }
    };
    /**Custom error with signature `EdgeNotLengthOne(uint256)` and selector `0x6b595e50`.
```solidity
error EdgeNotLengthOne(uint256 length);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct EdgeNotLengthOne {
        pub length: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = (
            alloy::sol_types::private::primitives::aliases::U256,
        );
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<EdgeNotLengthOne> for UnderlyingRustTuple<'_> {
            fn from(value: EdgeNotLengthOne) -> Self {
                (value.length,)
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for EdgeNotLengthOne {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self { length: tuple.0 }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for EdgeNotLengthOne {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "EdgeNotLengthOne(uint256)";
            const SELECTOR: [u8; 4] = [107u8, 89u8, 94u8, 80u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.length),
                )
            }
        }
    };
    /**Custom error with signature `EdgeNotPending(bytes32,uint8)` and selector `0x23f8405d`.
```solidity
error EdgeNotPending(bytes32 edgeId, EdgeStatus status);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct EdgeNotPending {
        pub edgeId: alloy::sol_types::private::FixedBytes<32>,
        pub status: <EdgeStatus as alloy::sol_types::SolType>::RustType,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = (
            alloy::sol_types::sol_data::FixedBytes<32>,
            EdgeStatus,
        );
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = (
            alloy::sol_types::private::FixedBytes<32>,
            <EdgeStatus as alloy::sol_types::SolType>::RustType,
        );
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<EdgeNotPending> for UnderlyingRustTuple<'_> {
            fn from(value: EdgeNotPending) -> Self {
                (value.edgeId, value.status)
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for EdgeNotPending {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self {
                    edgeId: tuple.0,
                    status: tuple.1,
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for EdgeNotPending {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "EdgeNotPending(bytes32,uint8)";
            const SELECTOR: [u8; 4] = [35u8, 248u8, 64u8, 93u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.edgeId),
                    <EdgeStatus as alloy_sol_types::SolType>::tokenize(&self.status),
                )
            }
        }
    };
    /**Custom error with signature `EdgeTypeNotSmallStep(uint8)` and selector `0x348aefdf`.
```solidity
error EdgeTypeNotSmallStep(uint8 level);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct EdgeTypeNotSmallStep {
        pub level: u8,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<8>,);
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = (u8,);
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<EdgeTypeNotSmallStep> for UnderlyingRustTuple<'_> {
            fn from(value: EdgeTypeNotSmallStep) -> Self {
                (value.level,)
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for EdgeTypeNotSmallStep {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self { level: tuple.0 }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for EdgeTypeNotSmallStep {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "EdgeTypeNotSmallStep(uint8)";
            const SELECTOR: [u8; 4] = [52u8, 138u8, 239u8, 223u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        8,
                    > as alloy_sol_types::SolType>::tokenize(&self.level),
                )
            }
        }
    };
    /**Custom error with signature `EdgeUnrivaled(bytes32)` and selector `0x80e07e45`.
```solidity
error EdgeUnrivaled(bytes32 edgeId);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct EdgeUnrivaled {
        pub edgeId: alloy::sol_types::private::FixedBytes<32>,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::FixedBytes<32>,);
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = (alloy::sol_types::private::FixedBytes<32>,);
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<EdgeUnrivaled> for UnderlyingRustTuple<'_> {
            fn from(value: EdgeUnrivaled) -> Self {
                (value.edgeId,)
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for EdgeUnrivaled {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self { edgeId: tuple.0 }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for EdgeUnrivaled {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "EdgeUnrivaled(bytes32)";
            const SELECTOR: [u8; 4] = [128u8, 224u8, 126u8, 69u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.edgeId),
                )
            }
        }
    };
    /**Custom error with signature `EmptyArray()` and selector `0x521299a9`.
```solidity
error EmptyArray();
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct EmptyArray {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = ();
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = ();
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<EmptyArray> for UnderlyingRustTuple<'_> {
            fn from(value: EmptyArray) -> Self {
                ()
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for EmptyArray {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self {}
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for EmptyArray {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "EmptyArray()";
            const SELECTOR: [u8; 4] = [82u8, 18u8, 153u8, 169u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
        }
    };
    /**Custom error with signature `EmptyAssertionChain()` and selector `0xc83e0862`.
```solidity
error EmptyAssertionChain();
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct EmptyAssertionChain {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = ();
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = ();
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<EmptyAssertionChain> for UnderlyingRustTuple<'_> {
            fn from(value: EmptyAssertionChain) -> Self {
                ()
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for EmptyAssertionChain {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self {}
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for EmptyAssertionChain {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "EmptyAssertionChain()";
            const SELECTOR: [u8; 4] = [200u8, 62u8, 8u8, 98u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
        }
    };
    /**Custom error with signature `EmptyChallengePeriod()` and selector `0x8a0eedcc`.
```solidity
error EmptyChallengePeriod();
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct EmptyChallengePeriod {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = ();
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = ();
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<EmptyChallengePeriod> for UnderlyingRustTuple<'_> {
            fn from(value: EmptyChallengePeriod) -> Self {
                ()
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for EmptyChallengePeriod {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self {}
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for EmptyChallengePeriod {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "EmptyChallengePeriod()";
            const SELECTOR: [u8; 4] = [138u8, 14u8, 237u8, 204u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
        }
    };
    /**Custom error with signature `EmptyClaimId()` and selector `0x6932bcfd`.
```solidity
error EmptyClaimId();
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct EmptyClaimId {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = ();
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = ();
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<EmptyClaimId> for UnderlyingRustTuple<'_> {
            fn from(value: EmptyClaimId) -> Self {
                ()
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for EmptyClaimId {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self {}
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for EmptyClaimId {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "EmptyClaimId()";
            const SELECTOR: [u8; 4] = [105u8, 50u8, 188u8, 253u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
        }
    };
    /**Custom error with signature `EmptyEdgeSpecificProof()` and selector `0xc9ccac50`.
```solidity
error EmptyEdgeSpecificProof();
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct EmptyEdgeSpecificProof {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = ();
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = ();
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<EmptyEdgeSpecificProof> for UnderlyingRustTuple<'_> {
            fn from(value: EmptyEdgeSpecificProof) -> Self {
                ()
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for EmptyEdgeSpecificProof {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self {}
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for EmptyEdgeSpecificProof {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "EmptyEdgeSpecificProof()";
            const SELECTOR: [u8; 4] = [201u8, 204u8, 172u8, 80u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
        }
    };
    /**Custom error with signature `EmptyEndMachineStatus()` and selector `0x8999857d`.
```solidity
error EmptyEndMachineStatus();
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct EmptyEndMachineStatus {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = ();
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = ();
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<EmptyEndMachineStatus> for UnderlyingRustTuple<'_> {
            fn from(value: EmptyEndMachineStatus) -> Self {
                ()
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for EmptyEndMachineStatus {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self {}
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for EmptyEndMachineStatus {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "EmptyEndMachineStatus()";
            const SELECTOR: [u8; 4] = [137u8, 153u8, 133u8, 125u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
        }
    };
    /**Custom error with signature `EmptyEndRoot()` and selector `0x5cb6e5bb`.
```solidity
error EmptyEndRoot();
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct EmptyEndRoot {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = ();
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = ();
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<EmptyEndRoot> for UnderlyingRustTuple<'_> {
            fn from(value: EmptyEndRoot) -> Self {
                ()
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for EmptyEndRoot {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self {}
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for EmptyEndRoot {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "EmptyEndRoot()";
            const SELECTOR: [u8; 4] = [92u8, 182u8, 229u8, 187u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
        }
    };
    /**Custom error with signature `EmptyFirstRival()` and selector `0xda10f67c`.
```solidity
error EmptyFirstRival();
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct EmptyFirstRival {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = ();
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = ();
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<EmptyFirstRival> for UnderlyingRustTuple<'_> {
            fn from(value: EmptyFirstRival) -> Self {
                ()
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for EmptyFirstRival {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self {}
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for EmptyFirstRival {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "EmptyFirstRival()";
            const SELECTOR: [u8; 4] = [218u8, 16u8, 246u8, 124u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
        }
    };
    /**Custom error with signature `EmptyOneStepProofEntry()` and selector `0xfb60b0ef`.
```solidity
error EmptyOneStepProofEntry();
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct EmptyOneStepProofEntry {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = ();
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = ();
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<EmptyOneStepProofEntry> for UnderlyingRustTuple<'_> {
            fn from(value: EmptyOneStepProofEntry) -> Self {
                ()
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for EmptyOneStepProofEntry {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self {}
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for EmptyOneStepProofEntry {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "EmptyOneStepProofEntry()";
            const SELECTOR: [u8; 4] = [251u8, 96u8, 176u8, 239u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
        }
    };
    /**Custom error with signature `EmptyOriginId()` and selector `0x8d79dbbc`.
```solidity
error EmptyOriginId();
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct EmptyOriginId {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = ();
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = ();
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<EmptyOriginId> for UnderlyingRustTuple<'_> {
            fn from(value: EmptyOriginId) -> Self {
                ()
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for EmptyOriginId {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self {}
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for EmptyOriginId {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "EmptyOriginId()";
            const SELECTOR: [u8; 4] = [141u8, 121u8, 219u8, 188u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
        }
    };
    /**Custom error with signature `EmptyPrefixProof()` and selector `0x342a0752`.
```solidity
error EmptyPrefixProof();
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct EmptyPrefixProof {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = ();
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = ();
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<EmptyPrefixProof> for UnderlyingRustTuple<'_> {
            fn from(value: EmptyPrefixProof) -> Self {
                ()
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for EmptyPrefixProof {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self {}
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for EmptyPrefixProof {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "EmptyPrefixProof()";
            const SELECTOR: [u8; 4] = [52u8, 42u8, 7u8, 82u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
        }
    };
    /**Custom error with signature `EmptyStakeReceiver()` and selector `0x0f0ec8a8`.
```solidity
error EmptyStakeReceiver();
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct EmptyStakeReceiver {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = ();
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = ();
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<EmptyStakeReceiver> for UnderlyingRustTuple<'_> {
            fn from(value: EmptyStakeReceiver) -> Self {
                ()
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for EmptyStakeReceiver {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self {}
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for EmptyStakeReceiver {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "EmptyStakeReceiver()";
            const SELECTOR: [u8; 4] = [15u8, 14u8, 200u8, 168u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
        }
    };
    /**Custom error with signature `EmptyStaker()` and selector `0xf289e657`.
```solidity
error EmptyStaker();
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct EmptyStaker {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = ();
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = ();
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<EmptyStaker> for UnderlyingRustTuple<'_> {
            fn from(value: EmptyStaker) -> Self {
                ()
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for EmptyStaker {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self {}
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for EmptyStaker {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "EmptyStaker()";
            const SELECTOR: [u8; 4] = [242u8, 137u8, 230u8, 87u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
        }
    };
    /**Custom error with signature `EmptyStartMachineStatus()` and selector `0x46365e52`.
```solidity
error EmptyStartMachineStatus();
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct EmptyStartMachineStatus {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = ();
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = ();
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<EmptyStartMachineStatus> for UnderlyingRustTuple<'_> {
            fn from(value: EmptyStartMachineStatus) -> Self {
                ()
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for EmptyStartMachineStatus {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self {}
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for EmptyStartMachineStatus {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "EmptyStartMachineStatus()";
            const SELECTOR: [u8; 4] = [70u8, 54u8, 94u8, 82u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
        }
    };
    /**Custom error with signature `EmptyStartRoot()` and selector `0x83c683e4`.
```solidity
error EmptyStartRoot();
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct EmptyStartRoot {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = ();
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = ();
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<EmptyStartRoot> for UnderlyingRustTuple<'_> {
            fn from(value: EmptyStartRoot) -> Self {
                ()
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for EmptyStartRoot {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self {}
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for EmptyStartRoot {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "EmptyStartRoot()";
            const SELECTOR: [u8; 4] = [131u8, 198u8, 131u8, 228u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
        }
    };
    /**Custom error with signature `EndHistoryRootMismatch(bytes32,bytes32)` and selector `0x3a63e99a`.
```solidity
error EndHistoryRootMismatch(bytes32 endHistoryRoot, bytes32 assertionEndRoot);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct EndHistoryRootMismatch {
        pub endHistoryRoot: alloy::sol_types::private::FixedBytes<32>,
        pub assertionEndRoot: alloy::sol_types::private::FixedBytes<32>,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = (
            alloy::sol_types::sol_data::FixedBytes<32>,
            alloy::sol_types::sol_data::FixedBytes<32>,
        );
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = (
            alloy::sol_types::private::FixedBytes<32>,
            alloy::sol_types::private::FixedBytes<32>,
        );
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<EndHistoryRootMismatch> for UnderlyingRustTuple<'_> {
            fn from(value: EndHistoryRootMismatch) -> Self {
                (value.endHistoryRoot, value.assertionEndRoot)
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for EndHistoryRootMismatch {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self {
                    endHistoryRoot: tuple.0,
                    assertionEndRoot: tuple.1,
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for EndHistoryRootMismatch {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "EndHistoryRootMismatch(bytes32,bytes32)";
            const SELECTOR: [u8; 4] = [58u8, 99u8, 233u8, 154u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.endHistoryRoot),
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.assertionEndRoot),
                )
            }
        }
    };
    /**Custom error with signature `HeightDiffLtTwo(uint256,uint256)` and selector `0x90298594`.
```solidity
error HeightDiffLtTwo(uint256 h1, uint256 h2);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct HeightDiffLtTwo {
        pub h1: alloy::sol_types::private::primitives::aliases::U256,
        pub h2: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = (
            alloy::sol_types::sol_data::Uint<256>,
            alloy::sol_types::sol_data::Uint<256>,
        );
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = (
            alloy::sol_types::private::primitives::aliases::U256,
            alloy::sol_types::private::primitives::aliases::U256,
        );
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<HeightDiffLtTwo> for UnderlyingRustTuple<'_> {
            fn from(value: HeightDiffLtTwo) -> Self {
                (value.h1, value.h2)
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for HeightDiffLtTwo {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self { h1: tuple.0, h2: tuple.1 }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for HeightDiffLtTwo {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "HeightDiffLtTwo(uint256,uint256)";
            const SELECTOR: [u8; 4] = [144u8, 41u8, 133u8, 148u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.h1),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.h2),
                )
            }
        }
    };
    /**Custom error with signature `InsufficientConfirmationBlocks(uint256,uint256)` and selector `0x11a8d4d0`.
```solidity
error InsufficientConfirmationBlocks(uint256 totalBlocks, uint256 thresholdBlocks);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct InsufficientConfirmationBlocks {
        pub totalBlocks: alloy::sol_types::private::primitives::aliases::U256,
        pub thresholdBlocks: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = (
            alloy::sol_types::sol_data::Uint<256>,
            alloy::sol_types::sol_data::Uint<256>,
        );
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = (
            alloy::sol_types::private::primitives::aliases::U256,
            alloy::sol_types::private::primitives::aliases::U256,
        );
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<InsufficientConfirmationBlocks>
        for UnderlyingRustTuple<'_> {
            fn from(value: InsufficientConfirmationBlocks) -> Self {
                (value.totalBlocks, value.thresholdBlocks)
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>>
        for InsufficientConfirmationBlocks {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self {
                    totalBlocks: tuple.0,
                    thresholdBlocks: tuple.1,
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for InsufficientConfirmationBlocks {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "InsufficientConfirmationBlocks(uint256,uint256)";
            const SELECTOR: [u8; 4] = [17u8, 168u8, 212u8, 208u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.totalBlocks),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.thresholdBlocks),
                )
            }
        }
    };
    /**Custom error with signature `InvalidEdgeType(uint8)` and selector `0x3bf2e1ec`.
```solidity
error InvalidEdgeType(EdgeType edgeType);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct InvalidEdgeType {
        pub edgeType: <EdgeType as alloy::sol_types::SolType>::RustType,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = (EdgeType,);
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = (
            <EdgeType as alloy::sol_types::SolType>::RustType,
        );
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<InvalidEdgeType> for UnderlyingRustTuple<'_> {
            fn from(value: InvalidEdgeType) -> Self {
                (value.edgeType,)
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for InvalidEdgeType {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self { edgeType: tuple.0 }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for InvalidEdgeType {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "InvalidEdgeType(uint8)";
            const SELECTOR: [u8; 4] = [59u8, 242u8, 225u8, 236u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (<EdgeType as alloy_sol_types::SolType>::tokenize(&self.edgeType),)
            }
        }
    };
    /**Custom error with signature `InvalidEndHeight(uint256,uint256)` and selector `0xdfcc62bc`.
```solidity
error InvalidEndHeight(uint256 actualHeight, uint256 expectedHeight);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct InvalidEndHeight {
        pub actualHeight: alloy::sol_types::private::primitives::aliases::U256,
        pub expectedHeight: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = (
            alloy::sol_types::sol_data::Uint<256>,
            alloy::sol_types::sol_data::Uint<256>,
        );
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = (
            alloy::sol_types::private::primitives::aliases::U256,
            alloy::sol_types::private::primitives::aliases::U256,
        );
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<InvalidEndHeight> for UnderlyingRustTuple<'_> {
            fn from(value: InvalidEndHeight) -> Self {
                (value.actualHeight, value.expectedHeight)
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for InvalidEndHeight {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self {
                    actualHeight: tuple.0,
                    expectedHeight: tuple.1,
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for InvalidEndHeight {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "InvalidEndHeight(uint256,uint256)";
            const SELECTOR: [u8; 4] = [223u8, 204u8, 98u8, 188u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.actualHeight),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.expectedHeight),
                )
            }
        }
    };
    /**Custom error with signature `InvalidHeights(uint256,uint256)` and selector `0x2060faf4`.
```solidity
error InvalidHeights(uint256 start, uint256 end);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct InvalidHeights {
        pub start: alloy::sol_types::private::primitives::aliases::U256,
        pub end: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = (
            alloy::sol_types::sol_data::Uint<256>,
            alloy::sol_types::sol_data::Uint<256>,
        );
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = (
            alloy::sol_types::private::primitives::aliases::U256,
            alloy::sol_types::private::primitives::aliases::U256,
        );
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<InvalidHeights> for UnderlyingRustTuple<'_> {
            fn from(value: InvalidHeights) -> Self {
                (value.start, value.end)
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for InvalidHeights {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self {
                    start: tuple.0,
                    end: tuple.1,
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for InvalidHeights {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "InvalidHeights(uint256,uint256)";
            const SELECTOR: [u8; 4] = [32u8, 96u8, 250u8, 244u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.start),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.end),
                )
            }
        }
    };
    /**Custom error with signature `LevelTooHigh(uint8,uint8)` and selector `0xae0da578`.
```solidity
error LevelTooHigh(uint8 level, uint8 numBigStepLevels);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct LevelTooHigh {
        pub level: u8,
        pub numBigStepLevels: u8,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = (
            alloy::sol_types::sol_data::Uint<8>,
            alloy::sol_types::sol_data::Uint<8>,
        );
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = (u8, u8);
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<LevelTooHigh> for UnderlyingRustTuple<'_> {
            fn from(value: LevelTooHigh) -> Self {
                (value.level, value.numBigStepLevels)
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for LevelTooHigh {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self {
                    level: tuple.0,
                    numBigStepLevels: tuple.1,
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for LevelTooHigh {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "LevelTooHigh(uint8,uint8)";
            const SELECTOR: [u8; 4] = [174u8, 13u8, 165u8, 120u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        8,
                    > as alloy_sol_types::SolType>::tokenize(&self.level),
                    <alloy::sol_types::sol_data::Uint<
                        8,
                    > as alloy_sol_types::SolType>::tokenize(&self.numBigStepLevels),
                )
            }
        }
    };
    /**Custom error with signature `MerkleProofTooLong(uint256,uint256)` and selector `0xfdac331e`.
```solidity
error MerkleProofTooLong(uint256 actualLength, uint256 maxProofLength);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct MerkleProofTooLong {
        pub actualLength: alloy::sol_types::private::primitives::aliases::U256,
        pub maxProofLength: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = (
            alloy::sol_types::sol_data::Uint<256>,
            alloy::sol_types::sol_data::Uint<256>,
        );
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = (
            alloy::sol_types::private::primitives::aliases::U256,
            alloy::sol_types::private::primitives::aliases::U256,
        );
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<MerkleProofTooLong> for UnderlyingRustTuple<'_> {
            fn from(value: MerkleProofTooLong) -> Self {
                (value.actualLength, value.maxProofLength)
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for MerkleProofTooLong {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self {
                    actualLength: tuple.0,
                    maxProofLength: tuple.1,
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for MerkleProofTooLong {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "MerkleProofTooLong(uint256,uint256)";
            const SELECTOR: [u8; 4] = [253u8, 172u8, 51u8, 30u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.actualLength),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.maxProofLength),
                )
            }
        }
    };
    /**Custom error with signature `NotPowerOfTwo(uint256)` and selector `0xeafedbfc`.
```solidity
error NotPowerOfTwo(uint256 val);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct NotPowerOfTwo {
        pub val: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = (
            alloy::sol_types::private::primitives::aliases::U256,
        );
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<NotPowerOfTwo> for UnderlyingRustTuple<'_> {
            fn from(value: NotPowerOfTwo) -> Self {
                (value.val,)
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for NotPowerOfTwo {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self { val: tuple.0 }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for NotPowerOfTwo {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "NotPowerOfTwo(uint256)";
            const SELECTOR: [u8; 4] = [234u8, 254u8, 219u8, 252u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.val),
                )
            }
        }
    };
    /**Custom error with signature `NotValidator(address)` and selector `0xed3db8ac`.
```solidity
error NotValidator(address account);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct NotValidator {
        pub account: alloy::sol_types::private::Address,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Address,);
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = (alloy::sol_types::private::Address,);
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<NotValidator> for UnderlyingRustTuple<'_> {
            fn from(value: NotValidator) -> Self {
                (value.account,)
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for NotValidator {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self { account: tuple.0 }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for NotValidator {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "NotValidator(address)";
            const SELECTOR: [u8; 4] = [237u8, 61u8, 184u8, 172u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.account,
                    ),
                )
            }
        }
    };
    /**Custom error with signature `OriginIdMutualIdMismatch(bytes32,bytes32)` and selector `0xe2e27f87`.
```solidity
error OriginIdMutualIdMismatch(bytes32 mutualId, bytes32 originId);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct OriginIdMutualIdMismatch {
        pub mutualId: alloy::sol_types::private::FixedBytes<32>,
        pub originId: alloy::sol_types::private::FixedBytes<32>,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = (
            alloy::sol_types::sol_data::FixedBytes<32>,
            alloy::sol_types::sol_data::FixedBytes<32>,
        );
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = (
            alloy::sol_types::private::FixedBytes<32>,
            alloy::sol_types::private::FixedBytes<32>,
        );
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<OriginIdMutualIdMismatch>
        for UnderlyingRustTuple<'_> {
            fn from(value: OriginIdMutualIdMismatch) -> Self {
                (value.mutualId, value.originId)
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>>
        for OriginIdMutualIdMismatch {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self {
                    mutualId: tuple.0,
                    originId: tuple.1,
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for OriginIdMutualIdMismatch {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "OriginIdMutualIdMismatch(bytes32,bytes32)";
            const SELECTOR: [u8; 4] = [226u8, 226u8, 127u8, 135u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.mutualId),
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.originId),
                )
            }
        }
    };
    /**Custom error with signature `RivalEdgeConfirmed(bytes32,bytes32)` and selector `0xdd7028f0`.
```solidity
error RivalEdgeConfirmed(bytes32 edgeId, bytes32 confirmedRivalId);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct RivalEdgeConfirmed {
        pub edgeId: alloy::sol_types::private::FixedBytes<32>,
        pub confirmedRivalId: alloy::sol_types::private::FixedBytes<32>,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = (
            alloy::sol_types::sol_data::FixedBytes<32>,
            alloy::sol_types::sol_data::FixedBytes<32>,
        );
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = (
            alloy::sol_types::private::FixedBytes<32>,
            alloy::sol_types::private::FixedBytes<32>,
        );
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<RivalEdgeConfirmed> for UnderlyingRustTuple<'_> {
            fn from(value: RivalEdgeConfirmed) -> Self {
                (value.edgeId, value.confirmedRivalId)
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for RivalEdgeConfirmed {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self {
                    edgeId: tuple.0,
                    confirmedRivalId: tuple.1,
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for RivalEdgeConfirmed {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "RivalEdgeConfirmed(bytes32,bytes32)";
            const SELECTOR: [u8; 4] = [221u8, 112u8, 40u8, 240u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.edgeId),
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.confirmedRivalId),
                )
            }
        }
    };
    /**Custom error with signature `StakeAmountsMismatch(uint256,uint256)` and selector `0x0aece9c0`.
```solidity
error StakeAmountsMismatch(uint256 stakeLevels, uint256 numLevels);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct StakeAmountsMismatch {
        pub stakeLevels: alloy::sol_types::private::primitives::aliases::U256,
        pub numLevels: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = (
            alloy::sol_types::sol_data::Uint<256>,
            alloy::sol_types::sol_data::Uint<256>,
        );
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = (
            alloy::sol_types::private::primitives::aliases::U256,
            alloy::sol_types::private::primitives::aliases::U256,
        );
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<StakeAmountsMismatch> for UnderlyingRustTuple<'_> {
            fn from(value: StakeAmountsMismatch) -> Self {
                (value.stakeLevels, value.numLevels)
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for StakeAmountsMismatch {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self {
                    stakeLevels: tuple.0,
                    numLevels: tuple.1,
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for StakeAmountsMismatch {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "StakeAmountsMismatch(uint256,uint256)";
            const SELECTOR: [u8; 4] = [10u8, 236u8, 233u8, 192u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.stakeLevels),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.numLevels),
                )
            }
        }
    };
    /**Custom error with signature `ZeroBigStepLevels()` and selector `0xa863d6e4`.
```solidity
error ZeroBigStepLevels();
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct ZeroBigStepLevels {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = ();
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = ();
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<ZeroBigStepLevels> for UnderlyingRustTuple<'_> {
            fn from(value: ZeroBigStepLevels) -> Self {
                ()
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for ZeroBigStepLevels {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self {}
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for ZeroBigStepLevels {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "ZeroBigStepLevels()";
            const SELECTOR: [u8; 4] = [168u8, 99u8, 214u8, 228u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
        }
    };
    /**Event with signature `EdgeAdded(bytes32,bytes32,bytes32,bytes32,uint256,uint8,bool,bool)` and selector `0xaa4b66b1ce938c06e2a3f8466bae10ef62e747630e3859889f4719fc6427b5a4`.
```solidity
event EdgeAdded(bytes32 indexed edgeId, bytes32 indexed mutualId, bytes32 indexed originId, bytes32 claimId, uint256 length, uint8 level, bool hasRival, bool isLayerZero);
```*/
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    #[derive(Clone)]
    pub struct EdgeAdded {
        #[allow(missing_docs)]
        pub edgeId: alloy::sol_types::private::FixedBytes<32>,
        #[allow(missing_docs)]
        pub mutualId: alloy::sol_types::private::FixedBytes<32>,
        #[allow(missing_docs)]
        pub originId: alloy::sol_types::private::FixedBytes<32>,
        #[allow(missing_docs)]
        pub claimId: alloy::sol_types::private::FixedBytes<32>,
        #[allow(missing_docs)]
        pub length: alloy::sol_types::private::primitives::aliases::U256,
        #[allow(missing_docs)]
        pub level: u8,
        #[allow(missing_docs)]
        pub hasRival: bool,
        #[allow(missing_docs)]
        pub isLayerZero: bool,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[automatically_derived]
        impl alloy_sol_types::SolEvent for EdgeAdded {
            type DataTuple<'a> = (
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Uint<8>,
                alloy::sol_types::sol_data::Bool,
                alloy::sol_types::sol_data::Bool,
            );
            type DataToken<'a> = <Self::DataTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type TopicList = (
                alloy_sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<32>,
            );
            const SIGNATURE: &'static str = "EdgeAdded(bytes32,bytes32,bytes32,bytes32,uint256,uint8,bool,bool)";
            const SIGNATURE_HASH: alloy_sol_types::private::B256 = alloy_sol_types::private::B256::new([
                170u8,
                75u8,
                102u8,
                177u8,
                206u8,
                147u8,
                140u8,
                6u8,
                226u8,
                163u8,
                248u8,
                70u8,
                107u8,
                174u8,
                16u8,
                239u8,
                98u8,
                231u8,
                71u8,
                99u8,
                14u8,
                56u8,
                89u8,
                136u8,
                159u8,
                71u8,
                25u8,
                252u8,
                100u8,
                39u8,
                181u8,
                164u8,
            ]);
            const ANONYMOUS: bool = false;
            #[allow(unused_variables)]
            #[inline]
            fn new(
                topics: <Self::TopicList as alloy_sol_types::SolType>::RustType,
                data: <Self::DataTuple<'_> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                Self {
                    edgeId: topics.1,
                    mutualId: topics.2,
                    originId: topics.3,
                    claimId: data.0,
                    length: data.1,
                    level: data.2,
                    hasRival: data.3,
                    isLayerZero: data.4,
                }
            }
            #[inline]
            fn check_signature(
                topics: &<Self::TopicList as alloy_sol_types::SolType>::RustType,
            ) -> alloy_sol_types::Result<()> {
                if topics.0 != Self::SIGNATURE_HASH {
                    return Err(
                        alloy_sol_types::Error::invalid_event_signature_hash(
                            Self::SIGNATURE,
                            topics.0,
                            Self::SIGNATURE_HASH,
                        ),
                    );
                }
                Ok(())
            }
            #[inline]
            fn tokenize_body(&self) -> Self::DataToken<'_> {
                (
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.claimId),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.length),
                    <alloy::sol_types::sol_data::Uint<
                        8,
                    > as alloy_sol_types::SolType>::tokenize(&self.level),
                    <alloy::sol_types::sol_data::Bool as alloy_sol_types::SolType>::tokenize(
                        &self.hasRival,
                    ),
                    <alloy::sol_types::sol_data::Bool as alloy_sol_types::SolType>::tokenize(
                        &self.isLayerZero,
                    ),
                )
            }
            #[inline]
            fn topics(&self) -> <Self::TopicList as alloy_sol_types::SolType>::RustType {
                (
                    Self::SIGNATURE_HASH.into(),
                    self.edgeId.clone(),
                    self.mutualId.clone(),
                    self.originId.clone(),
                )
            }
            #[inline]
            fn encode_topics_raw(
                &self,
                out: &mut [alloy_sol_types::abi::token::WordToken],
            ) -> alloy_sol_types::Result<()> {
                if out.len() < <Self::TopicList as alloy_sol_types::TopicList>::COUNT {
                    return Err(alloy_sol_types::Error::Overrun);
                }
                out[0usize] = alloy_sol_types::abi::token::WordToken(
                    Self::SIGNATURE_HASH,
                );
                out[1usize] = <alloy::sol_types::sol_data::FixedBytes<
                    32,
                > as alloy_sol_types::EventTopic>::encode_topic(&self.edgeId);
                out[2usize] = <alloy::sol_types::sol_data::FixedBytes<
                    32,
                > as alloy_sol_types::EventTopic>::encode_topic(&self.mutualId);
                out[3usize] = <alloy::sol_types::sol_data::FixedBytes<
                    32,
                > as alloy_sol_types::EventTopic>::encode_topic(&self.originId);
                Ok(())
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::private::IntoLogData for EdgeAdded {
            fn to_log_data(&self) -> alloy_sol_types::private::LogData {
                From::from(self)
            }
            fn into_log_data(self) -> alloy_sol_types::private::LogData {
                From::from(&self)
            }
        }
        #[automatically_derived]
        impl From<&EdgeAdded> for alloy_sol_types::private::LogData {
            #[inline]
            fn from(this: &EdgeAdded) -> alloy_sol_types::private::LogData {
                alloy_sol_types::SolEvent::encode_log_data(this)
            }
        }
    };
    /**Event with signature `EdgeBisected(bytes32,bytes32,bytes32,bool)` and selector `0x7340510d24b7ec9b5c100f5500d93429d80d00d46f0d18e4e85d0c4cc22b9924`.
```solidity
event EdgeBisected(bytes32 indexed edgeId, bytes32 indexed lowerChildId, bytes32 indexed upperChildId, bool lowerChildAlreadyExists);
```*/
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    #[derive(Clone)]
    pub struct EdgeBisected {
        #[allow(missing_docs)]
        pub edgeId: alloy::sol_types::private::FixedBytes<32>,
        #[allow(missing_docs)]
        pub lowerChildId: alloy::sol_types::private::FixedBytes<32>,
        #[allow(missing_docs)]
        pub upperChildId: alloy::sol_types::private::FixedBytes<32>,
        #[allow(missing_docs)]
        pub lowerChildAlreadyExists: bool,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[automatically_derived]
        impl alloy_sol_types::SolEvent for EdgeBisected {
            type DataTuple<'a> = (alloy::sol_types::sol_data::Bool,);
            type DataToken<'a> = <Self::DataTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type TopicList = (
                alloy_sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<32>,
            );
            const SIGNATURE: &'static str = "EdgeBisected(bytes32,bytes32,bytes32,bool)";
            const SIGNATURE_HASH: alloy_sol_types::private::B256 = alloy_sol_types::private::B256::new([
                115u8,
                64u8,
                81u8,
                13u8,
                36u8,
                183u8,
                236u8,
                155u8,
                92u8,
                16u8,
                15u8,
                85u8,
                0u8,
                217u8,
                52u8,
                41u8,
                216u8,
                13u8,
                0u8,
                212u8,
                111u8,
                13u8,
                24u8,
                228u8,
                232u8,
                93u8,
                12u8,
                76u8,
                194u8,
                43u8,
                153u8,
                36u8,
            ]);
            const ANONYMOUS: bool = false;
            #[allow(unused_variables)]
            #[inline]
            fn new(
                topics: <Self::TopicList as alloy_sol_types::SolType>::RustType,
                data: <Self::DataTuple<'_> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                Self {
                    edgeId: topics.1,
                    lowerChildId: topics.2,
                    upperChildId: topics.3,
                    lowerChildAlreadyExists: data.0,
                }
            }
            #[inline]
            fn check_signature(
                topics: &<Self::TopicList as alloy_sol_types::SolType>::RustType,
            ) -> alloy_sol_types::Result<()> {
                if topics.0 != Self::SIGNATURE_HASH {
                    return Err(
                        alloy_sol_types::Error::invalid_event_signature_hash(
                            Self::SIGNATURE,
                            topics.0,
                            Self::SIGNATURE_HASH,
                        ),
                    );
                }
                Ok(())
            }
            #[inline]
            fn tokenize_body(&self) -> Self::DataToken<'_> {
                (
                    <alloy::sol_types::sol_data::Bool as alloy_sol_types::SolType>::tokenize(
                        &self.lowerChildAlreadyExists,
                    ),
                )
            }
            #[inline]
            fn topics(&self) -> <Self::TopicList as alloy_sol_types::SolType>::RustType {
                (
                    Self::SIGNATURE_HASH.into(),
                    self.edgeId.clone(),
                    self.lowerChildId.clone(),
                    self.upperChildId.clone(),
                )
            }
            #[inline]
            fn encode_topics_raw(
                &self,
                out: &mut [alloy_sol_types::abi::token::WordToken],
            ) -> alloy_sol_types::Result<()> {
                if out.len() < <Self::TopicList as alloy_sol_types::TopicList>::COUNT {
                    return Err(alloy_sol_types::Error::Overrun);
                }
                out[0usize] = alloy_sol_types::abi::token::WordToken(
                    Self::SIGNATURE_HASH,
                );
                out[1usize] = <alloy::sol_types::sol_data::FixedBytes<
                    32,
                > as alloy_sol_types::EventTopic>::encode_topic(&self.edgeId);
                out[2usize] = <alloy::sol_types::sol_data::FixedBytes<
                    32,
                > as alloy_sol_types::EventTopic>::encode_topic(&self.lowerChildId);
                out[3usize] = <alloy::sol_types::sol_data::FixedBytes<
                    32,
                > as alloy_sol_types::EventTopic>::encode_topic(&self.upperChildId);
                Ok(())
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::private::IntoLogData for EdgeBisected {
            fn to_log_data(&self) -> alloy_sol_types::private::LogData {
                From::from(self)
            }
            fn into_log_data(self) -> alloy_sol_types::private::LogData {
                From::from(&self)
            }
        }
        #[automatically_derived]
        impl From<&EdgeBisected> for alloy_sol_types::private::LogData {
            #[inline]
            fn from(this: &EdgeBisected) -> alloy_sol_types::private::LogData {
                alloy_sol_types::SolEvent::encode_log_data(this)
            }
        }
    };
    /**Event with signature `EdgeConfirmedByOneStepProof(bytes32,bytes32)` and selector `0xe11db4b27bc8c6ea5943ecbb205ae1ca8d56c42c719717aaf8a53d43d0cee7c2`.
```solidity
event EdgeConfirmedByOneStepProof(bytes32 indexed edgeId, bytes32 indexed mutualId);
```*/
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    #[derive(Clone)]
    pub struct EdgeConfirmedByOneStepProof {
        #[allow(missing_docs)]
        pub edgeId: alloy::sol_types::private::FixedBytes<32>,
        #[allow(missing_docs)]
        pub mutualId: alloy::sol_types::private::FixedBytes<32>,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[automatically_derived]
        impl alloy_sol_types::SolEvent for EdgeConfirmedByOneStepProof {
            type DataTuple<'a> = ();
            type DataToken<'a> = <Self::DataTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type TopicList = (
                alloy_sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<32>,
            );
            const SIGNATURE: &'static str = "EdgeConfirmedByOneStepProof(bytes32,bytes32)";
            const SIGNATURE_HASH: alloy_sol_types::private::B256 = alloy_sol_types::private::B256::new([
                225u8,
                29u8,
                180u8,
                178u8,
                123u8,
                200u8,
                198u8,
                234u8,
                89u8,
                67u8,
                236u8,
                187u8,
                32u8,
                90u8,
                225u8,
                202u8,
                141u8,
                86u8,
                196u8,
                44u8,
                113u8,
                151u8,
                23u8,
                170u8,
                248u8,
                165u8,
                61u8,
                67u8,
                208u8,
                206u8,
                231u8,
                194u8,
            ]);
            const ANONYMOUS: bool = false;
            #[allow(unused_variables)]
            #[inline]
            fn new(
                topics: <Self::TopicList as alloy_sol_types::SolType>::RustType,
                data: <Self::DataTuple<'_> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                Self {
                    edgeId: topics.1,
                    mutualId: topics.2,
                }
            }
            #[inline]
            fn check_signature(
                topics: &<Self::TopicList as alloy_sol_types::SolType>::RustType,
            ) -> alloy_sol_types::Result<()> {
                if topics.0 != Self::SIGNATURE_HASH {
                    return Err(
                        alloy_sol_types::Error::invalid_event_signature_hash(
                            Self::SIGNATURE,
                            topics.0,
                            Self::SIGNATURE_HASH,
                        ),
                    );
                }
                Ok(())
            }
            #[inline]
            fn tokenize_body(&self) -> Self::DataToken<'_> {
                ()
            }
            #[inline]
            fn topics(&self) -> <Self::TopicList as alloy_sol_types::SolType>::RustType {
                (Self::SIGNATURE_HASH.into(), self.edgeId.clone(), self.mutualId.clone())
            }
            #[inline]
            fn encode_topics_raw(
                &self,
                out: &mut [alloy_sol_types::abi::token::WordToken],
            ) -> alloy_sol_types::Result<()> {
                if out.len() < <Self::TopicList as alloy_sol_types::TopicList>::COUNT {
                    return Err(alloy_sol_types::Error::Overrun);
                }
                out[0usize] = alloy_sol_types::abi::token::WordToken(
                    Self::SIGNATURE_HASH,
                );
                out[1usize] = <alloy::sol_types::sol_data::FixedBytes<
                    32,
                > as alloy_sol_types::EventTopic>::encode_topic(&self.edgeId);
                out[2usize] = <alloy::sol_types::sol_data::FixedBytes<
                    32,
                > as alloy_sol_types::EventTopic>::encode_topic(&self.mutualId);
                Ok(())
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::private::IntoLogData for EdgeConfirmedByOneStepProof {
            fn to_log_data(&self) -> alloy_sol_types::private::LogData {
                From::from(self)
            }
            fn into_log_data(self) -> alloy_sol_types::private::LogData {
                From::from(&self)
            }
        }
        #[automatically_derived]
        impl From<&EdgeConfirmedByOneStepProof> for alloy_sol_types::private::LogData {
            #[inline]
            fn from(
                this: &EdgeConfirmedByOneStepProof,
            ) -> alloy_sol_types::private::LogData {
                alloy_sol_types::SolEvent::encode_log_data(this)
            }
        }
    };
    /**Event with signature `EdgeConfirmedByTime(bytes32,bytes32,uint256)` and selector `0x2e0808830a22204cb3fb8f8d784b28bc97e9ce2e39d2f9cde2860de0957d68eb`.
```solidity
event EdgeConfirmedByTime(bytes32 indexed edgeId, bytes32 indexed mutualId, uint256 totalTimeUnrivaled);
```*/
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    #[derive(Clone)]
    pub struct EdgeConfirmedByTime {
        #[allow(missing_docs)]
        pub edgeId: alloy::sol_types::private::FixedBytes<32>,
        #[allow(missing_docs)]
        pub mutualId: alloy::sol_types::private::FixedBytes<32>,
        #[allow(missing_docs)]
        pub totalTimeUnrivaled: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[automatically_derived]
        impl alloy_sol_types::SolEvent for EdgeConfirmedByTime {
            type DataTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type DataToken<'a> = <Self::DataTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type TopicList = (
                alloy_sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<32>,
            );
            const SIGNATURE: &'static str = "EdgeConfirmedByTime(bytes32,bytes32,uint256)";
            const SIGNATURE_HASH: alloy_sol_types::private::B256 = alloy_sol_types::private::B256::new([
                46u8,
                8u8,
                8u8,
                131u8,
                10u8,
                34u8,
                32u8,
                76u8,
                179u8,
                251u8,
                143u8,
                141u8,
                120u8,
                75u8,
                40u8,
                188u8,
                151u8,
                233u8,
                206u8,
                46u8,
                57u8,
                210u8,
                249u8,
                205u8,
                226u8,
                134u8,
                13u8,
                224u8,
                149u8,
                125u8,
                104u8,
                235u8,
            ]);
            const ANONYMOUS: bool = false;
            #[allow(unused_variables)]
            #[inline]
            fn new(
                topics: <Self::TopicList as alloy_sol_types::SolType>::RustType,
                data: <Self::DataTuple<'_> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                Self {
                    edgeId: topics.1,
                    mutualId: topics.2,
                    totalTimeUnrivaled: data.0,
                }
            }
            #[inline]
            fn check_signature(
                topics: &<Self::TopicList as alloy_sol_types::SolType>::RustType,
            ) -> alloy_sol_types::Result<()> {
                if topics.0 != Self::SIGNATURE_HASH {
                    return Err(
                        alloy_sol_types::Error::invalid_event_signature_hash(
                            Self::SIGNATURE,
                            topics.0,
                            Self::SIGNATURE_HASH,
                        ),
                    );
                }
                Ok(())
            }
            #[inline]
            fn tokenize_body(&self) -> Self::DataToken<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.totalTimeUnrivaled),
                )
            }
            #[inline]
            fn topics(&self) -> <Self::TopicList as alloy_sol_types::SolType>::RustType {
                (Self::SIGNATURE_HASH.into(), self.edgeId.clone(), self.mutualId.clone())
            }
            #[inline]
            fn encode_topics_raw(
                &self,
                out: &mut [alloy_sol_types::abi::token::WordToken],
            ) -> alloy_sol_types::Result<()> {
                if out.len() < <Self::TopicList as alloy_sol_types::TopicList>::COUNT {
                    return Err(alloy_sol_types::Error::Overrun);
                }
                out[0usize] = alloy_sol_types::abi::token::WordToken(
                    Self::SIGNATURE_HASH,
                );
                out[1usize] = <alloy::sol_types::sol_data::FixedBytes<
                    32,
                > as alloy_sol_types::EventTopic>::encode_topic(&self.edgeId);
                out[2usize] = <alloy::sol_types::sol_data::FixedBytes<
                    32,
                > as alloy_sol_types::EventTopic>::encode_topic(&self.mutualId);
                Ok(())
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::private::IntoLogData for EdgeConfirmedByTime {
            fn to_log_data(&self) -> alloy_sol_types::private::LogData {
                From::from(self)
            }
            fn into_log_data(self) -> alloy_sol_types::private::LogData {
                From::from(&self)
            }
        }
        #[automatically_derived]
        impl From<&EdgeConfirmedByTime> for alloy_sol_types::private::LogData {
            #[inline]
            fn from(this: &EdgeConfirmedByTime) -> alloy_sol_types::private::LogData {
                alloy_sol_types::SolEvent::encode_log_data(this)
            }
        }
    };
    /**Event with signature `EdgeRefunded(bytes32,bytes32,address,uint256)` and selector `0xa635398959ddb5ce3b14537edfc25b2e671274c9b8cad0f4bd634752e69007b6`.
```solidity
event EdgeRefunded(bytes32 indexed edgeId, bytes32 indexed mutualId, address stakeToken, uint256 stakeAmount);
```*/
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    #[derive(Clone)]
    pub struct EdgeRefunded {
        #[allow(missing_docs)]
        pub edgeId: alloy::sol_types::private::FixedBytes<32>,
        #[allow(missing_docs)]
        pub mutualId: alloy::sol_types::private::FixedBytes<32>,
        #[allow(missing_docs)]
        pub stakeToken: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub stakeAmount: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[automatically_derived]
        impl alloy_sol_types::SolEvent for EdgeRefunded {
            type DataTuple<'a> = (
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Uint<256>,
            );
            type DataToken<'a> = <Self::DataTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type TopicList = (
                alloy_sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<32>,
            );
            const SIGNATURE: &'static str = "EdgeRefunded(bytes32,bytes32,address,uint256)";
            const SIGNATURE_HASH: alloy_sol_types::private::B256 = alloy_sol_types::private::B256::new([
                166u8,
                53u8,
                57u8,
                137u8,
                89u8,
                221u8,
                181u8,
                206u8,
                59u8,
                20u8,
                83u8,
                126u8,
                223u8,
                194u8,
                91u8,
                46u8,
                103u8,
                18u8,
                116u8,
                201u8,
                184u8,
                202u8,
                208u8,
                244u8,
                189u8,
                99u8,
                71u8,
                82u8,
                230u8,
                144u8,
                7u8,
                182u8,
            ]);
            const ANONYMOUS: bool = false;
            #[allow(unused_variables)]
            #[inline]
            fn new(
                topics: <Self::TopicList as alloy_sol_types::SolType>::RustType,
                data: <Self::DataTuple<'_> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                Self {
                    edgeId: topics.1,
                    mutualId: topics.2,
                    stakeToken: data.0,
                    stakeAmount: data.1,
                }
            }
            #[inline]
            fn check_signature(
                topics: &<Self::TopicList as alloy_sol_types::SolType>::RustType,
            ) -> alloy_sol_types::Result<()> {
                if topics.0 != Self::SIGNATURE_HASH {
                    return Err(
                        alloy_sol_types::Error::invalid_event_signature_hash(
                            Self::SIGNATURE,
                            topics.0,
                            Self::SIGNATURE_HASH,
                        ),
                    );
                }
                Ok(())
            }
            #[inline]
            fn tokenize_body(&self) -> Self::DataToken<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.stakeToken,
                    ),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.stakeAmount),
                )
            }
            #[inline]
            fn topics(&self) -> <Self::TopicList as alloy_sol_types::SolType>::RustType {
                (Self::SIGNATURE_HASH.into(), self.edgeId.clone(), self.mutualId.clone())
            }
            #[inline]
            fn encode_topics_raw(
                &self,
                out: &mut [alloy_sol_types::abi::token::WordToken],
            ) -> alloy_sol_types::Result<()> {
                if out.len() < <Self::TopicList as alloy_sol_types::TopicList>::COUNT {
                    return Err(alloy_sol_types::Error::Overrun);
                }
                out[0usize] = alloy_sol_types::abi::token::WordToken(
                    Self::SIGNATURE_HASH,
                );
                out[1usize] = <alloy::sol_types::sol_data::FixedBytes<
                    32,
                > as alloy_sol_types::EventTopic>::encode_topic(&self.edgeId);
                out[2usize] = <alloy::sol_types::sol_data::FixedBytes<
                    32,
                > as alloy_sol_types::EventTopic>::encode_topic(&self.mutualId);
                Ok(())
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::private::IntoLogData for EdgeRefunded {
            fn to_log_data(&self) -> alloy_sol_types::private::LogData {
                From::from(self)
            }
            fn into_log_data(self) -> alloy_sol_types::private::LogData {
                From::from(&self)
            }
        }
        #[automatically_derived]
        impl From<&EdgeRefunded> for alloy_sol_types::private::LogData {
            #[inline]
            fn from(this: &EdgeRefunded) -> alloy_sol_types::private::LogData {
                alloy_sol_types::SolEvent::encode_log_data(this)
            }
        }
    };
    /**Event with signature `Initialized(uint8)` and selector `0x7f26b83ff96e1f2b6a682f133852f6798a09c465da95921460cefb3847402498`.
```solidity
event Initialized(uint8 version);
```*/
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    #[derive(Clone)]
    pub struct Initialized {
        #[allow(missing_docs)]
        pub version: u8,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[automatically_derived]
        impl alloy_sol_types::SolEvent for Initialized {
            type DataTuple<'a> = (alloy::sol_types::sol_data::Uint<8>,);
            type DataToken<'a> = <Self::DataTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type TopicList = (alloy_sol_types::sol_data::FixedBytes<32>,);
            const SIGNATURE: &'static str = "Initialized(uint8)";
            const SIGNATURE_HASH: alloy_sol_types::private::B256 = alloy_sol_types::private::B256::new([
                127u8,
                38u8,
                184u8,
                63u8,
                249u8,
                110u8,
                31u8,
                43u8,
                106u8,
                104u8,
                47u8,
                19u8,
                56u8,
                82u8,
                246u8,
                121u8,
                138u8,
                9u8,
                196u8,
                101u8,
                218u8,
                149u8,
                146u8,
                20u8,
                96u8,
                206u8,
                251u8,
                56u8,
                71u8,
                64u8,
                36u8,
                152u8,
            ]);
            const ANONYMOUS: bool = false;
            #[allow(unused_variables)]
            #[inline]
            fn new(
                topics: <Self::TopicList as alloy_sol_types::SolType>::RustType,
                data: <Self::DataTuple<'_> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                Self { version: data.0 }
            }
            #[inline]
            fn check_signature(
                topics: &<Self::TopicList as alloy_sol_types::SolType>::RustType,
            ) -> alloy_sol_types::Result<()> {
                if topics.0 != Self::SIGNATURE_HASH {
                    return Err(
                        alloy_sol_types::Error::invalid_event_signature_hash(
                            Self::SIGNATURE,
                            topics.0,
                            Self::SIGNATURE_HASH,
                        ),
                    );
                }
                Ok(())
            }
            #[inline]
            fn tokenize_body(&self) -> Self::DataToken<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        8,
                    > as alloy_sol_types::SolType>::tokenize(&self.version),
                )
            }
            #[inline]
            fn topics(&self) -> <Self::TopicList as alloy_sol_types::SolType>::RustType {
                (Self::SIGNATURE_HASH.into(),)
            }
            #[inline]
            fn encode_topics_raw(
                &self,
                out: &mut [alloy_sol_types::abi::token::WordToken],
            ) -> alloy_sol_types::Result<()> {
                if out.len() < <Self::TopicList as alloy_sol_types::TopicList>::COUNT {
                    return Err(alloy_sol_types::Error::Overrun);
                }
                out[0usize] = alloy_sol_types::abi::token::WordToken(
                    Self::SIGNATURE_HASH,
                );
                Ok(())
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::private::IntoLogData for Initialized {
            fn to_log_data(&self) -> alloy_sol_types::private::LogData {
                From::from(self)
            }
            fn into_log_data(self) -> alloy_sol_types::private::LogData {
                From::from(&self)
            }
        }
        #[automatically_derived]
        impl From<&Initialized> for alloy_sol_types::private::LogData {
            #[inline]
            fn from(this: &Initialized) -> alloy_sol_types::private::LogData {
                alloy_sol_types::SolEvent::encode_log_data(this)
            }
        }
    };
    /**Event with signature `TimerCacheUpdated(bytes32,uint256)` and selector `0xbe17755d8d836ad67bfaf8e5b3869aedb4cba03f295a167c5547feddd9ef50ad`.
```solidity
event TimerCacheUpdated(bytes32 indexed edgeId, uint256 newValue);
```*/
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    #[derive(Clone)]
    pub struct TimerCacheUpdated {
        #[allow(missing_docs)]
        pub edgeId: alloy::sol_types::private::FixedBytes<32>,
        #[allow(missing_docs)]
        pub newValue: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[automatically_derived]
        impl alloy_sol_types::SolEvent for TimerCacheUpdated {
            type DataTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type DataToken<'a> = <Self::DataTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type TopicList = (
                alloy_sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<32>,
            );
            const SIGNATURE: &'static str = "TimerCacheUpdated(bytes32,uint256)";
            const SIGNATURE_HASH: alloy_sol_types::private::B256 = alloy_sol_types::private::B256::new([
                190u8,
                23u8,
                117u8,
                93u8,
                141u8,
                131u8,
                106u8,
                214u8,
                123u8,
                250u8,
                248u8,
                229u8,
                179u8,
                134u8,
                154u8,
                237u8,
                180u8,
                203u8,
                160u8,
                63u8,
                41u8,
                90u8,
                22u8,
                124u8,
                85u8,
                71u8,
                254u8,
                221u8,
                217u8,
                239u8,
                80u8,
                173u8,
            ]);
            const ANONYMOUS: bool = false;
            #[allow(unused_variables)]
            #[inline]
            fn new(
                topics: <Self::TopicList as alloy_sol_types::SolType>::RustType,
                data: <Self::DataTuple<'_> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                Self {
                    edgeId: topics.1,
                    newValue: data.0,
                }
            }
            #[inline]
            fn check_signature(
                topics: &<Self::TopicList as alloy_sol_types::SolType>::RustType,
            ) -> alloy_sol_types::Result<()> {
                if topics.0 != Self::SIGNATURE_HASH {
                    return Err(
                        alloy_sol_types::Error::invalid_event_signature_hash(
                            Self::SIGNATURE,
                            topics.0,
                            Self::SIGNATURE_HASH,
                        ),
                    );
                }
                Ok(())
            }
            #[inline]
            fn tokenize_body(&self) -> Self::DataToken<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.newValue),
                )
            }
            #[inline]
            fn topics(&self) -> <Self::TopicList as alloy_sol_types::SolType>::RustType {
                (Self::SIGNATURE_HASH.into(), self.edgeId.clone())
            }
            #[inline]
            fn encode_topics_raw(
                &self,
                out: &mut [alloy_sol_types::abi::token::WordToken],
            ) -> alloy_sol_types::Result<()> {
                if out.len() < <Self::TopicList as alloy_sol_types::TopicList>::COUNT {
                    return Err(alloy_sol_types::Error::Overrun);
                }
                out[0usize] = alloy_sol_types::abi::token::WordToken(
                    Self::SIGNATURE_HASH,
                );
                out[1usize] = <alloy::sol_types::sol_data::FixedBytes<
                    32,
                > as alloy_sol_types::EventTopic>::encode_topic(&self.edgeId);
                Ok(())
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::private::IntoLogData for TimerCacheUpdated {
            fn to_log_data(&self) -> alloy_sol_types::private::LogData {
                From::from(self)
            }
            fn into_log_data(self) -> alloy_sol_types::private::LogData {
                From::from(&self)
            }
        }
        #[automatically_derived]
        impl From<&TimerCacheUpdated> for alloy_sol_types::private::LogData {
            #[inline]
            fn from(this: &TimerCacheUpdated) -> alloy_sol_types::private::LogData {
                alloy_sol_types::SolEvent::encode_log_data(this)
            }
        }
    };
    /**Constructor`.
```solidity
constructor();
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct constructorCall {}
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<constructorCall> for UnderlyingRustTuple<'_> {
                fn from(value: constructorCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for constructorCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolConstructor for constructorCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
        }
    };
    /**Function with signature `LAYERZERO_BIGSTEPEDGE_HEIGHT()` and selector `0x416e6657`.
```solidity
function LAYERZERO_BIGSTEPEDGE_HEIGHT() external view returns (uint256);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct LAYERZERO_BIGSTEPEDGE_HEIGHTCall {}
    ///Container type for the return parameters of the [`LAYERZERO_BIGSTEPEDGE_HEIGHT()`](LAYERZERO_BIGSTEPEDGE_HEIGHTCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct LAYERZERO_BIGSTEPEDGE_HEIGHTReturn {
        pub _0: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<LAYERZERO_BIGSTEPEDGE_HEIGHTCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: LAYERZERO_BIGSTEPEDGE_HEIGHTCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for LAYERZERO_BIGSTEPEDGE_HEIGHTCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<LAYERZERO_BIGSTEPEDGE_HEIGHTReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: LAYERZERO_BIGSTEPEDGE_HEIGHTReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for LAYERZERO_BIGSTEPEDGE_HEIGHTReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for LAYERZERO_BIGSTEPEDGE_HEIGHTCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = LAYERZERO_BIGSTEPEDGE_HEIGHTReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "LAYERZERO_BIGSTEPEDGE_HEIGHT()";
            const SELECTOR: [u8; 4] = [65u8, 110u8, 102u8, 87u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `LAYERZERO_BLOCKEDGE_HEIGHT()` and selector `0x1dce5166`.
```solidity
function LAYERZERO_BLOCKEDGE_HEIGHT() external view returns (uint256);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct LAYERZERO_BLOCKEDGE_HEIGHTCall {}
    ///Container type for the return parameters of the [`LAYERZERO_BLOCKEDGE_HEIGHT()`](LAYERZERO_BLOCKEDGE_HEIGHTCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct LAYERZERO_BLOCKEDGE_HEIGHTReturn {
        pub _0: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<LAYERZERO_BLOCKEDGE_HEIGHTCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: LAYERZERO_BLOCKEDGE_HEIGHTCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for LAYERZERO_BLOCKEDGE_HEIGHTCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<LAYERZERO_BLOCKEDGE_HEIGHTReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: LAYERZERO_BLOCKEDGE_HEIGHTReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for LAYERZERO_BLOCKEDGE_HEIGHTReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for LAYERZERO_BLOCKEDGE_HEIGHTCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = LAYERZERO_BLOCKEDGE_HEIGHTReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "LAYERZERO_BLOCKEDGE_HEIGHT()";
            const SELECTOR: [u8; 4] = [29u8, 206u8, 81u8, 102u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `LAYERZERO_SMALLSTEPEDGE_HEIGHT()` and selector `0xf8ee77d6`.
```solidity
function LAYERZERO_SMALLSTEPEDGE_HEIGHT() external view returns (uint256);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct LAYERZERO_SMALLSTEPEDGE_HEIGHTCall {}
    ///Container type for the return parameters of the [`LAYERZERO_SMALLSTEPEDGE_HEIGHT()`](LAYERZERO_SMALLSTEPEDGE_HEIGHTCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct LAYERZERO_SMALLSTEPEDGE_HEIGHTReturn {
        pub _0: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<LAYERZERO_SMALLSTEPEDGE_HEIGHTCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: LAYERZERO_SMALLSTEPEDGE_HEIGHTCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for LAYERZERO_SMALLSTEPEDGE_HEIGHTCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<LAYERZERO_SMALLSTEPEDGE_HEIGHTReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: LAYERZERO_SMALLSTEPEDGE_HEIGHTReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for LAYERZERO_SMALLSTEPEDGE_HEIGHTReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for LAYERZERO_SMALLSTEPEDGE_HEIGHTCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = LAYERZERO_SMALLSTEPEDGE_HEIGHTReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "LAYERZERO_SMALLSTEPEDGE_HEIGHT()";
            const SELECTOR: [u8; 4] = [248u8, 238u8, 119u8, 214u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `NUM_BIGSTEP_LEVEL()` and selector `0x5d9e2444`.
```solidity
function NUM_BIGSTEP_LEVEL() external view returns (uint8);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct NUM_BIGSTEP_LEVELCall {}
    ///Container type for the return parameters of the [`NUM_BIGSTEP_LEVEL()`](NUM_BIGSTEP_LEVELCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct NUM_BIGSTEP_LEVELReturn {
        pub _0: u8,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<NUM_BIGSTEP_LEVELCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: NUM_BIGSTEP_LEVELCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for NUM_BIGSTEP_LEVELCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<8>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (u8,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<NUM_BIGSTEP_LEVELReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: NUM_BIGSTEP_LEVELReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for NUM_BIGSTEP_LEVELReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for NUM_BIGSTEP_LEVELCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = NUM_BIGSTEP_LEVELReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Uint<8>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "NUM_BIGSTEP_LEVEL()";
            const SELECTOR: [u8; 4] = [93u8, 158u8, 36u8, 68u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `assertionChain()` and selector `0x48dd2924`.
```solidity
function assertionChain() external view returns (address);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct assertionChainCall {}
    ///Container type for the return parameters of the [`assertionChain()`](assertionChainCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct assertionChainReturn {
        pub _0: alloy::sol_types::private::Address,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<assertionChainCall> for UnderlyingRustTuple<'_> {
                fn from(value: assertionChainCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for assertionChainCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Address,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::Address,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<assertionChainReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: assertionChainReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for assertionChainReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for assertionChainCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = assertionChainReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Address,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "assertionChain()";
            const SELECTOR: [u8; 4] = [72u8, 221u8, 41u8, 36u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `bisectEdge(bytes32,bytes32,bytes)` and selector `0xc8bc4e43`.
```solidity
function bisectEdge(bytes32 edgeId, bytes32 bisectionHistoryRoot, bytes memory prefixProof) external returns (bytes32, bytes32);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct bisectEdgeCall {
        pub edgeId: alloy::sol_types::private::FixedBytes<32>,
        pub bisectionHistoryRoot: alloy::sol_types::private::FixedBytes<32>,
        pub prefixProof: alloy::sol_types::private::Bytes,
    }
    ///Container type for the return parameters of the [`bisectEdge(bytes32,bytes32,bytes)`](bisectEdgeCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct bisectEdgeReturn {
        pub _0: alloy::sol_types::private::FixedBytes<32>,
        pub _1: alloy::sol_types::private::FixedBytes<32>,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Bytes,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::FixedBytes<32>,
                alloy::sol_types::private::FixedBytes<32>,
                alloy::sol_types::private::Bytes,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<bisectEdgeCall> for UnderlyingRustTuple<'_> {
                fn from(value: bisectEdgeCall) -> Self {
                    (value.edgeId, value.bisectionHistoryRoot, value.prefixProof)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for bisectEdgeCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        edgeId: tuple.0,
                        bisectionHistoryRoot: tuple.1,
                        prefixProof: tuple.2,
                    }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<32>,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::FixedBytes<32>,
                alloy::sol_types::private::FixedBytes<32>,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<bisectEdgeReturn> for UnderlyingRustTuple<'_> {
                fn from(value: bisectEdgeReturn) -> Self {
                    (value._0, value._1)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for bisectEdgeReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0, _1: tuple.1 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for bisectEdgeCall {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Bytes,
            );
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = bisectEdgeReturn;
            type ReturnTuple<'a> = (
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<32>,
            );
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "bisectEdge(bytes32,bytes32,bytes)";
            const SELECTOR: [u8; 4] = [200u8, 188u8, 78u8, 67u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.edgeId),
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.bisectionHistoryRoot),
                    <alloy::sol_types::sol_data::Bytes as alloy_sol_types::SolType>::tokenize(
                        &self.prefixProof,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `calculateEdgeId(uint8,bytes32,uint256,bytes32,uint256,bytes32)` and selector `0x004d8efe`.
```solidity
function calculateEdgeId(uint8 level, bytes32 originId, uint256 startHeight, bytes32 startHistoryRoot, uint256 endHeight, bytes32 endHistoryRoot) external pure returns (bytes32);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct calculateEdgeIdCall {
        pub level: u8,
        pub originId: alloy::sol_types::private::FixedBytes<32>,
        pub startHeight: alloy::sol_types::private::primitives::aliases::U256,
        pub startHistoryRoot: alloy::sol_types::private::FixedBytes<32>,
        pub endHeight: alloy::sol_types::private::primitives::aliases::U256,
        pub endHistoryRoot: alloy::sol_types::private::FixedBytes<32>,
    }
    ///Container type for the return parameters of the [`calculateEdgeId(uint8,bytes32,uint256,bytes32,uint256,bytes32)`](calculateEdgeIdCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct calculateEdgeIdReturn {
        pub _0: alloy::sol_types::private::FixedBytes<32>,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::Uint<8>,
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::FixedBytes<32>,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                u8,
                alloy::sol_types::private::FixedBytes<32>,
                alloy::sol_types::private::primitives::aliases::U256,
                alloy::sol_types::private::FixedBytes<32>,
                alloy::sol_types::private::primitives::aliases::U256,
                alloy::sol_types::private::FixedBytes<32>,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<calculateEdgeIdCall> for UnderlyingRustTuple<'_> {
                fn from(value: calculateEdgeIdCall) -> Self {
                    (
                        value.level,
                        value.originId,
                        value.startHeight,
                        value.startHistoryRoot,
                        value.endHeight,
                        value.endHistoryRoot,
                    )
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for calculateEdgeIdCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        level: tuple.0,
                        originId: tuple.1,
                        startHeight: tuple.2,
                        startHistoryRoot: tuple.3,
                        endHeight: tuple.4,
                        endHistoryRoot: tuple.5,
                    }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::FixedBytes<32>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::FixedBytes<32>,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<calculateEdgeIdReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: calculateEdgeIdReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for calculateEdgeIdReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for calculateEdgeIdCall {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::Uint<8>,
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::FixedBytes<32>,
            );
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = calculateEdgeIdReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::FixedBytes<32>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "calculateEdgeId(uint8,bytes32,uint256,bytes32,uint256,bytes32)";
            const SELECTOR: [u8; 4] = [0u8, 77u8, 142u8, 254u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        8,
                    > as alloy_sol_types::SolType>::tokenize(&self.level),
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.originId),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.startHeight),
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.startHistoryRoot),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.endHeight),
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.endHistoryRoot),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `calculateMutualId(uint8,bytes32,uint256,bytes32,uint256)` and selector `0xc32d8c63`.
```solidity
function calculateMutualId(uint8 level, bytes32 originId, uint256 startHeight, bytes32 startHistoryRoot, uint256 endHeight) external pure returns (bytes32);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct calculateMutualIdCall {
        pub level: u8,
        pub originId: alloy::sol_types::private::FixedBytes<32>,
        pub startHeight: alloy::sol_types::private::primitives::aliases::U256,
        pub startHistoryRoot: alloy::sol_types::private::FixedBytes<32>,
        pub endHeight: alloy::sol_types::private::primitives::aliases::U256,
    }
    ///Container type for the return parameters of the [`calculateMutualId(uint8,bytes32,uint256,bytes32,uint256)`](calculateMutualIdCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct calculateMutualIdReturn {
        pub _0: alloy::sol_types::private::FixedBytes<32>,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::Uint<8>,
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Uint<256>,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                u8,
                alloy::sol_types::private::FixedBytes<32>,
                alloy::sol_types::private::primitives::aliases::U256,
                alloy::sol_types::private::FixedBytes<32>,
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<calculateMutualIdCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: calculateMutualIdCall) -> Self {
                    (
                        value.level,
                        value.originId,
                        value.startHeight,
                        value.startHistoryRoot,
                        value.endHeight,
                    )
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for calculateMutualIdCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        level: tuple.0,
                        originId: tuple.1,
                        startHeight: tuple.2,
                        startHistoryRoot: tuple.3,
                        endHeight: tuple.4,
                    }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::FixedBytes<32>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::FixedBytes<32>,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<calculateMutualIdReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: calculateMutualIdReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for calculateMutualIdReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for calculateMutualIdCall {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::Uint<8>,
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Uint<256>,
            );
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = calculateMutualIdReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::FixedBytes<32>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "calculateMutualId(uint8,bytes32,uint256,bytes32,uint256)";
            const SELECTOR: [u8; 4] = [195u8, 45u8, 140u8, 99u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        8,
                    > as alloy_sol_types::SolType>::tokenize(&self.level),
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.originId),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.startHeight),
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.startHistoryRoot),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.endHeight),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `challengePeriodBlocks()` and selector `0x46c2781a`.
```solidity
function challengePeriodBlocks() external view returns (uint64);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct challengePeriodBlocksCall {}
    ///Container type for the return parameters of the [`challengePeriodBlocks()`](challengePeriodBlocksCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct challengePeriodBlocksReturn {
        pub _0: u64,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<challengePeriodBlocksCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: challengePeriodBlocksCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for challengePeriodBlocksCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<64>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (u64,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<challengePeriodBlocksReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: challengePeriodBlocksReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for challengePeriodBlocksReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for challengePeriodBlocksCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = challengePeriodBlocksReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Uint<64>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "challengePeriodBlocks()";
            const SELECTOR: [u8; 4] = [70u8, 194u8, 120u8, 26u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `confirmEdgeByOneStepProof(bytes32,(bytes32,bytes),(bytes32,uint256,address,uint64,uint64),bytes32[],bytes32[])` and selector `0x8c1b3a40`.
```solidity
function confirmEdgeByOneStepProof(bytes32 edgeId, OneStepData memory oneStepData, ConfigData memory prevConfig, bytes32[] memory beforeHistoryInclusionProof, bytes32[] memory afterHistoryInclusionProof) external;
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct confirmEdgeByOneStepProofCall {
        pub edgeId: alloy::sol_types::private::FixedBytes<32>,
        pub oneStepData: <OneStepData as alloy::sol_types::SolType>::RustType,
        pub prevConfig: <ConfigData as alloy::sol_types::SolType>::RustType,
        pub beforeHistoryInclusionProof: alloy::sol_types::private::Vec<
            alloy::sol_types::private::FixedBytes<32>,
        >,
        pub afterHistoryInclusionProof: alloy::sol_types::private::Vec<
            alloy::sol_types::private::FixedBytes<32>,
        >,
    }
    ///Container type for the return parameters of the [`confirmEdgeByOneStepProof(bytes32,(bytes32,bytes),(bytes32,uint256,address,uint64,uint64),bytes32[],bytes32[])`](confirmEdgeByOneStepProofCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct confirmEdgeByOneStepProofReturn {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::FixedBytes<32>,
                OneStepData,
                ConfigData,
                alloy::sol_types::sol_data::Array<
                    alloy::sol_types::sol_data::FixedBytes<32>,
                >,
                alloy::sol_types::sol_data::Array<
                    alloy::sol_types::sol_data::FixedBytes<32>,
                >,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::FixedBytes<32>,
                <OneStepData as alloy::sol_types::SolType>::RustType,
                <ConfigData as alloy::sol_types::SolType>::RustType,
                alloy::sol_types::private::Vec<
                    alloy::sol_types::private::FixedBytes<32>,
                >,
                alloy::sol_types::private::Vec<alloy::sol_types::private::FixedBytes<32>>,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<confirmEdgeByOneStepProofCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: confirmEdgeByOneStepProofCall) -> Self {
                    (
                        value.edgeId,
                        value.oneStepData,
                        value.prevConfig,
                        value.beforeHistoryInclusionProof,
                        value.afterHistoryInclusionProof,
                    )
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for confirmEdgeByOneStepProofCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        edgeId: tuple.0,
                        oneStepData: tuple.1,
                        prevConfig: tuple.2,
                        beforeHistoryInclusionProof: tuple.3,
                        afterHistoryInclusionProof: tuple.4,
                    }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<confirmEdgeByOneStepProofReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: confirmEdgeByOneStepProofReturn) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for confirmEdgeByOneStepProofReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for confirmEdgeByOneStepProofCall {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::FixedBytes<32>,
                OneStepData,
                ConfigData,
                alloy::sol_types::sol_data::Array<
                    alloy::sol_types::sol_data::FixedBytes<32>,
                >,
                alloy::sol_types::sol_data::Array<
                    alloy::sol_types::sol_data::FixedBytes<32>,
                >,
            );
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = confirmEdgeByOneStepProofReturn;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "confirmEdgeByOneStepProof(bytes32,(bytes32,bytes),(bytes32,uint256,address,uint64,uint64),bytes32[],bytes32[])";
            const SELECTOR: [u8; 4] = [140u8, 27u8, 58u8, 64u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.edgeId),
                    <OneStepData as alloy_sol_types::SolType>::tokenize(
                        &self.oneStepData,
                    ),
                    <ConfigData as alloy_sol_types::SolType>::tokenize(&self.prevConfig),
                    <alloy::sol_types::sol_data::Array<
                        alloy::sol_types::sol_data::FixedBytes<32>,
                    > as alloy_sol_types::SolType>::tokenize(
                        &self.beforeHistoryInclusionProof,
                    ),
                    <alloy::sol_types::sol_data::Array<
                        alloy::sol_types::sol_data::FixedBytes<32>,
                    > as alloy_sol_types::SolType>::tokenize(
                        &self.afterHistoryInclusionProof,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `confirmEdgeByTime(bytes32,(((bytes32[2],uint64[2]),uint8,bytes32),bytes32,bytes32))` and selector `0xb2a1408e`.
```solidity
function confirmEdgeByTime(bytes32 edgeId, AssertionStateData memory claimStateData) external;
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct confirmEdgeByTimeCall {
        pub edgeId: alloy::sol_types::private::FixedBytes<32>,
        pub claimStateData: <AssertionStateData as alloy::sol_types::SolType>::RustType,
    }
    ///Container type for the return parameters of the [`confirmEdgeByTime(bytes32,(((bytes32[2],uint64[2]),uint8,bytes32),bytes32,bytes32))`](confirmEdgeByTimeCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct confirmEdgeByTimeReturn {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::FixedBytes<32>,
                AssertionStateData,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::FixedBytes<32>,
                <AssertionStateData as alloy::sol_types::SolType>::RustType,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<confirmEdgeByTimeCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: confirmEdgeByTimeCall) -> Self {
                    (value.edgeId, value.claimStateData)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for confirmEdgeByTimeCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        edgeId: tuple.0,
                        claimStateData: tuple.1,
                    }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<confirmEdgeByTimeReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: confirmEdgeByTimeReturn) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for confirmEdgeByTimeReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for confirmEdgeByTimeCall {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::FixedBytes<32>,
                AssertionStateData,
            );
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = confirmEdgeByTimeReturn;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "confirmEdgeByTime(bytes32,(((bytes32[2],uint64[2]),uint8,bytes32),bytes32,bytes32))";
            const SELECTOR: [u8; 4] = [178u8, 161u8, 64u8, 142u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.edgeId),
                    <AssertionStateData as alloy_sol_types::SolType>::tokenize(
                        &self.claimStateData,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `confirmedRival(bytes32)` and selector `0xe5b123da`.
```solidity
function confirmedRival(bytes32 mutualId) external view returns (bytes32);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct confirmedRivalCall {
        pub mutualId: alloy::sol_types::private::FixedBytes<32>,
    }
    ///Container type for the return parameters of the [`confirmedRival(bytes32)`](confirmedRivalCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct confirmedRivalReturn {
        pub _0: alloy::sol_types::private::FixedBytes<32>,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::FixedBytes<32>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::FixedBytes<32>,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<confirmedRivalCall> for UnderlyingRustTuple<'_> {
                fn from(value: confirmedRivalCall) -> Self {
                    (value.mutualId,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for confirmedRivalCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { mutualId: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::FixedBytes<32>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::FixedBytes<32>,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<confirmedRivalReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: confirmedRivalReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for confirmedRivalReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for confirmedRivalCall {
            type Parameters<'a> = (alloy::sol_types::sol_data::FixedBytes<32>,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = confirmedRivalReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::FixedBytes<32>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "confirmedRival(bytes32)";
            const SELECTOR: [u8; 4] = [229u8, 177u8, 35u8, 218u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.mutualId),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `createLayerZeroEdge((uint8,bytes32,uint256,bytes32,bytes,bytes))` and selector `0x05fae141`.
```solidity
function createLayerZeroEdge(CreateEdgeArgs memory args) external returns (bytes32);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct createLayerZeroEdgeCall {
        pub args: <CreateEdgeArgs as alloy::sol_types::SolType>::RustType,
    }
    ///Container type for the return parameters of the [`createLayerZeroEdge((uint8,bytes32,uint256,bytes32,bytes,bytes))`](createLayerZeroEdgeCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct createLayerZeroEdgeReturn {
        pub _0: alloy::sol_types::private::FixedBytes<32>,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (CreateEdgeArgs,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                <CreateEdgeArgs as alloy::sol_types::SolType>::RustType,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<createLayerZeroEdgeCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: createLayerZeroEdgeCall) -> Self {
                    (value.args,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for createLayerZeroEdgeCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { args: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::FixedBytes<32>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::FixedBytes<32>,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<createLayerZeroEdgeReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: createLayerZeroEdgeReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for createLayerZeroEdgeReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for createLayerZeroEdgeCall {
            type Parameters<'a> = (CreateEdgeArgs,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = createLayerZeroEdgeReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::FixedBytes<32>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "createLayerZeroEdge((uint8,bytes32,uint256,bytes32,bytes,bytes))";
            const SELECTOR: [u8; 4] = [5u8, 250u8, 225u8, 65u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (<CreateEdgeArgs as alloy_sol_types::SolType>::tokenize(&self.args),)
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `edgeExists(bytes32)` and selector `0x750e0c0f`.
```solidity
function edgeExists(bytes32 edgeId) external view returns (bool);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct edgeExistsCall {
        pub edgeId: alloy::sol_types::private::FixedBytes<32>,
    }
    ///Container type for the return parameters of the [`edgeExists(bytes32)`](edgeExistsCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct edgeExistsReturn {
        pub _0: bool,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::FixedBytes<32>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::FixedBytes<32>,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<edgeExistsCall> for UnderlyingRustTuple<'_> {
                fn from(value: edgeExistsCall) -> Self {
                    (value.edgeId,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for edgeExistsCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { edgeId: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Bool,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (bool,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<edgeExistsReturn> for UnderlyingRustTuple<'_> {
                fn from(value: edgeExistsReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for edgeExistsReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for edgeExistsCall {
            type Parameters<'a> = (alloy::sol_types::sol_data::FixedBytes<32>,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = edgeExistsReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Bool,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "edgeExists(bytes32)";
            const SELECTOR: [u8; 4] = [117u8, 14u8, 12u8, 15u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.edgeId),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `edgeLength(bytes32)` and selector `0xeae0328b`.
```solidity
function edgeLength(bytes32 edgeId) external view returns (uint256);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct edgeLengthCall {
        pub edgeId: alloy::sol_types::private::FixedBytes<32>,
    }
    ///Container type for the return parameters of the [`edgeLength(bytes32)`](edgeLengthCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct edgeLengthReturn {
        pub _0: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::FixedBytes<32>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::FixedBytes<32>,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<edgeLengthCall> for UnderlyingRustTuple<'_> {
                fn from(value: edgeLengthCall) -> Self {
                    (value.edgeId,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for edgeLengthCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { edgeId: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<edgeLengthReturn> for UnderlyingRustTuple<'_> {
                fn from(value: edgeLengthReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for edgeLengthReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for edgeLengthCall {
            type Parameters<'a> = (alloy::sol_types::sol_data::FixedBytes<32>,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = edgeLengthReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "edgeLength(bytes32)";
            const SELECTOR: [u8; 4] = [234u8, 224u8, 50u8, 139u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.edgeId),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `excessStakeReceiver()` and selector `0xe94e051e`.
```solidity
function excessStakeReceiver() external view returns (address);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct excessStakeReceiverCall {}
    ///Container type for the return parameters of the [`excessStakeReceiver()`](excessStakeReceiverCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct excessStakeReceiverReturn {
        pub _0: alloy::sol_types::private::Address,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<excessStakeReceiverCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: excessStakeReceiverCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for excessStakeReceiverCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Address,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::Address,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<excessStakeReceiverReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: excessStakeReceiverReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for excessStakeReceiverReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for excessStakeReceiverCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = excessStakeReceiverReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Address,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "excessStakeReceiver()";
            const SELECTOR: [u8; 4] = [233u8, 78u8, 5u8, 30u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `firstRival(bytes32)` and selector `0xbce6f54f`.
```solidity
function firstRival(bytes32 mutualId) external view returns (bytes32);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct firstRivalCall {
        pub mutualId: alloy::sol_types::private::FixedBytes<32>,
    }
    ///Container type for the return parameters of the [`firstRival(bytes32)`](firstRivalCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct firstRivalReturn {
        pub _0: alloy::sol_types::private::FixedBytes<32>,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::FixedBytes<32>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::FixedBytes<32>,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<firstRivalCall> for UnderlyingRustTuple<'_> {
                fn from(value: firstRivalCall) -> Self {
                    (value.mutualId,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for firstRivalCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { mutualId: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::FixedBytes<32>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::FixedBytes<32>,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<firstRivalReturn> for UnderlyingRustTuple<'_> {
                fn from(value: firstRivalReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for firstRivalReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for firstRivalCall {
            type Parameters<'a> = (alloy::sol_types::sol_data::FixedBytes<32>,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = firstRivalReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::FixedBytes<32>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "firstRival(bytes32)";
            const SELECTOR: [u8; 4] = [188u8, 230u8, 245u8, 79u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.mutualId),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `getEdge(bytes32)` and selector `0xfda2892e`.
```solidity
function getEdge(bytes32 edgeId) external view returns (ChallengeEdge memory);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct getEdgeCall {
        pub edgeId: alloy::sol_types::private::FixedBytes<32>,
    }
    ///Container type for the return parameters of the [`getEdge(bytes32)`](getEdgeCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct getEdgeReturn {
        pub _0: <ChallengeEdge as alloy::sol_types::SolType>::RustType,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::FixedBytes<32>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::FixedBytes<32>,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<getEdgeCall> for UnderlyingRustTuple<'_> {
                fn from(value: getEdgeCall) -> Self {
                    (value.edgeId,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for getEdgeCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { edgeId: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (ChallengeEdge,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                <ChallengeEdge as alloy::sol_types::SolType>::RustType,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<getEdgeReturn> for UnderlyingRustTuple<'_> {
                fn from(value: getEdgeReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for getEdgeReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for getEdgeCall {
            type Parameters<'a> = (alloy::sol_types::sol_data::FixedBytes<32>,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = getEdgeReturn;
            type ReturnTuple<'a> = (ChallengeEdge,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "getEdge(bytes32)";
            const SELECTOR: [u8; 4] = [253u8, 162u8, 137u8, 46u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.edgeId),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `getLayerZeroEndHeight(uint8)` and selector `0x42e1aaa8`.
```solidity
function getLayerZeroEndHeight(EdgeType eType) external view returns (uint256);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct getLayerZeroEndHeightCall {
        pub eType: <EdgeType as alloy::sol_types::SolType>::RustType,
    }
    ///Container type for the return parameters of the [`getLayerZeroEndHeight(uint8)`](getLayerZeroEndHeightCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct getLayerZeroEndHeightReturn {
        pub _0: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (EdgeType,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                <EdgeType as alloy::sol_types::SolType>::RustType,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<getLayerZeroEndHeightCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: getLayerZeroEndHeightCall) -> Self {
                    (value.eType,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for getLayerZeroEndHeightCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { eType: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<getLayerZeroEndHeightReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: getLayerZeroEndHeightReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for getLayerZeroEndHeightReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for getLayerZeroEndHeightCall {
            type Parameters<'a> = (EdgeType,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = getLayerZeroEndHeightReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "getLayerZeroEndHeight(uint8)";
            const SELECTOR: [u8; 4] = [66u8, 225u8, 170u8, 168u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (<EdgeType as alloy_sol_types::SolType>::tokenize(&self.eType),)
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `getPrevAssertionHash(bytes32)` and selector `0x5a48e0f4`.
```solidity
function getPrevAssertionHash(bytes32 edgeId) external view returns (bytes32);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct getPrevAssertionHashCall {
        pub edgeId: alloy::sol_types::private::FixedBytes<32>,
    }
    ///Container type for the return parameters of the [`getPrevAssertionHash(bytes32)`](getPrevAssertionHashCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct getPrevAssertionHashReturn {
        pub _0: alloy::sol_types::private::FixedBytes<32>,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::FixedBytes<32>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::FixedBytes<32>,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<getPrevAssertionHashCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: getPrevAssertionHashCall) -> Self {
                    (value.edgeId,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for getPrevAssertionHashCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { edgeId: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::FixedBytes<32>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::FixedBytes<32>,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<getPrevAssertionHashReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: getPrevAssertionHashReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for getPrevAssertionHashReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for getPrevAssertionHashCall {
            type Parameters<'a> = (alloy::sol_types::sol_data::FixedBytes<32>,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = getPrevAssertionHashReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::FixedBytes<32>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "getPrevAssertionHash(bytes32)";
            const SELECTOR: [u8; 4] = [90u8, 72u8, 224u8, 244u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.edgeId),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `hasLengthOneRival(bytes32)` and selector `0x54b64151`.
```solidity
function hasLengthOneRival(bytes32 edgeId) external view returns (bool);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct hasLengthOneRivalCall {
        pub edgeId: alloy::sol_types::private::FixedBytes<32>,
    }
    ///Container type for the return parameters of the [`hasLengthOneRival(bytes32)`](hasLengthOneRivalCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct hasLengthOneRivalReturn {
        pub _0: bool,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::FixedBytes<32>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::FixedBytes<32>,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<hasLengthOneRivalCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: hasLengthOneRivalCall) -> Self {
                    (value.edgeId,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for hasLengthOneRivalCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { edgeId: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Bool,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (bool,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<hasLengthOneRivalReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: hasLengthOneRivalReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for hasLengthOneRivalReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for hasLengthOneRivalCall {
            type Parameters<'a> = (alloy::sol_types::sol_data::FixedBytes<32>,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = hasLengthOneRivalReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Bool,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "hasLengthOneRival(bytes32)";
            const SELECTOR: [u8; 4] = [84u8, 182u8, 65u8, 81u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.edgeId),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `hasMadeLayerZeroRival(address,bytes32)` and selector `0x655b42f3`.
```solidity
function hasMadeLayerZeroRival(address account, bytes32 mutualId) external view returns (bool);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct hasMadeLayerZeroRivalCall {
        pub account: alloy::sol_types::private::Address,
        pub mutualId: alloy::sol_types::private::FixedBytes<32>,
    }
    ///Container type for the return parameters of the [`hasMadeLayerZeroRival(address,bytes32)`](hasMadeLayerZeroRivalCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct hasMadeLayerZeroRivalReturn {
        pub _0: bool,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::FixedBytes<32>,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::Address,
                alloy::sol_types::private::FixedBytes<32>,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<hasMadeLayerZeroRivalCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: hasMadeLayerZeroRivalCall) -> Self {
                    (value.account, value.mutualId)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for hasMadeLayerZeroRivalCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        account: tuple.0,
                        mutualId: tuple.1,
                    }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Bool,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (bool,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<hasMadeLayerZeroRivalReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: hasMadeLayerZeroRivalReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for hasMadeLayerZeroRivalReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for hasMadeLayerZeroRivalCall {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::FixedBytes<32>,
            );
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = hasMadeLayerZeroRivalReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Bool,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "hasMadeLayerZeroRival(address,bytes32)";
            const SELECTOR: [u8; 4] = [101u8, 91u8, 66u8, 243u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.account,
                    ),
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.mutualId),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `hasRival(bytes32)` and selector `0x908517e9`.
```solidity
function hasRival(bytes32 edgeId) external view returns (bool);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct hasRivalCall {
        pub edgeId: alloy::sol_types::private::FixedBytes<32>,
    }
    ///Container type for the return parameters of the [`hasRival(bytes32)`](hasRivalCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct hasRivalReturn {
        pub _0: bool,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::FixedBytes<32>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::FixedBytes<32>,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<hasRivalCall> for UnderlyingRustTuple<'_> {
                fn from(value: hasRivalCall) -> Self {
                    (value.edgeId,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for hasRivalCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { edgeId: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Bool,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (bool,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<hasRivalReturn> for UnderlyingRustTuple<'_> {
                fn from(value: hasRivalReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for hasRivalReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for hasRivalCall {
            type Parameters<'a> = (alloy::sol_types::sol_data::FixedBytes<32>,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = hasRivalReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Bool,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "hasRival(bytes32)";
            const SELECTOR: [u8; 4] = [144u8, 133u8, 23u8, 233u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.edgeId),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `initialize(address,uint64,address,uint256,uint256,uint256,address,address,uint8,uint256[])` and selector `0x1a72d54c`.
```solidity
function initialize(address _assertionChain, uint64 _challengePeriodBlocks, address _oneStepProofEntry, uint256 layerZeroBlockEdgeHeight, uint256 layerZeroBigStepEdgeHeight, uint256 layerZeroSmallStepEdgeHeight, address _stakeToken, address _excessStakeReceiver, uint8 _numBigStepLevel, uint256[] memory _stakeAmounts) external;
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct initializeCall {
        pub _assertionChain: alloy::sol_types::private::Address,
        pub _challengePeriodBlocks: u64,
        pub _oneStepProofEntry: alloy::sol_types::private::Address,
        pub layerZeroBlockEdgeHeight: alloy::sol_types::private::primitives::aliases::U256,
        pub layerZeroBigStepEdgeHeight: alloy::sol_types::private::primitives::aliases::U256,
        pub layerZeroSmallStepEdgeHeight: alloy::sol_types::private::primitives::aliases::U256,
        pub _stakeToken: alloy::sol_types::private::Address,
        pub _excessStakeReceiver: alloy::sol_types::private::Address,
        pub _numBigStepLevel: u8,
        pub _stakeAmounts: alloy::sol_types::private::Vec<
            alloy::sol_types::private::primitives::aliases::U256,
        >,
    }
    ///Container type for the return parameters of the [`initialize(address,uint64,address,uint256,uint256,uint256,address,address,uint8,uint256[])`](initializeCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct initializeReturn {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Uint<64>,
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Uint<8>,
                alloy::sol_types::sol_data::Array<alloy::sol_types::sol_data::Uint<256>>,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::Address,
                u64,
                alloy::sol_types::private::Address,
                alloy::sol_types::private::primitives::aliases::U256,
                alloy::sol_types::private::primitives::aliases::U256,
                alloy::sol_types::private::primitives::aliases::U256,
                alloy::sol_types::private::Address,
                alloy::sol_types::private::Address,
                u8,
                alloy::sol_types::private::Vec<
                    alloy::sol_types::private::primitives::aliases::U256,
                >,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<initializeCall> for UnderlyingRustTuple<'_> {
                fn from(value: initializeCall) -> Self {
                    (
                        value._assertionChain,
                        value._challengePeriodBlocks,
                        value._oneStepProofEntry,
                        value.layerZeroBlockEdgeHeight,
                        value.layerZeroBigStepEdgeHeight,
                        value.layerZeroSmallStepEdgeHeight,
                        value._stakeToken,
                        value._excessStakeReceiver,
                        value._numBigStepLevel,
                        value._stakeAmounts,
                    )
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for initializeCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        _assertionChain: tuple.0,
                        _challengePeriodBlocks: tuple.1,
                        _oneStepProofEntry: tuple.2,
                        layerZeroBlockEdgeHeight: tuple.3,
                        layerZeroBigStepEdgeHeight: tuple.4,
                        layerZeroSmallStepEdgeHeight: tuple.5,
                        _stakeToken: tuple.6,
                        _excessStakeReceiver: tuple.7,
                        _numBigStepLevel: tuple.8,
                        _stakeAmounts: tuple.9,
                    }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<initializeReturn> for UnderlyingRustTuple<'_> {
                fn from(value: initializeReturn) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for initializeReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for initializeCall {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Uint<64>,
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Uint<8>,
                alloy::sol_types::sol_data::Array<alloy::sol_types::sol_data::Uint<256>>,
            );
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = initializeReturn;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "initialize(address,uint64,address,uint256,uint256,uint256,address,address,uint8,uint256[])";
            const SELECTOR: [u8; 4] = [26u8, 114u8, 213u8, 76u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self._assertionChain,
                    ),
                    <alloy::sol_types::sol_data::Uint<
                        64,
                    > as alloy_sol_types::SolType>::tokenize(
                        &self._challengePeriodBlocks,
                    ),
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self._oneStepProofEntry,
                    ),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(
                        &self.layerZeroBlockEdgeHeight,
                    ),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(
                        &self.layerZeroBigStepEdgeHeight,
                    ),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(
                        &self.layerZeroSmallStepEdgeHeight,
                    ),
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self._stakeToken,
                    ),
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self._excessStakeReceiver,
                    ),
                    <alloy::sol_types::sol_data::Uint<
                        8,
                    > as alloy_sol_types::SolType>::tokenize(&self._numBigStepLevel),
                    <alloy::sol_types::sol_data::Array<
                        alloy::sol_types::sol_data::Uint<256>,
                    > as alloy_sol_types::SolType>::tokenize(&self._stakeAmounts),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `multiUpdateTimeCacheByChildren(bytes32[],uint256)` and selector `0x432bb78a`.
```solidity
function multiUpdateTimeCacheByChildren(bytes32[] memory edgeIds, uint256 maximumCachedTime) external;
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct multiUpdateTimeCacheByChildrenCall {
        pub edgeIds: alloy::sol_types::private::Vec<
            alloy::sol_types::private::FixedBytes<32>,
        >,
        pub maximumCachedTime: alloy::sol_types::private::primitives::aliases::U256,
    }
    ///Container type for the return parameters of the [`multiUpdateTimeCacheByChildren(bytes32[],uint256)`](multiUpdateTimeCacheByChildrenCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct multiUpdateTimeCacheByChildrenReturn {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::Array<
                    alloy::sol_types::sol_data::FixedBytes<32>,
                >,
                alloy::sol_types::sol_data::Uint<256>,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::Vec<
                    alloy::sol_types::private::FixedBytes<32>,
                >,
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<multiUpdateTimeCacheByChildrenCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: multiUpdateTimeCacheByChildrenCall) -> Self {
                    (value.edgeIds, value.maximumCachedTime)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for multiUpdateTimeCacheByChildrenCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        edgeIds: tuple.0,
                        maximumCachedTime: tuple.1,
                    }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<multiUpdateTimeCacheByChildrenReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: multiUpdateTimeCacheByChildrenReturn) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for multiUpdateTimeCacheByChildrenReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for multiUpdateTimeCacheByChildrenCall {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::Array<
                    alloy::sol_types::sol_data::FixedBytes<32>,
                >,
                alloy::sol_types::sol_data::Uint<256>,
            );
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = multiUpdateTimeCacheByChildrenReturn;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "multiUpdateTimeCacheByChildren(bytes32[],uint256)";
            const SELECTOR: [u8; 4] = [67u8, 43u8, 183u8, 138u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Array<
                        alloy::sol_types::sol_data::FixedBytes<32>,
                    > as alloy_sol_types::SolType>::tokenize(&self.edgeIds),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.maximumCachedTime),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `oneStepProofEntry()` and selector `0x48923bc5`.
```solidity
function oneStepProofEntry() external view returns (address);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct oneStepProofEntryCall {}
    ///Container type for the return parameters of the [`oneStepProofEntry()`](oneStepProofEntryCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct oneStepProofEntryReturn {
        pub _0: alloy::sol_types::private::Address,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<oneStepProofEntryCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: oneStepProofEntryCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for oneStepProofEntryCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Address,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::Address,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<oneStepProofEntryReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: oneStepProofEntryReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for oneStepProofEntryReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for oneStepProofEntryCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = oneStepProofEntryReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Address,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "oneStepProofEntry()";
            const SELECTOR: [u8; 4] = [72u8, 146u8, 59u8, 197u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `refundStake(bytes32)` and selector `0x748926f3`.
```solidity
function refundStake(bytes32 edgeId) external;
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct refundStakeCall {
        pub edgeId: alloy::sol_types::private::FixedBytes<32>,
    }
    ///Container type for the return parameters of the [`refundStake(bytes32)`](refundStakeCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct refundStakeReturn {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::FixedBytes<32>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::FixedBytes<32>,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<refundStakeCall> for UnderlyingRustTuple<'_> {
                fn from(value: refundStakeCall) -> Self {
                    (value.edgeId,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for refundStakeCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { edgeId: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<refundStakeReturn> for UnderlyingRustTuple<'_> {
                fn from(value: refundStakeReturn) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for refundStakeReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for refundStakeCall {
            type Parameters<'a> = (alloy::sol_types::sol_data::FixedBytes<32>,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = refundStakeReturn;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "refundStake(bytes32)";
            const SELECTOR: [u8; 4] = [116u8, 137u8, 38u8, 243u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.edgeId),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `stakeAmounts(uint256)` and selector `0x1c1b4f3a`.
```solidity
function stakeAmounts(uint256) external view returns (uint256);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct stakeAmountsCall {
        pub _0: alloy::sol_types::private::primitives::aliases::U256,
    }
    ///Container type for the return parameters of the [`stakeAmounts(uint256)`](stakeAmountsCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct stakeAmountsReturn {
        pub _0: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<stakeAmountsCall> for UnderlyingRustTuple<'_> {
                fn from(value: stakeAmountsCall) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for stakeAmountsCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<stakeAmountsReturn> for UnderlyingRustTuple<'_> {
                fn from(value: stakeAmountsReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for stakeAmountsReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for stakeAmountsCall {
            type Parameters<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = stakeAmountsReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "stakeAmounts(uint256)";
            const SELECTOR: [u8; 4] = [28u8, 27u8, 79u8, 58u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self._0),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `stakeToken()` and selector `0x51ed6a30`.
```solidity
function stakeToken() external view returns (address);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct stakeTokenCall {}
    ///Container type for the return parameters of the [`stakeToken()`](stakeTokenCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct stakeTokenReturn {
        pub _0: alloy::sol_types::private::Address,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<stakeTokenCall> for UnderlyingRustTuple<'_> {
                fn from(value: stakeTokenCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for stakeTokenCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Address,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::Address,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<stakeTokenReturn> for UnderlyingRustTuple<'_> {
                fn from(value: stakeTokenReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for stakeTokenReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for stakeTokenCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = stakeTokenReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Address,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "stakeToken()";
            const SELECTOR: [u8; 4] = [81u8, 237u8, 106u8, 48u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `timeUnrivaled(bytes32)` and selector `0x3e35f5e8`.
```solidity
function timeUnrivaled(bytes32 edgeId) external view returns (uint256);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct timeUnrivaledCall {
        pub edgeId: alloy::sol_types::private::FixedBytes<32>,
    }
    ///Container type for the return parameters of the [`timeUnrivaled(bytes32)`](timeUnrivaledCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct timeUnrivaledReturn {
        pub _0: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::FixedBytes<32>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::FixedBytes<32>,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<timeUnrivaledCall> for UnderlyingRustTuple<'_> {
                fn from(value: timeUnrivaledCall) -> Self {
                    (value.edgeId,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for timeUnrivaledCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { edgeId: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<timeUnrivaledReturn> for UnderlyingRustTuple<'_> {
                fn from(value: timeUnrivaledReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for timeUnrivaledReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for timeUnrivaledCall {
            type Parameters<'a> = (alloy::sol_types::sol_data::FixedBytes<32>,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = timeUnrivaledReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "timeUnrivaled(bytes32)";
            const SELECTOR: [u8; 4] = [62u8, 53u8, 245u8, 232u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.edgeId),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `updateTimerCacheByChildren(bytes32,uint256)` and selector `0xedaab54a`.
```solidity
function updateTimerCacheByChildren(bytes32 edgeId, uint256 maximumCachedTime) external;
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct updateTimerCacheByChildrenCall {
        pub edgeId: alloy::sol_types::private::FixedBytes<32>,
        pub maximumCachedTime: alloy::sol_types::private::primitives::aliases::U256,
    }
    ///Container type for the return parameters of the [`updateTimerCacheByChildren(bytes32,uint256)`](updateTimerCacheByChildrenCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct updateTimerCacheByChildrenReturn {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Uint<256>,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::FixedBytes<32>,
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<updateTimerCacheByChildrenCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: updateTimerCacheByChildrenCall) -> Self {
                    (value.edgeId, value.maximumCachedTime)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for updateTimerCacheByChildrenCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        edgeId: tuple.0,
                        maximumCachedTime: tuple.1,
                    }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<updateTimerCacheByChildrenReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: updateTimerCacheByChildrenReturn) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for updateTimerCacheByChildrenReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for updateTimerCacheByChildrenCall {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Uint<256>,
            );
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = updateTimerCacheByChildrenReturn;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "updateTimerCacheByChildren(bytes32,uint256)";
            const SELECTOR: [u8; 4] = [237u8, 170u8, 181u8, 74u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.edgeId),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.maximumCachedTime),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `updateTimerCacheByClaim(bytes32,bytes32,uint256)` and selector `0x8826a370`.
```solidity
function updateTimerCacheByClaim(bytes32 edgeId, bytes32 claimingEdgeId, uint256 maximumCachedTime) external;
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct updateTimerCacheByClaimCall {
        pub edgeId: alloy::sol_types::private::FixedBytes<32>,
        pub claimingEdgeId: alloy::sol_types::private::FixedBytes<32>,
        pub maximumCachedTime: alloy::sol_types::private::primitives::aliases::U256,
    }
    ///Container type for the return parameters of the [`updateTimerCacheByClaim(bytes32,bytes32,uint256)`](updateTimerCacheByClaimCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct updateTimerCacheByClaimReturn {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Uint<256>,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::FixedBytes<32>,
                alloy::sol_types::private::FixedBytes<32>,
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<updateTimerCacheByClaimCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: updateTimerCacheByClaimCall) -> Self {
                    (value.edgeId, value.claimingEdgeId, value.maximumCachedTime)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for updateTimerCacheByClaimCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        edgeId: tuple.0,
                        claimingEdgeId: tuple.1,
                        maximumCachedTime: tuple.2,
                    }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<updateTimerCacheByClaimReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: updateTimerCacheByClaimReturn) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for updateTimerCacheByClaimReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for updateTimerCacheByClaimCall {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Uint<256>,
            );
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = updateTimerCacheByClaimReturn;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "updateTimerCacheByClaim(bytes32,bytes32,uint256)";
            const SELECTOR: [u8; 4] = [136u8, 38u8, 163u8, 112u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.edgeId),
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.claimingEdgeId),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.maximumCachedTime),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    ///Container for all the [`EdgeChallengeManager`](self) function calls.
    pub enum EdgeChallengeManagerCalls {
        LAYERZERO_BIGSTEPEDGE_HEIGHT(LAYERZERO_BIGSTEPEDGE_HEIGHTCall),
        LAYERZERO_BLOCKEDGE_HEIGHT(LAYERZERO_BLOCKEDGE_HEIGHTCall),
        LAYERZERO_SMALLSTEPEDGE_HEIGHT(LAYERZERO_SMALLSTEPEDGE_HEIGHTCall),
        NUM_BIGSTEP_LEVEL(NUM_BIGSTEP_LEVELCall),
        assertionChain(assertionChainCall),
        bisectEdge(bisectEdgeCall),
        calculateEdgeId(calculateEdgeIdCall),
        calculateMutualId(calculateMutualIdCall),
        challengePeriodBlocks(challengePeriodBlocksCall),
        confirmEdgeByOneStepProof(confirmEdgeByOneStepProofCall),
        confirmEdgeByTime(confirmEdgeByTimeCall),
        confirmedRival(confirmedRivalCall),
        createLayerZeroEdge(createLayerZeroEdgeCall),
        edgeExists(edgeExistsCall),
        edgeLength(edgeLengthCall),
        excessStakeReceiver(excessStakeReceiverCall),
        firstRival(firstRivalCall),
        getEdge(getEdgeCall),
        getLayerZeroEndHeight(getLayerZeroEndHeightCall),
        getPrevAssertionHash(getPrevAssertionHashCall),
        hasLengthOneRival(hasLengthOneRivalCall),
        hasMadeLayerZeroRival(hasMadeLayerZeroRivalCall),
        hasRival(hasRivalCall),
        initialize(initializeCall),
        multiUpdateTimeCacheByChildren(multiUpdateTimeCacheByChildrenCall),
        oneStepProofEntry(oneStepProofEntryCall),
        refundStake(refundStakeCall),
        stakeAmounts(stakeAmountsCall),
        stakeToken(stakeTokenCall),
        timeUnrivaled(timeUnrivaledCall),
        updateTimerCacheByChildren(updateTimerCacheByChildrenCall),
        updateTimerCacheByClaim(updateTimerCacheByClaimCall),
    }
    #[automatically_derived]
    impl EdgeChallengeManagerCalls {
        /// All the selectors of this enum.
        ///
        /// Note that the selectors might not be in the same order as the variants.
        /// No guarantees are made about the order of the selectors.
        ///
        /// Prefer using `SolInterface` methods instead.
        pub const SELECTORS: &'static [[u8; 4usize]] = &[
            [0u8, 77u8, 142u8, 254u8],
            [5u8, 250u8, 225u8, 65u8],
            [26u8, 114u8, 213u8, 76u8],
            [28u8, 27u8, 79u8, 58u8],
            [29u8, 206u8, 81u8, 102u8],
            [62u8, 53u8, 245u8, 232u8],
            [65u8, 110u8, 102u8, 87u8],
            [66u8, 225u8, 170u8, 168u8],
            [67u8, 43u8, 183u8, 138u8],
            [70u8, 194u8, 120u8, 26u8],
            [72u8, 146u8, 59u8, 197u8],
            [72u8, 221u8, 41u8, 36u8],
            [81u8, 237u8, 106u8, 48u8],
            [84u8, 182u8, 65u8, 81u8],
            [90u8, 72u8, 224u8, 244u8],
            [93u8, 158u8, 36u8, 68u8],
            [101u8, 91u8, 66u8, 243u8],
            [116u8, 137u8, 38u8, 243u8],
            [117u8, 14u8, 12u8, 15u8],
            [136u8, 38u8, 163u8, 112u8],
            [140u8, 27u8, 58u8, 64u8],
            [144u8, 133u8, 23u8, 233u8],
            [178u8, 161u8, 64u8, 142u8],
            [188u8, 230u8, 245u8, 79u8],
            [195u8, 45u8, 140u8, 99u8],
            [200u8, 188u8, 78u8, 67u8],
            [229u8, 177u8, 35u8, 218u8],
            [233u8, 78u8, 5u8, 30u8],
            [234u8, 224u8, 50u8, 139u8],
            [237u8, 170u8, 181u8, 74u8],
            [248u8, 238u8, 119u8, 214u8],
            [253u8, 162u8, 137u8, 46u8],
        ];
    }
    #[automatically_derived]
    impl alloy_sol_types::SolInterface for EdgeChallengeManagerCalls {
        const NAME: &'static str = "EdgeChallengeManagerCalls";
        const MIN_DATA_LENGTH: usize = 0usize;
        const COUNT: usize = 32usize;
        #[inline]
        fn selector(&self) -> [u8; 4] {
            match self {
                Self::LAYERZERO_BIGSTEPEDGE_HEIGHT(_) => {
                    <LAYERZERO_BIGSTEPEDGE_HEIGHTCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::LAYERZERO_BLOCKEDGE_HEIGHT(_) => {
                    <LAYERZERO_BLOCKEDGE_HEIGHTCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::LAYERZERO_SMALLSTEPEDGE_HEIGHT(_) => {
                    <LAYERZERO_SMALLSTEPEDGE_HEIGHTCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::NUM_BIGSTEP_LEVEL(_) => {
                    <NUM_BIGSTEP_LEVELCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::assertionChain(_) => {
                    <assertionChainCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::bisectEdge(_) => {
                    <bisectEdgeCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::calculateEdgeId(_) => {
                    <calculateEdgeIdCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::calculateMutualId(_) => {
                    <calculateMutualIdCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::challengePeriodBlocks(_) => {
                    <challengePeriodBlocksCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::confirmEdgeByOneStepProof(_) => {
                    <confirmEdgeByOneStepProofCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::confirmEdgeByTime(_) => {
                    <confirmEdgeByTimeCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::confirmedRival(_) => {
                    <confirmedRivalCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::createLayerZeroEdge(_) => {
                    <createLayerZeroEdgeCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::edgeExists(_) => {
                    <edgeExistsCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::edgeLength(_) => {
                    <edgeLengthCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::excessStakeReceiver(_) => {
                    <excessStakeReceiverCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::firstRival(_) => {
                    <firstRivalCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::getEdge(_) => <getEdgeCall as alloy_sol_types::SolCall>::SELECTOR,
                Self::getLayerZeroEndHeight(_) => {
                    <getLayerZeroEndHeightCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::getPrevAssertionHash(_) => {
                    <getPrevAssertionHashCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::hasLengthOneRival(_) => {
                    <hasLengthOneRivalCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::hasMadeLayerZeroRival(_) => {
                    <hasMadeLayerZeroRivalCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::hasRival(_) => <hasRivalCall as alloy_sol_types::SolCall>::SELECTOR,
                Self::initialize(_) => {
                    <initializeCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::multiUpdateTimeCacheByChildren(_) => {
                    <multiUpdateTimeCacheByChildrenCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::oneStepProofEntry(_) => {
                    <oneStepProofEntryCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::refundStake(_) => {
                    <refundStakeCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::stakeAmounts(_) => {
                    <stakeAmountsCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::stakeToken(_) => {
                    <stakeTokenCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::timeUnrivaled(_) => {
                    <timeUnrivaledCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::updateTimerCacheByChildren(_) => {
                    <updateTimerCacheByChildrenCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::updateTimerCacheByClaim(_) => {
                    <updateTimerCacheByClaimCall as alloy_sol_types::SolCall>::SELECTOR
                }
            }
        }
        #[inline]
        fn selector_at(i: usize) -> ::core::option::Option<[u8; 4]> {
            Self::SELECTORS.get(i).copied()
        }
        #[inline]
        fn valid_selector(selector: [u8; 4]) -> bool {
            Self::SELECTORS.binary_search(&selector).is_ok()
        }
        #[inline]
        #[allow(non_snake_case)]
        fn abi_decode_raw(
            selector: [u8; 4],
            data: &[u8],
            validate: bool,
        ) -> alloy_sol_types::Result<Self> {
            static DECODE_SHIMS: &[fn(
                &[u8],
                bool,
            ) -> alloy_sol_types::Result<EdgeChallengeManagerCalls>] = &[
                {
                    fn calculateEdgeId(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<EdgeChallengeManagerCalls> {
                        <calculateEdgeIdCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(EdgeChallengeManagerCalls::calculateEdgeId)
                    }
                    calculateEdgeId
                },
                {
                    fn createLayerZeroEdge(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<EdgeChallengeManagerCalls> {
                        <createLayerZeroEdgeCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(EdgeChallengeManagerCalls::createLayerZeroEdge)
                    }
                    createLayerZeroEdge
                },
                {
                    fn initialize(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<EdgeChallengeManagerCalls> {
                        <initializeCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(EdgeChallengeManagerCalls::initialize)
                    }
                    initialize
                },
                {
                    fn stakeAmounts(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<EdgeChallengeManagerCalls> {
                        <stakeAmountsCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(EdgeChallengeManagerCalls::stakeAmounts)
                    }
                    stakeAmounts
                },
                {
                    fn LAYERZERO_BLOCKEDGE_HEIGHT(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<EdgeChallengeManagerCalls> {
                        <LAYERZERO_BLOCKEDGE_HEIGHTCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(EdgeChallengeManagerCalls::LAYERZERO_BLOCKEDGE_HEIGHT)
                    }
                    LAYERZERO_BLOCKEDGE_HEIGHT
                },
                {
                    fn timeUnrivaled(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<EdgeChallengeManagerCalls> {
                        <timeUnrivaledCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(EdgeChallengeManagerCalls::timeUnrivaled)
                    }
                    timeUnrivaled
                },
                {
                    fn LAYERZERO_BIGSTEPEDGE_HEIGHT(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<EdgeChallengeManagerCalls> {
                        <LAYERZERO_BIGSTEPEDGE_HEIGHTCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(EdgeChallengeManagerCalls::LAYERZERO_BIGSTEPEDGE_HEIGHT)
                    }
                    LAYERZERO_BIGSTEPEDGE_HEIGHT
                },
                {
                    fn getLayerZeroEndHeight(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<EdgeChallengeManagerCalls> {
                        <getLayerZeroEndHeightCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(EdgeChallengeManagerCalls::getLayerZeroEndHeight)
                    }
                    getLayerZeroEndHeight
                },
                {
                    fn multiUpdateTimeCacheByChildren(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<EdgeChallengeManagerCalls> {
                        <multiUpdateTimeCacheByChildrenCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(
                                EdgeChallengeManagerCalls::multiUpdateTimeCacheByChildren,
                            )
                    }
                    multiUpdateTimeCacheByChildren
                },
                {
                    fn challengePeriodBlocks(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<EdgeChallengeManagerCalls> {
                        <challengePeriodBlocksCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(EdgeChallengeManagerCalls::challengePeriodBlocks)
                    }
                    challengePeriodBlocks
                },
                {
                    fn oneStepProofEntry(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<EdgeChallengeManagerCalls> {
                        <oneStepProofEntryCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(EdgeChallengeManagerCalls::oneStepProofEntry)
                    }
                    oneStepProofEntry
                },
                {
                    fn assertionChain(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<EdgeChallengeManagerCalls> {
                        <assertionChainCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(EdgeChallengeManagerCalls::assertionChain)
                    }
                    assertionChain
                },
                {
                    fn stakeToken(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<EdgeChallengeManagerCalls> {
                        <stakeTokenCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(EdgeChallengeManagerCalls::stakeToken)
                    }
                    stakeToken
                },
                {
                    fn hasLengthOneRival(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<EdgeChallengeManagerCalls> {
                        <hasLengthOneRivalCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(EdgeChallengeManagerCalls::hasLengthOneRival)
                    }
                    hasLengthOneRival
                },
                {
                    fn getPrevAssertionHash(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<EdgeChallengeManagerCalls> {
                        <getPrevAssertionHashCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(EdgeChallengeManagerCalls::getPrevAssertionHash)
                    }
                    getPrevAssertionHash
                },
                {
                    fn NUM_BIGSTEP_LEVEL(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<EdgeChallengeManagerCalls> {
                        <NUM_BIGSTEP_LEVELCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(EdgeChallengeManagerCalls::NUM_BIGSTEP_LEVEL)
                    }
                    NUM_BIGSTEP_LEVEL
                },
                {
                    fn hasMadeLayerZeroRival(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<EdgeChallengeManagerCalls> {
                        <hasMadeLayerZeroRivalCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(EdgeChallengeManagerCalls::hasMadeLayerZeroRival)
                    }
                    hasMadeLayerZeroRival
                },
                {
                    fn refundStake(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<EdgeChallengeManagerCalls> {
                        <refundStakeCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(EdgeChallengeManagerCalls::refundStake)
                    }
                    refundStake
                },
                {
                    fn edgeExists(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<EdgeChallengeManagerCalls> {
                        <edgeExistsCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(EdgeChallengeManagerCalls::edgeExists)
                    }
                    edgeExists
                },
                {
                    fn updateTimerCacheByClaim(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<EdgeChallengeManagerCalls> {
                        <updateTimerCacheByClaimCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(EdgeChallengeManagerCalls::updateTimerCacheByClaim)
                    }
                    updateTimerCacheByClaim
                },
                {
                    fn confirmEdgeByOneStepProof(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<EdgeChallengeManagerCalls> {
                        <confirmEdgeByOneStepProofCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(EdgeChallengeManagerCalls::confirmEdgeByOneStepProof)
                    }
                    confirmEdgeByOneStepProof
                },
                {
                    fn hasRival(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<EdgeChallengeManagerCalls> {
                        <hasRivalCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(EdgeChallengeManagerCalls::hasRival)
                    }
                    hasRival
                },
                {
                    fn confirmEdgeByTime(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<EdgeChallengeManagerCalls> {
                        <confirmEdgeByTimeCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(EdgeChallengeManagerCalls::confirmEdgeByTime)
                    }
                    confirmEdgeByTime
                },
                {
                    fn firstRival(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<EdgeChallengeManagerCalls> {
                        <firstRivalCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(EdgeChallengeManagerCalls::firstRival)
                    }
                    firstRival
                },
                {
                    fn calculateMutualId(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<EdgeChallengeManagerCalls> {
                        <calculateMutualIdCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(EdgeChallengeManagerCalls::calculateMutualId)
                    }
                    calculateMutualId
                },
                {
                    fn bisectEdge(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<EdgeChallengeManagerCalls> {
                        <bisectEdgeCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(EdgeChallengeManagerCalls::bisectEdge)
                    }
                    bisectEdge
                },
                {
                    fn confirmedRival(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<EdgeChallengeManagerCalls> {
                        <confirmedRivalCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(EdgeChallengeManagerCalls::confirmedRival)
                    }
                    confirmedRival
                },
                {
                    fn excessStakeReceiver(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<EdgeChallengeManagerCalls> {
                        <excessStakeReceiverCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(EdgeChallengeManagerCalls::excessStakeReceiver)
                    }
                    excessStakeReceiver
                },
                {
                    fn edgeLength(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<EdgeChallengeManagerCalls> {
                        <edgeLengthCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(EdgeChallengeManagerCalls::edgeLength)
                    }
                    edgeLength
                },
                {
                    fn updateTimerCacheByChildren(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<EdgeChallengeManagerCalls> {
                        <updateTimerCacheByChildrenCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(EdgeChallengeManagerCalls::updateTimerCacheByChildren)
                    }
                    updateTimerCacheByChildren
                },
                {
                    fn LAYERZERO_SMALLSTEPEDGE_HEIGHT(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<EdgeChallengeManagerCalls> {
                        <LAYERZERO_SMALLSTEPEDGE_HEIGHTCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(
                                EdgeChallengeManagerCalls::LAYERZERO_SMALLSTEPEDGE_HEIGHT,
                            )
                    }
                    LAYERZERO_SMALLSTEPEDGE_HEIGHT
                },
                {
                    fn getEdge(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<EdgeChallengeManagerCalls> {
                        <getEdgeCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(EdgeChallengeManagerCalls::getEdge)
                    }
                    getEdge
                },
            ];
            let Ok(idx) = Self::SELECTORS.binary_search(&selector) else {
                return Err(
                    alloy_sol_types::Error::unknown_selector(
                        <Self as alloy_sol_types::SolInterface>::NAME,
                        selector,
                    ),
                );
            };
            DECODE_SHIMS[idx](data, validate)
        }
        #[inline]
        fn abi_encoded_size(&self) -> usize {
            match self {
                Self::LAYERZERO_BIGSTEPEDGE_HEIGHT(inner) => {
                    <LAYERZERO_BIGSTEPEDGE_HEIGHTCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::LAYERZERO_BLOCKEDGE_HEIGHT(inner) => {
                    <LAYERZERO_BLOCKEDGE_HEIGHTCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::LAYERZERO_SMALLSTEPEDGE_HEIGHT(inner) => {
                    <LAYERZERO_SMALLSTEPEDGE_HEIGHTCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::NUM_BIGSTEP_LEVEL(inner) => {
                    <NUM_BIGSTEP_LEVELCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::assertionChain(inner) => {
                    <assertionChainCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::bisectEdge(inner) => {
                    <bisectEdgeCall as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::calculateEdgeId(inner) => {
                    <calculateEdgeIdCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::calculateMutualId(inner) => {
                    <calculateMutualIdCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::challengePeriodBlocks(inner) => {
                    <challengePeriodBlocksCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::confirmEdgeByOneStepProof(inner) => {
                    <confirmEdgeByOneStepProofCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::confirmEdgeByTime(inner) => {
                    <confirmEdgeByTimeCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::confirmedRival(inner) => {
                    <confirmedRivalCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::createLayerZeroEdge(inner) => {
                    <createLayerZeroEdgeCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::edgeExists(inner) => {
                    <edgeExistsCall as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::edgeLength(inner) => {
                    <edgeLengthCall as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::excessStakeReceiver(inner) => {
                    <excessStakeReceiverCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::firstRival(inner) => {
                    <firstRivalCall as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::getEdge(inner) => {
                    <getEdgeCall as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::getLayerZeroEndHeight(inner) => {
                    <getLayerZeroEndHeightCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::getPrevAssertionHash(inner) => {
                    <getPrevAssertionHashCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::hasLengthOneRival(inner) => {
                    <hasLengthOneRivalCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::hasMadeLayerZeroRival(inner) => {
                    <hasMadeLayerZeroRivalCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::hasRival(inner) => {
                    <hasRivalCall as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::initialize(inner) => {
                    <initializeCall as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::multiUpdateTimeCacheByChildren(inner) => {
                    <multiUpdateTimeCacheByChildrenCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::oneStepProofEntry(inner) => {
                    <oneStepProofEntryCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::refundStake(inner) => {
                    <refundStakeCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::stakeAmounts(inner) => {
                    <stakeAmountsCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::stakeToken(inner) => {
                    <stakeTokenCall as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::timeUnrivaled(inner) => {
                    <timeUnrivaledCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::updateTimerCacheByChildren(inner) => {
                    <updateTimerCacheByChildrenCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::updateTimerCacheByClaim(inner) => {
                    <updateTimerCacheByClaimCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
            }
        }
        #[inline]
        fn abi_encode_raw(&self, out: &mut alloy_sol_types::private::Vec<u8>) {
            match self {
                Self::LAYERZERO_BIGSTEPEDGE_HEIGHT(inner) => {
                    <LAYERZERO_BIGSTEPEDGE_HEIGHTCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::LAYERZERO_BLOCKEDGE_HEIGHT(inner) => {
                    <LAYERZERO_BLOCKEDGE_HEIGHTCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::LAYERZERO_SMALLSTEPEDGE_HEIGHT(inner) => {
                    <LAYERZERO_SMALLSTEPEDGE_HEIGHTCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::NUM_BIGSTEP_LEVEL(inner) => {
                    <NUM_BIGSTEP_LEVELCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::assertionChain(inner) => {
                    <assertionChainCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::bisectEdge(inner) => {
                    <bisectEdgeCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::calculateEdgeId(inner) => {
                    <calculateEdgeIdCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::calculateMutualId(inner) => {
                    <calculateMutualIdCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::challengePeriodBlocks(inner) => {
                    <challengePeriodBlocksCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::confirmEdgeByOneStepProof(inner) => {
                    <confirmEdgeByOneStepProofCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::confirmEdgeByTime(inner) => {
                    <confirmEdgeByTimeCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::confirmedRival(inner) => {
                    <confirmedRivalCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::createLayerZeroEdge(inner) => {
                    <createLayerZeroEdgeCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::edgeExists(inner) => {
                    <edgeExistsCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::edgeLength(inner) => {
                    <edgeLengthCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::excessStakeReceiver(inner) => {
                    <excessStakeReceiverCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::firstRival(inner) => {
                    <firstRivalCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::getEdge(inner) => {
                    <getEdgeCall as alloy_sol_types::SolCall>::abi_encode_raw(inner, out)
                }
                Self::getLayerZeroEndHeight(inner) => {
                    <getLayerZeroEndHeightCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::getPrevAssertionHash(inner) => {
                    <getPrevAssertionHashCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::hasLengthOneRival(inner) => {
                    <hasLengthOneRivalCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::hasMadeLayerZeroRival(inner) => {
                    <hasMadeLayerZeroRivalCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::hasRival(inner) => {
                    <hasRivalCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::initialize(inner) => {
                    <initializeCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::multiUpdateTimeCacheByChildren(inner) => {
                    <multiUpdateTimeCacheByChildrenCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::oneStepProofEntry(inner) => {
                    <oneStepProofEntryCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::refundStake(inner) => {
                    <refundStakeCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::stakeAmounts(inner) => {
                    <stakeAmountsCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::stakeToken(inner) => {
                    <stakeTokenCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::timeUnrivaled(inner) => {
                    <timeUnrivaledCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::updateTimerCacheByChildren(inner) => {
                    <updateTimerCacheByChildrenCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::updateTimerCacheByClaim(inner) => {
                    <updateTimerCacheByClaimCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
            }
        }
    }
    ///Container for all the [`EdgeChallengeManager`](self) custom errors.
    pub enum EdgeChallengeManagerErrors {
        AccountHasMadeLayerZeroRival(AccountHasMadeLayerZeroRival),
        AssertionHashEmpty(AssertionHashEmpty),
        AssertionHashMismatch(AssertionHashMismatch),
        AssertionNoSibling(AssertionNoSibling),
        AssertionNotPending(AssertionNotPending),
        BigStepLevelsTooMany(BigStepLevelsTooMany),
        CachedTimeSufficient(CachedTimeSufficient),
        ChildrenAlreadySet(ChildrenAlreadySet),
        ClaimEdgeInvalidLevel(ClaimEdgeInvalidLevel),
        ClaimEdgeNotLengthOneRival(ClaimEdgeNotLengthOneRival),
        ClaimEdgeNotPending(ClaimEdgeNotPending),
        EdgeAlreadyExists(EdgeAlreadyExists),
        EdgeAlreadyRefunded(EdgeAlreadyRefunded),
        EdgeClaimMismatch(EdgeClaimMismatch),
        EdgeLevelInvalid(EdgeLevelInvalid),
        EdgeNotConfirmed(EdgeNotConfirmed),
        EdgeNotExists(EdgeNotExists),
        EdgeNotLayerZero(EdgeNotLayerZero),
        EdgeNotLengthOne(EdgeNotLengthOne),
        EdgeNotPending(EdgeNotPending),
        EdgeTypeNotSmallStep(EdgeTypeNotSmallStep),
        EdgeUnrivaled(EdgeUnrivaled),
        EmptyArray(EmptyArray),
        EmptyAssertionChain(EmptyAssertionChain),
        EmptyChallengePeriod(EmptyChallengePeriod),
        EmptyClaimId(EmptyClaimId),
        EmptyEdgeSpecificProof(EmptyEdgeSpecificProof),
        EmptyEndMachineStatus(EmptyEndMachineStatus),
        EmptyEndRoot(EmptyEndRoot),
        EmptyFirstRival(EmptyFirstRival),
        EmptyOneStepProofEntry(EmptyOneStepProofEntry),
        EmptyOriginId(EmptyOriginId),
        EmptyPrefixProof(EmptyPrefixProof),
        EmptyStakeReceiver(EmptyStakeReceiver),
        EmptyStaker(EmptyStaker),
        EmptyStartMachineStatus(EmptyStartMachineStatus),
        EmptyStartRoot(EmptyStartRoot),
        EndHistoryRootMismatch(EndHistoryRootMismatch),
        HeightDiffLtTwo(HeightDiffLtTwo),
        InsufficientConfirmationBlocks(InsufficientConfirmationBlocks),
        InvalidEdgeType(InvalidEdgeType),
        InvalidEndHeight(InvalidEndHeight),
        InvalidHeights(InvalidHeights),
        LevelTooHigh(LevelTooHigh),
        MerkleProofTooLong(MerkleProofTooLong),
        NotPowerOfTwo(NotPowerOfTwo),
        NotValidator(NotValidator),
        OriginIdMutualIdMismatch(OriginIdMutualIdMismatch),
        RivalEdgeConfirmed(RivalEdgeConfirmed),
        StakeAmountsMismatch(StakeAmountsMismatch),
        ZeroBigStepLevels(ZeroBigStepLevels),
    }
    #[automatically_derived]
    impl EdgeChallengeManagerErrors {
        /// All the selectors of this enum.
        ///
        /// Note that the selectors might not be in the same order as the variants.
        /// No guarantees are made about the order of the selectors.
        ///
        /// Prefer using `SolInterface` methods instead.
        pub const SELECTORS: &'static [[u8; 4usize]] = &[
            [0u8, 167u8, 176u8, 43u8],
            [10u8, 236u8, 233u8, 192u8],
            [15u8, 14u8, 200u8, 168u8],
            [17u8, 168u8, 212u8, 208u8],
            [18u8, 69u8, 159u8, 253u8],
            [32u8, 96u8, 250u8, 244u8],
            [35u8, 248u8, 64u8, 93u8],
            [48u8, 127u8, 118u8, 105u8],
            [52u8, 42u8, 7u8, 82u8],
            [52u8, 138u8, 239u8, 223u8],
            [58u8, 99u8, 233u8, 154u8],
            [59u8, 242u8, 225u8, 236u8],
            [64u8, 210u8, 59u8, 240u8],
            [70u8, 54u8, 94u8, 82u8],
            [82u8, 18u8, 153u8, 169u8],
            [90u8, 70u8, 172u8, 58u8],
            [91u8, 23u8, 122u8, 60u8],
            [92u8, 182u8, 229u8, 187u8],
            [105u8, 50u8, 188u8, 253u8],
            [107u8, 89u8, 94u8, 80u8],
            [126u8, 114u8, 109u8, 21u8],
            [128u8, 224u8, 126u8, 69u8],
            [131u8, 198u8, 131u8, 228u8],
            [137u8, 153u8, 133u8, 125u8],
            [138u8, 14u8, 237u8, 204u8],
            [139u8, 14u8, 113u8, 208u8],
            [141u8, 121u8, 219u8, 188u8],
            [144u8, 41u8, 133u8, 148u8],
            [168u8, 99u8, 214u8, 228u8],
            [172u8, 158u8, 97u8, 22u8],
            [174u8, 13u8, 165u8, 120u8],
            [180u8, 93u8, 28u8, 58u8],
            [188u8, 237u8, 243u8, 222u8],
            [193u8, 105u8, 36u8, 54u8],
            [194u8, 173u8, 195u8, 232u8],
            [200u8, 62u8, 8u8, 98u8],
            [201u8, 204u8, 172u8, 80u8],
            [209u8, 245u8, 146u8, 129u8],
            [218u8, 16u8, 246u8, 124u8],
            [221u8, 112u8, 40u8, 240u8],
            [223u8, 204u8, 98u8, 188u8],
            [226u8, 226u8, 127u8, 135u8],
            [229u8, 140u8, 131u8, 8u8],
            [233u8, 107u8, 198u8, 26u8],
            [234u8, 254u8, 219u8, 252u8],
            [237u8, 61u8, 184u8, 172u8],
            [239u8, 18u8, 103u8, 180u8],
            [242u8, 137u8, 230u8, 87u8],
            [251u8, 96u8, 176u8, 239u8],
            [253u8, 172u8, 51u8, 30u8],
            [255u8, 109u8, 155u8, 215u8],
        ];
    }
    #[automatically_derived]
    impl alloy_sol_types::SolInterface for EdgeChallengeManagerErrors {
        const NAME: &'static str = "EdgeChallengeManagerErrors";
        const MIN_DATA_LENGTH: usize = 0usize;
        const COUNT: usize = 51usize;
        #[inline]
        fn selector(&self) -> [u8; 4] {
            match self {
                Self::AccountHasMadeLayerZeroRival(_) => {
                    <AccountHasMadeLayerZeroRival as alloy_sol_types::SolError>::SELECTOR
                }
                Self::AssertionHashEmpty(_) => {
                    <AssertionHashEmpty as alloy_sol_types::SolError>::SELECTOR
                }
                Self::AssertionHashMismatch(_) => {
                    <AssertionHashMismatch as alloy_sol_types::SolError>::SELECTOR
                }
                Self::AssertionNoSibling(_) => {
                    <AssertionNoSibling as alloy_sol_types::SolError>::SELECTOR
                }
                Self::AssertionNotPending(_) => {
                    <AssertionNotPending as alloy_sol_types::SolError>::SELECTOR
                }
                Self::BigStepLevelsTooMany(_) => {
                    <BigStepLevelsTooMany as alloy_sol_types::SolError>::SELECTOR
                }
                Self::CachedTimeSufficient(_) => {
                    <CachedTimeSufficient as alloy_sol_types::SolError>::SELECTOR
                }
                Self::ChildrenAlreadySet(_) => {
                    <ChildrenAlreadySet as alloy_sol_types::SolError>::SELECTOR
                }
                Self::ClaimEdgeInvalidLevel(_) => {
                    <ClaimEdgeInvalidLevel as alloy_sol_types::SolError>::SELECTOR
                }
                Self::ClaimEdgeNotLengthOneRival(_) => {
                    <ClaimEdgeNotLengthOneRival as alloy_sol_types::SolError>::SELECTOR
                }
                Self::ClaimEdgeNotPending(_) => {
                    <ClaimEdgeNotPending as alloy_sol_types::SolError>::SELECTOR
                }
                Self::EdgeAlreadyExists(_) => {
                    <EdgeAlreadyExists as alloy_sol_types::SolError>::SELECTOR
                }
                Self::EdgeAlreadyRefunded(_) => {
                    <EdgeAlreadyRefunded as alloy_sol_types::SolError>::SELECTOR
                }
                Self::EdgeClaimMismatch(_) => {
                    <EdgeClaimMismatch as alloy_sol_types::SolError>::SELECTOR
                }
                Self::EdgeLevelInvalid(_) => {
                    <EdgeLevelInvalid as alloy_sol_types::SolError>::SELECTOR
                }
                Self::EdgeNotConfirmed(_) => {
                    <EdgeNotConfirmed as alloy_sol_types::SolError>::SELECTOR
                }
                Self::EdgeNotExists(_) => {
                    <EdgeNotExists as alloy_sol_types::SolError>::SELECTOR
                }
                Self::EdgeNotLayerZero(_) => {
                    <EdgeNotLayerZero as alloy_sol_types::SolError>::SELECTOR
                }
                Self::EdgeNotLengthOne(_) => {
                    <EdgeNotLengthOne as alloy_sol_types::SolError>::SELECTOR
                }
                Self::EdgeNotPending(_) => {
                    <EdgeNotPending as alloy_sol_types::SolError>::SELECTOR
                }
                Self::EdgeTypeNotSmallStep(_) => {
                    <EdgeTypeNotSmallStep as alloy_sol_types::SolError>::SELECTOR
                }
                Self::EdgeUnrivaled(_) => {
                    <EdgeUnrivaled as alloy_sol_types::SolError>::SELECTOR
                }
                Self::EmptyArray(_) => {
                    <EmptyArray as alloy_sol_types::SolError>::SELECTOR
                }
                Self::EmptyAssertionChain(_) => {
                    <EmptyAssertionChain as alloy_sol_types::SolError>::SELECTOR
                }
                Self::EmptyChallengePeriod(_) => {
                    <EmptyChallengePeriod as alloy_sol_types::SolError>::SELECTOR
                }
                Self::EmptyClaimId(_) => {
                    <EmptyClaimId as alloy_sol_types::SolError>::SELECTOR
                }
                Self::EmptyEdgeSpecificProof(_) => {
                    <EmptyEdgeSpecificProof as alloy_sol_types::SolError>::SELECTOR
                }
                Self::EmptyEndMachineStatus(_) => {
                    <EmptyEndMachineStatus as alloy_sol_types::SolError>::SELECTOR
                }
                Self::EmptyEndRoot(_) => {
                    <EmptyEndRoot as alloy_sol_types::SolError>::SELECTOR
                }
                Self::EmptyFirstRival(_) => {
                    <EmptyFirstRival as alloy_sol_types::SolError>::SELECTOR
                }
                Self::EmptyOneStepProofEntry(_) => {
                    <EmptyOneStepProofEntry as alloy_sol_types::SolError>::SELECTOR
                }
                Self::EmptyOriginId(_) => {
                    <EmptyOriginId as alloy_sol_types::SolError>::SELECTOR
                }
                Self::EmptyPrefixProof(_) => {
                    <EmptyPrefixProof as alloy_sol_types::SolError>::SELECTOR
                }
                Self::EmptyStakeReceiver(_) => {
                    <EmptyStakeReceiver as alloy_sol_types::SolError>::SELECTOR
                }
                Self::EmptyStaker(_) => {
                    <EmptyStaker as alloy_sol_types::SolError>::SELECTOR
                }
                Self::EmptyStartMachineStatus(_) => {
                    <EmptyStartMachineStatus as alloy_sol_types::SolError>::SELECTOR
                }
                Self::EmptyStartRoot(_) => {
                    <EmptyStartRoot as alloy_sol_types::SolError>::SELECTOR
                }
                Self::EndHistoryRootMismatch(_) => {
                    <EndHistoryRootMismatch as alloy_sol_types::SolError>::SELECTOR
                }
                Self::HeightDiffLtTwo(_) => {
                    <HeightDiffLtTwo as alloy_sol_types::SolError>::SELECTOR
                }
                Self::InsufficientConfirmationBlocks(_) => {
                    <InsufficientConfirmationBlocks as alloy_sol_types::SolError>::SELECTOR
                }
                Self::InvalidEdgeType(_) => {
                    <InvalidEdgeType as alloy_sol_types::SolError>::SELECTOR
                }
                Self::InvalidEndHeight(_) => {
                    <InvalidEndHeight as alloy_sol_types::SolError>::SELECTOR
                }
                Self::InvalidHeights(_) => {
                    <InvalidHeights as alloy_sol_types::SolError>::SELECTOR
                }
                Self::LevelTooHigh(_) => {
                    <LevelTooHigh as alloy_sol_types::SolError>::SELECTOR
                }
                Self::MerkleProofTooLong(_) => {
                    <MerkleProofTooLong as alloy_sol_types::SolError>::SELECTOR
                }
                Self::NotPowerOfTwo(_) => {
                    <NotPowerOfTwo as alloy_sol_types::SolError>::SELECTOR
                }
                Self::NotValidator(_) => {
                    <NotValidator as alloy_sol_types::SolError>::SELECTOR
                }
                Self::OriginIdMutualIdMismatch(_) => {
                    <OriginIdMutualIdMismatch as alloy_sol_types::SolError>::SELECTOR
                }
                Self::RivalEdgeConfirmed(_) => {
                    <RivalEdgeConfirmed as alloy_sol_types::SolError>::SELECTOR
                }
                Self::StakeAmountsMismatch(_) => {
                    <StakeAmountsMismatch as alloy_sol_types::SolError>::SELECTOR
                }
                Self::ZeroBigStepLevels(_) => {
                    <ZeroBigStepLevels as alloy_sol_types::SolError>::SELECTOR
                }
            }
        }
        #[inline]
        fn selector_at(i: usize) -> ::core::option::Option<[u8; 4]> {
            Self::SELECTORS.get(i).copied()
        }
        #[inline]
        fn valid_selector(selector: [u8; 4]) -> bool {
            Self::SELECTORS.binary_search(&selector).is_ok()
        }
        #[inline]
        #[allow(non_snake_case)]
        fn abi_decode_raw(
            selector: [u8; 4],
            data: &[u8],
            validate: bool,
        ) -> alloy_sol_types::Result<Self> {
            static DECODE_SHIMS: &[fn(
                &[u8],
                bool,
            ) -> alloy_sol_types::Result<EdgeChallengeManagerErrors>] = &[
                {
                    fn EdgeNotExists(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<EdgeChallengeManagerErrors> {
                        <EdgeNotExists as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(EdgeChallengeManagerErrors::EdgeNotExists)
                    }
                    EdgeNotExists
                },
                {
                    fn StakeAmountsMismatch(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<EdgeChallengeManagerErrors> {
                        <StakeAmountsMismatch as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(EdgeChallengeManagerErrors::StakeAmountsMismatch)
                    }
                    StakeAmountsMismatch
                },
                {
                    fn EmptyStakeReceiver(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<EdgeChallengeManagerErrors> {
                        <EmptyStakeReceiver as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(EdgeChallengeManagerErrors::EmptyStakeReceiver)
                    }
                    EmptyStakeReceiver
                },
                {
                    fn InsufficientConfirmationBlocks(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<EdgeChallengeManagerErrors> {
                        <InsufficientConfirmationBlocks as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(
                                EdgeChallengeManagerErrors::InsufficientConfirmationBlocks,
                            )
                    }
                    InsufficientConfirmationBlocks
                },
                {
                    fn ClaimEdgeNotPending(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<EdgeChallengeManagerErrors> {
                        <ClaimEdgeNotPending as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(EdgeChallengeManagerErrors::ClaimEdgeNotPending)
                    }
                    ClaimEdgeNotPending
                },
                {
                    fn InvalidHeights(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<EdgeChallengeManagerErrors> {
                        <InvalidHeights as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(EdgeChallengeManagerErrors::InvalidHeights)
                    }
                    InvalidHeights
                },
                {
                    fn EdgeNotPending(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<EdgeChallengeManagerErrors> {
                        <EdgeNotPending as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(EdgeChallengeManagerErrors::EdgeNotPending)
                    }
                    EdgeNotPending
                },
                {
                    fn EdgeAlreadyRefunded(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<EdgeChallengeManagerErrors> {
                        <EdgeAlreadyRefunded as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(EdgeChallengeManagerErrors::EdgeAlreadyRefunded)
                    }
                    EdgeAlreadyRefunded
                },
                {
                    fn EmptyPrefixProof(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<EdgeChallengeManagerErrors> {
                        <EmptyPrefixProof as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(EdgeChallengeManagerErrors::EmptyPrefixProof)
                    }
                    EmptyPrefixProof
                },
                {
                    fn EdgeTypeNotSmallStep(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<EdgeChallengeManagerErrors> {
                        <EdgeTypeNotSmallStep as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(EdgeChallengeManagerErrors::EdgeTypeNotSmallStep)
                    }
                    EdgeTypeNotSmallStep
                },
                {
                    fn EndHistoryRootMismatch(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<EdgeChallengeManagerErrors> {
                        <EndHistoryRootMismatch as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(EdgeChallengeManagerErrors::EndHistoryRootMismatch)
                    }
                    EndHistoryRootMismatch
                },
                {
                    fn InvalidEdgeType(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<EdgeChallengeManagerErrors> {
                        <InvalidEdgeType as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(EdgeChallengeManagerErrors::InvalidEdgeType)
                    }
                    InvalidEdgeType
                },
                {
                    fn BigStepLevelsTooMany(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<EdgeChallengeManagerErrors> {
                        <BigStepLevelsTooMany as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(EdgeChallengeManagerErrors::BigStepLevelsTooMany)
                    }
                    BigStepLevelsTooMany
                },
                {
                    fn EmptyStartMachineStatus(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<EdgeChallengeManagerErrors> {
                        <EmptyStartMachineStatus as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(EdgeChallengeManagerErrors::EmptyStartMachineStatus)
                    }
                    EmptyStartMachineStatus
                },
                {
                    fn EmptyArray(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<EdgeChallengeManagerErrors> {
                        <EmptyArray as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(EdgeChallengeManagerErrors::EmptyArray)
                    }
                    EmptyArray
                },
                {
                    fn AccountHasMadeLayerZeroRival(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<EdgeChallengeManagerErrors> {
                        <AccountHasMadeLayerZeroRival as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(
                                EdgeChallengeManagerErrors::AccountHasMadeLayerZeroRival,
                            )
                    }
                    AccountHasMadeLayerZeroRival
                },
                {
                    fn AssertionHashMismatch(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<EdgeChallengeManagerErrors> {
                        <AssertionHashMismatch as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(EdgeChallengeManagerErrors::AssertionHashMismatch)
                    }
                    AssertionHashMismatch
                },
                {
                    fn EmptyEndRoot(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<EdgeChallengeManagerErrors> {
                        <EmptyEndRoot as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(EdgeChallengeManagerErrors::EmptyEndRoot)
                    }
                    EmptyEndRoot
                },
                {
                    fn EmptyClaimId(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<EdgeChallengeManagerErrors> {
                        <EmptyClaimId as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(EdgeChallengeManagerErrors::EmptyClaimId)
                    }
                    EmptyClaimId
                },
                {
                    fn EdgeNotLengthOne(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<EdgeChallengeManagerErrors> {
                        <EdgeNotLengthOne as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(EdgeChallengeManagerErrors::EdgeNotLengthOne)
                    }
                    EdgeNotLengthOne
                },
                {
                    fn EdgeLevelInvalid(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<EdgeChallengeManagerErrors> {
                        <EdgeLevelInvalid as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(EdgeChallengeManagerErrors::EdgeLevelInvalid)
                    }
                    EdgeLevelInvalid
                },
                {
                    fn EdgeUnrivaled(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<EdgeChallengeManagerErrors> {
                        <EdgeUnrivaled as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(EdgeChallengeManagerErrors::EdgeUnrivaled)
                    }
                    EdgeUnrivaled
                },
                {
                    fn EmptyStartRoot(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<EdgeChallengeManagerErrors> {
                        <EmptyStartRoot as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(EdgeChallengeManagerErrors::EmptyStartRoot)
                    }
                    EmptyStartRoot
                },
                {
                    fn EmptyEndMachineStatus(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<EdgeChallengeManagerErrors> {
                        <EmptyEndMachineStatus as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(EdgeChallengeManagerErrors::EmptyEndMachineStatus)
                    }
                    EmptyEndMachineStatus
                },
                {
                    fn EmptyChallengePeriod(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<EdgeChallengeManagerErrors> {
                        <EmptyChallengePeriod as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(EdgeChallengeManagerErrors::EmptyChallengePeriod)
                    }
                    EmptyChallengePeriod
                },
                {
                    fn ChildrenAlreadySet(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<EdgeChallengeManagerErrors> {
                        <ChildrenAlreadySet as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(EdgeChallengeManagerErrors::ChildrenAlreadySet)
                    }
                    ChildrenAlreadySet
                },
                {
                    fn EmptyOriginId(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<EdgeChallengeManagerErrors> {
                        <EmptyOriginId as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(EdgeChallengeManagerErrors::EmptyOriginId)
                    }
                    EmptyOriginId
                },
                {
                    fn HeightDiffLtTwo(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<EdgeChallengeManagerErrors> {
                        <HeightDiffLtTwo as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(EdgeChallengeManagerErrors::HeightDiffLtTwo)
                    }
                    HeightDiffLtTwo
                },
                {
                    fn ZeroBigStepLevels(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<EdgeChallengeManagerErrors> {
                        <ZeroBigStepLevels as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(EdgeChallengeManagerErrors::ZeroBigStepLevels)
                    }
                    ZeroBigStepLevels
                },
                {
                    fn ClaimEdgeInvalidLevel(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<EdgeChallengeManagerErrors> {
                        <ClaimEdgeInvalidLevel as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(EdgeChallengeManagerErrors::ClaimEdgeInvalidLevel)
                    }
                    ClaimEdgeInvalidLevel
                },
                {
                    fn LevelTooHigh(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<EdgeChallengeManagerErrors> {
                        <LevelTooHigh as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(EdgeChallengeManagerErrors::LevelTooHigh)
                    }
                    LevelTooHigh
                },
                {
                    fn AssertionNoSibling(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<EdgeChallengeManagerErrors> {
                        <AssertionNoSibling as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(EdgeChallengeManagerErrors::AssertionNoSibling)
                    }
                    AssertionNoSibling
                },
                {
                    fn EdgeAlreadyExists(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<EdgeChallengeManagerErrors> {
                        <EdgeAlreadyExists as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(EdgeChallengeManagerErrors::EdgeAlreadyExists)
                    }
                    EdgeAlreadyExists
                },
                {
                    fn AssertionNotPending(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<EdgeChallengeManagerErrors> {
                        <AssertionNotPending as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(EdgeChallengeManagerErrors::AssertionNotPending)
                    }
                    AssertionNotPending
                },
                {
                    fn EdgeClaimMismatch(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<EdgeChallengeManagerErrors> {
                        <EdgeClaimMismatch as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(EdgeChallengeManagerErrors::EdgeClaimMismatch)
                    }
                    EdgeClaimMismatch
                },
                {
                    fn EmptyAssertionChain(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<EdgeChallengeManagerErrors> {
                        <EmptyAssertionChain as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(EdgeChallengeManagerErrors::EmptyAssertionChain)
                    }
                    EmptyAssertionChain
                },
                {
                    fn EmptyEdgeSpecificProof(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<EdgeChallengeManagerErrors> {
                        <EmptyEdgeSpecificProof as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(EdgeChallengeManagerErrors::EmptyEdgeSpecificProof)
                    }
                    EmptyEdgeSpecificProof
                },
                {
                    fn CachedTimeSufficient(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<EdgeChallengeManagerErrors> {
                        <CachedTimeSufficient as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(EdgeChallengeManagerErrors::CachedTimeSufficient)
                    }
                    CachedTimeSufficient
                },
                {
                    fn EmptyFirstRival(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<EdgeChallengeManagerErrors> {
                        <EmptyFirstRival as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(EdgeChallengeManagerErrors::EmptyFirstRival)
                    }
                    EmptyFirstRival
                },
                {
                    fn RivalEdgeConfirmed(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<EdgeChallengeManagerErrors> {
                        <RivalEdgeConfirmed as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(EdgeChallengeManagerErrors::RivalEdgeConfirmed)
                    }
                    RivalEdgeConfirmed
                },
                {
                    fn InvalidEndHeight(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<EdgeChallengeManagerErrors> {
                        <InvalidEndHeight as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(EdgeChallengeManagerErrors::InvalidEndHeight)
                    }
                    InvalidEndHeight
                },
                {
                    fn OriginIdMutualIdMismatch(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<EdgeChallengeManagerErrors> {
                        <OriginIdMutualIdMismatch as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(EdgeChallengeManagerErrors::OriginIdMutualIdMismatch)
                    }
                    OriginIdMutualIdMismatch
                },
                {
                    fn EdgeNotLayerZero(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<EdgeChallengeManagerErrors> {
                        <EdgeNotLayerZero as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(EdgeChallengeManagerErrors::EdgeNotLayerZero)
                    }
                    EdgeNotLayerZero
                },
                {
                    fn AssertionHashEmpty(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<EdgeChallengeManagerErrors> {
                        <AssertionHashEmpty as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(EdgeChallengeManagerErrors::AssertionHashEmpty)
                    }
                    AssertionHashEmpty
                },
                {
                    fn NotPowerOfTwo(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<EdgeChallengeManagerErrors> {
                        <NotPowerOfTwo as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(EdgeChallengeManagerErrors::NotPowerOfTwo)
                    }
                    NotPowerOfTwo
                },
                {
                    fn NotValidator(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<EdgeChallengeManagerErrors> {
                        <NotValidator as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(EdgeChallengeManagerErrors::NotValidator)
                    }
                    NotValidator
                },
                {
                    fn EdgeNotConfirmed(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<EdgeChallengeManagerErrors> {
                        <EdgeNotConfirmed as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(EdgeChallengeManagerErrors::EdgeNotConfirmed)
                    }
                    EdgeNotConfirmed
                },
                {
                    fn EmptyStaker(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<EdgeChallengeManagerErrors> {
                        <EmptyStaker as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(EdgeChallengeManagerErrors::EmptyStaker)
                    }
                    EmptyStaker
                },
                {
                    fn EmptyOneStepProofEntry(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<EdgeChallengeManagerErrors> {
                        <EmptyOneStepProofEntry as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(EdgeChallengeManagerErrors::EmptyOneStepProofEntry)
                    }
                    EmptyOneStepProofEntry
                },
                {
                    fn MerkleProofTooLong(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<EdgeChallengeManagerErrors> {
                        <MerkleProofTooLong as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(EdgeChallengeManagerErrors::MerkleProofTooLong)
                    }
                    MerkleProofTooLong
                },
                {
                    fn ClaimEdgeNotLengthOneRival(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<EdgeChallengeManagerErrors> {
                        <ClaimEdgeNotLengthOneRival as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(EdgeChallengeManagerErrors::ClaimEdgeNotLengthOneRival)
                    }
                    ClaimEdgeNotLengthOneRival
                },
            ];
            let Ok(idx) = Self::SELECTORS.binary_search(&selector) else {
                return Err(
                    alloy_sol_types::Error::unknown_selector(
                        <Self as alloy_sol_types::SolInterface>::NAME,
                        selector,
                    ),
                );
            };
            DECODE_SHIMS[idx](data, validate)
        }
        #[inline]
        fn abi_encoded_size(&self) -> usize {
            match self {
                Self::AccountHasMadeLayerZeroRival(inner) => {
                    <AccountHasMadeLayerZeroRival as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::AssertionHashEmpty(inner) => {
                    <AssertionHashEmpty as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::AssertionHashMismatch(inner) => {
                    <AssertionHashMismatch as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::AssertionNoSibling(inner) => {
                    <AssertionNoSibling as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::AssertionNotPending(inner) => {
                    <AssertionNotPending as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::BigStepLevelsTooMany(inner) => {
                    <BigStepLevelsTooMany as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::CachedTimeSufficient(inner) => {
                    <CachedTimeSufficient as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::ChildrenAlreadySet(inner) => {
                    <ChildrenAlreadySet as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::ClaimEdgeInvalidLevel(inner) => {
                    <ClaimEdgeInvalidLevel as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::ClaimEdgeNotLengthOneRival(inner) => {
                    <ClaimEdgeNotLengthOneRival as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::ClaimEdgeNotPending(inner) => {
                    <ClaimEdgeNotPending as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::EdgeAlreadyExists(inner) => {
                    <EdgeAlreadyExists as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::EdgeAlreadyRefunded(inner) => {
                    <EdgeAlreadyRefunded as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::EdgeClaimMismatch(inner) => {
                    <EdgeClaimMismatch as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::EdgeLevelInvalid(inner) => {
                    <EdgeLevelInvalid as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::EdgeNotConfirmed(inner) => {
                    <EdgeNotConfirmed as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::EdgeNotExists(inner) => {
                    <EdgeNotExists as alloy_sol_types::SolError>::abi_encoded_size(inner)
                }
                Self::EdgeNotLayerZero(inner) => {
                    <EdgeNotLayerZero as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::EdgeNotLengthOne(inner) => {
                    <EdgeNotLengthOne as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::EdgeNotPending(inner) => {
                    <EdgeNotPending as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::EdgeTypeNotSmallStep(inner) => {
                    <EdgeTypeNotSmallStep as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::EdgeUnrivaled(inner) => {
                    <EdgeUnrivaled as alloy_sol_types::SolError>::abi_encoded_size(inner)
                }
                Self::EmptyArray(inner) => {
                    <EmptyArray as alloy_sol_types::SolError>::abi_encoded_size(inner)
                }
                Self::EmptyAssertionChain(inner) => {
                    <EmptyAssertionChain as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::EmptyChallengePeriod(inner) => {
                    <EmptyChallengePeriod as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::EmptyClaimId(inner) => {
                    <EmptyClaimId as alloy_sol_types::SolError>::abi_encoded_size(inner)
                }
                Self::EmptyEdgeSpecificProof(inner) => {
                    <EmptyEdgeSpecificProof as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::EmptyEndMachineStatus(inner) => {
                    <EmptyEndMachineStatus as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::EmptyEndRoot(inner) => {
                    <EmptyEndRoot as alloy_sol_types::SolError>::abi_encoded_size(inner)
                }
                Self::EmptyFirstRival(inner) => {
                    <EmptyFirstRival as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::EmptyOneStepProofEntry(inner) => {
                    <EmptyOneStepProofEntry as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::EmptyOriginId(inner) => {
                    <EmptyOriginId as alloy_sol_types::SolError>::abi_encoded_size(inner)
                }
                Self::EmptyPrefixProof(inner) => {
                    <EmptyPrefixProof as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::EmptyStakeReceiver(inner) => {
                    <EmptyStakeReceiver as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::EmptyStaker(inner) => {
                    <EmptyStaker as alloy_sol_types::SolError>::abi_encoded_size(inner)
                }
                Self::EmptyStartMachineStatus(inner) => {
                    <EmptyStartMachineStatus as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::EmptyStartRoot(inner) => {
                    <EmptyStartRoot as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::EndHistoryRootMismatch(inner) => {
                    <EndHistoryRootMismatch as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::HeightDiffLtTwo(inner) => {
                    <HeightDiffLtTwo as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::InsufficientConfirmationBlocks(inner) => {
                    <InsufficientConfirmationBlocks as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::InvalidEdgeType(inner) => {
                    <InvalidEdgeType as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::InvalidEndHeight(inner) => {
                    <InvalidEndHeight as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::InvalidHeights(inner) => {
                    <InvalidHeights as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::LevelTooHigh(inner) => {
                    <LevelTooHigh as alloy_sol_types::SolError>::abi_encoded_size(inner)
                }
                Self::MerkleProofTooLong(inner) => {
                    <MerkleProofTooLong as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::NotPowerOfTwo(inner) => {
                    <NotPowerOfTwo as alloy_sol_types::SolError>::abi_encoded_size(inner)
                }
                Self::NotValidator(inner) => {
                    <NotValidator as alloy_sol_types::SolError>::abi_encoded_size(inner)
                }
                Self::OriginIdMutualIdMismatch(inner) => {
                    <OriginIdMutualIdMismatch as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::RivalEdgeConfirmed(inner) => {
                    <RivalEdgeConfirmed as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::StakeAmountsMismatch(inner) => {
                    <StakeAmountsMismatch as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::ZeroBigStepLevels(inner) => {
                    <ZeroBigStepLevels as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
            }
        }
        #[inline]
        fn abi_encode_raw(&self, out: &mut alloy_sol_types::private::Vec<u8>) {
            match self {
                Self::AccountHasMadeLayerZeroRival(inner) => {
                    <AccountHasMadeLayerZeroRival as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::AssertionHashEmpty(inner) => {
                    <AssertionHashEmpty as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::AssertionHashMismatch(inner) => {
                    <AssertionHashMismatch as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::AssertionNoSibling(inner) => {
                    <AssertionNoSibling as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::AssertionNotPending(inner) => {
                    <AssertionNotPending as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::BigStepLevelsTooMany(inner) => {
                    <BigStepLevelsTooMany as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::CachedTimeSufficient(inner) => {
                    <CachedTimeSufficient as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::ChildrenAlreadySet(inner) => {
                    <ChildrenAlreadySet as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::ClaimEdgeInvalidLevel(inner) => {
                    <ClaimEdgeInvalidLevel as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::ClaimEdgeNotLengthOneRival(inner) => {
                    <ClaimEdgeNotLengthOneRival as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::ClaimEdgeNotPending(inner) => {
                    <ClaimEdgeNotPending as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::EdgeAlreadyExists(inner) => {
                    <EdgeAlreadyExists as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::EdgeAlreadyRefunded(inner) => {
                    <EdgeAlreadyRefunded as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::EdgeClaimMismatch(inner) => {
                    <EdgeClaimMismatch as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::EdgeLevelInvalid(inner) => {
                    <EdgeLevelInvalid as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::EdgeNotConfirmed(inner) => {
                    <EdgeNotConfirmed as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::EdgeNotExists(inner) => {
                    <EdgeNotExists as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::EdgeNotLayerZero(inner) => {
                    <EdgeNotLayerZero as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::EdgeNotLengthOne(inner) => {
                    <EdgeNotLengthOne as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::EdgeNotPending(inner) => {
                    <EdgeNotPending as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::EdgeTypeNotSmallStep(inner) => {
                    <EdgeTypeNotSmallStep as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::EdgeUnrivaled(inner) => {
                    <EdgeUnrivaled as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::EmptyArray(inner) => {
                    <EmptyArray as alloy_sol_types::SolError>::abi_encode_raw(inner, out)
                }
                Self::EmptyAssertionChain(inner) => {
                    <EmptyAssertionChain as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::EmptyChallengePeriod(inner) => {
                    <EmptyChallengePeriod as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::EmptyClaimId(inner) => {
                    <EmptyClaimId as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::EmptyEdgeSpecificProof(inner) => {
                    <EmptyEdgeSpecificProof as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::EmptyEndMachineStatus(inner) => {
                    <EmptyEndMachineStatus as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::EmptyEndRoot(inner) => {
                    <EmptyEndRoot as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::EmptyFirstRival(inner) => {
                    <EmptyFirstRival as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::EmptyOneStepProofEntry(inner) => {
                    <EmptyOneStepProofEntry as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::EmptyOriginId(inner) => {
                    <EmptyOriginId as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::EmptyPrefixProof(inner) => {
                    <EmptyPrefixProof as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::EmptyStakeReceiver(inner) => {
                    <EmptyStakeReceiver as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::EmptyStaker(inner) => {
                    <EmptyStaker as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::EmptyStartMachineStatus(inner) => {
                    <EmptyStartMachineStatus as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::EmptyStartRoot(inner) => {
                    <EmptyStartRoot as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::EndHistoryRootMismatch(inner) => {
                    <EndHistoryRootMismatch as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::HeightDiffLtTwo(inner) => {
                    <HeightDiffLtTwo as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::InsufficientConfirmationBlocks(inner) => {
                    <InsufficientConfirmationBlocks as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::InvalidEdgeType(inner) => {
                    <InvalidEdgeType as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::InvalidEndHeight(inner) => {
                    <InvalidEndHeight as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::InvalidHeights(inner) => {
                    <InvalidHeights as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::LevelTooHigh(inner) => {
                    <LevelTooHigh as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::MerkleProofTooLong(inner) => {
                    <MerkleProofTooLong as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::NotPowerOfTwo(inner) => {
                    <NotPowerOfTwo as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::NotValidator(inner) => {
                    <NotValidator as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::OriginIdMutualIdMismatch(inner) => {
                    <OriginIdMutualIdMismatch as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::RivalEdgeConfirmed(inner) => {
                    <RivalEdgeConfirmed as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::StakeAmountsMismatch(inner) => {
                    <StakeAmountsMismatch as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::ZeroBigStepLevels(inner) => {
                    <ZeroBigStepLevels as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
            }
        }
    }
    ///Container for all the [`EdgeChallengeManager`](self) events.
    pub enum EdgeChallengeManagerEvents {
        EdgeAdded(EdgeAdded),
        EdgeBisected(EdgeBisected),
        EdgeConfirmedByOneStepProof(EdgeConfirmedByOneStepProof),
        EdgeConfirmedByTime(EdgeConfirmedByTime),
        EdgeRefunded(EdgeRefunded),
        Initialized(Initialized),
        TimerCacheUpdated(TimerCacheUpdated),
    }
    #[automatically_derived]
    impl EdgeChallengeManagerEvents {
        /// All the selectors of this enum.
        ///
        /// Note that the selectors might not be in the same order as the variants.
        /// No guarantees are made about the order of the selectors.
        ///
        /// Prefer using `SolInterface` methods instead.
        pub const SELECTORS: &'static [[u8; 32usize]] = &[
            [
                46u8,
                8u8,
                8u8,
                131u8,
                10u8,
                34u8,
                32u8,
                76u8,
                179u8,
                251u8,
                143u8,
                141u8,
                120u8,
                75u8,
                40u8,
                188u8,
                151u8,
                233u8,
                206u8,
                46u8,
                57u8,
                210u8,
                249u8,
                205u8,
                226u8,
                134u8,
                13u8,
                224u8,
                149u8,
                125u8,
                104u8,
                235u8,
            ],
            [
                115u8,
                64u8,
                81u8,
                13u8,
                36u8,
                183u8,
                236u8,
                155u8,
                92u8,
                16u8,
                15u8,
                85u8,
                0u8,
                217u8,
                52u8,
                41u8,
                216u8,
                13u8,
                0u8,
                212u8,
                111u8,
                13u8,
                24u8,
                228u8,
                232u8,
                93u8,
                12u8,
                76u8,
                194u8,
                43u8,
                153u8,
                36u8,
            ],
            [
                127u8,
                38u8,
                184u8,
                63u8,
                249u8,
                110u8,
                31u8,
                43u8,
                106u8,
                104u8,
                47u8,
                19u8,
                56u8,
                82u8,
                246u8,
                121u8,
                138u8,
                9u8,
                196u8,
                101u8,
                218u8,
                149u8,
                146u8,
                20u8,
                96u8,
                206u8,
                251u8,
                56u8,
                71u8,
                64u8,
                36u8,
                152u8,
            ],
            [
                166u8,
                53u8,
                57u8,
                137u8,
                89u8,
                221u8,
                181u8,
                206u8,
                59u8,
                20u8,
                83u8,
                126u8,
                223u8,
                194u8,
                91u8,
                46u8,
                103u8,
                18u8,
                116u8,
                201u8,
                184u8,
                202u8,
                208u8,
                244u8,
                189u8,
                99u8,
                71u8,
                82u8,
                230u8,
                144u8,
                7u8,
                182u8,
            ],
            [
                170u8,
                75u8,
                102u8,
                177u8,
                206u8,
                147u8,
                140u8,
                6u8,
                226u8,
                163u8,
                248u8,
                70u8,
                107u8,
                174u8,
                16u8,
                239u8,
                98u8,
                231u8,
                71u8,
                99u8,
                14u8,
                56u8,
                89u8,
                136u8,
                159u8,
                71u8,
                25u8,
                252u8,
                100u8,
                39u8,
                181u8,
                164u8,
            ],
            [
                190u8,
                23u8,
                117u8,
                93u8,
                141u8,
                131u8,
                106u8,
                214u8,
                123u8,
                250u8,
                248u8,
                229u8,
                179u8,
                134u8,
                154u8,
                237u8,
                180u8,
                203u8,
                160u8,
                63u8,
                41u8,
                90u8,
                22u8,
                124u8,
                85u8,
                71u8,
                254u8,
                221u8,
                217u8,
                239u8,
                80u8,
                173u8,
            ],
            [
                225u8,
                29u8,
                180u8,
                178u8,
                123u8,
                200u8,
                198u8,
                234u8,
                89u8,
                67u8,
                236u8,
                187u8,
                32u8,
                90u8,
                225u8,
                202u8,
                141u8,
                86u8,
                196u8,
                44u8,
                113u8,
                151u8,
                23u8,
                170u8,
                248u8,
                165u8,
                61u8,
                67u8,
                208u8,
                206u8,
                231u8,
                194u8,
            ],
        ];
    }
    #[automatically_derived]
    impl alloy_sol_types::SolEventInterface for EdgeChallengeManagerEvents {
        const NAME: &'static str = "EdgeChallengeManagerEvents";
        const COUNT: usize = 7usize;
        fn decode_raw_log(
            topics: &[alloy_sol_types::Word],
            data: &[u8],
            validate: bool,
        ) -> alloy_sol_types::Result<Self> {
            match topics.first().copied() {
                Some(<EdgeAdded as alloy_sol_types::SolEvent>::SIGNATURE_HASH) => {
                    <EdgeAdded as alloy_sol_types::SolEvent>::decode_raw_log(
                            topics,
                            data,
                            validate,
                        )
                        .map(Self::EdgeAdded)
                }
                Some(<EdgeBisected as alloy_sol_types::SolEvent>::SIGNATURE_HASH) => {
                    <EdgeBisected as alloy_sol_types::SolEvent>::decode_raw_log(
                            topics,
                            data,
                            validate,
                        )
                        .map(Self::EdgeBisected)
                }
                Some(
                    <EdgeConfirmedByOneStepProof as alloy_sol_types::SolEvent>::SIGNATURE_HASH,
                ) => {
                    <EdgeConfirmedByOneStepProof as alloy_sol_types::SolEvent>::decode_raw_log(
                            topics,
                            data,
                            validate,
                        )
                        .map(Self::EdgeConfirmedByOneStepProof)
                }
                Some(
                    <EdgeConfirmedByTime as alloy_sol_types::SolEvent>::SIGNATURE_HASH,
                ) => {
                    <EdgeConfirmedByTime as alloy_sol_types::SolEvent>::decode_raw_log(
                            topics,
                            data,
                            validate,
                        )
                        .map(Self::EdgeConfirmedByTime)
                }
                Some(<EdgeRefunded as alloy_sol_types::SolEvent>::SIGNATURE_HASH) => {
                    <EdgeRefunded as alloy_sol_types::SolEvent>::decode_raw_log(
                            topics,
                            data,
                            validate,
                        )
                        .map(Self::EdgeRefunded)
                }
                Some(<Initialized as alloy_sol_types::SolEvent>::SIGNATURE_HASH) => {
                    <Initialized as alloy_sol_types::SolEvent>::decode_raw_log(
                            topics,
                            data,
                            validate,
                        )
                        .map(Self::Initialized)
                }
                Some(
                    <TimerCacheUpdated as alloy_sol_types::SolEvent>::SIGNATURE_HASH,
                ) => {
                    <TimerCacheUpdated as alloy_sol_types::SolEvent>::decode_raw_log(
                            topics,
                            data,
                            validate,
                        )
                        .map(Self::TimerCacheUpdated)
                }
                _ => {
                    alloy_sol_types::private::Err(alloy_sol_types::Error::InvalidLog {
                        name: <Self as alloy_sol_types::SolEventInterface>::NAME,
                        log: alloy_sol_types::private::Box::new(
                            alloy_sol_types::private::LogData::new_unchecked(
                                topics.to_vec(),
                                data.to_vec().into(),
                            ),
                        ),
                    })
                }
            }
        }
    }
    #[automatically_derived]
    impl alloy_sol_types::private::IntoLogData for EdgeChallengeManagerEvents {
        fn to_log_data(&self) -> alloy_sol_types::private::LogData {
            match self {
                Self::EdgeAdded(inner) => {
                    alloy_sol_types::private::IntoLogData::to_log_data(inner)
                }
                Self::EdgeBisected(inner) => {
                    alloy_sol_types::private::IntoLogData::to_log_data(inner)
                }
                Self::EdgeConfirmedByOneStepProof(inner) => {
                    alloy_sol_types::private::IntoLogData::to_log_data(inner)
                }
                Self::EdgeConfirmedByTime(inner) => {
                    alloy_sol_types::private::IntoLogData::to_log_data(inner)
                }
                Self::EdgeRefunded(inner) => {
                    alloy_sol_types::private::IntoLogData::to_log_data(inner)
                }
                Self::Initialized(inner) => {
                    alloy_sol_types::private::IntoLogData::to_log_data(inner)
                }
                Self::TimerCacheUpdated(inner) => {
                    alloy_sol_types::private::IntoLogData::to_log_data(inner)
                }
            }
        }
        fn into_log_data(self) -> alloy_sol_types::private::LogData {
            match self {
                Self::EdgeAdded(inner) => {
                    alloy_sol_types::private::IntoLogData::into_log_data(inner)
                }
                Self::EdgeBisected(inner) => {
                    alloy_sol_types::private::IntoLogData::into_log_data(inner)
                }
                Self::EdgeConfirmedByOneStepProof(inner) => {
                    alloy_sol_types::private::IntoLogData::into_log_data(inner)
                }
                Self::EdgeConfirmedByTime(inner) => {
                    alloy_sol_types::private::IntoLogData::into_log_data(inner)
                }
                Self::EdgeRefunded(inner) => {
                    alloy_sol_types::private::IntoLogData::into_log_data(inner)
                }
                Self::Initialized(inner) => {
                    alloy_sol_types::private::IntoLogData::into_log_data(inner)
                }
                Self::TimerCacheUpdated(inner) => {
                    alloy_sol_types::private::IntoLogData::into_log_data(inner)
                }
            }
        }
    }
    use alloy::contract as alloy_contract;
    /**Creates a new wrapper around an on-chain [`EdgeChallengeManager`](self) contract instance.

See the [wrapper's documentation](`EdgeChallengeManagerInstance`) for more details.*/
    #[inline]
    pub const fn new<
        T: alloy_contract::private::Transport + ::core::clone::Clone,
        P: alloy_contract::private::Provider<T, N>,
        N: alloy_contract::private::Network,
    >(
        address: alloy_sol_types::private::Address,
        provider: P,
    ) -> EdgeChallengeManagerInstance<T, P, N> {
        EdgeChallengeManagerInstance::<T, P, N>::new(address, provider)
    }
    /**Deploys this contract using the given `provider` and constructor arguments, if any.

Returns a new instance of the contract, if the deployment was successful.

For more fine-grained control over the deployment process, use [`deploy_builder`] instead.*/
    #[inline]
    pub fn deploy<
        T: alloy_contract::private::Transport + ::core::clone::Clone,
        P: alloy_contract::private::Provider<T, N>,
        N: alloy_contract::private::Network,
    >(
        provider: P,
    ) -> impl ::core::future::Future<
        Output = alloy_contract::Result<EdgeChallengeManagerInstance<T, P, N>>,
    > {
        EdgeChallengeManagerInstance::<T, P, N>::deploy(provider)
    }
    /**Creates a `RawCallBuilder` for deploying this contract using the given `provider`
and constructor arguments, if any.

This is a simple wrapper around creating a `RawCallBuilder` with the data set to
the bytecode concatenated with the constructor's ABI-encoded arguments.*/
    #[inline]
    pub fn deploy_builder<
        T: alloy_contract::private::Transport + ::core::clone::Clone,
        P: alloy_contract::private::Provider<T, N>,
        N: alloy_contract::private::Network,
    >(provider: P) -> alloy_contract::RawCallBuilder<T, P, N> {
        EdgeChallengeManagerInstance::<T, P, N>::deploy_builder(provider)
    }
    /**A [`EdgeChallengeManager`](self) instance.

Contains type-safe methods for interacting with an on-chain instance of the
[`EdgeChallengeManager`](self) contract located at a given `address`, using a given
provider `P`.

If the contract bytecode is available (see the [`sol!`](alloy_sol_types::sol!)
documentation on how to provide it), the `deploy` and `deploy_builder` methods can
be used to deploy a new instance of the contract.

See the [module-level documentation](self) for all the available methods.*/
    #[derive(Clone)]
    pub struct EdgeChallengeManagerInstance<
        T,
        P,
        N = alloy_contract::private::Ethereum,
    > {
        address: alloy_sol_types::private::Address,
        provider: P,
        _network_transport: ::core::marker::PhantomData<(N, T)>,
    }
    #[automatically_derived]
    impl<T, P, N> ::core::fmt::Debug for EdgeChallengeManagerInstance<T, P, N> {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
            f.debug_tuple("EdgeChallengeManagerInstance").field(&self.address).finish()
        }
    }
    /// Instantiation and getters/setters.
    #[automatically_derived]
    impl<
        T: alloy_contract::private::Transport + ::core::clone::Clone,
        P: alloy_contract::private::Provider<T, N>,
        N: alloy_contract::private::Network,
    > EdgeChallengeManagerInstance<T, P, N> {
        /**Creates a new wrapper around an on-chain [`EdgeChallengeManager`](self) contract instance.

See the [wrapper's documentation](`EdgeChallengeManagerInstance`) for more details.*/
        #[inline]
        pub const fn new(
            address: alloy_sol_types::private::Address,
            provider: P,
        ) -> Self {
            Self {
                address,
                provider,
                _network_transport: ::core::marker::PhantomData,
            }
        }
        /**Deploys this contract using the given `provider` and constructor arguments, if any.

Returns a new instance of the contract, if the deployment was successful.

For more fine-grained control over the deployment process, use [`deploy_builder`] instead.*/
        #[inline]
        pub async fn deploy(
            provider: P,
        ) -> alloy_contract::Result<EdgeChallengeManagerInstance<T, P, N>> {
            let call_builder = Self::deploy_builder(provider);
            let contract_address = call_builder.deploy().await?;
            Ok(Self::new(contract_address, call_builder.provider))
        }
        /**Creates a `RawCallBuilder` for deploying this contract using the given `provider`
and constructor arguments, if any.

This is a simple wrapper around creating a `RawCallBuilder` with the data set to
the bytecode concatenated with the constructor's ABI-encoded arguments.*/
        #[inline]
        pub fn deploy_builder(provider: P) -> alloy_contract::RawCallBuilder<T, P, N> {
            alloy_contract::RawCallBuilder::new_raw_deploy(
                provider,
                ::core::clone::Clone::clone(&BYTECODE),
            )
        }
        /// Returns a reference to the address.
        #[inline]
        pub const fn address(&self) -> &alloy_sol_types::private::Address {
            &self.address
        }
        /// Sets the address.
        #[inline]
        pub fn set_address(&mut self, address: alloy_sol_types::private::Address) {
            self.address = address;
        }
        /// Sets the address and returns `self`.
        pub fn at(mut self, address: alloy_sol_types::private::Address) -> Self {
            self.set_address(address);
            self
        }
        /// Returns a reference to the provider.
        #[inline]
        pub const fn provider(&self) -> &P {
            &self.provider
        }
    }
    impl<T, P: ::core::clone::Clone, N> EdgeChallengeManagerInstance<T, &P, N> {
        /// Clones the provider and returns a new instance with the cloned provider.
        #[inline]
        pub fn with_cloned_provider(self) -> EdgeChallengeManagerInstance<T, P, N> {
            EdgeChallengeManagerInstance {
                address: self.address,
                provider: ::core::clone::Clone::clone(&self.provider),
                _network_transport: ::core::marker::PhantomData,
            }
        }
    }
    /// Function calls.
    #[automatically_derived]
    impl<
        T: alloy_contract::private::Transport + ::core::clone::Clone,
        P: alloy_contract::private::Provider<T, N>,
        N: alloy_contract::private::Network,
    > EdgeChallengeManagerInstance<T, P, N> {
        /// Creates a new call builder using this contract instance's provider and address.
        ///
        /// Note that the call can be any function call, not just those defined in this
        /// contract. Prefer using the other methods for building type-safe contract calls.
        pub fn call_builder<C: alloy_sol_types::SolCall>(
            &self,
            call: &C,
        ) -> alloy_contract::SolCallBuilder<T, &P, C, N> {
            alloy_contract::SolCallBuilder::new_sol(&self.provider, &self.address, call)
        }
        ///Creates a new call builder for the [`LAYERZERO_BIGSTEPEDGE_HEIGHT`] function.
        pub fn LAYERZERO_BIGSTEPEDGE_HEIGHT(
            &self,
        ) -> alloy_contract::SolCallBuilder<T, &P, LAYERZERO_BIGSTEPEDGE_HEIGHTCall, N> {
            self.call_builder(
                &LAYERZERO_BIGSTEPEDGE_HEIGHTCall {
                },
            )
        }
        ///Creates a new call builder for the [`LAYERZERO_BLOCKEDGE_HEIGHT`] function.
        pub fn LAYERZERO_BLOCKEDGE_HEIGHT(
            &self,
        ) -> alloy_contract::SolCallBuilder<T, &P, LAYERZERO_BLOCKEDGE_HEIGHTCall, N> {
            self.call_builder(&LAYERZERO_BLOCKEDGE_HEIGHTCall {})
        }
        ///Creates a new call builder for the [`LAYERZERO_SMALLSTEPEDGE_HEIGHT`] function.
        pub fn LAYERZERO_SMALLSTEPEDGE_HEIGHT(
            &self,
        ) -> alloy_contract::SolCallBuilder<
            T,
            &P,
            LAYERZERO_SMALLSTEPEDGE_HEIGHTCall,
            N,
        > {
            self.call_builder(
                &LAYERZERO_SMALLSTEPEDGE_HEIGHTCall {
                },
            )
        }
        ///Creates a new call builder for the [`NUM_BIGSTEP_LEVEL`] function.
        pub fn NUM_BIGSTEP_LEVEL(
            &self,
        ) -> alloy_contract::SolCallBuilder<T, &P, NUM_BIGSTEP_LEVELCall, N> {
            self.call_builder(&NUM_BIGSTEP_LEVELCall {})
        }
        ///Creates a new call builder for the [`assertionChain`] function.
        pub fn assertionChain(
            &self,
        ) -> alloy_contract::SolCallBuilder<T, &P, assertionChainCall, N> {
            self.call_builder(&assertionChainCall {})
        }
        ///Creates a new call builder for the [`bisectEdge`] function.
        pub fn bisectEdge(
            &self,
            edgeId: alloy::sol_types::private::FixedBytes<32>,
            bisectionHistoryRoot: alloy::sol_types::private::FixedBytes<32>,
            prefixProof: alloy::sol_types::private::Bytes,
        ) -> alloy_contract::SolCallBuilder<T, &P, bisectEdgeCall, N> {
            self.call_builder(
                &bisectEdgeCall {
                    edgeId,
                    bisectionHistoryRoot,
                    prefixProof,
                },
            )
        }
        ///Creates a new call builder for the [`calculateEdgeId`] function.
        pub fn calculateEdgeId(
            &self,
            level: u8,
            originId: alloy::sol_types::private::FixedBytes<32>,
            startHeight: alloy::sol_types::private::primitives::aliases::U256,
            startHistoryRoot: alloy::sol_types::private::FixedBytes<32>,
            endHeight: alloy::sol_types::private::primitives::aliases::U256,
            endHistoryRoot: alloy::sol_types::private::FixedBytes<32>,
        ) -> alloy_contract::SolCallBuilder<T, &P, calculateEdgeIdCall, N> {
            self.call_builder(
                &calculateEdgeIdCall {
                    level,
                    originId,
                    startHeight,
                    startHistoryRoot,
                    endHeight,
                    endHistoryRoot,
                },
            )
        }
        ///Creates a new call builder for the [`calculateMutualId`] function.
        pub fn calculateMutualId(
            &self,
            level: u8,
            originId: alloy::sol_types::private::FixedBytes<32>,
            startHeight: alloy::sol_types::private::primitives::aliases::U256,
            startHistoryRoot: alloy::sol_types::private::FixedBytes<32>,
            endHeight: alloy::sol_types::private::primitives::aliases::U256,
        ) -> alloy_contract::SolCallBuilder<T, &P, calculateMutualIdCall, N> {
            self.call_builder(
                &calculateMutualIdCall {
                    level,
                    originId,
                    startHeight,
                    startHistoryRoot,
                    endHeight,
                },
            )
        }
        ///Creates a new call builder for the [`challengePeriodBlocks`] function.
        pub fn challengePeriodBlocks(
            &self,
        ) -> alloy_contract::SolCallBuilder<T, &P, challengePeriodBlocksCall, N> {
            self.call_builder(&challengePeriodBlocksCall {})
        }
        ///Creates a new call builder for the [`confirmEdgeByOneStepProof`] function.
        pub fn confirmEdgeByOneStepProof(
            &self,
            edgeId: alloy::sol_types::private::FixedBytes<32>,
            oneStepData: <OneStepData as alloy::sol_types::SolType>::RustType,
            prevConfig: <ConfigData as alloy::sol_types::SolType>::RustType,
            beforeHistoryInclusionProof: alloy::sol_types::private::Vec<
                alloy::sol_types::private::FixedBytes<32>,
            >,
            afterHistoryInclusionProof: alloy::sol_types::private::Vec<
                alloy::sol_types::private::FixedBytes<32>,
            >,
        ) -> alloy_contract::SolCallBuilder<T, &P, confirmEdgeByOneStepProofCall, N> {
            self.call_builder(
                &confirmEdgeByOneStepProofCall {
                    edgeId,
                    oneStepData,
                    prevConfig,
                    beforeHistoryInclusionProof,
                    afterHistoryInclusionProof,
                },
            )
        }
        ///Creates a new call builder for the [`confirmEdgeByTime`] function.
        pub fn confirmEdgeByTime(
            &self,
            edgeId: alloy::sol_types::private::FixedBytes<32>,
            claimStateData: <AssertionStateData as alloy::sol_types::SolType>::RustType,
        ) -> alloy_contract::SolCallBuilder<T, &P, confirmEdgeByTimeCall, N> {
            self.call_builder(
                &confirmEdgeByTimeCall {
                    edgeId,
                    claimStateData,
                },
            )
        }
        ///Creates a new call builder for the [`confirmedRival`] function.
        pub fn confirmedRival(
            &self,
            mutualId: alloy::sol_types::private::FixedBytes<32>,
        ) -> alloy_contract::SolCallBuilder<T, &P, confirmedRivalCall, N> {
            self.call_builder(&confirmedRivalCall { mutualId })
        }
        ///Creates a new call builder for the [`createLayerZeroEdge`] function.
        pub fn createLayerZeroEdge(
            &self,
            args: <CreateEdgeArgs as alloy::sol_types::SolType>::RustType,
        ) -> alloy_contract::SolCallBuilder<T, &P, createLayerZeroEdgeCall, N> {
            self.call_builder(&createLayerZeroEdgeCall { args })
        }
        ///Creates a new call builder for the [`edgeExists`] function.
        pub fn edgeExists(
            &self,
            edgeId: alloy::sol_types::private::FixedBytes<32>,
        ) -> alloy_contract::SolCallBuilder<T, &P, edgeExistsCall, N> {
            self.call_builder(&edgeExistsCall { edgeId })
        }
        ///Creates a new call builder for the [`edgeLength`] function.
        pub fn edgeLength(
            &self,
            edgeId: alloy::sol_types::private::FixedBytes<32>,
        ) -> alloy_contract::SolCallBuilder<T, &P, edgeLengthCall, N> {
            self.call_builder(&edgeLengthCall { edgeId })
        }
        ///Creates a new call builder for the [`excessStakeReceiver`] function.
        pub fn excessStakeReceiver(
            &self,
        ) -> alloy_contract::SolCallBuilder<T, &P, excessStakeReceiverCall, N> {
            self.call_builder(&excessStakeReceiverCall {})
        }
        ///Creates a new call builder for the [`firstRival`] function.
        pub fn firstRival(
            &self,
            mutualId: alloy::sol_types::private::FixedBytes<32>,
        ) -> alloy_contract::SolCallBuilder<T, &P, firstRivalCall, N> {
            self.call_builder(&firstRivalCall { mutualId })
        }
        ///Creates a new call builder for the [`getEdge`] function.
        pub fn getEdge(
            &self,
            edgeId: alloy::sol_types::private::FixedBytes<32>,
        ) -> alloy_contract::SolCallBuilder<T, &P, getEdgeCall, N> {
            self.call_builder(&getEdgeCall { edgeId })
        }
        ///Creates a new call builder for the [`getLayerZeroEndHeight`] function.
        pub fn getLayerZeroEndHeight(
            &self,
            eType: <EdgeType as alloy::sol_types::SolType>::RustType,
        ) -> alloy_contract::SolCallBuilder<T, &P, getLayerZeroEndHeightCall, N> {
            self.call_builder(&getLayerZeroEndHeightCall { eType })
        }
        ///Creates a new call builder for the [`getPrevAssertionHash`] function.
        pub fn getPrevAssertionHash(
            &self,
            edgeId: alloy::sol_types::private::FixedBytes<32>,
        ) -> alloy_contract::SolCallBuilder<T, &P, getPrevAssertionHashCall, N> {
            self.call_builder(&getPrevAssertionHashCall { edgeId })
        }
        ///Creates a new call builder for the [`hasLengthOneRival`] function.
        pub fn hasLengthOneRival(
            &self,
            edgeId: alloy::sol_types::private::FixedBytes<32>,
        ) -> alloy_contract::SolCallBuilder<T, &P, hasLengthOneRivalCall, N> {
            self.call_builder(&hasLengthOneRivalCall { edgeId })
        }
        ///Creates a new call builder for the [`hasMadeLayerZeroRival`] function.
        pub fn hasMadeLayerZeroRival(
            &self,
            account: alloy::sol_types::private::Address,
            mutualId: alloy::sol_types::private::FixedBytes<32>,
        ) -> alloy_contract::SolCallBuilder<T, &P, hasMadeLayerZeroRivalCall, N> {
            self.call_builder(
                &hasMadeLayerZeroRivalCall {
                    account,
                    mutualId,
                },
            )
        }
        ///Creates a new call builder for the [`hasRival`] function.
        pub fn hasRival(
            &self,
            edgeId: alloy::sol_types::private::FixedBytes<32>,
        ) -> alloy_contract::SolCallBuilder<T, &P, hasRivalCall, N> {
            self.call_builder(&hasRivalCall { edgeId })
        }
        ///Creates a new call builder for the [`initialize`] function.
        pub fn initialize(
            &self,
            _assertionChain: alloy::sol_types::private::Address,
            _challengePeriodBlocks: u64,
            _oneStepProofEntry: alloy::sol_types::private::Address,
            layerZeroBlockEdgeHeight: alloy::sol_types::private::primitives::aliases::U256,
            layerZeroBigStepEdgeHeight: alloy::sol_types::private::primitives::aliases::U256,
            layerZeroSmallStepEdgeHeight: alloy::sol_types::private::primitives::aliases::U256,
            _stakeToken: alloy::sol_types::private::Address,
            _excessStakeReceiver: alloy::sol_types::private::Address,
            _numBigStepLevel: u8,
            _stakeAmounts: alloy::sol_types::private::Vec<
                alloy::sol_types::private::primitives::aliases::U256,
            >,
        ) -> alloy_contract::SolCallBuilder<T, &P, initializeCall, N> {
            self.call_builder(
                &initializeCall {
                    _assertionChain,
                    _challengePeriodBlocks,
                    _oneStepProofEntry,
                    layerZeroBlockEdgeHeight,
                    layerZeroBigStepEdgeHeight,
                    layerZeroSmallStepEdgeHeight,
                    _stakeToken,
                    _excessStakeReceiver,
                    _numBigStepLevel,
                    _stakeAmounts,
                },
            )
        }
        ///Creates a new call builder for the [`multiUpdateTimeCacheByChildren`] function.
        pub fn multiUpdateTimeCacheByChildren(
            &self,
            edgeIds: alloy::sol_types::private::Vec<
                alloy::sol_types::private::FixedBytes<32>,
            >,
            maximumCachedTime: alloy::sol_types::private::primitives::aliases::U256,
        ) -> alloy_contract::SolCallBuilder<
            T,
            &P,
            multiUpdateTimeCacheByChildrenCall,
            N,
        > {
            self.call_builder(
                &multiUpdateTimeCacheByChildrenCall {
                    edgeIds,
                    maximumCachedTime,
                },
            )
        }
        ///Creates a new call builder for the [`oneStepProofEntry`] function.
        pub fn oneStepProofEntry(
            &self,
        ) -> alloy_contract::SolCallBuilder<T, &P, oneStepProofEntryCall, N> {
            self.call_builder(&oneStepProofEntryCall {})
        }
        ///Creates a new call builder for the [`refundStake`] function.
        pub fn refundStake(
            &self,
            edgeId: alloy::sol_types::private::FixedBytes<32>,
        ) -> alloy_contract::SolCallBuilder<T, &P, refundStakeCall, N> {
            self.call_builder(&refundStakeCall { edgeId })
        }
        ///Creates a new call builder for the [`stakeAmounts`] function.
        pub fn stakeAmounts(
            &self,
            _0: alloy::sol_types::private::primitives::aliases::U256,
        ) -> alloy_contract::SolCallBuilder<T, &P, stakeAmountsCall, N> {
            self.call_builder(&stakeAmountsCall { _0 })
        }
        ///Creates a new call builder for the [`stakeToken`] function.
        pub fn stakeToken(
            &self,
        ) -> alloy_contract::SolCallBuilder<T, &P, stakeTokenCall, N> {
            self.call_builder(&stakeTokenCall {})
        }
        ///Creates a new call builder for the [`timeUnrivaled`] function.
        pub fn timeUnrivaled(
            &self,
            edgeId: alloy::sol_types::private::FixedBytes<32>,
        ) -> alloy_contract::SolCallBuilder<T, &P, timeUnrivaledCall, N> {
            self.call_builder(&timeUnrivaledCall { edgeId })
        }
        ///Creates a new call builder for the [`updateTimerCacheByChildren`] function.
        pub fn updateTimerCacheByChildren(
            &self,
            edgeId: alloy::sol_types::private::FixedBytes<32>,
            maximumCachedTime: alloy::sol_types::private::primitives::aliases::U256,
        ) -> alloy_contract::SolCallBuilder<T, &P, updateTimerCacheByChildrenCall, N> {
            self.call_builder(
                &updateTimerCacheByChildrenCall {
                    edgeId,
                    maximumCachedTime,
                },
            )
        }
        ///Creates a new call builder for the [`updateTimerCacheByClaim`] function.
        pub fn updateTimerCacheByClaim(
            &self,
            edgeId: alloy::sol_types::private::FixedBytes<32>,
            claimingEdgeId: alloy::sol_types::private::FixedBytes<32>,
            maximumCachedTime: alloy::sol_types::private::primitives::aliases::U256,
        ) -> alloy_contract::SolCallBuilder<T, &P, updateTimerCacheByClaimCall, N> {
            self.call_builder(
                &updateTimerCacheByClaimCall {
                    edgeId,
                    claimingEdgeId,
                    maximumCachedTime,
                },
            )
        }
    }
    /// Event filters.
    #[automatically_derived]
    impl<
        T: alloy_contract::private::Transport + ::core::clone::Clone,
        P: alloy_contract::private::Provider<T, N>,
        N: alloy_contract::private::Network,
    > EdgeChallengeManagerInstance<T, P, N> {
        /// Creates a new event filter using this contract instance's provider and address.
        ///
        /// Note that the type can be any event, not just those defined in this contract.
        /// Prefer using the other methods for building type-safe event filters.
        pub fn event_filter<E: alloy_sol_types::SolEvent>(
            &self,
        ) -> alloy_contract::Event<T, &P, E, N> {
            alloy_contract::Event::new_sol(&self.provider, &self.address)
        }
        ///Creates a new event filter for the [`EdgeAdded`] event.
        pub fn EdgeAdded_filter(&self) -> alloy_contract::Event<T, &P, EdgeAdded, N> {
            self.event_filter::<EdgeAdded>()
        }
        ///Creates a new event filter for the [`EdgeBisected`] event.
        pub fn EdgeBisected_filter(
            &self,
        ) -> alloy_contract::Event<T, &P, EdgeBisected, N> {
            self.event_filter::<EdgeBisected>()
        }
        ///Creates a new event filter for the [`EdgeConfirmedByOneStepProof`] event.
        pub fn EdgeConfirmedByOneStepProof_filter(
            &self,
        ) -> alloy_contract::Event<T, &P, EdgeConfirmedByOneStepProof, N> {
            self.event_filter::<EdgeConfirmedByOneStepProof>()
        }
        ///Creates a new event filter for the [`EdgeConfirmedByTime`] event.
        pub fn EdgeConfirmedByTime_filter(
            &self,
        ) -> alloy_contract::Event<T, &P, EdgeConfirmedByTime, N> {
            self.event_filter::<EdgeConfirmedByTime>()
        }
        ///Creates a new event filter for the [`EdgeRefunded`] event.
        pub fn EdgeRefunded_filter(
            &self,
        ) -> alloy_contract::Event<T, &P, EdgeRefunded, N> {
            self.event_filter::<EdgeRefunded>()
        }
        ///Creates a new event filter for the [`Initialized`] event.
        pub fn Initialized_filter(
            &self,
        ) -> alloy_contract::Event<T, &P, Initialized, N> {
            self.event_filter::<Initialized>()
        }
        ///Creates a new event filter for the [`TimerCacheUpdated`] event.
        pub fn TimerCacheUpdated_filter(
            &self,
        ) -> alloy_contract::Event<T, &P, TimerCacheUpdated, N> {
            self.event_filter::<TimerCacheUpdated>()
        }
    }
}
