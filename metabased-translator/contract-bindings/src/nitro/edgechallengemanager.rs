/**

Generated by the following Solidity interface...
```solidity
interface EdgeChallengeManager {
    type EdgeStatus is uint8;
    type EdgeType is uint8;
    type MachineStatus is uint8;
    struct AssertionState {
        GlobalState globalState;
        MachineStatus machineStatus;
        bytes32 endHistoryRoot;
    }
    struct AssertionStateData {
        AssertionState assertionState;
        bytes32 prevAssertionHash;
        bytes32 inboxAcc;
    }
    struct ChallengeEdge {
        bytes32 originId;
        bytes32 startHistoryRoot;
        uint256 startHeight;
        bytes32 endHistoryRoot;
        uint256 endHeight;
        bytes32 lowerChildId;
        bytes32 upperChildId;
        bytes32 claimId;
        address staker;
        uint64 createdAtBlock;
        uint64 confirmedAtBlock;
        EdgeStatus status;
        uint8 level;
        bool refunded;
        uint64 totalTimeUnrivaledCache;
    }
    struct ConfigData {
        bytes32 wasmModuleRoot;
        uint256 requiredStake;
        address challengeManager;
        uint64 confirmPeriodBlocks;
        uint64 nextInboxPosition;
    }
    struct CreateEdgeArgs {
        uint8 level;
        bytes32 endHistoryRoot;
        uint256 endHeight;
        bytes32 claimId;
        bytes prefixProof;
        bytes proof;
    }
    struct GlobalState {
        bytes32[2] bytes32Vals;
        uint64[2] u64Vals;
    }
    struct OneStepData {
        bytes32 beforeHash;
        bytes proof;
    }

    error AccountHasMadeLayerZeroRival(address account, bytes32 mutualId);
    error AssertionHashEmpty();
    error AssertionHashMismatch(bytes32 h1, bytes32 h2);
    error AssertionNoSibling();
    error AssertionNotPending();
    error BigStepLevelsTooMany(uint8 levels);
    error CachedTimeSufficient(uint256 actual, uint256 expected);
    error ChildrenAlreadySet(bytes32 edgeId, bytes32 lowerChildId, bytes32 upperChildId);
    error ClaimEdgeInvalidLevel(uint8 argLevel, uint8 claimLevel);
    error ClaimEdgeNotLengthOneRival(bytes32 claimId);
    error ClaimEdgeNotPending();
    error EdgeAlreadyExists(bytes32 edgeId);
    error EdgeAlreadyRefunded(bytes32 edgeId);
    error EdgeClaimMismatch(bytes32 edgeId, bytes32 claimingEdgeId);
    error EdgeLevelInvalid(bytes32 edgeId1, bytes32 edgeId2, uint8 level1, uint8 level2);
    error EdgeNotConfirmed(bytes32 edgeId, EdgeStatus);
    error EdgeNotExists(bytes32 edgeId);
    error EdgeNotLayerZero(bytes32 edgeId, address staker, bytes32 claimId);
    error EdgeNotLengthOne(uint256 length);
    error EdgeNotPending(bytes32 edgeId, EdgeStatus status);
    error EdgeTypeNotSmallStep(uint8 level);
    error EdgeUnrivaled(bytes32 edgeId);
    error EmptyArray();
    error EmptyAssertionChain();
    error EmptyChallengePeriod();
    error EmptyClaimId();
    error EmptyEdgeSpecificProof();
    error EmptyEndMachineStatus();
    error EmptyEndRoot();
    error EmptyFirstRival();
    error EmptyOneStepProofEntry();
    error EmptyOriginId();
    error EmptyPrefixProof();
    error EmptyStakeReceiver();
    error EmptyStaker();
    error EmptyStartMachineStatus();
    error EmptyStartRoot();
    error EndHistoryRootMismatch(bytes32 endHistoryRoot, bytes32 assertionEndRoot);
    error HeightDiffLtTwo(uint256 h1, uint256 h2);
    error InsufficientConfirmationBlocks(uint256 totalBlocks, uint256 thresholdBlocks);
    error InvalidEdgeType(EdgeType edgeType);
    error InvalidEndHeight(uint256 actualHeight, uint256 expectedHeight);
    error InvalidHeights(uint256 start, uint256 end);
    error LevelTooHigh(uint8 level, uint8 numBigStepLevels);
    error MerkleProofTooLong(uint256 actualLength, uint256 maxProofLength);
    error NotPowerOfTwo(uint256 val);
    error NotValidator(address account);
    error OriginIdMutualIdMismatch(bytes32 mutualId, bytes32 originId);
    error RivalEdgeConfirmed(bytes32 edgeId, bytes32 confirmedRivalId);
    error StakeAmountsMismatch(uint256 stakeLevels, uint256 numLevels);
    error ZeroBigStepLevels();

    event EdgeAdded(bytes32 indexed edgeId, bytes32 indexed mutualId, bytes32 indexed originId, bytes32 claimId, uint256 length, uint8 level, bool hasRival, bool isLayerZero);
    event EdgeBisected(bytes32 indexed edgeId, bytes32 indexed lowerChildId, bytes32 indexed upperChildId, bool lowerChildAlreadyExists);
    event EdgeConfirmedByOneStepProof(bytes32 indexed edgeId, bytes32 indexed mutualId);
    event EdgeConfirmedByTime(bytes32 indexed edgeId, bytes32 indexed mutualId, uint256 totalTimeUnrivaled);
    event EdgeRefunded(bytes32 indexed edgeId, bytes32 indexed mutualId, address stakeToken, uint256 stakeAmount);
    event Initialized(uint8 version);
    event TimerCacheUpdated(bytes32 indexed edgeId, uint256 newValue);

    constructor();

    function LAYERZERO_BIGSTEPEDGE_HEIGHT() external view returns (uint256);
    function LAYERZERO_BLOCKEDGE_HEIGHT() external view returns (uint256);
    function LAYERZERO_SMALLSTEPEDGE_HEIGHT() external view returns (uint256);
    function NUM_BIGSTEP_LEVEL() external view returns (uint8);
    function assertionChain() external view returns (address);
    function bisectEdge(bytes32 edgeId, bytes32 bisectionHistoryRoot, bytes memory prefixProof) external returns (bytes32, bytes32);
    function calculateEdgeId(uint8 level, bytes32 originId, uint256 startHeight, bytes32 startHistoryRoot, uint256 endHeight, bytes32 endHistoryRoot) external pure returns (bytes32);
    function calculateMutualId(uint8 level, bytes32 originId, uint256 startHeight, bytes32 startHistoryRoot, uint256 endHeight) external pure returns (bytes32);
    function challengePeriodBlocks() external view returns (uint64);
    function confirmEdgeByOneStepProof(bytes32 edgeId, OneStepData memory oneStepData, ConfigData memory prevConfig, bytes32[] memory beforeHistoryInclusionProof, bytes32[] memory afterHistoryInclusionProof) external;
    function confirmEdgeByTime(bytes32 edgeId, AssertionStateData memory claimStateData) external;
    function confirmedRival(bytes32 mutualId) external view returns (bytes32);
    function createLayerZeroEdge(CreateEdgeArgs memory args) external returns (bytes32);
    function edgeExists(bytes32 edgeId) external view returns (bool);
    function edgeLength(bytes32 edgeId) external view returns (uint256);
    function excessStakeReceiver() external view returns (address);
    function firstRival(bytes32 mutualId) external view returns (bytes32);
    function getEdge(bytes32 edgeId) external view returns (ChallengeEdge memory);
    function getLayerZeroEndHeight(EdgeType eType) external view returns (uint256);
    function getPrevAssertionHash(bytes32 edgeId) external view returns (bytes32);
    function hasLengthOneRival(bytes32 edgeId) external view returns (bool);
    function hasMadeLayerZeroRival(address account, bytes32 mutualId) external view returns (bool);
    function hasRival(bytes32 edgeId) external view returns (bool);
    function initialize(address _assertionChain, uint64 _challengePeriodBlocks, address _oneStepProofEntry, uint256 layerZeroBlockEdgeHeight, uint256 layerZeroBigStepEdgeHeight, uint256 layerZeroSmallStepEdgeHeight, address _stakeToken, address _excessStakeReceiver, uint8 _numBigStepLevel, uint256[] memory _stakeAmounts) external;
    function multiUpdateTimeCacheByChildren(bytes32[] memory edgeIds, uint256 maximumCachedTime) external;
    function oneStepProofEntry() external view returns (address);
    function refundStake(bytes32 edgeId) external;
    function stakeAmounts(uint256) external view returns (uint256);
    function stakeToken() external view returns (address);
    function timeUnrivaled(bytes32 edgeId) external view returns (uint256);
    function updateTimerCacheByChildren(bytes32 edgeId, uint256 maximumCachedTime) external;
    function updateTimerCacheByClaim(bytes32 edgeId, bytes32 claimingEdgeId, uint256 maximumCachedTime) external;
}
```

...which was generated by the following JSON ABI:
```json
[
  {
    "type": "constructor",
    "inputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "LAYERZERO_BIGSTEPEDGE_HEIGHT",
    "inputs": [],
    "outputs": [
      {
        "name": "",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "LAYERZERO_BLOCKEDGE_HEIGHT",
    "inputs": [],
    "outputs": [
      {
        "name": "",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "LAYERZERO_SMALLSTEPEDGE_HEIGHT",
    "inputs": [],
    "outputs": [
      {
        "name": "",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "NUM_BIGSTEP_LEVEL",
    "inputs": [],
    "outputs": [
      {
        "name": "",
        "type": "uint8",
        "internalType": "uint8"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "assertionChain",
    "inputs": [],
    "outputs": [
      {
        "name": "",
        "type": "address",
        "internalType": "contract IAssertionChain"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "bisectEdge",
    "inputs": [
      {
        "name": "edgeId",
        "type": "bytes32",
        "internalType": "bytes32"
      },
      {
        "name": "bisectionHistoryRoot",
        "type": "bytes32",
        "internalType": "bytes32"
      },
      {
        "name": "prefixProof",
        "type": "bytes",
        "internalType": "bytes"
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "bytes32",
        "internalType": "bytes32"
      },
      {
        "name": "",
        "type": "bytes32",
        "internalType": "bytes32"
      }
    ],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "calculateEdgeId",
    "inputs": [
      {
        "name": "level",
        "type": "uint8",
        "internalType": "uint8"
      },
      {
        "name": "originId",
        "type": "bytes32",
        "internalType": "bytes32"
      },
      {
        "name": "startHeight",
        "type": "uint256",
        "internalType": "uint256"
      },
      {
        "name": "startHistoryRoot",
        "type": "bytes32",
        "internalType": "bytes32"
      },
      {
        "name": "endHeight",
        "type": "uint256",
        "internalType": "uint256"
      },
      {
        "name": "endHistoryRoot",
        "type": "bytes32",
        "internalType": "bytes32"
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "bytes32",
        "internalType": "bytes32"
      }
    ],
    "stateMutability": "pure"
  },
  {
    "type": "function",
    "name": "calculateMutualId",
    "inputs": [
      {
        "name": "level",
        "type": "uint8",
        "internalType": "uint8"
      },
      {
        "name": "originId",
        "type": "bytes32",
        "internalType": "bytes32"
      },
      {
        "name": "startHeight",
        "type": "uint256",
        "internalType": "uint256"
      },
      {
        "name": "startHistoryRoot",
        "type": "bytes32",
        "internalType": "bytes32"
      },
      {
        "name": "endHeight",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "bytes32",
        "internalType": "bytes32"
      }
    ],
    "stateMutability": "pure"
  },
  {
    "type": "function",
    "name": "challengePeriodBlocks",
    "inputs": [],
    "outputs": [
      {
        "name": "",
        "type": "uint64",
        "internalType": "uint64"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "confirmEdgeByOneStepProof",
    "inputs": [
      {
        "name": "edgeId",
        "type": "bytes32",
        "internalType": "bytes32"
      },
      {
        "name": "oneStepData",
        "type": "tuple",
        "internalType": "struct OneStepData",
        "components": [
          {
            "name": "beforeHash",
            "type": "bytes32",
            "internalType": "bytes32"
          },
          {
            "name": "proof",
            "type": "bytes",
            "internalType": "bytes"
          }
        ]
      },
      {
        "name": "prevConfig",
        "type": "tuple",
        "internalType": "struct ConfigData",
        "components": [
          {
            "name": "wasmModuleRoot",
            "type": "bytes32",
            "internalType": "bytes32"
          },
          {
            "name": "requiredStake",
            "type": "uint256",
            "internalType": "uint256"
          },
          {
            "name": "challengeManager",
            "type": "address",
            "internalType": "address"
          },
          {
            "name": "confirmPeriodBlocks",
            "type": "uint64",
            "internalType": "uint64"
          },
          {
            "name": "nextInboxPosition",
            "type": "uint64",
            "internalType": "uint64"
          }
        ]
      },
      {
        "name": "beforeHistoryInclusionProof",
        "type": "bytes32[]",
        "internalType": "bytes32[]"
      },
      {
        "name": "afterHistoryInclusionProof",
        "type": "bytes32[]",
        "internalType": "bytes32[]"
      }
    ],
    "outputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "confirmEdgeByTime",
    "inputs": [
      {
        "name": "edgeId",
        "type": "bytes32",
        "internalType": "bytes32"
      },
      {
        "name": "claimStateData",
        "type": "tuple",
        "internalType": "struct AssertionStateData",
        "components": [
          {
            "name": "assertionState",
            "type": "tuple",
            "internalType": "struct AssertionState",
            "components": [
              {
                "name": "globalState",
                "type": "tuple",
                "internalType": "struct GlobalState",
                "components": [
                  {
                    "name": "bytes32Vals",
                    "type": "bytes32[2]",
                    "internalType": "bytes32[2]"
                  },
                  {
                    "name": "u64Vals",
                    "type": "uint64[2]",
                    "internalType": "uint64[2]"
                  }
                ]
              },
              {
                "name": "machineStatus",
                "type": "uint8",
                "internalType": "enum MachineStatus"
              },
              {
                "name": "endHistoryRoot",
                "type": "bytes32",
                "internalType": "bytes32"
              }
            ]
          },
          {
            "name": "prevAssertionHash",
            "type": "bytes32",
            "internalType": "bytes32"
          },
          {
            "name": "inboxAcc",
            "type": "bytes32",
            "internalType": "bytes32"
          }
        ]
      }
    ],
    "outputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "confirmedRival",
    "inputs": [
      {
        "name": "mutualId",
        "type": "bytes32",
        "internalType": "bytes32"
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "bytes32",
        "internalType": "bytes32"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "createLayerZeroEdge",
    "inputs": [
      {
        "name": "args",
        "type": "tuple",
        "internalType": "struct CreateEdgeArgs",
        "components": [
          {
            "name": "level",
            "type": "uint8",
            "internalType": "uint8"
          },
          {
            "name": "endHistoryRoot",
            "type": "bytes32",
            "internalType": "bytes32"
          },
          {
            "name": "endHeight",
            "type": "uint256",
            "internalType": "uint256"
          },
          {
            "name": "claimId",
            "type": "bytes32",
            "internalType": "bytes32"
          },
          {
            "name": "prefixProof",
            "type": "bytes",
            "internalType": "bytes"
          },
          {
            "name": "proof",
            "type": "bytes",
            "internalType": "bytes"
          }
        ]
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "bytes32",
        "internalType": "bytes32"
      }
    ],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "edgeExists",
    "inputs": [
      {
        "name": "edgeId",
        "type": "bytes32",
        "internalType": "bytes32"
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "bool",
        "internalType": "bool"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "edgeLength",
    "inputs": [
      {
        "name": "edgeId",
        "type": "bytes32",
        "internalType": "bytes32"
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "excessStakeReceiver",
    "inputs": [],
    "outputs": [
      {
        "name": "",
        "type": "address",
        "internalType": "address"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "firstRival",
    "inputs": [
      {
        "name": "mutualId",
        "type": "bytes32",
        "internalType": "bytes32"
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "bytes32",
        "internalType": "bytes32"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "getEdge",
    "inputs": [
      {
        "name": "edgeId",
        "type": "bytes32",
        "internalType": "bytes32"
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "tuple",
        "internalType": "struct ChallengeEdge",
        "components": [
          {
            "name": "originId",
            "type": "bytes32",
            "internalType": "bytes32"
          },
          {
            "name": "startHistoryRoot",
            "type": "bytes32",
            "internalType": "bytes32"
          },
          {
            "name": "startHeight",
            "type": "uint256",
            "internalType": "uint256"
          },
          {
            "name": "endHistoryRoot",
            "type": "bytes32",
            "internalType": "bytes32"
          },
          {
            "name": "endHeight",
            "type": "uint256",
            "internalType": "uint256"
          },
          {
            "name": "lowerChildId",
            "type": "bytes32",
            "internalType": "bytes32"
          },
          {
            "name": "upperChildId",
            "type": "bytes32",
            "internalType": "bytes32"
          },
          {
            "name": "claimId",
            "type": "bytes32",
            "internalType": "bytes32"
          },
          {
            "name": "staker",
            "type": "address",
            "internalType": "address"
          },
          {
            "name": "createdAtBlock",
            "type": "uint64",
            "internalType": "uint64"
          },
          {
            "name": "confirmedAtBlock",
            "type": "uint64",
            "internalType": "uint64"
          },
          {
            "name": "status",
            "type": "uint8",
            "internalType": "enum EdgeStatus"
          },
          {
            "name": "level",
            "type": "uint8",
            "internalType": "uint8"
          },
          {
            "name": "refunded",
            "type": "bool",
            "internalType": "bool"
          },
          {
            "name": "totalTimeUnrivaledCache",
            "type": "uint64",
            "internalType": "uint64"
          }
        ]
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "getLayerZeroEndHeight",
    "inputs": [
      {
        "name": "eType",
        "type": "uint8",
        "internalType": "enum EdgeType"
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "getPrevAssertionHash",
    "inputs": [
      {
        "name": "edgeId",
        "type": "bytes32",
        "internalType": "bytes32"
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "bytes32",
        "internalType": "bytes32"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "hasLengthOneRival",
    "inputs": [
      {
        "name": "edgeId",
        "type": "bytes32",
        "internalType": "bytes32"
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "bool",
        "internalType": "bool"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "hasMadeLayerZeroRival",
    "inputs": [
      {
        "name": "account",
        "type": "address",
        "internalType": "address"
      },
      {
        "name": "mutualId",
        "type": "bytes32",
        "internalType": "bytes32"
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "bool",
        "internalType": "bool"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "hasRival",
    "inputs": [
      {
        "name": "edgeId",
        "type": "bytes32",
        "internalType": "bytes32"
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "bool",
        "internalType": "bool"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "initialize",
    "inputs": [
      {
        "name": "_assertionChain",
        "type": "address",
        "internalType": "contract IAssertionChain"
      },
      {
        "name": "_challengePeriodBlocks",
        "type": "uint64",
        "internalType": "uint64"
      },
      {
        "name": "_oneStepProofEntry",
        "type": "address",
        "internalType": "contract IOneStepProofEntry"
      },
      {
        "name": "layerZeroBlockEdgeHeight",
        "type": "uint256",
        "internalType": "uint256"
      },
      {
        "name": "layerZeroBigStepEdgeHeight",
        "type": "uint256",
        "internalType": "uint256"
      },
      {
        "name": "layerZeroSmallStepEdgeHeight",
        "type": "uint256",
        "internalType": "uint256"
      },
      {
        "name": "_stakeToken",
        "type": "address",
        "internalType": "contract IERC20"
      },
      {
        "name": "_excessStakeReceiver",
        "type": "address",
        "internalType": "address"
      },
      {
        "name": "_numBigStepLevel",
        "type": "uint8",
        "internalType": "uint8"
      },
      {
        "name": "_stakeAmounts",
        "type": "uint256[]",
        "internalType": "uint256[]"
      }
    ],
    "outputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "multiUpdateTimeCacheByChildren",
    "inputs": [
      {
        "name": "edgeIds",
        "type": "bytes32[]",
        "internalType": "bytes32[]"
      },
      {
        "name": "maximumCachedTime",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "outputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "oneStepProofEntry",
    "inputs": [],
    "outputs": [
      {
        "name": "",
        "type": "address",
        "internalType": "contract IOneStepProofEntry"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "refundStake",
    "inputs": [
      {
        "name": "edgeId",
        "type": "bytes32",
        "internalType": "bytes32"
      }
    ],
    "outputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "stakeAmounts",
    "inputs": [
      {
        "name": "",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "stakeToken",
    "inputs": [],
    "outputs": [
      {
        "name": "",
        "type": "address",
        "internalType": "contract IERC20"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "timeUnrivaled",
    "inputs": [
      {
        "name": "edgeId",
        "type": "bytes32",
        "internalType": "bytes32"
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "updateTimerCacheByChildren",
    "inputs": [
      {
        "name": "edgeId",
        "type": "bytes32",
        "internalType": "bytes32"
      },
      {
        "name": "maximumCachedTime",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "outputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "updateTimerCacheByClaim",
    "inputs": [
      {
        "name": "edgeId",
        "type": "bytes32",
        "internalType": "bytes32"
      },
      {
        "name": "claimingEdgeId",
        "type": "bytes32",
        "internalType": "bytes32"
      },
      {
        "name": "maximumCachedTime",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "outputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "event",
    "name": "EdgeAdded",
    "inputs": [
      {
        "name": "edgeId",
        "type": "bytes32",
        "indexed": true,
        "internalType": "bytes32"
      },
      {
        "name": "mutualId",
        "type": "bytes32",
        "indexed": true,
        "internalType": "bytes32"
      },
      {
        "name": "originId",
        "type": "bytes32",
        "indexed": true,
        "internalType": "bytes32"
      },
      {
        "name": "claimId",
        "type": "bytes32",
        "indexed": false,
        "internalType": "bytes32"
      },
      {
        "name": "length",
        "type": "uint256",
        "indexed": false,
        "internalType": "uint256"
      },
      {
        "name": "level",
        "type": "uint8",
        "indexed": false,
        "internalType": "uint8"
      },
      {
        "name": "hasRival",
        "type": "bool",
        "indexed": false,
        "internalType": "bool"
      },
      {
        "name": "isLayerZero",
        "type": "bool",
        "indexed": false,
        "internalType": "bool"
      }
    ],
    "anonymous": false
  },
  {
    "type": "event",
    "name": "EdgeBisected",
    "inputs": [
      {
        "name": "edgeId",
        "type": "bytes32",
        "indexed": true,
        "internalType": "bytes32"
      },
      {
        "name": "lowerChildId",
        "type": "bytes32",
        "indexed": true,
        "internalType": "bytes32"
      },
      {
        "name": "upperChildId",
        "type": "bytes32",
        "indexed": true,
        "internalType": "bytes32"
      },
      {
        "name": "lowerChildAlreadyExists",
        "type": "bool",
        "indexed": false,
        "internalType": "bool"
      }
    ],
    "anonymous": false
  },
  {
    "type": "event",
    "name": "EdgeConfirmedByOneStepProof",
    "inputs": [
      {
        "name": "edgeId",
        "type": "bytes32",
        "indexed": true,
        "internalType": "bytes32"
      },
      {
        "name": "mutualId",
        "type": "bytes32",
        "indexed": true,
        "internalType": "bytes32"
      }
    ],
    "anonymous": false
  },
  {
    "type": "event",
    "name": "EdgeConfirmedByTime",
    "inputs": [
      {
        "name": "edgeId",
        "type": "bytes32",
        "indexed": true,
        "internalType": "bytes32"
      },
      {
        "name": "mutualId",
        "type": "bytes32",
        "indexed": true,
        "internalType": "bytes32"
      },
      {
        "name": "totalTimeUnrivaled",
        "type": "uint256",
        "indexed": false,
        "internalType": "uint256"
      }
    ],
    "anonymous": false
  },
  {
    "type": "event",
    "name": "EdgeRefunded",
    "inputs": [
      {
        "name": "edgeId",
        "type": "bytes32",
        "indexed": true,
        "internalType": "bytes32"
      },
      {
        "name": "mutualId",
        "type": "bytes32",
        "indexed": true,
        "internalType": "bytes32"
      },
      {
        "name": "stakeToken",
        "type": "address",
        "indexed": false,
        "internalType": "address"
      },
      {
        "name": "stakeAmount",
        "type": "uint256",
        "indexed": false,
        "internalType": "uint256"
      }
    ],
    "anonymous": false
  },
  {
    "type": "event",
    "name": "Initialized",
    "inputs": [
      {
        "name": "version",
        "type": "uint8",
        "indexed": false,
        "internalType": "uint8"
      }
    ],
    "anonymous": false
  },
  {
    "type": "event",
    "name": "TimerCacheUpdated",
    "inputs": [
      {
        "name": "edgeId",
        "type": "bytes32",
        "indexed": true,
        "internalType": "bytes32"
      },
      {
        "name": "newValue",
        "type": "uint256",
        "indexed": false,
        "internalType": "uint256"
      }
    ],
    "anonymous": false
  },
  {
    "type": "error",
    "name": "AccountHasMadeLayerZeroRival",
    "inputs": [
      {
        "name": "account",
        "type": "address",
        "internalType": "address"
      },
      {
        "name": "mutualId",
        "type": "bytes32",
        "internalType": "bytes32"
      }
    ]
  },
  {
    "type": "error",
    "name": "AssertionHashEmpty",
    "inputs": []
  },
  {
    "type": "error",
    "name": "AssertionHashMismatch",
    "inputs": [
      {
        "name": "h1",
        "type": "bytes32",
        "internalType": "bytes32"
      },
      {
        "name": "h2",
        "type": "bytes32",
        "internalType": "bytes32"
      }
    ]
  },
  {
    "type": "error",
    "name": "AssertionNoSibling",
    "inputs": []
  },
  {
    "type": "error",
    "name": "AssertionNotPending",
    "inputs": []
  },
  {
    "type": "error",
    "name": "BigStepLevelsTooMany",
    "inputs": [
      {
        "name": "levels",
        "type": "uint8",
        "internalType": "uint8"
      }
    ]
  },
  {
    "type": "error",
    "name": "CachedTimeSufficient",
    "inputs": [
      {
        "name": "actual",
        "type": "uint256",
        "internalType": "uint256"
      },
      {
        "name": "expected",
        "type": "uint256",
        "internalType": "uint256"
      }
    ]
  },
  {
    "type": "error",
    "name": "ChildrenAlreadySet",
    "inputs": [
      {
        "name": "edgeId",
        "type": "bytes32",
        "internalType": "bytes32"
      },
      {
        "name": "lowerChildId",
        "type": "bytes32",
        "internalType": "bytes32"
      },
      {
        "name": "upperChildId",
        "type": "bytes32",
        "internalType": "bytes32"
      }
    ]
  },
  {
    "type": "error",
    "name": "ClaimEdgeInvalidLevel",
    "inputs": [
      {
        "name": "argLevel",
        "type": "uint8",
        "internalType": "uint8"
      },
      {
        "name": "claimLevel",
        "type": "uint8",
        "internalType": "uint8"
      }
    ]
  },
  {
    "type": "error",
    "name": "ClaimEdgeNotLengthOneRival",
    "inputs": [
      {
        "name": "claimId",
        "type": "bytes32",
        "internalType": "bytes32"
      }
    ]
  },
  {
    "type": "error",
    "name": "ClaimEdgeNotPending",
    "inputs": []
  },
  {
    "type": "error",
    "name": "EdgeAlreadyExists",
    "inputs": [
      {
        "name": "edgeId",
        "type": "bytes32",
        "internalType": "bytes32"
      }
    ]
  },
  {
    "type": "error",
    "name": "EdgeAlreadyRefunded",
    "inputs": [
      {
        "name": "edgeId",
        "type": "bytes32",
        "internalType": "bytes32"
      }
    ]
  },
  {
    "type": "error",
    "name": "EdgeClaimMismatch",
    "inputs": [
      {
        "name": "edgeId",
        "type": "bytes32",
        "internalType": "bytes32"
      },
      {
        "name": "claimingEdgeId",
        "type": "bytes32",
        "internalType": "bytes32"
      }
    ]
  },
  {
    "type": "error",
    "name": "EdgeLevelInvalid",
    "inputs": [
      {
        "name": "edgeId1",
        "type": "bytes32",
        "internalType": "bytes32"
      },
      {
        "name": "edgeId2",
        "type": "bytes32",
        "internalType": "bytes32"
      },
      {
        "name": "level1",
        "type": "uint8",
        "internalType": "uint8"
      },
      {
        "name": "level2",
        "type": "uint8",
        "internalType": "uint8"
      }
    ]
  },
  {
    "type": "error",
    "name": "EdgeNotConfirmed",
    "inputs": [
      {
        "name": "edgeId",
        "type": "bytes32",
        "internalType": "bytes32"
      },
      {
        "name": "",
        "type": "uint8",
        "internalType": "enum EdgeStatus"
      }
    ]
  },
  {
    "type": "error",
    "name": "EdgeNotExists",
    "inputs": [
      {
        "name": "edgeId",
        "type": "bytes32",
        "internalType": "bytes32"
      }
    ]
  },
  {
    "type": "error",
    "name": "EdgeNotLayerZero",
    "inputs": [
      {
        "name": "edgeId",
        "type": "bytes32",
        "internalType": "bytes32"
      },
      {
        "name": "staker",
        "type": "address",
        "internalType": "address"
      },
      {
        "name": "claimId",
        "type": "bytes32",
        "internalType": "bytes32"
      }
    ]
  },
  {
    "type": "error",
    "name": "EdgeNotLengthOne",
    "inputs": [
      {
        "name": "length",
        "type": "uint256",
        "internalType": "uint256"
      }
    ]
  },
  {
    "type": "error",
    "name": "EdgeNotPending",
    "inputs": [
      {
        "name": "edgeId",
        "type": "bytes32",
        "internalType": "bytes32"
      },
      {
        "name": "status",
        "type": "uint8",
        "internalType": "enum EdgeStatus"
      }
    ]
  },
  {
    "type": "error",
    "name": "EdgeTypeNotSmallStep",
    "inputs": [
      {
        "name": "level",
        "type": "uint8",
        "internalType": "uint8"
      }
    ]
  },
  {
    "type": "error",
    "name": "EdgeUnrivaled",
    "inputs": [
      {
        "name": "edgeId",
        "type": "bytes32",
        "internalType": "bytes32"
      }
    ]
  },
  {
    "type": "error",
    "name": "EmptyArray",
    "inputs": []
  },
  {
    "type": "error",
    "name": "EmptyAssertionChain",
    "inputs": []
  },
  {
    "type": "error",
    "name": "EmptyChallengePeriod",
    "inputs": []
  },
  {
    "type": "error",
    "name": "EmptyClaimId",
    "inputs": []
  },
  {
    "type": "error",
    "name": "EmptyEdgeSpecificProof",
    "inputs": []
  },
  {
    "type": "error",
    "name": "EmptyEndMachineStatus",
    "inputs": []
  },
  {
    "type": "error",
    "name": "EmptyEndRoot",
    "inputs": []
  },
  {
    "type": "error",
    "name": "EmptyFirstRival",
    "inputs": []
  },
  {
    "type": "error",
    "name": "EmptyOneStepProofEntry",
    "inputs": []
  },
  {
    "type": "error",
    "name": "EmptyOriginId",
    "inputs": []
  },
  {
    "type": "error",
    "name": "EmptyPrefixProof",
    "inputs": []
  },
  {
    "type": "error",
    "name": "EmptyStakeReceiver",
    "inputs": []
  },
  {
    "type": "error",
    "name": "EmptyStaker",
    "inputs": []
  },
  {
    "type": "error",
    "name": "EmptyStartMachineStatus",
    "inputs": []
  },
  {
    "type": "error",
    "name": "EmptyStartRoot",
    "inputs": []
  },
  {
    "type": "error",
    "name": "EndHistoryRootMismatch",
    "inputs": [
      {
        "name": "endHistoryRoot",
        "type": "bytes32",
        "internalType": "bytes32"
      },
      {
        "name": "assertionEndRoot",
        "type": "bytes32",
        "internalType": "bytes32"
      }
    ]
  },
  {
    "type": "error",
    "name": "HeightDiffLtTwo",
    "inputs": [
      {
        "name": "h1",
        "type": "uint256",
        "internalType": "uint256"
      },
      {
        "name": "h2",
        "type": "uint256",
        "internalType": "uint256"
      }
    ]
  },
  {
    "type": "error",
    "name": "InsufficientConfirmationBlocks",
    "inputs": [
      {
        "name": "totalBlocks",
        "type": "uint256",
        "internalType": "uint256"
      },
      {
        "name": "thresholdBlocks",
        "type": "uint256",
        "internalType": "uint256"
      }
    ]
  },
  {
    "type": "error",
    "name": "InvalidEdgeType",
    "inputs": [
      {
        "name": "edgeType",
        "type": "uint8",
        "internalType": "enum EdgeType"
      }
    ]
  },
  {
    "type": "error",
    "name": "InvalidEndHeight",
    "inputs": [
      {
        "name": "actualHeight",
        "type": "uint256",
        "internalType": "uint256"
      },
      {
        "name": "expectedHeight",
        "type": "uint256",
        "internalType": "uint256"
      }
    ]
  },
  {
    "type": "error",
    "name": "InvalidHeights",
    "inputs": [
      {
        "name": "start",
        "type": "uint256",
        "internalType": "uint256"
      },
      {
        "name": "end",
        "type": "uint256",
        "internalType": "uint256"
      }
    ]
  },
  {
    "type": "error",
    "name": "LevelTooHigh",
    "inputs": [
      {
        "name": "level",
        "type": "uint8",
        "internalType": "uint8"
      },
      {
        "name": "numBigStepLevels",
        "type": "uint8",
        "internalType": "uint8"
      }
    ]
  },
  {
    "type": "error",
    "name": "MerkleProofTooLong",
    "inputs": [
      {
        "name": "actualLength",
        "type": "uint256",
        "internalType": "uint256"
      },
      {
        "name": "maxProofLength",
        "type": "uint256",
        "internalType": "uint256"
      }
    ]
  },
  {
    "type": "error",
    "name": "NotPowerOfTwo",
    "inputs": [
      {
        "name": "val",
        "type": "uint256",
        "internalType": "uint256"
      }
    ]
  },
  {
    "type": "error",
    "name": "NotValidator",
    "inputs": [
      {
        "name": "account",
        "type": "address",
        "internalType": "address"
      }
    ]
  },
  {
    "type": "error",
    "name": "OriginIdMutualIdMismatch",
    "inputs": [
      {
        "name": "mutualId",
        "type": "bytes32",
        "internalType": "bytes32"
      },
      {
        "name": "originId",
        "type": "bytes32",
        "internalType": "bytes32"
      }
    ]
  },
  {
    "type": "error",
    "name": "RivalEdgeConfirmed",
    "inputs": [
      {
        "name": "edgeId",
        "type": "bytes32",
        "internalType": "bytes32"
      },
      {
        "name": "confirmedRivalId",
        "type": "bytes32",
        "internalType": "bytes32"
      }
    ]
  },
  {
    "type": "error",
    "name": "StakeAmountsMismatch",
    "inputs": [
      {
        "name": "stakeLevels",
        "type": "uint256",
        "internalType": "uint256"
      },
      {
        "name": "numLevels",
        "type": "uint256",
        "internalType": "uint256"
      }
    ]
  },
  {
    "type": "error",
    "name": "ZeroBigStepLevels",
    "inputs": []
  }
]
```*/
#[allow(
    non_camel_case_types,
    non_snake_case,
    clippy::pub_underscore_fields,
    clippy::style,
    clippy::empty_structs_with_brackets
)]
pub mod EdgeChallengeManager {
    use super::*;
    use alloy::sol_types as alloy_sol_types;
    /// The creation / init bytecode of the contract.
    ///
    /// ```text
    ///0x6080604052348015600e575f5ffd5b5060156019565b60d4565b5f54610100900460ff161560835760405162461bcd60e51b815260206004820152602760248201527f496e697469616c697a61626c653a20636f6e747261637420697320696e697469604482015266616c697a696e6760c81b606482015260840160405180910390fd5b5f5460ff908116101560d2575f805460ff191660ff9081179091556040519081527f7f26b83ff96e1f2b6a682f133852f6798a09c465da95921460cefb38474024989060200160405180910390a15b565b616642806100e15f395ff3fe608060405234801561000f575f5ffd5b50600436106101e6575f3560e01c8063655b42f311610109578063c32d8c631161009e578063eae0328b1161006e578063eae0328b146104a6578063edaab54a146104b9578063f8ee77d6146104cc578063fda2892e146104d5575f5ffd5b8063c32d8c6314610439578063c8bc4e431461044c578063e5b123da14610474578063e94e051e14610493575f5ffd5b80638c1b3a40116100d95780638c1b3a40146103e1578063908517e9146103f4578063b2a1408e14610407578063bce6f54f1461041a575f5ffd5b8063655b42f314610370578063748926f3146103a8578063750e0c0f146103bb5780638826a370146103ce575f5ffd5b8063432bb78a1161017f57806351ed6a301161014f57806351ed6a301461030857806354b641511461031b5780635a48e0f41461033e5780635d9e244414610351575f5ffd5b8063432bb78a1461028357806346c2781a1461029657806348923bc5146102c357806348dd2924146102ee575f5ffd5b80631dce5166116101ba5780631dce51661461024b5780633e35f5e814610254578063416e66571461026757806342e1aaa814610270575f5ffd5b80624d8efe146101ea57806305fae141146102105780631a72d54c146102235780631c1b4f3a14610238575b5f5ffd5b6101fd6101f8366004615666565b6104f5565b6040519081526020015b60405180910390f35b6101fd61021e3660046156ac565b610577565b610236610231366004615762565b610bb8565b005b6101fd61024636600461582c565b611025565b6101fd600a5481565b6101fd61026236600461582c565b611044565b6101fd600b5481565b6101fd61027e36600461585a565b611056565b610236610291366004615875565b6110f2565b6008546102aa9067ffffffffffffffff1681565b60405167ffffffffffffffff9091168152602001610207565b6009546102d6906001600160a01b031681565b6040516001600160a01b039091168152602001610207565b6008546102d690600160401b90046001600160a01b031681565b6006546102d6906001600160a01b031681565b61032e61032936600461582c565b611199565b6040519015158152602001610207565b6101fd61034c36600461582c565b6111a5565b600d5461035e9060ff1681565b60405160ff9091168152602001610207565b61032e61037e3660046158bd565b6001600160a01b03919091165f908152600460209081526040808320938352929052205460ff1690565b6102366103b636600461582c565b6111b1565b61032e6103c936600461582c565b6112a0565b6102366103dc3660046158e7565b6112c9565b6102366103ef366004615910565b611330565b61032e61040236600461582c565b6114ef565b6102366104153660046159f2565b6114fb565b6101fd61042836600461582c565b5f9081526002602052604090205490565b6101fd610447366004615a29565b611874565b61045f61045a366004615a67565b6118d1565b60408051928352602083019190915201610207565b6101fd61048236600461582c565b5f9081526003602052604090205490565b6005546102d6906001600160a01b031681565b6101fd6104b436600461582c565b611a87565b6102366104c7366004615ae3565b611a9b565b6101fd600c5481565b6104e86104e336600461582c565b611af3565b6040516102079190615b2b565b6040805160f888901b6001600160f81b03191660208083019190915260218201889052604182018790526061820186905260818083018690528351808403909101815260a18301845280519082012060c183015260e18083018590528351808403909101815261010190920190925280519101205f905b979650505050505050565b5f5f60088054906101000a90046001600160a01b03166001600160a01b03166312ab3d3b6040518163ffffffff1660e01b8152600401602060405180830381865afa1580156105c8573d5f5f3e3d5ffd5b505050506040513d601f19601f820116820180604052508101906105ec9190615c35565b15905080801561068257506008546040517ffacd743b000000000000000000000000000000000000000000000000000000008152336004820152600160401b9091046001600160a01b03169063facd743b90602401602060405180830381865afa15801561065c573d5f5f3e3d5ffd5b505050506040513d601f19601f820116820180604052508101906106809190615c35565b155b156106c0576040517fed3db8ac0000000000000000000000000000000000000000000000000000000081523360048201526024015b60405180910390fd5b6107076040518061010001604052805f81526020015f81526020015f81526020015f81526020015f81526020015f60ff1681526020015f151581526020015f151581525090565b5f6107236107186020870187615c54565b600d5460ff16611c23565b90505f61072f82611056565b90506107396154a4565b5f83600281111561074c5761074c615b03565b03610a6b5761075e60a0880188615c6d565b90505f0361077f57604051630c9ccac560e41b815260040160405180910390fd5b5f8061078e60a08a018a615c6d565b81019061079b9190615f15565b925092505060088054906101000a90046001600160a01b03166001600160a01b031663e51019a68a60600135835f0151846020015185604001516040518563ffffffff1660e01b81526004016107f49493929190615fde565b5f6040518083038186803b15801561080a575f5ffd5b505afa15801561081c573d5f5f3e3d5ffd5b505060085460208481015186519187015160408089015190517fe51019a6000000000000000000000000000000000000000000000000000000008152600160401b9095046001600160a01b0316965063e51019a6955061088194929392600401615fde565b5f6040518083038186803b158015610897575f5ffd5b505afa1580156108a9573d5f5f3e3d5ffd5b50505050805f01516040015189602001351461090657805160409081015190517f3a63e99a00000000000000000000000000000000000000000000000000000000815260208b0135600482015260248101919091526044016106b7565b6040805160c08101825260608b01358082526020848101519083015260085483517fe531d8c700000000000000000000000000000000000000000000000000000000815260048101929092529192830191600160401b90046001600160a01b03169063e531d8c790602401602060405180830381865afa15801561098c573d5f5f3e3d5ffd5b505050506040513d601f19601f820116820180604052508101906109b09190615c35565b151581526008546020848101516040517f56bbc9e600000000000000000000000000000000000000000000000000000000815260048101919091529201915f91600160401b90046001600160a01b0316906356bbc9e690602401602060405180830381865afa158015610a25573d5f5f3e3d5ffd5b505050506040513d601f19601f82011682018060405250810190610a49919061602a565b67ffffffffffffffff1611815292516020840152905160409092019190915290505b600954600d54610a93916001918a9185916001600160a01b0390911690879060ff168b611ca8565b6006549094506001600160a01b03165f6007610ab260208b018b615c54565b60ff1681548110610ac557610ac5616045565b5f9182526020909120015490506001600160a01b03821615801590610ae957508015155b15610b24575f8660c00151610afe5730610b0b565b6005546001600160a01b03165b9050610b226001600160a01b038416338385611dd0565b505b85604001518660200151875f01517faa4b66b1ce938c06e2a3f8466bae10ef62e747630e3859889f4719fc6427b5a489606001518a608001518b60a001518c60c001518d60e00151604051610ba2959493929190948552602085019390935260ff919091166040840152151560608301521515608082015260a00190565b60405180910390a4505092519695505050505050565b5f54610100900460ff1615808015610bd657505f54600160ff909116105b80610bef5750303b158015610bef57505f5460ff166001145b610c615760405162461bcd60e51b815260206004820152602e60248201527f496e697469616c697a61626c653a20636f6e747261637420697320616c72656160448201527f647920696e697469616c697a656400000000000000000000000000000000000060648201526084016106b7565b5f805460ff191660011790558015610c82575f805461ff0019166101001790555b6001600160a01b038c16610cc2576040517fc83e086200000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b600880546001600160a01b03808f16600160401b027fffffffff0000000000000000000000000000000000000000ffffffffffffffff909216919091179091558a16610d3a576040517ffb60b0ef00000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b6009805473ffffffffffffffffffffffffffffffffffffffff19166001600160a01b038c1617905567ffffffffffffffff8b165f03610da5576040517f8a0eedcc00000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b6008805467ffffffffffffffff191667ffffffffffffffff8d161790556006805473ffffffffffffffffffffffffffffffffffffffff19166001600160a01b03888116919091179091558516610e27576040517f0f0ec8a800000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b6005805473ffffffffffffffffffffffffffffffffffffffff19166001600160a01b038716179055610e5889611e81565b610e7857604051633abfb6ff60e21b8152600481018a90526024016106b7565b600a899055610e8688611e81565b610ea657604051633abfb6ff60e21b8152600481018990526024016106b7565b600b889055610eb487611e81565b610ed457604051633abfb6ff60e21b8152600481018890526024016106b7565b600c87905560ff84165f03610f15576040517fa863d6e400000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b60fd8460ff161115610f58576040517f40d23bf000000000000000000000000000000000000000000000000000000000815260ff851660048201526024016106b7565b600d805460ff191660ff861617905581610f7385600261606d565b60ff1614610fc55781610f8785600261606d565b6040517f0aece9c0000000000000000000000000000000000000000000000000000000008152600481019290925260ff1660248201526044016106b7565b610fd1600784846154e5565b508015611017575f805461ff0019169055604051600181527f7f26b83ff96e1f2b6a682f133852f6798a09c465da95921460cefb38474024989060200160405180910390a15b505050505050505050505050565b60078181548110611034575f80fd5b5f91825260209091200154905081565b5f611050600183611ea7565b92915050565b5f8082600281111561106a5761106a615b03565b03611077575050600a5490565b600182600281111561108b5761108b615b03565b03611098575050600b5490565b60028260028111156110ac576110ac615b03565b036110b9575050600c5490565b816040517f3bf2e1ec0000000000000000000000000000000000000000000000000000000081526004016106b79190616086565b919050565b5f82900361112c576040517f521299a900000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b61115d838361113c600182616099565b81811061114b5761114b616045565b60019260209091020135905083612055565b505f5b828110156111935761118b84848381811061117d5761117d616045565b905060200201355f19611a9b565b600101611160565b50505050565b5f6110506001836120cc565b5f6110506001836120fe565b5f6111bd60018361214d565b90506111c8816121a0565b6006546009820154600780546001600160a01b03909316925f92600160481b900460ff169081106111fb576111fb616045565b5f9182526020909120015490506001600160a01b0382161580159061121f57508015155b15611240576008830154611240906001600160a01b038481169116836122aa565b5f848152600160205260409020611256906122f8565b604080516001600160a01b03851681526020810184905286917fa635398959ddb5ce3b14537edfc25b2e671274c9b8cad0f4bd634752e69007b6910160405180910390a350505050565b5f81815260016020526040812060080154600160a01b900467ffffffffffffffff161515611050565b600d545f9081906112e4906001908790879060ff168761236e565b91509150811561132957847fbe17755d8d836ad67bfaf8e5b3869aedb4cba03f295a167c5547feddd9ef50ad8260405161132091815260200190565b60405180910390a25b5050505050565b5f61133c6001896120fe565b6008546040517f04972af9000000000000000000000000000000000000000000000000000000008152919250600160401b90046001600160a01b0316906304972af99061138f9084908a906004016160ac565b5f6040518083038186803b1580156113a5575f5ffd5b505afa1580156113b7573d5f5f3e3d5ffd5b505050505f60405180606001604052808860800160208101906113da919061612c565b67ffffffffffffffff16815260200160088054906101000a90046001600160a01b03166001600160a01b031663e78cea926040518163ffffffff1660e01b8152600401602060405180830381865afa158015611438573d5f5f3e3d5ffd5b505050506040513d601f19601f8201168201806040525081019061145c9190616147565b6001600160a01b0390811682528935602090920191909152600954600d54600b54600c549495506114a4946001948f9416928e9288928e928e928e928e9260ff1691906123db565b5f8981526001602052604090206114ba906122f8565b6040518a907fe11db4b27bc8c6ea5943ecbb205ae1ca8d56c42c719717aaf8a53d43d0cee7c2905f90a3505050505050505050565b5f61105060018361276d565b5f61150760018461214d565b90506115128161284a565b6115745761151f8161286d565b600882015460078301546040517fe58c830800000000000000000000000000000000000000000000000000000000815260048101939093526001600160a01b03909116602483015260448201526064016106b7565b5f80806009840154600d546115969160ff600160481b90910481169116611c23565b60028111156115a7576115a7615b03565b149050808015611642575060085460078401546040517f308362280000000000000000000000000000000000000000000000000000000081526004810191909152600160401b9091046001600160a01b031690633083622890602401602060405180830381865afa15801561161e573d5f5f3e3d5ffd5b505050506040513d601f19601f820116820180604052508101906116429190615c35565b156117fa5760085460078401546040517fe51019a6000000000000000000000000000000000000000000000000000000008152600160401b9092046001600160a01b03169163e51019a6916116a791889060c08201359060e083013590600401616162565b5f6040518083038186803b1580156116bd575f5ffd5b505afa1580156116cf573d5f5f3e3d5ffd5b50506008546040517f1171558500000000000000000000000000000000000000000000000000000000815260c08801356004820152600160401b9091046001600160a01b0316925063117155859150602401602060405180830381865afa15801561173c573d5f5f3e3d5ffd5b505050506040513d601f19601f82011682018060405250810190611760919061602a565b6008546040517f56bbc9e600000000000000000000000000000000000000000000000000000000815260c08701356004820152600160401b9091046001600160a01b0316906356bbc9e690602401602060405180830381865afa1580156117c9573d5f5f3e3d5ffd5b505050506040513d601f19601f820116820180604052508101906117ed919061602a565b6117f791906161f0565b91505b6008545f90611819906001908890869067ffffffffffffffff1661290d565b5f878152600160205260409020909150611832906122f8565b867f2e0808830a22204cb3fb8f8d784b28bc97e9ce2e39d2f9cde2860de0957d68eb8360405161186491815260200190565b60405180910390a3505050505050565b6040805160f887901b6001600160f81b03191660208083019190915260218201879052604182018690526061820185905260818083018590528351808403909101815260a190920190925280519101205f905b9695505050505050565b5f5f5f5f5f61191c898989898080601f0160208091040260200160405190810160405280939291908181526020018383808284375f9201919091525060019594939250506129f19050565b8151929550909350915015806119b35782604001518360200151845f01517faa4b66b1ce938c06e2a3f8466bae10ef62e747630e3859889f4719fc6427b5a4866060015187608001518860a001518960c001518a60e001516040516119aa959493929190948552602085019390935260ff919091166040840152151560608301521515608082015260a00190565b60405180910390a45b81604001518260200151835f01517faa4b66b1ce938c06e2a3f8466bae10ef62e747630e3859889f4719fc6427b5a4856060015186608001518760a001518860c001518960e00151604051611a31959493929190948552602085019390935260ff919091166040840152151560608301521515608082015260a00190565b60405180910390a48151604051821515815285908c907f7340510d24b7ec9b5c100f5500d93429d80d00d46f0d18e4e85d0c4cc22b99249060200160405180910390a45051919350909150505b94509492505050565b5f611050611a9660018461214d565b612e1b565b5f80611aa960018585612e5e565b91509150811561119357837fbe17755d8d836ad67bfaf8e5b3869aedb4cba03f295a167c5547feddd9ef50ad82604051611ae591815260200190565b60405180910390a250505050565b611afb61552e565b611b0660018361214d565b604080516101e0810182528254815260018084015460208301526002840154928201929092526003830154606082015260048301546080820152600583015460a0820152600683015460c0820152600783015460e082015260088301546001600160a01b038116610100830152600160a01b900467ffffffffffffffff9081166101208301526009840154908116610140830152909291610160840191600160401b900460ff1690811115611bbd57611bbd615b03565b6001811115611bce57611bce615b03565b81526009919091015460ff600160481b8204811660208401526a01000000000000000000008204161515604083015267ffffffffffffffff6b0100000000000000000000009091041660609091015292915050565b5f8260ff165f03611c3557505f611050565b8160ff168360ff1611611c4a57506001611050565b611c5582600161606d565b60ff168360ff1603611c6957506002611050565b6040517fae0da57800000000000000000000000000000000000000000000000000000000815260ff8085166004830152831660248201526044016106b7565b611cef6040518061010001604052805f81526020015f81526020015f81526020015f81526020015f81526020015f60ff1681526020015f151581526020015f151581525090565b5f5f611cfe8a8a8a8a89612e82565b915091505f611d0e838b896133d7565b90505f611d1c83838d613519565b90508515611db6575f611d2e8261354b565b335f90815260038f016020908152604080832084845290915290205490915060ff1615611d90576040517f5a46ac3a000000000000000000000000000000000000000000000000000000008152336004820152602481018290526044016106b7565b335f90815260038e016020908152604080832093835292905220805460ff191660011790555b611dc08c826135b8565b9c9b505050505050505050505050565b6040516001600160a01b03808516602483015283166044820152606481018290526111939085907f23b872dd00000000000000000000000000000000000000000000000000000000906084015b60408051601f198184030181529190526020810180517bffffffffffffffffffffffffffffffffffffffffffffffffffffffff167fffffffff000000000000000000000000000000000000000000000000000000009093169290921790915261399b565b5f815f03611e9057505f919050565b5f611e9c600184616099565b929092161592915050565b5f81815260208390526040812060080154600160a01b900467ffffffffffffffff16611ee85760405162a7b02b60e01b8152600481018390526024016106b7565b5f828152602084905260408120611efe906122f8565b5f818152600186016020526040812054919250819003611f4a576040517fda10f67c00000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b6040516815539492559053115160ba1b6020820152602901604051602081830303815290604052805190602001208103611fb3575f84815260208690526040902060080154611faa90600160a01b900467ffffffffffffffff1643616099565b92505050611050565b5f81815260208690526040902060080154600160a01b900467ffffffffffffffff16611ff45760405162a7b02b60e01b8152600481018290526024016106b7565b5f81815260208690526040808220600890810154878452919092209091015467ffffffffffffffff600160a01b9283900481169290910416808211156120495761203e8183616099565b945050505050611050565b5f945050505050611050565b5f828152602084905260408120600901546b010000000000000000000000900467ffffffffffffffff168281106120c2576040517fd1f5928100000000000000000000000000000000000000000000000000000000815260048101829052602481018490526044016106b7565b90505b9392505050565b5f6120d7838361276d565b80156120c557505f8281526020849052604090206120f490612e1b565b6001149392505050565b5f5f61210a848461214d565b90505b6009810154600160481b900460ff16156121455780545f90815260018501602052604090205461213d858261214d565b91505061210d565b549392505050565b5f81815260208390526040812060080154600160a01b900467ffffffffffffffff1661218e5760405162a7b02b60e01b8152600481018390526024016106b7565b505f9081526020919091526040902090565b60016009820154600160401b900460ff1660018111156121c2576121c2615b03565b14612213576121d08161286d565b60098201546040517fef1267b40000000000000000000000000000000000000000000000000000000081526106b79291600160401b900460ff1690600401616210565b61221c8161284a565b6122295761151f8161286d565b60098101546a0100000000000000000000900460ff161515600103612286576122518161286d565b6040517f307f76690000000000000000000000000000000000000000000000000000000081526004016106b791815260200190565b60090180546aff0000000000000000000019166a0100000000000000000000179055565b6040516001600160a01b0383166024820152604481018290526122f39084907fa9059cbb0000000000000000000000000000000000000000000000000000000090606401611e1d565b505050565b6009810154815460028301546001840154600485015460408051600160481b90960460f81b6001600160f81b0319166020808801919091526021870195909552604186019390935260618501919091526081808501919091528151808503909101815260a1909301905281519101205f90611050565b5f5f5f61237b8888611ea7565b905061238988888888613a7f565b5f868152602089905260409020600901546123bd906b010000000000000000000000900467ffffffffffffffff1682616224565b90506123cb88888387613c39565b92509250505b9550959350505050565b5f8b815260208d90526040902060080154600160a01b900467ffffffffffffffff1661241c5760405162a7b02b60e01b8152600481018c90526024016106b7565b60025f8c815260208e9052604090206009015461244390600160481b900460ff1685611c23565b600281111561245457612454615b03565b146124a9575f8b815260208d90526040908190206009015490517f348aefdf000000000000000000000000000000000000000000000000000000008152600160481b90910460ff1660048201526024016106b7565b5f8b815260208d9052604090206124bf90612e1b565b600114612511575f8b815260208d9052604090206124dc90612e1b565b6040517f6b595e500000000000000000000000000000000000000000000000000000000081526004016106b791815260200190565b5f8b815260208d905260409020600201548b825b60018f5f015f8481526020019081526020015f2060090160099054906101000a900460ff1660ff1611156125c0575f8f5f015f8481526020019081526020015f205f015490508f6001015f8281526020019081526020015f205492508f5f015f8481526020019081526020015f2060020154826125a29190616237565b6125ac9085616224565b93506125b88683616237565b915050612525565b50506126188d5f015f8e81526020019081526020015f20600101548b5f0135838b8b808060200260200160405190810160405280939291908181526020018383602002808284375f92019190915250613cce92505050565b5f8b6001600160a01b031663b5112fd28b848e5f01358f806020019061263e9190615c6d565b6040518663ffffffff1660e01b815260040161265e95949392919061624e565b602060405180830381865afa158015612679573d5f5f3e3d5ffd5b505050506040513d601f19601f8201168201806040525081019061269d91906162af565b90506126fe8e5f015f8f81526020019081526020015f2060030154828460016126c69190616224565b8a8a808060200260200160405190810160405280939291908181526020018383602002808284375f92019190915250613cce92505050565b5f8d815260208f90526040902061271490613d53565b61271e8e8e613dee565b5050505f998a5250505060209790975250506040909320600901805472ffffffffffffffff0000000000000000000000191672ffffffffffffffff000000000000000000000017905550505050565b5f81815260208390526040812060080154600160a01b900467ffffffffffffffff166127ae5760405162a7b02b60e01b8152600481018390526024016106b7565b5f8281526020849052604081206127c4906122f8565b5f818152600186016020526040812054919250819003612810576040517fda10f67c00000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b6040516815539492559053115160ba1b602082015260290160408051601f1981840301815291905280516020909101201415949350505050565b60078101545f9015801590611050575050600801546001600160a01b0316151590565b60098101548154600283015460018401546004850154600386015460408051600160481b90970460f81b6001600160f81b0319166020808901919091526021880196909652604187019490945260618601929092526081808601919091528251808603909101815260a18501835280519084012060c185015260e18085019190915281518085039091018152610101909301905281519101205f90611050565b5f83815260208590526040812060080154600160a01b900467ffffffffffffffff1661294e5760405162a7b02b60e01b8152600481018590526024016106b7565b5f6129598686613e6e565b905061296f67ffffffffffffffff851682616224565b90508267ffffffffffffffff168110156129c8576040517f11a8d4d00000000000000000000000000000000000000000000000000000000081526004810182905267ffffffffffffffff841660248201526044016106b7565b5f8581526020879052604090206129de90613d53565b6129e88686613dee565b95945050505050565b60408051610100810182525f80825260208201819052918101829052606081018290526080810182905260a0810182905260c0810182905260e08101829052612a776040518061010001604052805f81526020015f81526020015f81526020015f81526020015f81526020015f60ff1681526020015f151581526020015f151581525090565b5f5f87815260208990526040902060090154600160401b900460ff166001811115612aa457612aa4615b03565b14612afb575f86815260208890526040908190206009015490517f23f8405d0000000000000000000000000000000000000000000000000000000081526106b7918891600160401b90910460ff1690600401616210565b612b05878761276d565b612b3e576040517f80e07e45000000000000000000000000000000000000000000000000000000008152600481018790526024016106b7565b5f868152602088905260408120604080516101e0810182528254815260018084015460208301526002840154928201929092526003830154606082015260048301546080820152600583015460a0820152600683015460c0820152600783015460e082015260088301546001600160a01b038116610100830152600160a01b900467ffffffffffffffff9081166101208301526009840154908116610140830152909291610160840191600160401b900460ff1690811115612c0257612c02615b03565b6001811115612c1357612c13615b03565b815260099190910154600160481b810460ff90811660208401526a010000000000000000000082041615156040808401919091526b01000000000000000000000090910467ffffffffffffffff1660609092019190915281015160808201519192505f91612c819190613ef9565b90505f5f87806020019051810190612c999190616321565b9092509050612cc989612cad856001616224565b60608701516080880151612cc2906001616224565b8686613fa2565b505060408051610100810182525f80825260208201819052918101829052606081018290526080810182905260a0810182905260c0810182905260e081018290525f612d29855f0151866020015187604001518d888a61018001516142c3565b9050612d348161435b565b5f81815260208e90526040902060080154909350600160a01b900467ffffffffffffffff16612d6a57612d678c826135b8565b91505b50612db26040518061010001604052805f81526020015f81526020015f81526020015f81526020015f81526020015f60ff1681526020015f151581526020015f151581525090565b5f612dd1865f01518c8789606001518a608001518b61018001516142c3565b9050612ddd8d826135b8565b915050612e0983825f01518e5f015f8f81526020019081526020015f206143f29092919063ffffffff16565b919b909a509098509650505050505050565b5f5f82600201548360040154612e319190616099565b9050805f0361105057612e438361286d565b60405162a7b02b60e01b81526004016106b791815260200190565b5f5f612e758585612e6f8888613e6e565b86613c39565b915091505b935093915050565b612ea460405180606001604052805f81526020015f8152602001606081525090565b5f80612ebc612eb66020890189615c54565b85611c23565b6002811115612ecd57612ecd615b03565b036131e157602085015185515f03612f11576040517fe96bc61a00000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b8551606088013514612f5f5785516040517f5b177a3c0000000000000000000000000000000000000000000000000000000081526004810191909152606088013560248201526044016106b7565b8560400151612f9a576040517fc169243600000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b8560600151612fd5576040517fb45d1c3a00000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b612fe260a0880188615c6d565b90505f0361300357604051630c9ccac560e41b815260040160405180910390fd5b5f61301160a0890189615c6d565b81019061301e9190615f15565b509091505f9050876080015160200151600281111561303f5761303f615b03565b03613076576040517f46365e5200000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b5f8760a0015160200151600281111561309157613091615b03565b036130c8576040517f8999857d00000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b5f866001600160a01b031663c39619c46130e58a60800151614472565b6040518263ffffffff1660e01b81526004016131019190616386565b602060405180830381865afa15801561311c573d5f5f3e3d5ffd5b505050506040513d601f19601f8201168201806040525081019061314091906162af565b90505f876001600160a01b031663c39619c461315f8b60a00151614472565b6040518263ffffffff1660e01b815260040161317b9190616386565b602060405180830381865afa158015613196573d5f5f3e3d5ffd5b505050506040513d601f19601f820116820180604052508101906131ba91906162af565b60408051606081018252938452602084019190915282019290925293509091506123d19050565b6131ef8787606001356120cc565b61322b576040517fff6d9bd7000000000000000000000000000000000000000000000000000000008152606087013560048201526024016106b7565b60608601355f90815260208890526040812090613247826122f8565b90505f6009830154600160401b900460ff16600181111561326a5761326a615b03565b146132a1576040517f12459ffd00000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b60098201546132ba90600160481b900460ff16866144ac565b60ff166132ca60208a018a615c54565b60ff161461332c576132df6020890189615c54565b60098301546040517fac9e611600000000000000000000000000000000000000000000000000000000815260ff9283166004820152600160481b90910490911660248201526044016106b7565b61333960a0890189615c6d565b90505f0361335a57604051630c9ccac560e41b815260040160405180910390fd5b5f8080808061336c60a08e018e615c6d565b81019061337991906163b3565b94509450945094509450613397876001015486896002015486613cce565b6133ab876003015485896004015485613cce565b6040518060600160405280868152602001858152602001828152508698509850505050505050506123d1565b604080515f8082526020820190925281906133fc906133f79087516144cd565b614502565b905061340783611e81565b61342757604051633abfb6ff60e21b8152600481018490526024016106b7565b8284604001351461347157604080517fdfcc62bc000000000000000000000000000000000000000000000000000000008152908501356004820152602481018490526044016106b7565b61348d8460200135866020015186604001358860400151613cce565b61349a6080850185615c6d565b90505f036134d4576040517f342a075200000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b5f806134e36080870187615c6d565b8101906134f09190616454565b909250905061350e8360016020890135612cc260408b013583616224565b509095945050505050565b61352161552e565b6120c284845f602086018035906040880135906060890135903390613546908b615c54565b614692565b61018081015181516040808401516020808601516080870151845160f89790971b6001600160f81b031916878401526021870195909552604186019290925260618501919091526081808501939093528151808503909301835260a1909301905280519101205f90611050565b6135ff6040518061010001604052805f81526020015f81526020015f81526020015f81526020015f81526020015f60ff1681526020015f151581526020015f151581525090565b5f6136098361435b565b5f81815260208690526040902060080154909150600160a01b900467ffffffffffffffff1615613668576040517fbcedf3de000000000000000000000000000000000000000000000000000000008152600481018290526024016106b7565b5f81815260208581526040918290208551815590850151600180830191909155918501516002820155606085015160038201556080850151600482015560a0850151600582015560c0850151600682015560e0850151600782015561010085015160088201805461012088015167ffffffffffffffff908116600160a01b027fffffffff000000000000000000000000000000000000000000000000000000009092166001600160a01b03909416939093171790556101408601516009830180549190921667ffffffffffffffff19821681178355610160880151889590939268ffffffffffffffffff191690911790600160401b90849081111561376f5761376f615b03565b02179055506101808281015160099290920180546101a08501516101c09095015167ffffffffffffffff166b0100000000000000000000000272ffffffffffffffff0000000000000000000000199515156a0100000000000000000000026aff000000000000000000001960ff909616600160481b02959095167fffffffffffffffffffffffffffffffffffffffffff0000ffffffffffffffffff909216919091179390931793909316919091179091558301518351604080860151602080880151608089015184516001600160f81b031960f89890981b97909716878401526021870195909552604186019290925260618501919091526081808501939093528151808503909301835260a1909301905280519101205f905f8181526001870160205260408120549192508190036138e5576040516815539492559053115160ba1b602082015260290160408051601f1981840301815291815281516020928301205f85815260018a0190935291205561392c565b6040516815539492559053115160ba1b602082015260290160405160208183030381529060405280519060200120810361392c575f82815260018701602052604090208390555b6040805161010081018252848152602080820185905287518284015260e088015160608301525f8681529089905291909120608082019061396c90612e1b565b815261018087015160ff166020820152911515604083015260e090950151151560609091015250919392505050565b5f6139ef826040518060400160405280602081526020017f5361666545524332303a206c6f772d6c6576656c2063616c6c206661696c6564815250856001600160a01b03166147c99092919063ffffffff16565b8051909150156122f35780806020019051810190613a0d9190615c35565b6122f35760405162461bcd60e51b815260206004820152602a60248201527f5361666545524332303a204552433230206f7065726174696f6e20646964206e60448201527f6f7420737563636565640000000000000000000000000000000000000000000060648201526084016106b7565b5f828152602085905260409020600701548314613ae5575f82815260208590526040908190206007015490517fc2adc3e80000000000000000000000000000000000000000000000000000000081526106b7918591600401918252602082015260400190565b5f82815260208590526040808220548583529120613b02906122f8565b14613b67575f838152602085905260409020613b1d906122f8565b5f83815260208690526040908190205490517fe2e27f87000000000000000000000000000000000000000000000000000000008152600481019290925260248201526044016106b7565b5f82815260208590526040808220600990810154868452919092209091015460ff600160481b92839004811692613ba0920416836144ac565b60ff1614611193575f8381526020859052604090206009015483908390613bd190600160481b900460ff16846144ac565b5f85815260208890526040908190206009015490517f7e726d150000000000000000000000000000000000000000000000000000000081526004810194909452602484019290925260ff9081166044840152600160481b9091041660648201526084016106b7565b5f5f5f613c47878786612055565b905067ffffffffffffffff8511613c5e5784613c68565b67ffffffffffffffff5b945080851115613cc1575050505f838152602085905260409020600901805472ffffffffffffffff000000000000000000000019166b01000000000000000000000067ffffffffffffffff851602179055600182611a7e565b5f97909650945050505050565b5f613d02828486604051602001613ce791815260200190565b604051602081830303815290604052805190602001206147d7565b90508085146113295760405162461bcd60e51b815260206004820152601760248201527f496e76616c696420696e636c7573696f6e2070726f6f6600000000000000000060448201526064016106b7565b5f6009820154600160401b900460ff166001811115613d7457613d74615b03565b14613dc557613d828161286d565b60098201546040517f23f8405d0000000000000000000000000000000000000000000000000000000081526106b79291600160401b900460ff1690600401616210565b600901805467ffffffffffffffff431668ffffffffffffffffff1990911617600160401b179055565b5f818152602083905260408120613e04906122f8565b5f8181526002850160205260409020549091508015613e59576040517fdd7028f000000000000000000000000000000000000000000000000000000000815260048101849052602481018290526044016106b7565b505f9081526002909201602052604090912055565b5f5f613e7a8484611ea7565b5f84815260208690526040902060050154909150156120c5575f8381526020859052604080822060058101548352818320600990810154600690920154845291909220015467ffffffffffffffff6b0100000000000000000000009283900481169290910416808210613eed5780613eef565b815b6118c79084616224565b5f6002613f068484616099565b1015613f48576040517f9029859400000000000000000000000000000000000000000000000000000000815260048101849052602481018390526044016106b7565b613f528383616099565b600203613f6b57613f64836001616224565b9050611050565b5f83613f78600185616099565b1890505f613f858261488a565b90505f19811b80613f97600187616099565b169695505050505050565b5f8511613ff15760405162461bcd60e51b815260206004820152601460248201527f5072652d73697a652063616e6e6f74206265203000000000000000000000000060448201526064016106b7565b85613ffb83614502565b146140485760405162461bcd60e51b815260206004820152601b60248201527f50726520657870616e73696f6e20726f6f74206d69736d61746368000000000060448201526064016106b7565b84614052836149c4565b146140c55760405162461bcd60e51b815260206004820152602160248201527f5072652073697a6520646f6573206e6f74206d6174636820657870616e73696f60448201527f6e0000000000000000000000000000000000000000000000000000000000000060648201526084016106b7565b8285106141145760405162461bcd60e51b815260206004820181905260248201527f5072652073697a65206e6f74206c657373207468616e20706f73742073697a6560448201526064016106b7565b5f8590505f5f90505f614129855f8751614a13565b90505b858310156141eb575f61413f8488614b87565b9050845183106141915760405162461bcd60e51b815260206004820152601260248201527f496e646578206f7574206f662072616e6765000000000000000000000000000060448201526064016106b7565b6141b582828786815181106141a8576141a8616045565b6020026020010151614c6e565b91506001811b6141c58186616224565b9450878511156141d7576141d76164af565b836141e1816164c3565b945050505061412c565b866141f582614502565b146142685760405162461bcd60e51b815260206004820152602260248201527f506f737420657870616e73696f6e20726f6f74206e6f7420657175616c20706f60448201527f737400000000000000000000000000000000000000000000000000000000000060648201526084016106b7565b835182146142b85760405162461bcd60e51b815260206004820152601660248201527f496e636f6d706c6574652070726f6f662075736167650000000000000000000060448201526064016106b7565b505050505050505050565b6142cb61552e565b6142d887878787876151d6565b50604080516101e081018252968752602087019590955293850192909252606084015260808301525f60a0830181905260c0830181905260e08301819052610100830181905267ffffffffffffffff43166101208401526101408301819052610160830181905260ff9091166101808301526101a082018190526101c082015290565b610180810151815160408084015160208086015160808701516060880151855160f89890981b6001600160f81b031916888501526021880196909652604187019390935260618601526081808601929092528251808603909201825260a18501835281519181019190912060c185015260e18085019390935281518085039093018352610101909301905280519101205f90611050565b60058301541515806144075750600683015415155b15614462576144158361286d565b600584015460068501546040517f8b0e71d00000000000000000000000000000000000000000000000000000000081526004810193909352602483019190915260448201526064016106b7565b6005830191909155600690910155565b61447a6155c5565b6040518060400160405280835f01518152602001836020015160028111156144a4576144a4615b03565b905292915050565b5f806144b984600161606d565b90506144c58184611c23565b509392505050565b60606120c5835f846040516020016144e791815260200190565b60405160208183030381529060405280519060200120614c6e565b5f5f8251116145535760405162461bcd60e51b815260206004820152601660248201527f456d707479206d65726b6c6520657870616e73696f6e0000000000000000000060448201526064016106b7565b6040825111156145a55760405162461bcd60e51b815260206004820152601a60248201527f4d65726b6c6520657870616e73696f6e20746f6f206c6172676500000000000060448201526064016106b7565b5f805b835181101561468b575f8482815181106145c4576145c4616045565b60200260200101519050825f5f1b0361462e57801561462957809250600185516145ee9190616099565b8214614629576040516146109084905f90602001918252602082015260400190565b6040516020818303038152906040528051906020012092505b614682565b801561464d576040805160208101839052908101849052606001614610565b6040516146699084905f90602001918252602082015260400190565b6040516020818303038152906040528051906020012092505b506001016145a8565b5092915050565b61469a61552e565b6001600160a01b0383166146da576040517ff289e65700000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b5f849003614714576040517f6932bcfd00000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b61472189898989896151d6565b604051806101e001604052808a81526020018981526020018881526020018781526020018681526020015f5f1b81526020015f5f1b8152602001858152602001846001600160a01b031681526020014367ffffffffffffffff1681526020015f67ffffffffffffffff1681526020015f60018111156147a2576147a2615b03565b815260ff841660208201525f60408201819052606090910152905098975050505050505050565b60606120c284845f856152c7565b82515f90610100811115614822576040517ffdac331e0000000000000000000000000000000000000000000000000000000081526004810182905261010060248201526044016106b7565b825f5b82811015614880575f87828151811061484057614840616045565b60200260200101519050816001901b87165f0361486957825f528060205260405f209250614877565b805f528260205260405f2092505b50600101614825565b5095945050505050565b5f815f036148da5760405162461bcd60e51b815260206004820152601c60248201527f5a65726f20686173206e6f207369676e69666963616e7420626974730000000060448201526064016106b7565b700100000000000000000000000000000000821061490557608091821c916149029082616224565b90505b600160401b821061492357604091821c916149209082616224565b90505b640100000000821061494257602091821c9161493f9082616224565b90505b62010000821061495f57601091821c9161495c9082616224565b90505b610100821061497b57600891821c916149789082616224565b90505b6010821061499657600491821c916149939082616224565b90505b600482106149b157600291821c916149ae9082616224565b90505b600282106110ed57611050600182616224565b5f80805b835181101561468b578381815181106149e3576149e3616045565b60200260200101515f5f1b14614a0b576149fe8160026165b6565b614a089083616224565b91505b6001016149c8565b6060818310614a645760405162461bcd60e51b815260206004820152601760248201527f5374617274206e6f74206c657373207468616e20656e6400000000000000000060448201526064016106b7565b8351821115614adb5760405162461bcd60e51b815260206004820152602160248201527f456e64206e6f74206c657373206f7220657175616c207468616e206c656e677460448201527f680000000000000000000000000000000000000000000000000000000000000060648201526084016106b7565b5f614ae68484616099565b67ffffffffffffffff811115614afe57614afe615cce565b604051908082528060200260200182016040528015614b27578160200160208202803683370190505b509050835b83811015614b7e57858181518110614b4657614b46616045565b6020026020010151828683614b5b9190616099565b81518110614b6b57614b6b616045565b6020908102919091010152600101614b2c565b50949350505050565b5f818310614bd75760405162461bcd60e51b815260206004820152601760248201527f5374617274206e6f74206c657373207468616e20656e6400000000000000000060448201526064016106b7565b5f614be383851861488a565b90505f6001614bf28382616224565b6001901b614c009190616099565b90508481168482168115614c175761203e82615400565b8015614c265761203e8161488a565b60405162461bcd60e51b815260206004820152601b60248201527f426f7468207920616e64207a2063616e6e6f74206265207a65726f000000000060448201526064016106b7565b606060408310614cc05760405162461bcd60e51b815260206004820152600e60248201527f4c6576656c20746f6f206869676800000000000000000000000000000000000060448201526064016106b7565b5f829003614d105760405162461bcd60e51b815260206004820152601b60248201527f43616e6e6f7420617070656e6420656d7074792073756274726565000000000060448201526064016106b7565b604084511115614d625760405162461bcd60e51b815260206004820152601a60248201527f4d65726b6c6520657870616e73696f6e20746f6f206c6172676500000000000060448201526064016106b7565b83515f03614ddf575f614d76846001616224565b67ffffffffffffffff811115614d8e57614d8e615cce565b604051908082528060200260200182016040528015614db7578160200160208202803683370190505b50905082818581518110614dcd57614dcd616045565b602090810291909101015290506120c5565b83518310614e555760405162461bcd60e51b815260206004820152603560248201527f4c6576656c2067726561746572207468616e2068696768657374206c6576656c60448201527f206f662063757272656e7420657870616e73696f6e000000000000000000000060648201526084016106b7565b815f614e60866149c4565b90505f614e6e8660026165b6565b614e789083616224565b90505f614e848361488a565b614e8d8361488a565b11614edb57875167ffffffffffffffff811115614eac57614eac615cce565b604051908082528060200260200182016040528015614ed5578160200160208202803683370190505b50614f2b565b8751614ee8906001616224565b67ffffffffffffffff811115614f0057614f00615cce565b604051908082528060200260200182016040528015614f29578160200160208202803683370190505b505b9050604081511115614f7f5760405162461bcd60e51b815260206004820152601c60248201527f417070656e642063726561746573206f76657273697a6520747265650000000060448201526064016106b7565b5f5b885181101561512b578781101561502757888181518110614fa457614fa4616045565b60200260200101515f5f1b146150225760405162461bcd60e51b815260206004820152602260248201527f417070656e642061626f7665206c65617374207369676e69666963616e74206260448201527f697400000000000000000000000000000000000000000000000000000000000060648201526084016106b7565b615123565b5f85900361506c5788818151811061504157615041616045565b602002602001015182828151811061505b5761505b616045565b602002602001018181525050615123565b88818151811061507e5761507e616045565b60200260200101515f5f1b036150b457848282815181106150a1576150a1616045565b60209081029190910101525f9450615123565b5f5f1b8282815181106150c9576150c9616045565b6020026020010181815250508881815181106150e7576150e7616045565b60200260200101518560405160200161510a929190918252602082015260400190565b6040516020818303038152906040528051906020012094505b600101614f81565b50831561515f578381600183516151429190616099565b8151811061515257615152616045565b6020026020010181815250505b806001825161516e9190616099565b8151811061517e5761517e616045565b60200260200101515f5f1b0361056c5760405162461bcd60e51b815260206004820152600f60248201527f4c61737420656e747279207a65726f000000000000000000000000000000000060448201526064016106b7565b5f859003615210576040517f8d79dbbc00000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b828111615253576040517f2060faf400000000000000000000000000000000000000000000000000000000815260048101849052602481018290526044016106b7565b5f84900361528d576040517f83c683e400000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b5f829003611329576040517f5cb6e5bb00000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b60608247101561533f5760405162461bcd60e51b815260206004820152602660248201527f416464726573733a20696e73756666696369656e742062616c616e636520666f60448201527f722063616c6c000000000000000000000000000000000000000000000000000060648201526084016106b7565b6001600160a01b0385163b6153965760405162461bcd60e51b815260206004820152601d60248201527f416464726573733a2063616c6c20746f206e6f6e2d636f6e747261637400000060448201526064016106b7565b5f5f866001600160a01b031685876040516153b191906165c1565b5f6040518083038185875af1925050503d805f81146153eb576040519150601f19603f3d011682016040523d82523d5f602084013e6153f0565b606091505b509150915061056c82828661546b565b5f5f82116154505760405162461bcd60e51b815260206004820152601c60248201527f5a65726f20686173206e6f207369676e69666963616e7420626974730000000060448201526064016106b7565b5f828061545e600182616099565b161890506120c58161488a565b6060831561547a5750816120c5565b82511561548a5782518084602001fd5b8160405162461bcd60e51b81526004016106b791906165d7565b6040518060c001604052805f81526020015f81526020015f151581526020015f151581526020016154d36155e3565b81526020016154e06155e3565b905290565b828054828255905f5260205f2090810192821561551e579160200282015b8281111561551e578235825591602001919060010190615503565b5061552a929150615608565b5090565b604051806101e001604052805f81526020015f81526020015f81526020015f81526020015f81526020015f81526020015f81526020015f81526020015f6001600160a01b031681526020015f67ffffffffffffffff1681526020015f67ffffffffffffffff1681526020015f60018111156155ab576155ab615b03565b81525f602082018190526040820181905260609091015290565b60405180604001604052806155d861561c565b81526020015f905290565b60405180606001604052806155f661561c565b81526020015f81526020015f81525090565b5b8082111561552a575f8155600101615609565b604051806040016040528061562f615638565b81526020016154e05b60405180604001604052806002906020820280368337509192915050565b803560ff811681146110ed575f5ffd5b5f5f5f5f5f5f60c0878903121561567b575f5ffd5b61568487615656565b9860208801359850604088013597606081013597506080810135965060a00135945092505050565b5f602082840312156156bc575f5ffd5b813567ffffffffffffffff8111156156d2575f5ffd5b820160c081850312156120c5575f5ffd5b6001600160a01b03811681146156f7575f5ffd5b50565b67ffffffffffffffff811681146156f7575f5ffd5b80356110ed816156e3565b5f5f83601f84011261572a575f5ffd5b50813567ffffffffffffffff811115615741575f5ffd5b6020830191508360208260051b850101111561575b575f5ffd5b9250929050565b5f5f5f5f5f5f5f5f5f5f5f6101408c8e03121561577d575f5ffd5b8b35615788816156e3565b9a5060208c0135615798816156fa565b995060408c01356157a8816156e3565b985060608c0135975060808c0135965060a08c0135955060c08c01356157cd816156e3565b94506157db60e08d0161570f565b93506157ea6101008d01615656565b92506101208c013567ffffffffffffffff811115615806575f5ffd5b6158128e828f0161571a565b915080935050809150509295989b509295989b9093969950565b5f6020828403121561583c575f5ffd5b5035919050565b600381106156f7575f5ffd5b80356110ed81615843565b5f6020828403121561586a575f5ffd5b81356120c581615843565b5f5f5f60408486031215615887575f5ffd5b833567ffffffffffffffff81111561589d575f5ffd5b6158a98682870161571a565b909790965060209590950135949350505050565b5f5f604083850312156158ce575f5ffd5b82356158d9816156e3565b946020939093013593505050565b5f5f5f606084860312156158f9575f5ffd5b505081359360208301359350604090920135919050565b5f5f5f5f5f5f5f878903610120811215615928575f5ffd5b88359750602089013567ffffffffffffffff811115615945575f5ffd5b89016040818c031215615956575f5ffd5b965060a07fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc082011215615987575f5ffd5b5060408801945060e088013567ffffffffffffffff8111156159a7575f5ffd5b6159b38a828b0161571a565b90955093505061010088013567ffffffffffffffff8111156159d3575f5ffd5b6159df8a828b0161571a565b989b979a50959850939692959293505050565b5f5f828403610120811215615a05575f5ffd5b83359250610100601f1982011215615a1b575f5ffd5b506020830190509250929050565b5f5f5f5f5f60a08688031215615a3d575f5ffd5b615a4686615656565b97602087013597506040870135966060810135965060800135945092505050565b5f5f5f5f60608587031215615a7a575f5ffd5b8435935060208501359250604085013567ffffffffffffffff811115615a9e575f5ffd5b8501601f81018713615aae575f5ffd5b803567ffffffffffffffff811115615ac4575f5ffd5b876020828401011115615ad5575f5ffd5b949793965060200194505050565b5f5f60408385031215615af4575f5ffd5b50508035926020909101359150565b634e487b7160e01b5f52602160045260245ffd5b60028110615b2757615b27615b03565b9052565b5f6101e082019050825182526020830151602083015260408301516040830152606083015160608301526080830151608083015260a083015160a083015260c083015160c083015260e083015160e0830152610100830151615b996101008401826001600160a01b03169052565b50610120830151615bb761012084018267ffffffffffffffff169052565b50610140830151615bd561014084018267ffffffffffffffff169052565b50610160830151615bea610160840182615b17565b50610180830151615c0161018084018260ff169052565b506101a0830151615c176101a084018215159052565b506101c083015161468b6101c084018267ffffffffffffffff169052565b5f60208284031215615c45575f5ffd5b815180151581146120c5575f5ffd5b5f60208284031215615c64575f5ffd5b6120c582615656565b5f5f83357fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe1843603018112615ca0575f5ffd5b83018035915067ffffffffffffffff821115615cba575f5ffd5b60200191503681900382131561575b575f5ffd5b634e487b7160e01b5f52604160045260245ffd5b6040516060810167ffffffffffffffff81118282101715615d0557615d05615cce565b60405290565b6040805190810167ffffffffffffffff81118282101715615d0557615d05615cce565b604051601f8201601f1916810167ffffffffffffffff81118282101715615d5757615d57615cce565b604052919050565b5f67ffffffffffffffff821115615d7857615d78615cce565b5060051b60200190565b5f82601f830112615d91575f5ffd5b8135615da4615d9f82615d5f565b615d2e565b8082825260208201915060208360051b860101925085831115615dc5575f5ffd5b602085015b83811015614880578035835260209283019201615dca565b5f82601f830112615df1575f5ffd5b615dfb6040615d2e565b806040840185811115615e0c575f5ffd5b845b8181101561350e578035615e21816156fa565b845260209384019301615e0e565b5f818303610100811215615e41575f5ffd5b615e49615ce2565b915060c0811215615e58575f5ffd5b615e60615ce2565b6080821215615e6d575f5ffd5b615e75615d0b565b915084601f850112615e85575f5ffd5b615e8f6040615d2e565b806040860187811115615ea0575f5ffd5b865b81811015615eba578035845260209384019301615ea2565b50818552615ec88882615de2565b6020860152505050818152615edf6080850161584f565b60208281019190915260a085013560408084019190915291845260c08501359084015260e0909301359282019290925292915050565b5f5f5f6102208486031215615f28575f5ffd5b833567ffffffffffffffff811115615f3e575f5ffd5b615f4a86828701615d82565b935050615f5a8560208601615e2f565b9150615f6a856101208601615e2f565b90509250925092565b8051825f5b6002811015615f97578251825260209283019290910190600101615f78565b5050506020810151604083015f5b600281101561132957825167ffffffffffffffff16825260209283019290910190600101615fa5565b600381106156f7576156f7615b03565b5f61012082019050858252615ff7602083018651615f73565b602085015161600581615fce565b60a08301526040949094015160c082015260e081019290925261010090910152919050565b5f6020828403121561603a575f5ffd5b81516120c5816156fa565b634e487b7160e01b5f52603260045260245ffd5b634e487b7160e01b5f52601160045260245ffd5b60ff818116838216019081111561105057611050616059565b6020810161609383615fce565b91905290565b8181038181111561105057611050616059565b828152813560208083019190915282013560408083019190915260c08201908301356160d7816156e3565b6001600160a01b03811660608401525060608301356160f5816156fa565b67ffffffffffffffff81166080840152506080830135616114816156fa565b67ffffffffffffffff811660a0840152509392505050565b5f6020828403121561613c575f5ffd5b81356120c5816156fa565b5f60208284031215616157575f5ffd5b81516120c5816156e3565b8481526101208101604085602084013760608201604086015f5b60028110156161af578135616190816156fa565b67ffffffffffffffff168352602092830192919091019060010161617c565b50505060808501356161c081615843565b6161c981615fce565b60a083810191909152949094013560c082015260e081019290925261010090910152919050565b67ffffffffffffffff828116828216039081111561105057611050616059565b828152604081016120c56020830184615b17565b8082018082111561105057611050616059565b808202811582820484141761105057611050616059565b855181526001600160a01b0360208701511660208201526040860151604082015284606082015283608082015260c060a08201528160c0820152818360e08301375f81830160e090810191909152601f909201601f19160101949350505050565b5f602082840312156162bf575f5ffd5b5051919050565b5f82601f8301126162d5575f5ffd5b81516162e3615d9f82615d5f565b8082825260208201915060208360051b860101925085831115616304575f5ffd5b602085015b83811015614880578051835260209283019201616309565b5f5f60408385031215616332575f5ffd5b825167ffffffffffffffff811115616348575f5ffd5b616354858286016162c6565b925050602083015167ffffffffffffffff811115616370575f5ffd5b61637c858286016162c6565b9150509250929050565b5f60a082019050616398828451615f73565b60208301516163a681615fce565b8060808401525092915050565b5f5f5f5f5f60a086880312156163c7575f5ffd5b8535945060208601359350604086013567ffffffffffffffff8111156163eb575f5ffd5b6163f788828901615d82565b935050606086013567ffffffffffffffff811115616413575f5ffd5b61641f88828901615d82565b925050608086013567ffffffffffffffff81111561643b575f5ffd5b61644788828901615d82565b9150509295509295909350565b5f5f60408385031215616465575f5ffd5b823567ffffffffffffffff81111561647b575f5ffd5b61648785828601615d82565b925050602083013567ffffffffffffffff8111156164a3575f5ffd5b61637c85828601615d82565b634e487b7160e01b5f52600160045260245ffd5b5f600182016164d4576164d4616059565b5060010190565b6001815b6001841115612e7a578085048111156164fa576164fa616059565b600184161561650857908102905b60019390931c9280026164df565b5f8261652457506001611050565b8161653057505f611050565b816001811461654657600281146165505761656c565b6001915050611050565b60ff84111561656157616561616059565b50506001821b611050565b5060208310610133831016604e8410600b841016171561658f575081810a611050565b61659b5f1984846164db565b805f19048211156165ae576165ae616059565b029392505050565b5f6120c58383616516565b5f82518060208501845e5f920191825250919050565b602081525f82518060208401528060208501604085015e5f604082850101526040601f19601f8301168401019150509291505056fea26469706673582212207d5df4a80d58a52352e9efc07a006f66c944826899b9419b94d6deb8c4e114d164736f6c634300081c0033
    /// ```
    #[rustfmt::skip]
    #[allow(clippy::all)]
    pub static BYTECODE: alloy_sol_types::private::Bytes = alloy_sol_types::private::Bytes::from_static(
        b"`\x80`@R4\x80\x15`\x0EW__\xFD[P`\x15`\x19V[`\xD4V[_Ta\x01\0\x90\x04`\xFF\x16\x15`\x83W`@QbF\x1B\xCD`\xE5\x1B\x81R` `\x04\x82\x01R`'`$\x82\x01R\x7FInitializable: contract is initi`D\x82\x01Rfalizing`\xC8\x1B`d\x82\x01R`\x84\x01`@Q\x80\x91\x03\x90\xFD[_T`\xFF\x90\x81\x16\x10\x15`\xD2W_\x80T`\xFF\x19\x16`\xFF\x90\x81\x17\x90\x91U`@Q\x90\x81R\x7F\x7F&\xB8?\xF9n\x1F+jh/\x138R\xF6y\x8A\t\xC4e\xDA\x95\x92\x14`\xCE\xFB8G@$\x98\x90` \x01`@Q\x80\x91\x03\x90\xA1[V[afB\x80a\0\xE1_9_\xF3\xFE`\x80`@R4\x80\x15a\0\x0FW__\xFD[P`\x046\x10a\x01\xE6W_5`\xE0\x1C\x80ce[B\xF3\x11a\x01\tW\x80c\xC3-\x8Cc\x11a\0\x9EW\x80c\xEA\xE02\x8B\x11a\0nW\x80c\xEA\xE02\x8B\x14a\x04\xA6W\x80c\xED\xAA\xB5J\x14a\x04\xB9W\x80c\xF8\xEEw\xD6\x14a\x04\xCCW\x80c\xFD\xA2\x89.\x14a\x04\xD5W__\xFD[\x80c\xC3-\x8Cc\x14a\x049W\x80c\xC8\xBCNC\x14a\x04LW\x80c\xE5\xB1#\xDA\x14a\x04tW\x80c\xE9N\x05\x1E\x14a\x04\x93W__\xFD[\x80c\x8C\x1B:@\x11a\0\xD9W\x80c\x8C\x1B:@\x14a\x03\xE1W\x80c\x90\x85\x17\xE9\x14a\x03\xF4W\x80c\xB2\xA1@\x8E\x14a\x04\x07W\x80c\xBC\xE6\xF5O\x14a\x04\x1AW__\xFD[\x80ce[B\xF3\x14a\x03pW\x80ct\x89&\xF3\x14a\x03\xA8W\x80cu\x0E\x0C\x0F\x14a\x03\xBBW\x80c\x88&\xA3p\x14a\x03\xCEW__\xFD[\x80cC+\xB7\x8A\x11a\x01\x7FW\x80cQ\xEDj0\x11a\x01OW\x80cQ\xEDj0\x14a\x03\x08W\x80cT\xB6AQ\x14a\x03\x1BW\x80cZH\xE0\xF4\x14a\x03>W\x80c]\x9E$D\x14a\x03QW__\xFD[\x80cC+\xB7\x8A\x14a\x02\x83W\x80cF\xC2x\x1A\x14a\x02\x96W\x80cH\x92;\xC5\x14a\x02\xC3W\x80cH\xDD)$\x14a\x02\xEEW__\xFD[\x80c\x1D\xCEQf\x11a\x01\xBAW\x80c\x1D\xCEQf\x14a\x02KW\x80c>5\xF5\xE8\x14a\x02TW\x80cAnfW\x14a\x02gW\x80cB\xE1\xAA\xA8\x14a\x02pW__\xFD[\x80bM\x8E\xFE\x14a\x01\xEAW\x80c\x05\xFA\xE1A\x14a\x02\x10W\x80c\x1Ar\xD5L\x14a\x02#W\x80c\x1C\x1BO:\x14a\x028W[__\xFD[a\x01\xFDa\x01\xF86`\x04aVfV[a\x04\xF5V[`@Q\x90\x81R` \x01[`@Q\x80\x91\x03\x90\xF3[a\x01\xFDa\x02\x1E6`\x04aV\xACV[a\x05wV[a\x026a\x0216`\x04aWbV[a\x0B\xB8V[\0[a\x01\xFDa\x02F6`\x04aX,V[a\x10%V[a\x01\xFD`\nT\x81V[a\x01\xFDa\x02b6`\x04aX,V[a\x10DV[a\x01\xFD`\x0BT\x81V[a\x01\xFDa\x02~6`\x04aXZV[a\x10VV[a\x026a\x02\x916`\x04aXuV[a\x10\xF2V[`\x08Ta\x02\xAA\x90g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x81V[`@Qg\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x90\x91\x16\x81R` \x01a\x02\x07V[`\tTa\x02\xD6\x90`\x01`\x01`\xA0\x1B\x03\x16\x81V[`@Q`\x01`\x01`\xA0\x1B\x03\x90\x91\x16\x81R` \x01a\x02\x07V[`\x08Ta\x02\xD6\x90`\x01`@\x1B\x90\x04`\x01`\x01`\xA0\x1B\x03\x16\x81V[`\x06Ta\x02\xD6\x90`\x01`\x01`\xA0\x1B\x03\x16\x81V[a\x03.a\x03)6`\x04aX,V[a\x11\x99V[`@Q\x90\x15\x15\x81R` \x01a\x02\x07V[a\x01\xFDa\x03L6`\x04aX,V[a\x11\xA5V[`\rTa\x03^\x90`\xFF\x16\x81V[`@Q`\xFF\x90\x91\x16\x81R` \x01a\x02\x07V[a\x03.a\x03~6`\x04aX\xBDV[`\x01`\x01`\xA0\x1B\x03\x91\x90\x91\x16_\x90\x81R`\x04` \x90\x81R`@\x80\x83 \x93\x83R\x92\x90R T`\xFF\x16\x90V[a\x026a\x03\xB66`\x04aX,V[a\x11\xB1V[a\x03.a\x03\xC96`\x04aX,V[a\x12\xA0V[a\x026a\x03\xDC6`\x04aX\xE7V[a\x12\xC9V[a\x026a\x03\xEF6`\x04aY\x10V[a\x130V[a\x03.a\x04\x026`\x04aX,V[a\x14\xEFV[a\x026a\x04\x156`\x04aY\xF2V[a\x14\xFBV[a\x01\xFDa\x04(6`\x04aX,V[_\x90\x81R`\x02` R`@\x90 T\x90V[a\x01\xFDa\x04G6`\x04aZ)V[a\x18tV[a\x04_a\x04Z6`\x04aZgV[a\x18\xD1V[`@\x80Q\x92\x83R` \x83\x01\x91\x90\x91R\x01a\x02\x07V[a\x01\xFDa\x04\x826`\x04aX,V[_\x90\x81R`\x03` R`@\x90 T\x90V[`\x05Ta\x02\xD6\x90`\x01`\x01`\xA0\x1B\x03\x16\x81V[a\x01\xFDa\x04\xB46`\x04aX,V[a\x1A\x87V[a\x026a\x04\xC76`\x04aZ\xE3V[a\x1A\x9BV[a\x01\xFD`\x0CT\x81V[a\x04\xE8a\x04\xE36`\x04aX,V[a\x1A\xF3V[`@Qa\x02\x07\x91\x90a[+V[`@\x80Q`\xF8\x88\x90\x1B`\x01`\x01`\xF8\x1B\x03\x19\x16` \x80\x83\x01\x91\x90\x91R`!\x82\x01\x88\x90R`A\x82\x01\x87\x90R`a\x82\x01\x86\x90R`\x81\x80\x83\x01\x86\x90R\x83Q\x80\x84\x03\x90\x91\x01\x81R`\xA1\x83\x01\x84R\x80Q\x90\x82\x01 `\xC1\x83\x01R`\xE1\x80\x83\x01\x85\x90R\x83Q\x80\x84\x03\x90\x91\x01\x81Ra\x01\x01\x90\x92\x01\x90\x92R\x80Q\x91\x01 _\x90[\x97\x96PPPPPPPV[__`\x08\x80T\x90a\x01\0\n\x90\x04`\x01`\x01`\xA0\x1B\x03\x16`\x01`\x01`\xA0\x1B\x03\x16c\x12\xAB=;`@Q\x81c\xFF\xFF\xFF\xFF\x16`\xE0\x1B\x81R`\x04\x01` `@Q\x80\x83\x03\x81\x86Z\xFA\x15\x80\x15a\x05\xC8W=__>=_\xFD[PPPP`@Q=`\x1F\x19`\x1F\x82\x01\x16\x82\x01\x80`@RP\x81\x01\x90a\x05\xEC\x91\x90a\\5V[\x15\x90P\x80\x80\x15a\x06\x82WP`\x08T`@Q\x7F\xFA\xCDt;\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R3`\x04\x82\x01R`\x01`@\x1B\x90\x91\x04`\x01`\x01`\xA0\x1B\x03\x16\x90c\xFA\xCDt;\x90`$\x01` `@Q\x80\x83\x03\x81\x86Z\xFA\x15\x80\x15a\x06\\W=__>=_\xFD[PPPP`@Q=`\x1F\x19`\x1F\x82\x01\x16\x82\x01\x80`@RP\x81\x01\x90a\x06\x80\x91\x90a\\5V[\x15[\x15a\x06\xC0W`@Q\x7F\xED=\xB8\xAC\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R3`\x04\x82\x01R`$\x01[`@Q\x80\x91\x03\x90\xFD[a\x07\x07`@Q\x80a\x01\0\x01`@R\x80_\x81R` \x01_\x81R` \x01_\x81R` \x01_\x81R` \x01_\x81R` \x01_`\xFF\x16\x81R` \x01_\x15\x15\x81R` \x01_\x15\x15\x81RP\x90V[_a\x07#a\x07\x18` \x87\x01\x87a\\TV[`\rT`\xFF\x16a\x1C#V[\x90P_a\x07/\x82a\x10VV[\x90Pa\x079aT\xA4V[_\x83`\x02\x81\x11\x15a\x07LWa\x07La[\x03V[\x03a\nkWa\x07^`\xA0\x88\x01\x88a\\mV[\x90P_\x03a\x07\x7FW`@Qc\x0C\x9C\xCA\xC5`\xE4\x1B\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[_\x80a\x07\x8E`\xA0\x8A\x01\x8Aa\\mV[\x81\x01\x90a\x07\x9B\x91\x90a_\x15V[\x92P\x92PP`\x08\x80T\x90a\x01\0\n\x90\x04`\x01`\x01`\xA0\x1B\x03\x16`\x01`\x01`\xA0\x1B\x03\x16c\xE5\x10\x19\xA6\x8A``\x015\x83_\x01Q\x84` \x01Q\x85`@\x01Q`@Q\x85c\xFF\xFF\xFF\xFF\x16`\xE0\x1B\x81R`\x04\x01a\x07\xF4\x94\x93\x92\x91\x90a_\xDEV[_`@Q\x80\x83\x03\x81\x86\x80;\x15\x80\x15a\x08\nW__\xFD[PZ\xFA\x15\x80\x15a\x08\x1CW=__>=_\xFD[PP`\x08T` \x84\x81\x01Q\x86Q\x91\x87\x01Q`@\x80\x89\x01Q\x90Q\x7F\xE5\x10\x19\xA6\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x01`@\x1B\x90\x95\x04`\x01`\x01`\xA0\x1B\x03\x16\x96Pc\xE5\x10\x19\xA6\x95Pa\x08\x81\x94\x92\x93\x92`\x04\x01a_\xDEV[_`@Q\x80\x83\x03\x81\x86\x80;\x15\x80\x15a\x08\x97W__\xFD[PZ\xFA\x15\x80\x15a\x08\xA9W=__>=_\xFD[PPPP\x80_\x01Q`@\x01Q\x89` \x015\x14a\t\x06W\x80Q`@\x90\x81\x01Q\x90Q\x7F:c\xE9\x9A\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R` \x8B\x015`\x04\x82\x01R`$\x81\x01\x91\x90\x91R`D\x01a\x06\xB7V[`@\x80Q`\xC0\x81\x01\x82R``\x8B\x015\x80\x82R` \x84\x81\x01Q\x90\x83\x01R`\x08T\x83Q\x7F\xE51\xD8\xC7\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x81\x01\x92\x90\x92R\x91\x92\x83\x01\x91`\x01`@\x1B\x90\x04`\x01`\x01`\xA0\x1B\x03\x16\x90c\xE51\xD8\xC7\x90`$\x01` `@Q\x80\x83\x03\x81\x86Z\xFA\x15\x80\x15a\t\x8CW=__>=_\xFD[PPPP`@Q=`\x1F\x19`\x1F\x82\x01\x16\x82\x01\x80`@RP\x81\x01\x90a\t\xB0\x91\x90a\\5V[\x15\x15\x81R`\x08T` \x84\x81\x01Q`@Q\x7FV\xBB\xC9\xE6\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x81\x01\x91\x90\x91R\x92\x01\x91_\x91`\x01`@\x1B\x90\x04`\x01`\x01`\xA0\x1B\x03\x16\x90cV\xBB\xC9\xE6\x90`$\x01` `@Q\x80\x83\x03\x81\x86Z\xFA\x15\x80\x15a\n%W=__>=_\xFD[PPPP`@Q=`\x1F\x19`\x1F\x82\x01\x16\x82\x01\x80`@RP\x81\x01\x90a\nI\x91\x90a`*V[g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x11\x81R\x92Q` \x84\x01R\x90Q`@\x90\x92\x01\x91\x90\x91R\x90P[`\tT`\rTa\n\x93\x91`\x01\x91\x8A\x91\x85\x91`\x01`\x01`\xA0\x1B\x03\x90\x91\x16\x90\x87\x90`\xFF\x16\x8Ba\x1C\xA8V[`\x06T\x90\x94P`\x01`\x01`\xA0\x1B\x03\x16_`\x07a\n\xB2` \x8B\x01\x8Ba\\TV[`\xFF\x16\x81T\x81\x10a\n\xC5Wa\n\xC5a`EV[_\x91\x82R` \x90\x91 \x01T\x90P`\x01`\x01`\xA0\x1B\x03\x82\x16\x15\x80\x15\x90a\n\xE9WP\x80\x15\x15[\x15a\x0B$W_\x86`\xC0\x01Qa\n\xFEW0a\x0B\x0BV[`\x05T`\x01`\x01`\xA0\x1B\x03\x16[\x90Pa\x0B\"`\x01`\x01`\xA0\x1B\x03\x84\x163\x83\x85a\x1D\xD0V[P[\x85`@\x01Q\x86` \x01Q\x87_\x01Q\x7F\xAAKf\xB1\xCE\x93\x8C\x06\xE2\xA3\xF8Fk\xAE\x10\xEFb\xE7Gc\x0E8Y\x88\x9FG\x19\xFCd'\xB5\xA4\x89``\x01Q\x8A`\x80\x01Q\x8B`\xA0\x01Q\x8C`\xC0\x01Q\x8D`\xE0\x01Q`@Qa\x0B\xA2\x95\x94\x93\x92\x91\x90\x94\x85R` \x85\x01\x93\x90\x93R`\xFF\x91\x90\x91\x16`@\x84\x01R\x15\x15``\x83\x01R\x15\x15`\x80\x82\x01R`\xA0\x01\x90V[`@Q\x80\x91\x03\x90\xA4PP\x92Q\x96\x95PPPPPPV[_Ta\x01\0\x90\x04`\xFF\x16\x15\x80\x80\x15a\x0B\xD6WP_T`\x01`\xFF\x90\x91\x16\x10[\x80a\x0B\xEFWP0;\x15\x80\x15a\x0B\xEFWP_T`\xFF\x16`\x01\x14[a\x0CaW`@QbF\x1B\xCD`\xE5\x1B\x81R` `\x04\x82\x01R`.`$\x82\x01R\x7FInitializable: contract is alrea`D\x82\x01R\x7Fdy initialized\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0`d\x82\x01R`\x84\x01a\x06\xB7V[_\x80T`\xFF\x19\x16`\x01\x17\x90U\x80\x15a\x0C\x82W_\x80Ta\xFF\0\x19\x16a\x01\0\x17\x90U[`\x01`\x01`\xA0\x1B\x03\x8C\x16a\x0C\xC2W`@Q\x7F\xC8>\x08b\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[`\x08\x80T`\x01`\x01`\xA0\x1B\x03\x80\x8F\x16`\x01`@\x1B\x02\x7F\xFF\xFF\xFF\xFF\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x90\x92\x16\x91\x90\x91\x17\x90\x91U\x8A\x16a\r:W`@Q\x7F\xFB`\xB0\xEF\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[`\t\x80Ts\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x19\x16`\x01`\x01`\xA0\x1B\x03\x8C\x16\x17\x90Ug\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x8B\x16_\x03a\r\xA5W`@Q\x7F\x8A\x0E\xED\xCC\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[`\x08\x80Tg\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x19\x16g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x8D\x16\x17\x90U`\x06\x80Ts\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x19\x16`\x01`\x01`\xA0\x1B\x03\x88\x81\x16\x91\x90\x91\x17\x90\x91U\x85\x16a\x0E'W`@Q\x7F\x0F\x0E\xC8\xA8\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[`\x05\x80Ts\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x19\x16`\x01`\x01`\xA0\x1B\x03\x87\x16\x17\x90Ua\x0EX\x89a\x1E\x81V[a\x0ExW`@Qc:\xBF\xB6\xFF`\xE2\x1B\x81R`\x04\x81\x01\x8A\x90R`$\x01a\x06\xB7V[`\n\x89\x90Ua\x0E\x86\x88a\x1E\x81V[a\x0E\xA6W`@Qc:\xBF\xB6\xFF`\xE2\x1B\x81R`\x04\x81\x01\x89\x90R`$\x01a\x06\xB7V[`\x0B\x88\x90Ua\x0E\xB4\x87a\x1E\x81V[a\x0E\xD4W`@Qc:\xBF\xB6\xFF`\xE2\x1B\x81R`\x04\x81\x01\x88\x90R`$\x01a\x06\xB7V[`\x0C\x87\x90U`\xFF\x84\x16_\x03a\x0F\x15W`@Q\x7F\xA8c\xD6\xE4\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[`\xFD\x84`\xFF\x16\x11\x15a\x0FXW`@Q\x7F@\xD2;\xF0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\xFF\x85\x16`\x04\x82\x01R`$\x01a\x06\xB7V[`\r\x80T`\xFF\x19\x16`\xFF\x86\x16\x17\x90U\x81a\x0Fs\x85`\x02a`mV[`\xFF\x16\x14a\x0F\xC5W\x81a\x0F\x87\x85`\x02a`mV[`@Q\x7F\n\xEC\xE9\xC0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x81\x01\x92\x90\x92R`\xFF\x16`$\x82\x01R`D\x01a\x06\xB7V[a\x0F\xD1`\x07\x84\x84aT\xE5V[P\x80\x15a\x10\x17W_\x80Ta\xFF\0\x19\x16\x90U`@Q`\x01\x81R\x7F\x7F&\xB8?\xF9n\x1F+jh/\x138R\xF6y\x8A\t\xC4e\xDA\x95\x92\x14`\xCE\xFB8G@$\x98\x90` \x01`@Q\x80\x91\x03\x90\xA1[PPPPPPPPPPPPV[`\x07\x81\x81T\x81\x10a\x104W_\x80\xFD[_\x91\x82R` \x90\x91 \x01T\x90P\x81V[_a\x10P`\x01\x83a\x1E\xA7V[\x92\x91PPV[_\x80\x82`\x02\x81\x11\x15a\x10jWa\x10ja[\x03V[\x03a\x10wWPP`\nT\x90V[`\x01\x82`\x02\x81\x11\x15a\x10\x8BWa\x10\x8Ba[\x03V[\x03a\x10\x98WPP`\x0BT\x90V[`\x02\x82`\x02\x81\x11\x15a\x10\xACWa\x10\xACa[\x03V[\x03a\x10\xB9WPP`\x0CT\x90V[\x81`@Q\x7F;\xF2\xE1\xEC\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01a\x06\xB7\x91\x90a`\x86V[\x91\x90PV[_\x82\x90\x03a\x11,W`@Q\x7FR\x12\x99\xA9\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[a\x11]\x83\x83a\x11<`\x01\x82a`\x99V[\x81\x81\x10a\x11KWa\x11Ka`EV[`\x01\x92` \x90\x91\x02\x015\x90P\x83a UV[P_[\x82\x81\x10\x15a\x11\x93Wa\x11\x8B\x84\x84\x83\x81\x81\x10a\x11}Wa\x11}a`EV[\x90P` \x02\x015_\x19a\x1A\x9BV[`\x01\x01a\x11`V[PPPPV[_a\x10P`\x01\x83a \xCCV[_a\x10P`\x01\x83a \xFEV[_a\x11\xBD`\x01\x83a!MV[\x90Pa\x11\xC8\x81a!\xA0V[`\x06T`\t\x82\x01T`\x07\x80T`\x01`\x01`\xA0\x1B\x03\x90\x93\x16\x92_\x92`\x01`H\x1B\x90\x04`\xFF\x16\x90\x81\x10a\x11\xFBWa\x11\xFBa`EV[_\x91\x82R` \x90\x91 \x01T\x90P`\x01`\x01`\xA0\x1B\x03\x82\x16\x15\x80\x15\x90a\x12\x1FWP\x80\x15\x15[\x15a\x12@W`\x08\x83\x01Ta\x12@\x90`\x01`\x01`\xA0\x1B\x03\x84\x81\x16\x91\x16\x83a\"\xAAV[_\x84\x81R`\x01` R`@\x90 a\x12V\x90a\"\xF8V[`@\x80Q`\x01`\x01`\xA0\x1B\x03\x85\x16\x81R` \x81\x01\x84\x90R\x86\x91\x7F\xA659\x89Y\xDD\xB5\xCE;\x14S~\xDF\xC2[.g\x12t\xC9\xB8\xCA\xD0\xF4\xBDcGR\xE6\x90\x07\xB6\x91\x01`@Q\x80\x91\x03\x90\xA3PPPPV[_\x81\x81R`\x01` R`@\x81 `\x08\x01T`\x01`\xA0\x1B\x90\x04g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x15\x15a\x10PV[`\rT_\x90\x81\x90a\x12\xE4\x90`\x01\x90\x87\x90\x87\x90`\xFF\x16\x87a#nV[\x91P\x91P\x81\x15a\x13)W\x84\x7F\xBE\x17u]\x8D\x83j\xD6{\xFA\xF8\xE5\xB3\x86\x9A\xED\xB4\xCB\xA0?)Z\x16|UG\xFE\xDD\xD9\xEFP\xAD\x82`@Qa\x13 \x91\x81R` \x01\x90V[`@Q\x80\x91\x03\x90\xA2[PPPPPV[_a\x13<`\x01\x89a \xFEV[`\x08T`@Q\x7F\x04\x97*\xF9\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R\x91\x92P`\x01`@\x1B\x90\x04`\x01`\x01`\xA0\x1B\x03\x16\x90c\x04\x97*\xF9\x90a\x13\x8F\x90\x84\x90\x8A\x90`\x04\x01a`\xACV[_`@Q\x80\x83\x03\x81\x86\x80;\x15\x80\x15a\x13\xA5W__\xFD[PZ\xFA\x15\x80\x15a\x13\xB7W=__>=_\xFD[PPPP_`@Q\x80``\x01`@R\x80\x88`\x80\x01` \x81\x01\x90a\x13\xDA\x91\x90aa,V[g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x81R` \x01`\x08\x80T\x90a\x01\0\n\x90\x04`\x01`\x01`\xA0\x1B\x03\x16`\x01`\x01`\xA0\x1B\x03\x16c\xE7\x8C\xEA\x92`@Q\x81c\xFF\xFF\xFF\xFF\x16`\xE0\x1B\x81R`\x04\x01` `@Q\x80\x83\x03\x81\x86Z\xFA\x15\x80\x15a\x148W=__>=_\xFD[PPPP`@Q=`\x1F\x19`\x1F\x82\x01\x16\x82\x01\x80`@RP\x81\x01\x90a\x14\\\x91\x90aaGV[`\x01`\x01`\xA0\x1B\x03\x90\x81\x16\x82R\x895` \x90\x92\x01\x91\x90\x91R`\tT`\rT`\x0BT`\x0CT\x94\x95Pa\x14\xA4\x94`\x01\x94\x8F\x94\x16\x92\x8E\x92\x88\x92\x8E\x92\x8E\x92\x8E\x92\x8E\x92`\xFF\x16\x91\x90a#\xDBV[_\x89\x81R`\x01` R`@\x90 a\x14\xBA\x90a\"\xF8V[`@Q\x8A\x90\x7F\xE1\x1D\xB4\xB2{\xC8\xC6\xEAYC\xEC\xBB Z\xE1\xCA\x8DV\xC4,q\x97\x17\xAA\xF8\xA5=C\xD0\xCE\xE7\xC2\x90_\x90\xA3PPPPPPPPPV[_a\x10P`\x01\x83a'mV[_a\x15\x07`\x01\x84a!MV[\x90Pa\x15\x12\x81a(JV[a\x15tWa\x15\x1F\x81a(mV[`\x08\x82\x01T`\x07\x83\x01T`@Q\x7F\xE5\x8C\x83\x08\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x81\x01\x93\x90\x93R`\x01`\x01`\xA0\x1B\x03\x90\x91\x16`$\x83\x01R`D\x82\x01R`d\x01a\x06\xB7V[_\x80\x80`\t\x84\x01T`\rTa\x15\x96\x91`\xFF`\x01`H\x1B\x90\x91\x04\x81\x16\x91\x16a\x1C#V[`\x02\x81\x11\x15a\x15\xA7Wa\x15\xA7a[\x03V[\x14\x90P\x80\x80\x15a\x16BWP`\x08T`\x07\x84\x01T`@Q\x7F0\x83b(\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x81\x01\x91\x90\x91R`\x01`@\x1B\x90\x91\x04`\x01`\x01`\xA0\x1B\x03\x16\x90c0\x83b(\x90`$\x01` `@Q\x80\x83\x03\x81\x86Z\xFA\x15\x80\x15a\x16\x1EW=__>=_\xFD[PPPP`@Q=`\x1F\x19`\x1F\x82\x01\x16\x82\x01\x80`@RP\x81\x01\x90a\x16B\x91\x90a\\5V[\x15a\x17\xFAW`\x08T`\x07\x84\x01T`@Q\x7F\xE5\x10\x19\xA6\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x01`@\x1B\x90\x92\x04`\x01`\x01`\xA0\x1B\x03\x16\x91c\xE5\x10\x19\xA6\x91a\x16\xA7\x91\x88\x90`\xC0\x82\x015\x90`\xE0\x83\x015\x90`\x04\x01aabV[_`@Q\x80\x83\x03\x81\x86\x80;\x15\x80\x15a\x16\xBDW__\xFD[PZ\xFA\x15\x80\x15a\x16\xCFW=__>=_\xFD[PP`\x08T`@Q\x7F\x11qU\x85\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\xC0\x88\x015`\x04\x82\x01R`\x01`@\x1B\x90\x91\x04`\x01`\x01`\xA0\x1B\x03\x16\x92Pc\x11qU\x85\x91P`$\x01` `@Q\x80\x83\x03\x81\x86Z\xFA\x15\x80\x15a\x17<W=__>=_\xFD[PPPP`@Q=`\x1F\x19`\x1F\x82\x01\x16\x82\x01\x80`@RP\x81\x01\x90a\x17`\x91\x90a`*V[`\x08T`@Q\x7FV\xBB\xC9\xE6\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\xC0\x87\x015`\x04\x82\x01R`\x01`@\x1B\x90\x91\x04`\x01`\x01`\xA0\x1B\x03\x16\x90cV\xBB\xC9\xE6\x90`$\x01` `@Q\x80\x83\x03\x81\x86Z\xFA\x15\x80\x15a\x17\xC9W=__>=_\xFD[PPPP`@Q=`\x1F\x19`\x1F\x82\x01\x16\x82\x01\x80`@RP\x81\x01\x90a\x17\xED\x91\x90a`*V[a\x17\xF7\x91\x90aa\xF0V[\x91P[`\x08T_\x90a\x18\x19\x90`\x01\x90\x88\x90\x86\x90g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16a)\rV[_\x87\x81R`\x01` R`@\x90 \x90\x91Pa\x182\x90a\"\xF8V[\x86\x7F.\x08\x08\x83\n\" L\xB3\xFB\x8F\x8DxK(\xBC\x97\xE9\xCE.9\xD2\xF9\xCD\xE2\x86\r\xE0\x95}h\xEB\x83`@Qa\x18d\x91\x81R` \x01\x90V[`@Q\x80\x91\x03\x90\xA3PPPPPPV[`@\x80Q`\xF8\x87\x90\x1B`\x01`\x01`\xF8\x1B\x03\x19\x16` \x80\x83\x01\x91\x90\x91R`!\x82\x01\x87\x90R`A\x82\x01\x86\x90R`a\x82\x01\x85\x90R`\x81\x80\x83\x01\x85\x90R\x83Q\x80\x84\x03\x90\x91\x01\x81R`\xA1\x90\x92\x01\x90\x92R\x80Q\x91\x01 _\x90[\x96\x95PPPPPPV[_____a\x19\x1C\x89\x89\x89\x89\x80\x80`\x1F\x01` \x80\x91\x04\x02` \x01`@Q\x90\x81\x01`@R\x80\x93\x92\x91\x90\x81\x81R` \x01\x83\x83\x80\x82\x847_\x92\x01\x91\x90\x91RP`\x01\x95\x94\x93\x92PPa)\xF1\x90PV[\x81Q\x92\x95P\x90\x93P\x91P\x15\x80a\x19\xB3W\x82`@\x01Q\x83` \x01Q\x84_\x01Q\x7F\xAAKf\xB1\xCE\x93\x8C\x06\xE2\xA3\xF8Fk\xAE\x10\xEFb\xE7Gc\x0E8Y\x88\x9FG\x19\xFCd'\xB5\xA4\x86``\x01Q\x87`\x80\x01Q\x88`\xA0\x01Q\x89`\xC0\x01Q\x8A`\xE0\x01Q`@Qa\x19\xAA\x95\x94\x93\x92\x91\x90\x94\x85R` \x85\x01\x93\x90\x93R`\xFF\x91\x90\x91\x16`@\x84\x01R\x15\x15``\x83\x01R\x15\x15`\x80\x82\x01R`\xA0\x01\x90V[`@Q\x80\x91\x03\x90\xA4[\x81`@\x01Q\x82` \x01Q\x83_\x01Q\x7F\xAAKf\xB1\xCE\x93\x8C\x06\xE2\xA3\xF8Fk\xAE\x10\xEFb\xE7Gc\x0E8Y\x88\x9FG\x19\xFCd'\xB5\xA4\x85``\x01Q\x86`\x80\x01Q\x87`\xA0\x01Q\x88`\xC0\x01Q\x89`\xE0\x01Q`@Qa\x1A1\x95\x94\x93\x92\x91\x90\x94\x85R` \x85\x01\x93\x90\x93R`\xFF\x91\x90\x91\x16`@\x84\x01R\x15\x15``\x83\x01R\x15\x15`\x80\x82\x01R`\xA0\x01\x90V[`@Q\x80\x91\x03\x90\xA4\x81Q`@Q\x82\x15\x15\x81R\x85\x90\x8C\x90\x7Fs@Q\r$\xB7\xEC\x9B\\\x10\x0FU\0\xD94)\xD8\r\0\xD4o\r\x18\xE4\xE8]\x0CL\xC2+\x99$\x90` \x01`@Q\x80\x91\x03\x90\xA4PQ\x91\x93P\x90\x91PP[\x94P\x94\x92PPPV[_a\x10Pa\x1A\x96`\x01\x84a!MV[a.\x1BV[_\x80a\x1A\xA9`\x01\x85\x85a.^V[\x91P\x91P\x81\x15a\x11\x93W\x83\x7F\xBE\x17u]\x8D\x83j\xD6{\xFA\xF8\xE5\xB3\x86\x9A\xED\xB4\xCB\xA0?)Z\x16|UG\xFE\xDD\xD9\xEFP\xAD\x82`@Qa\x1A\xE5\x91\x81R` \x01\x90V[`@Q\x80\x91\x03\x90\xA2PPPPV[a\x1A\xFBaU.V[a\x1B\x06`\x01\x83a!MV[`@\x80Qa\x01\xE0\x81\x01\x82R\x82T\x81R`\x01\x80\x84\x01T` \x83\x01R`\x02\x84\x01T\x92\x82\x01\x92\x90\x92R`\x03\x83\x01T``\x82\x01R`\x04\x83\x01T`\x80\x82\x01R`\x05\x83\x01T`\xA0\x82\x01R`\x06\x83\x01T`\xC0\x82\x01R`\x07\x83\x01T`\xE0\x82\x01R`\x08\x83\x01T`\x01`\x01`\xA0\x1B\x03\x81\x16a\x01\0\x83\x01R`\x01`\xA0\x1B\x90\x04g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x90\x81\x16a\x01 \x83\x01R`\t\x84\x01T\x90\x81\x16a\x01@\x83\x01R\x90\x92\x91a\x01`\x84\x01\x91`\x01`@\x1B\x90\x04`\xFF\x16\x90\x81\x11\x15a\x1B\xBDWa\x1B\xBDa[\x03V[`\x01\x81\x11\x15a\x1B\xCEWa\x1B\xCEa[\x03V[\x81R`\t\x91\x90\x91\x01T`\xFF`\x01`H\x1B\x82\x04\x81\x16` \x84\x01Rj\x01\0\0\0\0\0\0\0\0\0\0\x82\x04\x16\x15\x15`@\x83\x01Rg\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFFk\x01\0\0\0\0\0\0\0\0\0\0\0\x90\x91\x04\x16``\x90\x91\x01R\x92\x91PPV[_\x82`\xFF\x16_\x03a\x1C5WP_a\x10PV[\x81`\xFF\x16\x83`\xFF\x16\x11a\x1CJWP`\x01a\x10PV[a\x1CU\x82`\x01a`mV[`\xFF\x16\x83`\xFF\x16\x03a\x1CiWP`\x02a\x10PV[`@Q\x7F\xAE\r\xA5x\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\xFF\x80\x85\x16`\x04\x83\x01R\x83\x16`$\x82\x01R`D\x01a\x06\xB7V[a\x1C\xEF`@Q\x80a\x01\0\x01`@R\x80_\x81R` \x01_\x81R` \x01_\x81R` \x01_\x81R` \x01_\x81R` \x01_`\xFF\x16\x81R` \x01_\x15\x15\x81R` \x01_\x15\x15\x81RP\x90V[__a\x1C\xFE\x8A\x8A\x8A\x8A\x89a.\x82V[\x91P\x91P_a\x1D\x0E\x83\x8B\x89a3\xD7V[\x90P_a\x1D\x1C\x83\x83\x8Da5\x19V[\x90P\x85\x15a\x1D\xB6W_a\x1D.\x82a5KV[3_\x90\x81R`\x03\x8F\x01` \x90\x81R`@\x80\x83 \x84\x84R\x90\x91R\x90 T\x90\x91P`\xFF\x16\x15a\x1D\x90W`@Q\x7FZF\xAC:\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R3`\x04\x82\x01R`$\x81\x01\x82\x90R`D\x01a\x06\xB7V[3_\x90\x81R`\x03\x8E\x01` \x90\x81R`@\x80\x83 \x93\x83R\x92\x90R \x80T`\xFF\x19\x16`\x01\x17\x90U[a\x1D\xC0\x8C\x82a5\xB8V[\x9C\x9BPPPPPPPPPPPPV[`@Q`\x01`\x01`\xA0\x1B\x03\x80\x85\x16`$\x83\x01R\x83\x16`D\x82\x01R`d\x81\x01\x82\x90Ra\x11\x93\x90\x85\x90\x7F#\xB8r\xDD\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x90`\x84\x01[`@\x80Q`\x1F\x19\x81\x84\x03\x01\x81R\x91\x90R` \x81\x01\x80Q{\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x7F\xFF\xFF\xFF\xFF\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x90\x93\x16\x92\x90\x92\x17\x90\x91Ra9\x9BV[_\x81_\x03a\x1E\x90WP_\x91\x90PV[_a\x1E\x9C`\x01\x84a`\x99V[\x92\x90\x92\x16\x15\x92\x91PPV[_\x81\x81R` \x83\x90R`@\x81 `\x08\x01T`\x01`\xA0\x1B\x90\x04g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16a\x1E\xE8W`@Qb\xA7\xB0+`\xE0\x1B\x81R`\x04\x81\x01\x83\x90R`$\x01a\x06\xB7V[_\x82\x81R` \x84\x90R`@\x81 a\x1E\xFE\x90a\"\xF8V[_\x81\x81R`\x01\x86\x01` R`@\x81 T\x91\x92P\x81\x90\x03a\x1FJW`@Q\x7F\xDA\x10\xF6|\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[`@Qh\x15S\x94\x92U\x90S\x11Q`\xBA\x1B` \x82\x01R`)\x01`@Q` \x81\x83\x03\x03\x81R\x90`@R\x80Q\x90` \x01 \x81\x03a\x1F\xB3W_\x84\x81R` \x86\x90R`@\x90 `\x08\x01Ta\x1F\xAA\x90`\x01`\xA0\x1B\x90\x04g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16Ca`\x99V[\x92PPPa\x10PV[_\x81\x81R` \x86\x90R`@\x90 `\x08\x01T`\x01`\xA0\x1B\x90\x04g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16a\x1F\xF4W`@Qb\xA7\xB0+`\xE0\x1B\x81R`\x04\x81\x01\x82\x90R`$\x01a\x06\xB7V[_\x81\x81R` \x86\x90R`@\x80\x82 `\x08\x90\x81\x01T\x87\x84R\x91\x90\x92 \x90\x91\x01Tg\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF`\x01`\xA0\x1B\x92\x83\x90\x04\x81\x16\x92\x90\x91\x04\x16\x80\x82\x11\x15a IWa >\x81\x83a`\x99V[\x94PPPPPa\x10PV[_\x94PPPPPa\x10PV[_\x82\x81R` \x84\x90R`@\x81 `\t\x01Tk\x01\0\0\0\0\0\0\0\0\0\0\0\x90\x04g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x82\x81\x10a \xC2W`@Q\x7F\xD1\xF5\x92\x81\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x81\x01\x82\x90R`$\x81\x01\x84\x90R`D\x01a\x06\xB7V[\x90P[\x93\x92PPPV[_a \xD7\x83\x83a'mV[\x80\x15a \xC5WP_\x82\x81R` \x84\x90R`@\x90 a \xF4\x90a.\x1BV[`\x01\x14\x93\x92PPPV[__a!\n\x84\x84a!MV[\x90P[`\t\x81\x01T`\x01`H\x1B\x90\x04`\xFF\x16\x15a!EW\x80T_\x90\x81R`\x01\x85\x01` R`@\x90 Ta!=\x85\x82a!MV[\x91PPa!\rV[T\x93\x92PPPV[_\x81\x81R` \x83\x90R`@\x81 `\x08\x01T`\x01`\xA0\x1B\x90\x04g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16a!\x8EW`@Qb\xA7\xB0+`\xE0\x1B\x81R`\x04\x81\x01\x83\x90R`$\x01a\x06\xB7V[P_\x90\x81R` \x91\x90\x91R`@\x90 \x90V[`\x01`\t\x82\x01T`\x01`@\x1B\x90\x04`\xFF\x16`\x01\x81\x11\x15a!\xC2Wa!\xC2a[\x03V[\x14a\"\x13Wa!\xD0\x81a(mV[`\t\x82\x01T`@Q\x7F\xEF\x12g\xB4\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81Ra\x06\xB7\x92\x91`\x01`@\x1B\x90\x04`\xFF\x16\x90`\x04\x01ab\x10V[a\"\x1C\x81a(JV[a\")Wa\x15\x1F\x81a(mV[`\t\x81\x01Tj\x01\0\0\0\0\0\0\0\0\0\0\x90\x04`\xFF\x16\x15\x15`\x01\x03a\"\x86Wa\"Q\x81a(mV[`@Q\x7F0\x7Fvi\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01a\x06\xB7\x91\x81R` \x01\x90V[`\t\x01\x80Tj\xFF\0\0\0\0\0\0\0\0\0\0\x19\x16j\x01\0\0\0\0\0\0\0\0\0\0\x17\x90UV[`@Q`\x01`\x01`\xA0\x1B\x03\x83\x16`$\x82\x01R`D\x81\x01\x82\x90Ra\"\xF3\x90\x84\x90\x7F\xA9\x05\x9C\xBB\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x90`d\x01a\x1E\x1DV[PPPV[`\t\x81\x01T\x81T`\x02\x83\x01T`\x01\x84\x01T`\x04\x85\x01T`@\x80Q`\x01`H\x1B\x90\x96\x04`\xF8\x1B`\x01`\x01`\xF8\x1B\x03\x19\x16` \x80\x88\x01\x91\x90\x91R`!\x87\x01\x95\x90\x95R`A\x86\x01\x93\x90\x93R`a\x85\x01\x91\x90\x91R`\x81\x80\x85\x01\x91\x90\x91R\x81Q\x80\x85\x03\x90\x91\x01\x81R`\xA1\x90\x93\x01\x90R\x81Q\x91\x01 _\x90a\x10PV[___a#{\x88\x88a\x1E\xA7V[\x90Pa#\x89\x88\x88\x88\x88a:\x7FV[_\x86\x81R` \x89\x90R`@\x90 `\t\x01Ta#\xBD\x90k\x01\0\0\0\0\0\0\0\0\0\0\0\x90\x04g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x82ab$V[\x90Pa#\xCB\x88\x88\x83\x87a<9V[\x92P\x92PP[\x95P\x95\x93PPPPV[_\x8B\x81R` \x8D\x90R`@\x90 `\x08\x01T`\x01`\xA0\x1B\x90\x04g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16a$\x1CW`@Qb\xA7\xB0+`\xE0\x1B\x81R`\x04\x81\x01\x8C\x90R`$\x01a\x06\xB7V[`\x02_\x8C\x81R` \x8E\x90R`@\x90 `\t\x01Ta$C\x90`\x01`H\x1B\x90\x04`\xFF\x16\x85a\x1C#V[`\x02\x81\x11\x15a$TWa$Ta[\x03V[\x14a$\xA9W_\x8B\x81R` \x8D\x90R`@\x90\x81\x90 `\t\x01T\x90Q\x7F4\x8A\xEF\xDF\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x01`H\x1B\x90\x91\x04`\xFF\x16`\x04\x82\x01R`$\x01a\x06\xB7V[_\x8B\x81R` \x8D\x90R`@\x90 a$\xBF\x90a.\x1BV[`\x01\x14a%\x11W_\x8B\x81R` \x8D\x90R`@\x90 a$\xDC\x90a.\x1BV[`@Q\x7FkY^P\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01a\x06\xB7\x91\x81R` \x01\x90V[_\x8B\x81R` \x8D\x90R`@\x90 `\x02\x01T\x8B\x82[`\x01\x8F_\x01_\x84\x81R` \x01\x90\x81R` \x01_ `\t\x01`\t\x90T\x90a\x01\0\n\x90\x04`\xFF\x16`\xFF\x16\x11\x15a%\xC0W_\x8F_\x01_\x84\x81R` \x01\x90\x81R` \x01_ _\x01T\x90P\x8F`\x01\x01_\x82\x81R` \x01\x90\x81R` \x01_ T\x92P\x8F_\x01_\x84\x81R` \x01\x90\x81R` \x01_ `\x02\x01T\x82a%\xA2\x91\x90ab7V[a%\xAC\x90\x85ab$V[\x93Pa%\xB8\x86\x83ab7V[\x91PPa%%V[PPa&\x18\x8D_\x01_\x8E\x81R` \x01\x90\x81R` \x01_ `\x01\x01T\x8B_\x015\x83\x8B\x8B\x80\x80` \x02` \x01`@Q\x90\x81\x01`@R\x80\x93\x92\x91\x90\x81\x81R` \x01\x83\x83` \x02\x80\x82\x847_\x92\x01\x91\x90\x91RPa<\xCE\x92PPPV[_\x8B`\x01`\x01`\xA0\x1B\x03\x16c\xB5\x11/\xD2\x8B\x84\x8E_\x015\x8F\x80` \x01\x90a&>\x91\x90a\\mV[`@Q\x86c\xFF\xFF\xFF\xFF\x16`\xE0\x1B\x81R`\x04\x01a&^\x95\x94\x93\x92\x91\x90abNV[` `@Q\x80\x83\x03\x81\x86Z\xFA\x15\x80\x15a&yW=__>=_\xFD[PPPP`@Q=`\x1F\x19`\x1F\x82\x01\x16\x82\x01\x80`@RP\x81\x01\x90a&\x9D\x91\x90ab\xAFV[\x90Pa&\xFE\x8E_\x01_\x8F\x81R` \x01\x90\x81R` \x01_ `\x03\x01T\x82\x84`\x01a&\xC6\x91\x90ab$V[\x8A\x8A\x80\x80` \x02` \x01`@Q\x90\x81\x01`@R\x80\x93\x92\x91\x90\x81\x81R` \x01\x83\x83` \x02\x80\x82\x847_\x92\x01\x91\x90\x91RPa<\xCE\x92PPPV[_\x8D\x81R` \x8F\x90R`@\x90 a'\x14\x90a=SV[a'\x1E\x8E\x8Ea=\xEEV[PPP_\x99\x8ARPPP` \x97\x90\x97RPP`@\x90\x93 `\t\x01\x80Tr\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\0\0\0\0\0\0\0\0\0\0\0\x19\x16r\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\0\0\0\0\0\0\0\0\0\0\0\x17\x90UPPPPV[_\x81\x81R` \x83\x90R`@\x81 `\x08\x01T`\x01`\xA0\x1B\x90\x04g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16a'\xAEW`@Qb\xA7\xB0+`\xE0\x1B\x81R`\x04\x81\x01\x83\x90R`$\x01a\x06\xB7V[_\x82\x81R` \x84\x90R`@\x81 a'\xC4\x90a\"\xF8V[_\x81\x81R`\x01\x86\x01` R`@\x81 T\x91\x92P\x81\x90\x03a(\x10W`@Q\x7F\xDA\x10\xF6|\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[`@Qh\x15S\x94\x92U\x90S\x11Q`\xBA\x1B` \x82\x01R`)\x01`@\x80Q`\x1F\x19\x81\x84\x03\x01\x81R\x91\x90R\x80Q` \x90\x91\x01 \x14\x15\x94\x93PPPPV[`\x07\x81\x01T_\x90\x15\x80\x15\x90a\x10PWPP`\x08\x01T`\x01`\x01`\xA0\x1B\x03\x16\x15\x15\x90V[`\t\x81\x01T\x81T`\x02\x83\x01T`\x01\x84\x01T`\x04\x85\x01T`\x03\x86\x01T`@\x80Q`\x01`H\x1B\x90\x97\x04`\xF8\x1B`\x01`\x01`\xF8\x1B\x03\x19\x16` \x80\x89\x01\x91\x90\x91R`!\x88\x01\x96\x90\x96R`A\x87\x01\x94\x90\x94R`a\x86\x01\x92\x90\x92R`\x81\x80\x86\x01\x91\x90\x91R\x82Q\x80\x86\x03\x90\x91\x01\x81R`\xA1\x85\x01\x83R\x80Q\x90\x84\x01 `\xC1\x85\x01R`\xE1\x80\x85\x01\x91\x90\x91R\x81Q\x80\x85\x03\x90\x91\x01\x81Ra\x01\x01\x90\x93\x01\x90R\x81Q\x91\x01 _\x90a\x10PV[_\x83\x81R` \x85\x90R`@\x81 `\x08\x01T`\x01`\xA0\x1B\x90\x04g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16a)NW`@Qb\xA7\xB0+`\xE0\x1B\x81R`\x04\x81\x01\x85\x90R`$\x01a\x06\xB7V[_a)Y\x86\x86a>nV[\x90Pa)og\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x85\x16\x82ab$V[\x90P\x82g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x81\x10\x15a)\xC8W`@Q\x7F\x11\xA8\xD4\xD0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x81\x01\x82\x90Rg\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x84\x16`$\x82\x01R`D\x01a\x06\xB7V[_\x85\x81R` \x87\x90R`@\x90 a)\xDE\x90a=SV[a)\xE8\x86\x86a=\xEEV[\x95\x94PPPPPV[`@\x80Qa\x01\0\x81\x01\x82R_\x80\x82R` \x82\x01\x81\x90R\x91\x81\x01\x82\x90R``\x81\x01\x82\x90R`\x80\x81\x01\x82\x90R`\xA0\x81\x01\x82\x90R`\xC0\x81\x01\x82\x90R`\xE0\x81\x01\x82\x90Ra*w`@Q\x80a\x01\0\x01`@R\x80_\x81R` \x01_\x81R` \x01_\x81R` \x01_\x81R` \x01_\x81R` \x01_`\xFF\x16\x81R` \x01_\x15\x15\x81R` \x01_\x15\x15\x81RP\x90V[__\x87\x81R` \x89\x90R`@\x90 `\t\x01T`\x01`@\x1B\x90\x04`\xFF\x16`\x01\x81\x11\x15a*\xA4Wa*\xA4a[\x03V[\x14a*\xFBW_\x86\x81R` \x88\x90R`@\x90\x81\x90 `\t\x01T\x90Q\x7F#\xF8@]\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81Ra\x06\xB7\x91\x88\x91`\x01`@\x1B\x90\x91\x04`\xFF\x16\x90`\x04\x01ab\x10V[a+\x05\x87\x87a'mV[a+>W`@Q\x7F\x80\xE0~E\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x81\x01\x87\x90R`$\x01a\x06\xB7V[_\x86\x81R` \x88\x90R`@\x81 `@\x80Qa\x01\xE0\x81\x01\x82R\x82T\x81R`\x01\x80\x84\x01T` \x83\x01R`\x02\x84\x01T\x92\x82\x01\x92\x90\x92R`\x03\x83\x01T``\x82\x01R`\x04\x83\x01T`\x80\x82\x01R`\x05\x83\x01T`\xA0\x82\x01R`\x06\x83\x01T`\xC0\x82\x01R`\x07\x83\x01T`\xE0\x82\x01R`\x08\x83\x01T`\x01`\x01`\xA0\x1B\x03\x81\x16a\x01\0\x83\x01R`\x01`\xA0\x1B\x90\x04g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x90\x81\x16a\x01 \x83\x01R`\t\x84\x01T\x90\x81\x16a\x01@\x83\x01R\x90\x92\x91a\x01`\x84\x01\x91`\x01`@\x1B\x90\x04`\xFF\x16\x90\x81\x11\x15a,\x02Wa,\x02a[\x03V[`\x01\x81\x11\x15a,\x13Wa,\x13a[\x03V[\x81R`\t\x91\x90\x91\x01T`\x01`H\x1B\x81\x04`\xFF\x90\x81\x16` \x84\x01Rj\x01\0\0\0\0\0\0\0\0\0\0\x82\x04\x16\x15\x15`@\x80\x84\x01\x91\x90\x91Rk\x01\0\0\0\0\0\0\0\0\0\0\0\x90\x91\x04g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16``\x90\x92\x01\x91\x90\x91R\x81\x01Q`\x80\x82\x01Q\x91\x92P_\x91a,\x81\x91\x90a>\xF9V[\x90P__\x87\x80` \x01\x90Q\x81\x01\x90a,\x99\x91\x90ac!V[\x90\x92P\x90Pa,\xC9\x89a,\xAD\x85`\x01ab$V[``\x87\x01Q`\x80\x88\x01Qa,\xC2\x90`\x01ab$V[\x86\x86a?\xA2V[PP`@\x80Qa\x01\0\x81\x01\x82R_\x80\x82R` \x82\x01\x81\x90R\x91\x81\x01\x82\x90R``\x81\x01\x82\x90R`\x80\x81\x01\x82\x90R`\xA0\x81\x01\x82\x90R`\xC0\x81\x01\x82\x90R`\xE0\x81\x01\x82\x90R_a-)\x85_\x01Q\x86` \x01Q\x87`@\x01Q\x8D\x88\x8Aa\x01\x80\x01QaB\xC3V[\x90Pa-4\x81aC[V[_\x81\x81R` \x8E\x90R`@\x90 `\x08\x01T\x90\x93P`\x01`\xA0\x1B\x90\x04g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16a-jWa-g\x8C\x82a5\xB8V[\x91P[Pa-\xB2`@Q\x80a\x01\0\x01`@R\x80_\x81R` \x01_\x81R` \x01_\x81R` \x01_\x81R` \x01_\x81R` \x01_`\xFF\x16\x81R` \x01_\x15\x15\x81R` \x01_\x15\x15\x81RP\x90V[_a-\xD1\x86_\x01Q\x8C\x87\x89``\x01Q\x8A`\x80\x01Q\x8Ba\x01\x80\x01QaB\xC3V[\x90Pa-\xDD\x8D\x82a5\xB8V[\x91PPa.\t\x83\x82_\x01Q\x8E_\x01_\x8F\x81R` \x01\x90\x81R` \x01_ aC\xF2\x90\x92\x91\x90c\xFF\xFF\xFF\xFF\x16V[\x91\x9B\x90\x9AP\x90\x98P\x96PPPPPPPV[__\x82`\x02\x01T\x83`\x04\x01Ta.1\x91\x90a`\x99V[\x90P\x80_\x03a\x10PWa.C\x83a(mV[`@Qb\xA7\xB0+`\xE0\x1B\x81R`\x04\x01a\x06\xB7\x91\x81R` \x01\x90V[__a.u\x85\x85a.o\x88\x88a>nV[\x86a<9V[\x91P\x91P[\x93P\x93\x91PPV[a.\xA4`@Q\x80``\x01`@R\x80_\x81R` \x01_\x81R` \x01``\x81RP\x90V[_\x80a.\xBCa.\xB6` \x89\x01\x89a\\TV[\x85a\x1C#V[`\x02\x81\x11\x15a.\xCDWa.\xCDa[\x03V[\x03a1\xE1W` \x85\x01Q\x85Q_\x03a/\x11W`@Q\x7F\xE9k\xC6\x1A\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[\x85Q``\x88\x015\x14a/_W\x85Q`@Q\x7F[\x17z<\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x81\x01\x91\x90\x91R``\x88\x015`$\x82\x01R`D\x01a\x06\xB7V[\x85`@\x01Qa/\x9AW`@Q\x7F\xC1i$6\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[\x85``\x01Qa/\xD5W`@Q\x7F\xB4]\x1C:\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[a/\xE2`\xA0\x88\x01\x88a\\mV[\x90P_\x03a0\x03W`@Qc\x0C\x9C\xCA\xC5`\xE4\x1B\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[_a0\x11`\xA0\x89\x01\x89a\\mV[\x81\x01\x90a0\x1E\x91\x90a_\x15V[P\x90\x91P_\x90P\x87`\x80\x01Q` \x01Q`\x02\x81\x11\x15a0?Wa0?a[\x03V[\x03a0vW`@Q\x7FF6^R\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[_\x87`\xA0\x01Q` \x01Q`\x02\x81\x11\x15a0\x91Wa0\x91a[\x03V[\x03a0\xC8W`@Q\x7F\x89\x99\x85}\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[_\x86`\x01`\x01`\xA0\x1B\x03\x16c\xC3\x96\x19\xC4a0\xE5\x8A`\x80\x01QaDrV[`@Q\x82c\xFF\xFF\xFF\xFF\x16`\xE0\x1B\x81R`\x04\x01a1\x01\x91\x90ac\x86V[` `@Q\x80\x83\x03\x81\x86Z\xFA\x15\x80\x15a1\x1CW=__>=_\xFD[PPPP`@Q=`\x1F\x19`\x1F\x82\x01\x16\x82\x01\x80`@RP\x81\x01\x90a1@\x91\x90ab\xAFV[\x90P_\x87`\x01`\x01`\xA0\x1B\x03\x16c\xC3\x96\x19\xC4a1_\x8B`\xA0\x01QaDrV[`@Q\x82c\xFF\xFF\xFF\xFF\x16`\xE0\x1B\x81R`\x04\x01a1{\x91\x90ac\x86V[` `@Q\x80\x83\x03\x81\x86Z\xFA\x15\x80\x15a1\x96W=__>=_\xFD[PPPP`@Q=`\x1F\x19`\x1F\x82\x01\x16\x82\x01\x80`@RP\x81\x01\x90a1\xBA\x91\x90ab\xAFV[`@\x80Q``\x81\x01\x82R\x93\x84R` \x84\x01\x91\x90\x91R\x82\x01\x92\x90\x92R\x93P\x90\x91Pa#\xD1\x90PV[a1\xEF\x87\x87``\x015a \xCCV[a2+W`@Q\x7F\xFFm\x9B\xD7\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R``\x87\x015`\x04\x82\x01R`$\x01a\x06\xB7V[``\x86\x015_\x90\x81R` \x88\x90R`@\x81 \x90a2G\x82a\"\xF8V[\x90P_`\t\x83\x01T`\x01`@\x1B\x90\x04`\xFF\x16`\x01\x81\x11\x15a2jWa2ja[\x03V[\x14a2\xA1W`@Q\x7F\x12E\x9F\xFD\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[`\t\x82\x01Ta2\xBA\x90`\x01`H\x1B\x90\x04`\xFF\x16\x86aD\xACV[`\xFF\x16a2\xCA` \x8A\x01\x8Aa\\TV[`\xFF\x16\x14a3,Wa2\xDF` \x89\x01\x89a\\TV[`\t\x83\x01T`@Q\x7F\xAC\x9Ea\x16\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\xFF\x92\x83\x16`\x04\x82\x01R`\x01`H\x1B\x90\x91\x04\x90\x91\x16`$\x82\x01R`D\x01a\x06\xB7V[a39`\xA0\x89\x01\x89a\\mV[\x90P_\x03a3ZW`@Qc\x0C\x9C\xCA\xC5`\xE4\x1B\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[_\x80\x80\x80\x80a3l`\xA0\x8E\x01\x8Ea\\mV[\x81\x01\x90a3y\x91\x90ac\xB3V[\x94P\x94P\x94P\x94P\x94Pa3\x97\x87`\x01\x01T\x86\x89`\x02\x01T\x86a<\xCEV[a3\xAB\x87`\x03\x01T\x85\x89`\x04\x01T\x85a<\xCEV[`@Q\x80``\x01`@R\x80\x86\x81R` \x01\x85\x81R` \x01\x82\x81RP\x86\x98P\x98PPPPPPPPa#\xD1V[`@\x80Q_\x80\x82R` \x82\x01\x90\x92R\x81\x90a3\xFC\x90a3\xF7\x90\x87QaD\xCDV[aE\x02V[\x90Pa4\x07\x83a\x1E\x81V[a4'W`@Qc:\xBF\xB6\xFF`\xE2\x1B\x81R`\x04\x81\x01\x84\x90R`$\x01a\x06\xB7V[\x82\x84`@\x015\x14a4qW`@\x80Q\x7F\xDF\xCCb\xBC\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R\x90\x85\x015`\x04\x82\x01R`$\x81\x01\x84\x90R`D\x01a\x06\xB7V[a4\x8D\x84` \x015\x86` \x01Q\x86`@\x015\x88`@\x01Qa<\xCEV[a4\x9A`\x80\x85\x01\x85a\\mV[\x90P_\x03a4\xD4W`@Q\x7F4*\x07R\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[_\x80a4\xE3`\x80\x87\x01\x87a\\mV[\x81\x01\x90a4\xF0\x91\x90adTV[\x90\x92P\x90Pa5\x0E\x83`\x01` \x89\x015a,\xC2`@\x8B\x015\x83ab$V[P\x90\x95\x94PPPPPV[a5!aU.V[a \xC2\x84\x84_` \x86\x01\x805\x90`@\x88\x015\x90``\x89\x015\x903\x90a5F\x90\x8Ba\\TV[aF\x92V[a\x01\x80\x81\x01Q\x81Q`@\x80\x84\x01Q` \x80\x86\x01Q`\x80\x87\x01Q\x84Q`\xF8\x97\x90\x97\x1B`\x01`\x01`\xF8\x1B\x03\x19\x16\x87\x84\x01R`!\x87\x01\x95\x90\x95R`A\x86\x01\x92\x90\x92R`a\x85\x01\x91\x90\x91R`\x81\x80\x85\x01\x93\x90\x93R\x81Q\x80\x85\x03\x90\x93\x01\x83R`\xA1\x90\x93\x01\x90R\x80Q\x91\x01 _\x90a\x10PV[a5\xFF`@Q\x80a\x01\0\x01`@R\x80_\x81R` \x01_\x81R` \x01_\x81R` \x01_\x81R` \x01_\x81R` \x01_`\xFF\x16\x81R` \x01_\x15\x15\x81R` \x01_\x15\x15\x81RP\x90V[_a6\t\x83aC[V[_\x81\x81R` \x86\x90R`@\x90 `\x08\x01T\x90\x91P`\x01`\xA0\x1B\x90\x04g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x15a6hW`@Q\x7F\xBC\xED\xF3\xDE\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x81\x01\x82\x90R`$\x01a\x06\xB7V[_\x81\x81R` \x85\x81R`@\x91\x82\x90 \x85Q\x81U\x90\x85\x01Q`\x01\x80\x83\x01\x91\x90\x91U\x91\x85\x01Q`\x02\x82\x01U``\x85\x01Q`\x03\x82\x01U`\x80\x85\x01Q`\x04\x82\x01U`\xA0\x85\x01Q`\x05\x82\x01U`\xC0\x85\x01Q`\x06\x82\x01U`\xE0\x85\x01Q`\x07\x82\x01Ua\x01\0\x85\x01Q`\x08\x82\x01\x80Ta\x01 \x88\x01Qg\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x90\x81\x16`\x01`\xA0\x1B\x02\x7F\xFF\xFF\xFF\xFF\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x90\x92\x16`\x01`\x01`\xA0\x1B\x03\x90\x94\x16\x93\x90\x93\x17\x17\x90Ua\x01@\x86\x01Q`\t\x83\x01\x80T\x91\x90\x92\x16g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x19\x82\x16\x81\x17\x83Ua\x01`\x88\x01Q\x88\x95\x90\x93\x92h\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x19\x16\x90\x91\x17\x90`\x01`@\x1B\x90\x84\x90\x81\x11\x15a7oWa7oa[\x03V[\x02\x17\x90UPa\x01\x80\x82\x81\x01Q`\t\x92\x90\x92\x01\x80Ta\x01\xA0\x85\x01Qa\x01\xC0\x90\x95\x01Qg\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16k\x01\0\0\0\0\0\0\0\0\0\0\0\x02r\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\0\0\0\0\0\0\0\0\0\0\0\x19\x95\x15\x15j\x01\0\0\0\0\0\0\0\0\0\0\x02j\xFF\0\0\0\0\0\0\0\0\0\0\x19`\xFF\x90\x96\x16`\x01`H\x1B\x02\x95\x90\x95\x16\x7F\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\0\0\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x90\x92\x16\x91\x90\x91\x17\x93\x90\x93\x17\x93\x90\x93\x16\x91\x90\x91\x17\x90\x91U\x83\x01Q\x83Q`@\x80\x86\x01Q` \x80\x88\x01Q`\x80\x89\x01Q\x84Q`\x01`\x01`\xF8\x1B\x03\x19`\xF8\x98\x90\x98\x1B\x97\x90\x97\x16\x87\x84\x01R`!\x87\x01\x95\x90\x95R`A\x86\x01\x92\x90\x92R`a\x85\x01\x91\x90\x91R`\x81\x80\x85\x01\x93\x90\x93R\x81Q\x80\x85\x03\x90\x93\x01\x83R`\xA1\x90\x93\x01\x90R\x80Q\x91\x01 _\x90_\x81\x81R`\x01\x87\x01` R`@\x81 T\x91\x92P\x81\x90\x03a8\xE5W`@Qh\x15S\x94\x92U\x90S\x11Q`\xBA\x1B` \x82\x01R`)\x01`@\x80Q`\x1F\x19\x81\x84\x03\x01\x81R\x91\x81R\x81Q` \x92\x83\x01 _\x85\x81R`\x01\x8A\x01\x90\x93R\x91 Ua9,V[`@Qh\x15S\x94\x92U\x90S\x11Q`\xBA\x1B` \x82\x01R`)\x01`@Q` \x81\x83\x03\x03\x81R\x90`@R\x80Q\x90` \x01 \x81\x03a9,W_\x82\x81R`\x01\x87\x01` R`@\x90 \x83\x90U[`@\x80Qa\x01\0\x81\x01\x82R\x84\x81R` \x80\x82\x01\x85\x90R\x87Q\x82\x84\x01R`\xE0\x88\x01Q``\x83\x01R_\x86\x81R\x90\x89\x90R\x91\x90\x91 `\x80\x82\x01\x90a9l\x90a.\x1BV[\x81Ra\x01\x80\x87\x01Q`\xFF\x16` \x82\x01R\x91\x15\x15`@\x83\x01R`\xE0\x90\x95\x01Q\x15\x15``\x90\x91\x01RP\x91\x93\x92PPPV[_a9\xEF\x82`@Q\x80`@\x01`@R\x80` \x81R` \x01\x7FSafeERC20: low-level call failed\x81RP\x85`\x01`\x01`\xA0\x1B\x03\x16aG\xC9\x90\x92\x91\x90c\xFF\xFF\xFF\xFF\x16V[\x80Q\x90\x91P\x15a\"\xF3W\x80\x80` \x01\x90Q\x81\x01\x90a:\r\x91\x90a\\5V[a\"\xF3W`@QbF\x1B\xCD`\xE5\x1B\x81R` `\x04\x82\x01R`*`$\x82\x01R\x7FSafeERC20: ERC20 operation did n`D\x82\x01R\x7Fot succeed\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0`d\x82\x01R`\x84\x01a\x06\xB7V[_\x82\x81R` \x85\x90R`@\x90 `\x07\x01T\x83\x14a:\xE5W_\x82\x81R` \x85\x90R`@\x90\x81\x90 `\x07\x01T\x90Q\x7F\xC2\xAD\xC3\xE8\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81Ra\x06\xB7\x91\x85\x91`\x04\x01\x91\x82R` \x82\x01R`@\x01\x90V[_\x82\x81R` \x85\x90R`@\x80\x82 T\x85\x83R\x91 a;\x02\x90a\"\xF8V[\x14a;gW_\x83\x81R` \x85\x90R`@\x90 a;\x1D\x90a\"\xF8V[_\x83\x81R` \x86\x90R`@\x90\x81\x90 T\x90Q\x7F\xE2\xE2\x7F\x87\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x81\x01\x92\x90\x92R`$\x82\x01R`D\x01a\x06\xB7V[_\x82\x81R` \x85\x90R`@\x80\x82 `\t\x90\x81\x01T\x86\x84R\x91\x90\x92 \x90\x91\x01T`\xFF`\x01`H\x1B\x92\x83\x90\x04\x81\x16\x92a;\xA0\x92\x04\x16\x83aD\xACV[`\xFF\x16\x14a\x11\x93W_\x83\x81R` \x85\x90R`@\x90 `\t\x01T\x83\x90\x83\x90a;\xD1\x90`\x01`H\x1B\x90\x04`\xFF\x16\x84aD\xACV[_\x85\x81R` \x88\x90R`@\x90\x81\x90 `\t\x01T\x90Q\x7F~rm\x15\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x81\x01\x94\x90\x94R`$\x84\x01\x92\x90\x92R`\xFF\x90\x81\x16`D\x84\x01R`\x01`H\x1B\x90\x91\x04\x16`d\x82\x01R`\x84\x01a\x06\xB7V[___a<G\x87\x87\x86a UV[\x90Pg\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x85\x11a<^W\x84a<hV[g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF[\x94P\x80\x85\x11\x15a<\xC1WPPP_\x83\x81R` \x85\x90R`@\x90 `\t\x01\x80Tr\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\0\0\0\0\0\0\0\0\0\0\0\x19\x16k\x01\0\0\0\0\0\0\0\0\0\0\0g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x85\x16\x02\x17\x90U`\x01\x82a\x1A~V[_\x97\x90\x96P\x94PPPPPV[_a=\x02\x82\x84\x86`@Q` \x01a<\xE7\x91\x81R` \x01\x90V[`@Q` \x81\x83\x03\x03\x81R\x90`@R\x80Q\x90` \x01 aG\xD7V[\x90P\x80\x85\x14a\x13)W`@QbF\x1B\xCD`\xE5\x1B\x81R` `\x04\x82\x01R`\x17`$\x82\x01R\x7FInvalid inclusion proof\0\0\0\0\0\0\0\0\0`D\x82\x01R`d\x01a\x06\xB7V[_`\t\x82\x01T`\x01`@\x1B\x90\x04`\xFF\x16`\x01\x81\x11\x15a=tWa=ta[\x03V[\x14a=\xC5Wa=\x82\x81a(mV[`\t\x82\x01T`@Q\x7F#\xF8@]\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81Ra\x06\xB7\x92\x91`\x01`@\x1B\x90\x04`\xFF\x16\x90`\x04\x01ab\x10V[`\t\x01\x80Tg\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFFC\x16h\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x19\x90\x91\x16\x17`\x01`@\x1B\x17\x90UV[_\x81\x81R` \x83\x90R`@\x81 a>\x04\x90a\"\xF8V[_\x81\x81R`\x02\x85\x01` R`@\x90 T\x90\x91P\x80\x15a>YW`@Q\x7F\xDDp(\xF0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x81\x01\x84\x90R`$\x81\x01\x82\x90R`D\x01a\x06\xB7V[P_\x90\x81R`\x02\x90\x92\x01` R`@\x90\x91 UV[__a>z\x84\x84a\x1E\xA7V[_\x84\x81R` \x86\x90R`@\x90 `\x05\x01T\x90\x91P\x15a \xC5W_\x83\x81R` \x85\x90R`@\x80\x82 `\x05\x81\x01T\x83R\x81\x83 `\t\x90\x81\x01T`\x06\x90\x92\x01T\x84R\x91\x90\x92 \x01Tg\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFFk\x01\0\0\0\0\0\0\0\0\0\0\0\x92\x83\x90\x04\x81\x16\x92\x90\x91\x04\x16\x80\x82\x10a>\xEDW\x80a>\xEFV[\x81[a\x18\xC7\x90\x84ab$V[_`\x02a?\x06\x84\x84a`\x99V[\x10\x15a?HW`@Q\x7F\x90)\x85\x94\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x81\x01\x84\x90R`$\x81\x01\x83\x90R`D\x01a\x06\xB7V[a?R\x83\x83a`\x99V[`\x02\x03a?kWa?d\x83`\x01ab$V[\x90Pa\x10PV[_\x83a?x`\x01\x85a`\x99V[\x18\x90P_a?\x85\x82aH\x8AV[\x90P_\x19\x81\x1B\x80a?\x97`\x01\x87a`\x99V[\x16\x96\x95PPPPPPV[_\x85\x11a?\xF1W`@QbF\x1B\xCD`\xE5\x1B\x81R` `\x04\x82\x01R`\x14`$\x82\x01R\x7FPre-size cannot be 0\0\0\0\0\0\0\0\0\0\0\0\0`D\x82\x01R`d\x01a\x06\xB7V[\x85a?\xFB\x83aE\x02V[\x14a@HW`@QbF\x1B\xCD`\xE5\x1B\x81R` `\x04\x82\x01R`\x1B`$\x82\x01R\x7FPre expansion root mismatch\0\0\0\0\0`D\x82\x01R`d\x01a\x06\xB7V[\x84a@R\x83aI\xC4V[\x14a@\xC5W`@QbF\x1B\xCD`\xE5\x1B\x81R` `\x04\x82\x01R`!`$\x82\x01R\x7FPre size does not match expansio`D\x82\x01R\x7Fn\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0`d\x82\x01R`\x84\x01a\x06\xB7V[\x82\x85\x10aA\x14W`@QbF\x1B\xCD`\xE5\x1B\x81R` `\x04\x82\x01\x81\x90R`$\x82\x01R\x7FPre size not less than post size`D\x82\x01R`d\x01a\x06\xB7V[_\x85\x90P__\x90P_aA)\x85_\x87QaJ\x13V[\x90P[\x85\x83\x10\x15aA\xEBW_aA?\x84\x88aK\x87V[\x90P\x84Q\x83\x10aA\x91W`@QbF\x1B\xCD`\xE5\x1B\x81R` `\x04\x82\x01R`\x12`$\x82\x01R\x7FIndex out of range\0\0\0\0\0\0\0\0\0\0\0\0\0\0`D\x82\x01R`d\x01a\x06\xB7V[aA\xB5\x82\x82\x87\x86\x81Q\x81\x10aA\xA8WaA\xA8a`EV[` \x02` \x01\x01QaLnV[\x91P`\x01\x81\x1BaA\xC5\x81\x86ab$V[\x94P\x87\x85\x11\x15aA\xD7WaA\xD7ad\xAFV[\x83aA\xE1\x81ad\xC3V[\x94PPPPaA,V[\x86aA\xF5\x82aE\x02V[\x14aBhW`@QbF\x1B\xCD`\xE5\x1B\x81R` `\x04\x82\x01R`\"`$\x82\x01R\x7FPost expansion root not equal po`D\x82\x01R\x7Fst\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0`d\x82\x01R`\x84\x01a\x06\xB7V[\x83Q\x82\x14aB\xB8W`@QbF\x1B\xCD`\xE5\x1B\x81R` `\x04\x82\x01R`\x16`$\x82\x01R\x7FIncomplete proof usage\0\0\0\0\0\0\0\0\0\0`D\x82\x01R`d\x01a\x06\xB7V[PPPPPPPPPV[aB\xCBaU.V[aB\xD8\x87\x87\x87\x87\x87aQ\xD6V[P`@\x80Qa\x01\xE0\x81\x01\x82R\x96\x87R` \x87\x01\x95\x90\x95R\x93\x85\x01\x92\x90\x92R``\x84\x01R`\x80\x83\x01R_`\xA0\x83\x01\x81\x90R`\xC0\x83\x01\x81\x90R`\xE0\x83\x01\x81\x90Ra\x01\0\x83\x01\x81\x90Rg\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFFC\x16a\x01 \x84\x01Ra\x01@\x83\x01\x81\x90Ra\x01`\x83\x01\x81\x90R`\xFF\x90\x91\x16a\x01\x80\x83\x01Ra\x01\xA0\x82\x01\x81\x90Ra\x01\xC0\x82\x01R\x90V[a\x01\x80\x81\x01Q\x81Q`@\x80\x84\x01Q` \x80\x86\x01Q`\x80\x87\x01Q``\x88\x01Q\x85Q`\xF8\x98\x90\x98\x1B`\x01`\x01`\xF8\x1B\x03\x19\x16\x88\x85\x01R`!\x88\x01\x96\x90\x96R`A\x87\x01\x93\x90\x93R`a\x86\x01R`\x81\x80\x86\x01\x92\x90\x92R\x82Q\x80\x86\x03\x90\x92\x01\x82R`\xA1\x85\x01\x83R\x81Q\x91\x81\x01\x91\x90\x91 `\xC1\x85\x01R`\xE1\x80\x85\x01\x93\x90\x93R\x81Q\x80\x85\x03\x90\x93\x01\x83Ra\x01\x01\x90\x93\x01\x90R\x80Q\x91\x01 _\x90a\x10PV[`\x05\x83\x01T\x15\x15\x80aD\x07WP`\x06\x83\x01T\x15\x15[\x15aDbWaD\x15\x83a(mV[`\x05\x84\x01T`\x06\x85\x01T`@Q\x7F\x8B\x0Eq\xD0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x81\x01\x93\x90\x93R`$\x83\x01\x91\x90\x91R`D\x82\x01R`d\x01a\x06\xB7V[`\x05\x83\x01\x91\x90\x91U`\x06\x90\x91\x01UV[aDzaU\xC5V[`@Q\x80`@\x01`@R\x80\x83_\x01Q\x81R` \x01\x83` \x01Q`\x02\x81\x11\x15aD\xA4WaD\xA4a[\x03V[\x90R\x92\x91PPV[_\x80aD\xB9\x84`\x01a`mV[\x90PaD\xC5\x81\x84a\x1C#V[P\x93\x92PPPV[``a \xC5\x83_\x84`@Q` \x01aD\xE7\x91\x81R` \x01\x90V[`@Q` \x81\x83\x03\x03\x81R\x90`@R\x80Q\x90` \x01 aLnV[__\x82Q\x11aESW`@QbF\x1B\xCD`\xE5\x1B\x81R` `\x04\x82\x01R`\x16`$\x82\x01R\x7FEmpty merkle expansion\0\0\0\0\0\0\0\0\0\0`D\x82\x01R`d\x01a\x06\xB7V[`@\x82Q\x11\x15aE\xA5W`@QbF\x1B\xCD`\xE5\x1B\x81R` `\x04\x82\x01R`\x1A`$\x82\x01R\x7FMerkle expansion too large\0\0\0\0\0\0`D\x82\x01R`d\x01a\x06\xB7V[_\x80[\x83Q\x81\x10\x15aF\x8BW_\x84\x82\x81Q\x81\x10aE\xC4WaE\xC4a`EV[` \x02` \x01\x01Q\x90P\x82__\x1B\x03aF.W\x80\x15aF)W\x80\x92P`\x01\x85QaE\xEE\x91\x90a`\x99V[\x82\x14aF)W`@QaF\x10\x90\x84\x90_\x90` \x01\x91\x82R` \x82\x01R`@\x01\x90V[`@Q` \x81\x83\x03\x03\x81R\x90`@R\x80Q\x90` \x01 \x92P[aF\x82V[\x80\x15aFMW`@\x80Q` \x81\x01\x83\x90R\x90\x81\x01\x84\x90R``\x01aF\x10V[`@QaFi\x90\x84\x90_\x90` \x01\x91\x82R` \x82\x01R`@\x01\x90V[`@Q` \x81\x83\x03\x03\x81R\x90`@R\x80Q\x90` \x01 \x92P[P`\x01\x01aE\xA8V[P\x92\x91PPV[aF\x9AaU.V[`\x01`\x01`\xA0\x1B\x03\x83\x16aF\xDAW`@Q\x7F\xF2\x89\xE6W\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[_\x84\x90\x03aG\x14W`@Q\x7Fi2\xBC\xFD\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[aG!\x89\x89\x89\x89\x89aQ\xD6V[`@Q\x80a\x01\xE0\x01`@R\x80\x8A\x81R` \x01\x89\x81R` \x01\x88\x81R` \x01\x87\x81R` \x01\x86\x81R` \x01__\x1B\x81R` \x01__\x1B\x81R` \x01\x85\x81R` \x01\x84`\x01`\x01`\xA0\x1B\x03\x16\x81R` \x01Cg\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x81R` \x01_g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x81R` \x01_`\x01\x81\x11\x15aG\xA2WaG\xA2a[\x03V[\x81R`\xFF\x84\x16` \x82\x01R_`@\x82\x01\x81\x90R``\x90\x91\x01R\x90P\x98\x97PPPPPPPPV[``a \xC2\x84\x84_\x85aR\xC7V[\x82Q_\x90a\x01\0\x81\x11\x15aH\"W`@Q\x7F\xFD\xAC3\x1E\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x81\x01\x82\x90Ra\x01\0`$\x82\x01R`D\x01a\x06\xB7V[\x82_[\x82\x81\x10\x15aH\x80W_\x87\x82\x81Q\x81\x10aH@WaH@a`EV[` \x02` \x01\x01Q\x90P\x81`\x01\x90\x1B\x87\x16_\x03aHiW\x82_R\x80` R`@_ \x92PaHwV[\x80_R\x82` R`@_ \x92P[P`\x01\x01aH%V[P\x95\x94PPPPPV[_\x81_\x03aH\xDAW`@QbF\x1B\xCD`\xE5\x1B\x81R` `\x04\x82\x01R`\x1C`$\x82\x01R\x7FZero has no significant bits\0\0\0\0`D\x82\x01R`d\x01a\x06\xB7V[p\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x82\x10aI\x05W`\x80\x91\x82\x1C\x91aI\x02\x90\x82ab$V[\x90P[`\x01`@\x1B\x82\x10aI#W`@\x91\x82\x1C\x91aI \x90\x82ab$V[\x90P[d\x01\0\0\0\0\x82\x10aIBW` \x91\x82\x1C\x91aI?\x90\x82ab$V[\x90P[b\x01\0\0\x82\x10aI_W`\x10\x91\x82\x1C\x91aI\\\x90\x82ab$V[\x90P[a\x01\0\x82\x10aI{W`\x08\x91\x82\x1C\x91aIx\x90\x82ab$V[\x90P[`\x10\x82\x10aI\x96W`\x04\x91\x82\x1C\x91aI\x93\x90\x82ab$V[\x90P[`\x04\x82\x10aI\xB1W`\x02\x91\x82\x1C\x91aI\xAE\x90\x82ab$V[\x90P[`\x02\x82\x10a\x10\xEDWa\x10P`\x01\x82ab$V[_\x80\x80[\x83Q\x81\x10\x15aF\x8BW\x83\x81\x81Q\x81\x10aI\xE3WaI\xE3a`EV[` \x02` \x01\x01Q__\x1B\x14aJ\x0BWaI\xFE\x81`\x02ae\xB6V[aJ\x08\x90\x83ab$V[\x91P[`\x01\x01aI\xC8V[``\x81\x83\x10aJdW`@QbF\x1B\xCD`\xE5\x1B\x81R` `\x04\x82\x01R`\x17`$\x82\x01R\x7FStart not less than end\0\0\0\0\0\0\0\0\0`D\x82\x01R`d\x01a\x06\xB7V[\x83Q\x82\x11\x15aJ\xDBW`@QbF\x1B\xCD`\xE5\x1B\x81R` `\x04\x82\x01R`!`$\x82\x01R\x7FEnd not less or equal than lengt`D\x82\x01R\x7Fh\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0`d\x82\x01R`\x84\x01a\x06\xB7V[_aJ\xE6\x84\x84a`\x99V[g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x11\x15aJ\xFEWaJ\xFEa\\\xCEV[`@Q\x90\x80\x82R\x80` \x02` \x01\x82\x01`@R\x80\x15aK'W\x81` \x01` \x82\x02\x806\x837\x01\x90P[P\x90P\x83[\x83\x81\x10\x15aK~W\x85\x81\x81Q\x81\x10aKFWaKFa`EV[` \x02` \x01\x01Q\x82\x86\x83aK[\x91\x90a`\x99V[\x81Q\x81\x10aKkWaKka`EV[` \x90\x81\x02\x91\x90\x91\x01\x01R`\x01\x01aK,V[P\x94\x93PPPPV[_\x81\x83\x10aK\xD7W`@QbF\x1B\xCD`\xE5\x1B\x81R` `\x04\x82\x01R`\x17`$\x82\x01R\x7FStart not less than end\0\0\0\0\0\0\0\0\0`D\x82\x01R`d\x01a\x06\xB7V[_aK\xE3\x83\x85\x18aH\x8AV[\x90P_`\x01aK\xF2\x83\x82ab$V[`\x01\x90\x1BaL\0\x91\x90a`\x99V[\x90P\x84\x81\x16\x84\x82\x16\x81\x15aL\x17Wa >\x82aT\0V[\x80\x15aL&Wa >\x81aH\x8AV[`@QbF\x1B\xCD`\xE5\x1B\x81R` `\x04\x82\x01R`\x1B`$\x82\x01R\x7FBoth y and z cannot be zero\0\0\0\0\0`D\x82\x01R`d\x01a\x06\xB7V[```@\x83\x10aL\xC0W`@QbF\x1B\xCD`\xE5\x1B\x81R` `\x04\x82\x01R`\x0E`$\x82\x01R\x7FLevel too high\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0`D\x82\x01R`d\x01a\x06\xB7V[_\x82\x90\x03aM\x10W`@QbF\x1B\xCD`\xE5\x1B\x81R` `\x04\x82\x01R`\x1B`$\x82\x01R\x7FCannot append empty subtree\0\0\0\0\0`D\x82\x01R`d\x01a\x06\xB7V[`@\x84Q\x11\x15aMbW`@QbF\x1B\xCD`\xE5\x1B\x81R` `\x04\x82\x01R`\x1A`$\x82\x01R\x7FMerkle expansion too large\0\0\0\0\0\0`D\x82\x01R`d\x01a\x06\xB7V[\x83Q_\x03aM\xDFW_aMv\x84`\x01ab$V[g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x11\x15aM\x8EWaM\x8Ea\\\xCEV[`@Q\x90\x80\x82R\x80` \x02` \x01\x82\x01`@R\x80\x15aM\xB7W\x81` \x01` \x82\x02\x806\x837\x01\x90P[P\x90P\x82\x81\x85\x81Q\x81\x10aM\xCDWaM\xCDa`EV[` \x90\x81\x02\x91\x90\x91\x01\x01R\x90Pa \xC5V[\x83Q\x83\x10aNUW`@QbF\x1B\xCD`\xE5\x1B\x81R` `\x04\x82\x01R`5`$\x82\x01R\x7FLevel greater than highest level`D\x82\x01R\x7F of current expansion\0\0\0\0\0\0\0\0\0\0\0`d\x82\x01R`\x84\x01a\x06\xB7V[\x81_aN`\x86aI\xC4V[\x90P_aNn\x86`\x02ae\xB6V[aNx\x90\x83ab$V[\x90P_aN\x84\x83aH\x8AV[aN\x8D\x83aH\x8AV[\x11aN\xDBW\x87Qg\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x11\x15aN\xACWaN\xACa\\\xCEV[`@Q\x90\x80\x82R\x80` \x02` \x01\x82\x01`@R\x80\x15aN\xD5W\x81` \x01` \x82\x02\x806\x837\x01\x90P[PaO+V[\x87QaN\xE8\x90`\x01ab$V[g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x11\x15aO\0WaO\0a\\\xCEV[`@Q\x90\x80\x82R\x80` \x02` \x01\x82\x01`@R\x80\x15aO)W\x81` \x01` \x82\x02\x806\x837\x01\x90P[P[\x90P`@\x81Q\x11\x15aO\x7FW`@QbF\x1B\xCD`\xE5\x1B\x81R` `\x04\x82\x01R`\x1C`$\x82\x01R\x7FAppend creates oversize tree\0\0\0\0`D\x82\x01R`d\x01a\x06\xB7V[_[\x88Q\x81\x10\x15aQ+W\x87\x81\x10\x15aP'W\x88\x81\x81Q\x81\x10aO\xA4WaO\xA4a`EV[` \x02` \x01\x01Q__\x1B\x14aP\"W`@QbF\x1B\xCD`\xE5\x1B\x81R` `\x04\x82\x01R`\"`$\x82\x01R\x7FAppend above least significant b`D\x82\x01R\x7Fit\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0`d\x82\x01R`\x84\x01a\x06\xB7V[aQ#V[_\x85\x90\x03aPlW\x88\x81\x81Q\x81\x10aPAWaPAa`EV[` \x02` \x01\x01Q\x82\x82\x81Q\x81\x10aP[WaP[a`EV[` \x02` \x01\x01\x81\x81RPPaQ#V[\x88\x81\x81Q\x81\x10aP~WaP~a`EV[` \x02` \x01\x01Q__\x1B\x03aP\xB4W\x84\x82\x82\x81Q\x81\x10aP\xA1WaP\xA1a`EV[` \x90\x81\x02\x91\x90\x91\x01\x01R_\x94PaQ#V[__\x1B\x82\x82\x81Q\x81\x10aP\xC9WaP\xC9a`EV[` \x02` \x01\x01\x81\x81RPP\x88\x81\x81Q\x81\x10aP\xE7WaP\xE7a`EV[` \x02` \x01\x01Q\x85`@Q` \x01aQ\n\x92\x91\x90\x91\x82R` \x82\x01R`@\x01\x90V[`@Q` \x81\x83\x03\x03\x81R\x90`@R\x80Q\x90` \x01 \x94P[`\x01\x01aO\x81V[P\x83\x15aQ_W\x83\x81`\x01\x83QaQB\x91\x90a`\x99V[\x81Q\x81\x10aQRWaQRa`EV[` \x02` \x01\x01\x81\x81RPP[\x80`\x01\x82QaQn\x91\x90a`\x99V[\x81Q\x81\x10aQ~WaQ~a`EV[` \x02` \x01\x01Q__\x1B\x03a\x05lW`@QbF\x1B\xCD`\xE5\x1B\x81R` `\x04\x82\x01R`\x0F`$\x82\x01R\x7FLast entry zero\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0`D\x82\x01R`d\x01a\x06\xB7V[_\x85\x90\x03aR\x10W`@Q\x7F\x8Dy\xDB\xBC\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[\x82\x81\x11aRSW`@Q\x7F `\xFA\xF4\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x81\x01\x84\x90R`$\x81\x01\x82\x90R`D\x01a\x06\xB7V[_\x84\x90\x03aR\x8DW`@Q\x7F\x83\xC6\x83\xE4\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[_\x82\x90\x03a\x13)W`@Q\x7F\\\xB6\xE5\xBB\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[``\x82G\x10\x15aS?W`@QbF\x1B\xCD`\xE5\x1B\x81R` `\x04\x82\x01R`&`$\x82\x01R\x7FAddress: insufficient balance fo`D\x82\x01R\x7Fr call\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0`d\x82\x01R`\x84\x01a\x06\xB7V[`\x01`\x01`\xA0\x1B\x03\x85\x16;aS\x96W`@QbF\x1B\xCD`\xE5\x1B\x81R` `\x04\x82\x01R`\x1D`$\x82\x01R\x7FAddress: call to non-contract\0\0\0`D\x82\x01R`d\x01a\x06\xB7V[__\x86`\x01`\x01`\xA0\x1B\x03\x16\x85\x87`@QaS\xB1\x91\x90ae\xC1V[_`@Q\x80\x83\x03\x81\x85\x87Z\xF1\x92PPP=\x80_\x81\x14aS\xEBW`@Q\x91P`\x1F\x19`?=\x01\x16\x82\x01`@R=\x82R=_` \x84\x01>aS\xF0V[``\x91P[P\x91P\x91Pa\x05l\x82\x82\x86aTkV[__\x82\x11aTPW`@QbF\x1B\xCD`\xE5\x1B\x81R` `\x04\x82\x01R`\x1C`$\x82\x01R\x7FZero has no significant bits\0\0\0\0`D\x82\x01R`d\x01a\x06\xB7V[_\x82\x80aT^`\x01\x82a`\x99V[\x16\x18\x90Pa \xC5\x81aH\x8AV[``\x83\x15aTzWP\x81a \xC5V[\x82Q\x15aT\x8AW\x82Q\x80\x84` \x01\xFD[\x81`@QbF\x1B\xCD`\xE5\x1B\x81R`\x04\x01a\x06\xB7\x91\x90ae\xD7V[`@Q\x80`\xC0\x01`@R\x80_\x81R` \x01_\x81R` \x01_\x15\x15\x81R` \x01_\x15\x15\x81R` \x01aT\xD3aU\xE3V[\x81R` \x01aT\xE0aU\xE3V[\x90R\x90V[\x82\x80T\x82\x82U\x90_R` _ \x90\x81\x01\x92\x82\x15aU\x1EW\x91` \x02\x82\x01[\x82\x81\x11\x15aU\x1EW\x825\x82U\x91` \x01\x91\x90`\x01\x01\x90aU\x03V[PaU*\x92\x91PaV\x08V[P\x90V[`@Q\x80a\x01\xE0\x01`@R\x80_\x81R` \x01_\x81R` \x01_\x81R` \x01_\x81R` \x01_\x81R` \x01_\x81R` \x01_\x81R` \x01_\x81R` \x01_`\x01`\x01`\xA0\x1B\x03\x16\x81R` \x01_g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x81R` \x01_g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x81R` \x01_`\x01\x81\x11\x15aU\xABWaU\xABa[\x03V[\x81R_` \x82\x01\x81\x90R`@\x82\x01\x81\x90R``\x90\x91\x01R\x90V[`@Q\x80`@\x01`@R\x80aU\xD8aV\x1CV[\x81R` \x01_\x90R\x90V[`@Q\x80``\x01`@R\x80aU\xF6aV\x1CV[\x81R` \x01_\x81R` \x01_\x81RP\x90V[[\x80\x82\x11\x15aU*W_\x81U`\x01\x01aV\tV[`@Q\x80`@\x01`@R\x80aV/aV8V[\x81R` \x01aT\xE0[`@Q\x80`@\x01`@R\x80`\x02\x90` \x82\x02\x806\x837P\x91\x92\x91PPV[\x805`\xFF\x81\x16\x81\x14a\x10\xEDW__\xFD[______`\xC0\x87\x89\x03\x12\x15aV{W__\xFD[aV\x84\x87aVVV[\x98` \x88\x015\x98P`@\x88\x015\x97``\x81\x015\x97P`\x80\x81\x015\x96P`\xA0\x015\x94P\x92PPPV[_` \x82\x84\x03\x12\x15aV\xBCW__\xFD[\x815g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x11\x15aV\xD2W__\xFD[\x82\x01`\xC0\x81\x85\x03\x12\x15a \xC5W__\xFD[`\x01`\x01`\xA0\x1B\x03\x81\x16\x81\x14aV\xF7W__\xFD[PV[g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x16\x81\x14aV\xF7W__\xFD[\x805a\x10\xED\x81aV\xE3V[__\x83`\x1F\x84\x01\x12aW*W__\xFD[P\x815g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x11\x15aWAW__\xFD[` \x83\x01\x91P\x83` \x82`\x05\x1B\x85\x01\x01\x11\x15aW[W__\xFD[\x92P\x92\x90PV[___________a\x01@\x8C\x8E\x03\x12\x15aW}W__\xFD[\x8B5aW\x88\x81aV\xE3V[\x9AP` \x8C\x015aW\x98\x81aV\xFAV[\x99P`@\x8C\x015aW\xA8\x81aV\xE3V[\x98P``\x8C\x015\x97P`\x80\x8C\x015\x96P`\xA0\x8C\x015\x95P`\xC0\x8C\x015aW\xCD\x81aV\xE3V[\x94PaW\xDB`\xE0\x8D\x01aW\x0FV[\x93PaW\xEAa\x01\0\x8D\x01aVVV[\x92Pa\x01 \x8C\x015g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x11\x15aX\x06W__\xFD[aX\x12\x8E\x82\x8F\x01aW\x1AV[\x91P\x80\x93PP\x80\x91PP\x92\x95\x98\x9BP\x92\x95\x98\x9B\x90\x93\x96\x99PV[_` \x82\x84\x03\x12\x15aX<W__\xFD[P5\x91\x90PV[`\x03\x81\x10aV\xF7W__\xFD[\x805a\x10\xED\x81aXCV[_` \x82\x84\x03\x12\x15aXjW__\xFD[\x815a \xC5\x81aXCV[___`@\x84\x86\x03\x12\x15aX\x87W__\xFD[\x835g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x11\x15aX\x9DW__\xFD[aX\xA9\x86\x82\x87\x01aW\x1AV[\x90\x97\x90\x96P` \x95\x90\x95\x015\x94\x93PPPPV[__`@\x83\x85\x03\x12\x15aX\xCEW__\xFD[\x825aX\xD9\x81aV\xE3V[\x94` \x93\x90\x93\x015\x93PPPV[___``\x84\x86\x03\x12\x15aX\xF9W__\xFD[PP\x815\x93` \x83\x015\x93P`@\x90\x92\x015\x91\x90PV[_______\x87\x89\x03a\x01 \x81\x12\x15aY(W__\xFD[\x885\x97P` \x89\x015g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x11\x15aYEW__\xFD[\x89\x01`@\x81\x8C\x03\x12\x15aYVW__\xFD[\x96P`\xA0\x7F\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xC0\x82\x01\x12\x15aY\x87W__\xFD[P`@\x88\x01\x94P`\xE0\x88\x015g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x11\x15aY\xA7W__\xFD[aY\xB3\x8A\x82\x8B\x01aW\x1AV[\x90\x95P\x93PPa\x01\0\x88\x015g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x11\x15aY\xD3W__\xFD[aY\xDF\x8A\x82\x8B\x01aW\x1AV[\x98\x9B\x97\x9AP\x95\x98P\x93\x96\x92\x95\x92\x93PPPV[__\x82\x84\x03a\x01 \x81\x12\x15aZ\x05W__\xFD[\x835\x92Pa\x01\0`\x1F\x19\x82\x01\x12\x15aZ\x1BW__\xFD[P` \x83\x01\x90P\x92P\x92\x90PV[_____`\xA0\x86\x88\x03\x12\x15aZ=W__\xFD[aZF\x86aVVV[\x97` \x87\x015\x97P`@\x87\x015\x96``\x81\x015\x96P`\x80\x015\x94P\x92PPPV[____``\x85\x87\x03\x12\x15aZzW__\xFD[\x845\x93P` \x85\x015\x92P`@\x85\x015g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x11\x15aZ\x9EW__\xFD[\x85\x01`\x1F\x81\x01\x87\x13aZ\xAEW__\xFD[\x805g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x11\x15aZ\xC4W__\xFD[\x87` \x82\x84\x01\x01\x11\x15aZ\xD5W__\xFD[\x94\x97\x93\x96P` \x01\x94PPPV[__`@\x83\x85\x03\x12\x15aZ\xF4W__\xFD[PP\x805\x92` \x90\x91\x015\x91PV[cNH{q`\xE0\x1B_R`!`\x04R`$_\xFD[`\x02\x81\x10a['Wa['a[\x03V[\x90RV[_a\x01\xE0\x82\x01\x90P\x82Q\x82R` \x83\x01Q` \x83\x01R`@\x83\x01Q`@\x83\x01R``\x83\x01Q``\x83\x01R`\x80\x83\x01Q`\x80\x83\x01R`\xA0\x83\x01Q`\xA0\x83\x01R`\xC0\x83\x01Q`\xC0\x83\x01R`\xE0\x83\x01Q`\xE0\x83\x01Ra\x01\0\x83\x01Qa[\x99a\x01\0\x84\x01\x82`\x01`\x01`\xA0\x1B\x03\x16\x90RV[Pa\x01 \x83\x01Qa[\xB7a\x01 \x84\x01\x82g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x90RV[Pa\x01@\x83\x01Qa[\xD5a\x01@\x84\x01\x82g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x90RV[Pa\x01`\x83\x01Qa[\xEAa\x01`\x84\x01\x82a[\x17V[Pa\x01\x80\x83\x01Qa\\\x01a\x01\x80\x84\x01\x82`\xFF\x16\x90RV[Pa\x01\xA0\x83\x01Qa\\\x17a\x01\xA0\x84\x01\x82\x15\x15\x90RV[Pa\x01\xC0\x83\x01QaF\x8Ba\x01\xC0\x84\x01\x82g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x90RV[_` \x82\x84\x03\x12\x15a\\EW__\xFD[\x81Q\x80\x15\x15\x81\x14a \xC5W__\xFD[_` \x82\x84\x03\x12\x15a\\dW__\xFD[a \xC5\x82aVVV[__\x835\x7F\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xE1\x846\x03\x01\x81\x12a\\\xA0W__\xFD[\x83\x01\x805\x91Pg\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x82\x11\x15a\\\xBAW__\xFD[` \x01\x91P6\x81\x90\x03\x82\x13\x15aW[W__\xFD[cNH{q`\xE0\x1B_R`A`\x04R`$_\xFD[`@Q``\x81\x01g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x11\x82\x82\x10\x17\x15a]\x05Wa]\x05a\\\xCEV[`@R\x90V[`@\x80Q\x90\x81\x01g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x11\x82\x82\x10\x17\x15a]\x05Wa]\x05a\\\xCEV[`@Q`\x1F\x82\x01`\x1F\x19\x16\x81\x01g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x11\x82\x82\x10\x17\x15a]WWa]Wa\\\xCEV[`@R\x91\x90PV[_g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x82\x11\x15a]xWa]xa\\\xCEV[P`\x05\x1B` \x01\x90V[_\x82`\x1F\x83\x01\x12a]\x91W__\xFD[\x815a]\xA4a]\x9F\x82a]_V[a].V[\x80\x82\x82R` \x82\x01\x91P` \x83`\x05\x1B\x86\x01\x01\x92P\x85\x83\x11\x15a]\xC5W__\xFD[` \x85\x01[\x83\x81\x10\x15aH\x80W\x805\x83R` \x92\x83\x01\x92\x01a]\xCAV[_\x82`\x1F\x83\x01\x12a]\xF1W__\xFD[a]\xFB`@a].V[\x80`@\x84\x01\x85\x81\x11\x15a^\x0CW__\xFD[\x84[\x81\x81\x10\x15a5\x0EW\x805a^!\x81aV\xFAV[\x84R` \x93\x84\x01\x93\x01a^\x0EV[_\x81\x83\x03a\x01\0\x81\x12\x15a^AW__\xFD[a^Ia\\\xE2V[\x91P`\xC0\x81\x12\x15a^XW__\xFD[a^`a\\\xE2V[`\x80\x82\x12\x15a^mW__\xFD[a^ua]\x0BV[\x91P\x84`\x1F\x85\x01\x12a^\x85W__\xFD[a^\x8F`@a].V[\x80`@\x86\x01\x87\x81\x11\x15a^\xA0W__\xFD[\x86[\x81\x81\x10\x15a^\xBAW\x805\x84R` \x93\x84\x01\x93\x01a^\xA2V[P\x81\x85Ra^\xC8\x88\x82a]\xE2V[` \x86\x01RPPP\x81\x81Ra^\xDF`\x80\x85\x01aXOV[` \x82\x81\x01\x91\x90\x91R`\xA0\x85\x015`@\x80\x84\x01\x91\x90\x91R\x91\x84R`\xC0\x85\x015\x90\x84\x01R`\xE0\x90\x93\x015\x92\x82\x01\x92\x90\x92R\x92\x91PPV[___a\x02 \x84\x86\x03\x12\x15a_(W__\xFD[\x835g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x11\x15a_>W__\xFD[a_J\x86\x82\x87\x01a]\x82V[\x93PPa_Z\x85` \x86\x01a^/V[\x91Pa_j\x85a\x01 \x86\x01a^/V[\x90P\x92P\x92P\x92V[\x80Q\x82_[`\x02\x81\x10\x15a_\x97W\x82Q\x82R` \x92\x83\x01\x92\x90\x91\x01\x90`\x01\x01a_xV[PPP` \x81\x01Q`@\x83\x01_[`\x02\x81\x10\x15a\x13)W\x82Qg\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x82R` \x92\x83\x01\x92\x90\x91\x01\x90`\x01\x01a_\xA5V[`\x03\x81\x10aV\xF7WaV\xF7a[\x03V[_a\x01 \x82\x01\x90P\x85\x82Ra_\xF7` \x83\x01\x86Qa_sV[` \x85\x01Qa`\x05\x81a_\xCEV[`\xA0\x83\x01R`@\x94\x90\x94\x01Q`\xC0\x82\x01R`\xE0\x81\x01\x92\x90\x92Ra\x01\0\x90\x91\x01R\x91\x90PV[_` \x82\x84\x03\x12\x15a`:W__\xFD[\x81Qa \xC5\x81aV\xFAV[cNH{q`\xE0\x1B_R`2`\x04R`$_\xFD[cNH{q`\xE0\x1B_R`\x11`\x04R`$_\xFD[`\xFF\x81\x81\x16\x83\x82\x16\x01\x90\x81\x11\x15a\x10PWa\x10Pa`YV[` \x81\x01a`\x93\x83a_\xCEV[\x91\x90R\x90V[\x81\x81\x03\x81\x81\x11\x15a\x10PWa\x10Pa`YV[\x82\x81R\x815` \x80\x83\x01\x91\x90\x91R\x82\x015`@\x80\x83\x01\x91\x90\x91R`\xC0\x82\x01\x90\x83\x015a`\xD7\x81aV\xE3V[`\x01`\x01`\xA0\x1B\x03\x81\x16``\x84\x01RP``\x83\x015a`\xF5\x81aV\xFAV[g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x16`\x80\x84\x01RP`\x80\x83\x015aa\x14\x81aV\xFAV[g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x16`\xA0\x84\x01RP\x93\x92PPPV[_` \x82\x84\x03\x12\x15aa<W__\xFD[\x815a \xC5\x81aV\xFAV[_` \x82\x84\x03\x12\x15aaWW__\xFD[\x81Qa \xC5\x81aV\xE3V[\x84\x81Ra\x01 \x81\x01`@\x85` \x84\x017``\x82\x01`@\x86\x01_[`\x02\x81\x10\x15aa\xAFW\x815aa\x90\x81aV\xFAV[g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x83R` \x92\x83\x01\x92\x91\x90\x91\x01\x90`\x01\x01aa|V[PPP`\x80\x85\x015aa\xC0\x81aXCV[aa\xC9\x81a_\xCEV[`\xA0\x83\x81\x01\x91\x90\x91R\x94\x90\x94\x015`\xC0\x82\x01R`\xE0\x81\x01\x92\x90\x92Ra\x01\0\x90\x91\x01R\x91\x90PV[g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x82\x81\x16\x82\x82\x16\x03\x90\x81\x11\x15a\x10PWa\x10Pa`YV[\x82\x81R`@\x81\x01a \xC5` \x83\x01\x84a[\x17V[\x80\x82\x01\x80\x82\x11\x15a\x10PWa\x10Pa`YV[\x80\x82\x02\x81\x15\x82\x82\x04\x84\x14\x17a\x10PWa\x10Pa`YV[\x85Q\x81R`\x01`\x01`\xA0\x1B\x03` \x87\x01Q\x16` \x82\x01R`@\x86\x01Q`@\x82\x01R\x84``\x82\x01R\x83`\x80\x82\x01R`\xC0`\xA0\x82\x01R\x81`\xC0\x82\x01R\x81\x83`\xE0\x83\x017_\x81\x83\x01`\xE0\x90\x81\x01\x91\x90\x91R`\x1F\x90\x92\x01`\x1F\x19\x16\x01\x01\x94\x93PPPPV[_` \x82\x84\x03\x12\x15ab\xBFW__\xFD[PQ\x91\x90PV[_\x82`\x1F\x83\x01\x12ab\xD5W__\xFD[\x81Qab\xE3a]\x9F\x82a]_V[\x80\x82\x82R` \x82\x01\x91P` \x83`\x05\x1B\x86\x01\x01\x92P\x85\x83\x11\x15ac\x04W__\xFD[` \x85\x01[\x83\x81\x10\x15aH\x80W\x80Q\x83R` \x92\x83\x01\x92\x01ac\tV[__`@\x83\x85\x03\x12\x15ac2W__\xFD[\x82Qg\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x11\x15acHW__\xFD[acT\x85\x82\x86\x01ab\xC6V[\x92PP` \x83\x01Qg\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x11\x15acpW__\xFD[ac|\x85\x82\x86\x01ab\xC6V[\x91PP\x92P\x92\x90PV[_`\xA0\x82\x01\x90Pac\x98\x82\x84Qa_sV[` \x83\x01Qac\xA6\x81a_\xCEV[\x80`\x80\x84\x01RP\x92\x91PPV[_____`\xA0\x86\x88\x03\x12\x15ac\xC7W__\xFD[\x855\x94P` \x86\x015\x93P`@\x86\x015g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x11\x15ac\xEBW__\xFD[ac\xF7\x88\x82\x89\x01a]\x82V[\x93PP``\x86\x015g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x11\x15ad\x13W__\xFD[ad\x1F\x88\x82\x89\x01a]\x82V[\x92PP`\x80\x86\x015g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x11\x15ad;W__\xFD[adG\x88\x82\x89\x01a]\x82V[\x91PP\x92\x95P\x92\x95\x90\x93PV[__`@\x83\x85\x03\x12\x15adeW__\xFD[\x825g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x11\x15ad{W__\xFD[ad\x87\x85\x82\x86\x01a]\x82V[\x92PP` \x83\x015g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x11\x15ad\xA3W__\xFD[ac|\x85\x82\x86\x01a]\x82V[cNH{q`\xE0\x1B_R`\x01`\x04R`$_\xFD[_`\x01\x82\x01ad\xD4Wad\xD4a`YV[P`\x01\x01\x90V[`\x01\x81[`\x01\x84\x11\x15a.zW\x80\x85\x04\x81\x11\x15ad\xFAWad\xFAa`YV[`\x01\x84\x16\x15ae\x08W\x90\x81\x02\x90[`\x01\x93\x90\x93\x1C\x92\x80\x02ad\xDFV[_\x82ae$WP`\x01a\x10PV[\x81ae0WP_a\x10PV[\x81`\x01\x81\x14aeFW`\x02\x81\x14aePWaelV[`\x01\x91PPa\x10PV[`\xFF\x84\x11\x15aeaWaeaa`YV[PP`\x01\x82\x1Ba\x10PV[P` \x83\x10a\x013\x83\x10\x16`N\x84\x10`\x0B\x84\x10\x16\x17\x15ae\x8FWP\x81\x81\na\x10PV[ae\x9B_\x19\x84\x84ad\xDBV[\x80_\x19\x04\x82\x11\x15ae\xAEWae\xAEa`YV[\x02\x93\x92PPPV[_a \xC5\x83\x83ae\x16V[_\x82Q\x80` \x85\x01\x84^_\x92\x01\x91\x82RP\x91\x90PV[` \x81R_\x82Q\x80` \x84\x01R\x80` \x85\x01`@\x85\x01^_`@\x82\x85\x01\x01R`@`\x1F\x19`\x1F\x83\x01\x16\x84\x01\x01\x91PP\x92\x91PPV\xFE\xA2dipfsX\"\x12 }]\xF4\xA8\rX\xA5#R\xE9\xEF\xC0z\0of\xC9D\x82h\x99\xB9A\x9B\x94\xD6\xDE\xB8\xC4\xE1\x14\xD1dsolcC\0\x08\x1C\x003",
    );
    /// The runtime bytecode of the contract, as deployed on the network.
    ///
    /// ```text
    ///0x608060405234801561000f575f5ffd5b50600436106101e6575f3560e01c8063655b42f311610109578063c32d8c631161009e578063eae0328b1161006e578063eae0328b146104a6578063edaab54a146104b9578063f8ee77d6146104cc578063fda2892e146104d5575f5ffd5b8063c32d8c6314610439578063c8bc4e431461044c578063e5b123da14610474578063e94e051e14610493575f5ffd5b80638c1b3a40116100d95780638c1b3a40146103e1578063908517e9146103f4578063b2a1408e14610407578063bce6f54f1461041a575f5ffd5b8063655b42f314610370578063748926f3146103a8578063750e0c0f146103bb5780638826a370146103ce575f5ffd5b8063432bb78a1161017f57806351ed6a301161014f57806351ed6a301461030857806354b641511461031b5780635a48e0f41461033e5780635d9e244414610351575f5ffd5b8063432bb78a1461028357806346c2781a1461029657806348923bc5146102c357806348dd2924146102ee575f5ffd5b80631dce5166116101ba5780631dce51661461024b5780633e35f5e814610254578063416e66571461026757806342e1aaa814610270575f5ffd5b80624d8efe146101ea57806305fae141146102105780631a72d54c146102235780631c1b4f3a14610238575b5f5ffd5b6101fd6101f8366004615666565b6104f5565b6040519081526020015b60405180910390f35b6101fd61021e3660046156ac565b610577565b610236610231366004615762565b610bb8565b005b6101fd61024636600461582c565b611025565b6101fd600a5481565b6101fd61026236600461582c565b611044565b6101fd600b5481565b6101fd61027e36600461585a565b611056565b610236610291366004615875565b6110f2565b6008546102aa9067ffffffffffffffff1681565b60405167ffffffffffffffff9091168152602001610207565b6009546102d6906001600160a01b031681565b6040516001600160a01b039091168152602001610207565b6008546102d690600160401b90046001600160a01b031681565b6006546102d6906001600160a01b031681565b61032e61032936600461582c565b611199565b6040519015158152602001610207565b6101fd61034c36600461582c565b6111a5565b600d5461035e9060ff1681565b60405160ff9091168152602001610207565b61032e61037e3660046158bd565b6001600160a01b03919091165f908152600460209081526040808320938352929052205460ff1690565b6102366103b636600461582c565b6111b1565b61032e6103c936600461582c565b6112a0565b6102366103dc3660046158e7565b6112c9565b6102366103ef366004615910565b611330565b61032e61040236600461582c565b6114ef565b6102366104153660046159f2565b6114fb565b6101fd61042836600461582c565b5f9081526002602052604090205490565b6101fd610447366004615a29565b611874565b61045f61045a366004615a67565b6118d1565b60408051928352602083019190915201610207565b6101fd61048236600461582c565b5f9081526003602052604090205490565b6005546102d6906001600160a01b031681565b6101fd6104b436600461582c565b611a87565b6102366104c7366004615ae3565b611a9b565b6101fd600c5481565b6104e86104e336600461582c565b611af3565b6040516102079190615b2b565b6040805160f888901b6001600160f81b03191660208083019190915260218201889052604182018790526061820186905260818083018690528351808403909101815260a18301845280519082012060c183015260e18083018590528351808403909101815261010190920190925280519101205f905b979650505050505050565b5f5f60088054906101000a90046001600160a01b03166001600160a01b03166312ab3d3b6040518163ffffffff1660e01b8152600401602060405180830381865afa1580156105c8573d5f5f3e3d5ffd5b505050506040513d601f19601f820116820180604052508101906105ec9190615c35565b15905080801561068257506008546040517ffacd743b000000000000000000000000000000000000000000000000000000008152336004820152600160401b9091046001600160a01b03169063facd743b90602401602060405180830381865afa15801561065c573d5f5f3e3d5ffd5b505050506040513d601f19601f820116820180604052508101906106809190615c35565b155b156106c0576040517fed3db8ac0000000000000000000000000000000000000000000000000000000081523360048201526024015b60405180910390fd5b6107076040518061010001604052805f81526020015f81526020015f81526020015f81526020015f81526020015f60ff1681526020015f151581526020015f151581525090565b5f6107236107186020870187615c54565b600d5460ff16611c23565b90505f61072f82611056565b90506107396154a4565b5f83600281111561074c5761074c615b03565b03610a6b5761075e60a0880188615c6d565b90505f0361077f57604051630c9ccac560e41b815260040160405180910390fd5b5f8061078e60a08a018a615c6d565b81019061079b9190615f15565b925092505060088054906101000a90046001600160a01b03166001600160a01b031663e51019a68a60600135835f0151846020015185604001516040518563ffffffff1660e01b81526004016107f49493929190615fde565b5f6040518083038186803b15801561080a575f5ffd5b505afa15801561081c573d5f5f3e3d5ffd5b505060085460208481015186519187015160408089015190517fe51019a6000000000000000000000000000000000000000000000000000000008152600160401b9095046001600160a01b0316965063e51019a6955061088194929392600401615fde565b5f6040518083038186803b158015610897575f5ffd5b505afa1580156108a9573d5f5f3e3d5ffd5b50505050805f01516040015189602001351461090657805160409081015190517f3a63e99a00000000000000000000000000000000000000000000000000000000815260208b0135600482015260248101919091526044016106b7565b6040805160c08101825260608b01358082526020848101519083015260085483517fe531d8c700000000000000000000000000000000000000000000000000000000815260048101929092529192830191600160401b90046001600160a01b03169063e531d8c790602401602060405180830381865afa15801561098c573d5f5f3e3d5ffd5b505050506040513d601f19601f820116820180604052508101906109b09190615c35565b151581526008546020848101516040517f56bbc9e600000000000000000000000000000000000000000000000000000000815260048101919091529201915f91600160401b90046001600160a01b0316906356bbc9e690602401602060405180830381865afa158015610a25573d5f5f3e3d5ffd5b505050506040513d601f19601f82011682018060405250810190610a49919061602a565b67ffffffffffffffff1611815292516020840152905160409092019190915290505b600954600d54610a93916001918a9185916001600160a01b0390911690879060ff168b611ca8565b6006549094506001600160a01b03165f6007610ab260208b018b615c54565b60ff1681548110610ac557610ac5616045565b5f9182526020909120015490506001600160a01b03821615801590610ae957508015155b15610b24575f8660c00151610afe5730610b0b565b6005546001600160a01b03165b9050610b226001600160a01b038416338385611dd0565b505b85604001518660200151875f01517faa4b66b1ce938c06e2a3f8466bae10ef62e747630e3859889f4719fc6427b5a489606001518a608001518b60a001518c60c001518d60e00151604051610ba2959493929190948552602085019390935260ff919091166040840152151560608301521515608082015260a00190565b60405180910390a4505092519695505050505050565b5f54610100900460ff1615808015610bd657505f54600160ff909116105b80610bef5750303b158015610bef57505f5460ff166001145b610c615760405162461bcd60e51b815260206004820152602e60248201527f496e697469616c697a61626c653a20636f6e747261637420697320616c72656160448201527f647920696e697469616c697a656400000000000000000000000000000000000060648201526084016106b7565b5f805460ff191660011790558015610c82575f805461ff0019166101001790555b6001600160a01b038c16610cc2576040517fc83e086200000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b600880546001600160a01b03808f16600160401b027fffffffff0000000000000000000000000000000000000000ffffffffffffffff909216919091179091558a16610d3a576040517ffb60b0ef00000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b6009805473ffffffffffffffffffffffffffffffffffffffff19166001600160a01b038c1617905567ffffffffffffffff8b165f03610da5576040517f8a0eedcc00000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b6008805467ffffffffffffffff191667ffffffffffffffff8d161790556006805473ffffffffffffffffffffffffffffffffffffffff19166001600160a01b03888116919091179091558516610e27576040517f0f0ec8a800000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b6005805473ffffffffffffffffffffffffffffffffffffffff19166001600160a01b038716179055610e5889611e81565b610e7857604051633abfb6ff60e21b8152600481018a90526024016106b7565b600a899055610e8688611e81565b610ea657604051633abfb6ff60e21b8152600481018990526024016106b7565b600b889055610eb487611e81565b610ed457604051633abfb6ff60e21b8152600481018890526024016106b7565b600c87905560ff84165f03610f15576040517fa863d6e400000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b60fd8460ff161115610f58576040517f40d23bf000000000000000000000000000000000000000000000000000000000815260ff851660048201526024016106b7565b600d805460ff191660ff861617905581610f7385600261606d565b60ff1614610fc55781610f8785600261606d565b6040517f0aece9c0000000000000000000000000000000000000000000000000000000008152600481019290925260ff1660248201526044016106b7565b610fd1600784846154e5565b508015611017575f805461ff0019169055604051600181527f7f26b83ff96e1f2b6a682f133852f6798a09c465da95921460cefb38474024989060200160405180910390a15b505050505050505050505050565b60078181548110611034575f80fd5b5f91825260209091200154905081565b5f611050600183611ea7565b92915050565b5f8082600281111561106a5761106a615b03565b03611077575050600a5490565b600182600281111561108b5761108b615b03565b03611098575050600b5490565b60028260028111156110ac576110ac615b03565b036110b9575050600c5490565b816040517f3bf2e1ec0000000000000000000000000000000000000000000000000000000081526004016106b79190616086565b919050565b5f82900361112c576040517f521299a900000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b61115d838361113c600182616099565b81811061114b5761114b616045565b60019260209091020135905083612055565b505f5b828110156111935761118b84848381811061117d5761117d616045565b905060200201355f19611a9b565b600101611160565b50505050565b5f6110506001836120cc565b5f6110506001836120fe565b5f6111bd60018361214d565b90506111c8816121a0565b6006546009820154600780546001600160a01b03909316925f92600160481b900460ff169081106111fb576111fb616045565b5f9182526020909120015490506001600160a01b0382161580159061121f57508015155b15611240576008830154611240906001600160a01b038481169116836122aa565b5f848152600160205260409020611256906122f8565b604080516001600160a01b03851681526020810184905286917fa635398959ddb5ce3b14537edfc25b2e671274c9b8cad0f4bd634752e69007b6910160405180910390a350505050565b5f81815260016020526040812060080154600160a01b900467ffffffffffffffff161515611050565b600d545f9081906112e4906001908790879060ff168761236e565b91509150811561132957847fbe17755d8d836ad67bfaf8e5b3869aedb4cba03f295a167c5547feddd9ef50ad8260405161132091815260200190565b60405180910390a25b5050505050565b5f61133c6001896120fe565b6008546040517f04972af9000000000000000000000000000000000000000000000000000000008152919250600160401b90046001600160a01b0316906304972af99061138f9084908a906004016160ac565b5f6040518083038186803b1580156113a5575f5ffd5b505afa1580156113b7573d5f5f3e3d5ffd5b505050505f60405180606001604052808860800160208101906113da919061612c565b67ffffffffffffffff16815260200160088054906101000a90046001600160a01b03166001600160a01b031663e78cea926040518163ffffffff1660e01b8152600401602060405180830381865afa158015611438573d5f5f3e3d5ffd5b505050506040513d601f19601f8201168201806040525081019061145c9190616147565b6001600160a01b0390811682528935602090920191909152600954600d54600b54600c549495506114a4946001948f9416928e9288928e928e928e928e9260ff1691906123db565b5f8981526001602052604090206114ba906122f8565b6040518a907fe11db4b27bc8c6ea5943ecbb205ae1ca8d56c42c719717aaf8a53d43d0cee7c2905f90a3505050505050505050565b5f61105060018361276d565b5f61150760018461214d565b90506115128161284a565b6115745761151f8161286d565b600882015460078301546040517fe58c830800000000000000000000000000000000000000000000000000000000815260048101939093526001600160a01b03909116602483015260448201526064016106b7565b5f80806009840154600d546115969160ff600160481b90910481169116611c23565b60028111156115a7576115a7615b03565b149050808015611642575060085460078401546040517f308362280000000000000000000000000000000000000000000000000000000081526004810191909152600160401b9091046001600160a01b031690633083622890602401602060405180830381865afa15801561161e573d5f5f3e3d5ffd5b505050506040513d601f19601f820116820180604052508101906116429190615c35565b156117fa5760085460078401546040517fe51019a6000000000000000000000000000000000000000000000000000000008152600160401b9092046001600160a01b03169163e51019a6916116a791889060c08201359060e083013590600401616162565b5f6040518083038186803b1580156116bd575f5ffd5b505afa1580156116cf573d5f5f3e3d5ffd5b50506008546040517f1171558500000000000000000000000000000000000000000000000000000000815260c08801356004820152600160401b9091046001600160a01b0316925063117155859150602401602060405180830381865afa15801561173c573d5f5f3e3d5ffd5b505050506040513d601f19601f82011682018060405250810190611760919061602a565b6008546040517f56bbc9e600000000000000000000000000000000000000000000000000000000815260c08701356004820152600160401b9091046001600160a01b0316906356bbc9e690602401602060405180830381865afa1580156117c9573d5f5f3e3d5ffd5b505050506040513d601f19601f820116820180604052508101906117ed919061602a565b6117f791906161f0565b91505b6008545f90611819906001908890869067ffffffffffffffff1661290d565b5f878152600160205260409020909150611832906122f8565b867f2e0808830a22204cb3fb8f8d784b28bc97e9ce2e39d2f9cde2860de0957d68eb8360405161186491815260200190565b60405180910390a3505050505050565b6040805160f887901b6001600160f81b03191660208083019190915260218201879052604182018690526061820185905260818083018590528351808403909101815260a190920190925280519101205f905b9695505050505050565b5f5f5f5f5f61191c898989898080601f0160208091040260200160405190810160405280939291908181526020018383808284375f9201919091525060019594939250506129f19050565b8151929550909350915015806119b35782604001518360200151845f01517faa4b66b1ce938c06e2a3f8466bae10ef62e747630e3859889f4719fc6427b5a4866060015187608001518860a001518960c001518a60e001516040516119aa959493929190948552602085019390935260ff919091166040840152151560608301521515608082015260a00190565b60405180910390a45b81604001518260200151835f01517faa4b66b1ce938c06e2a3f8466bae10ef62e747630e3859889f4719fc6427b5a4856060015186608001518760a001518860c001518960e00151604051611a31959493929190948552602085019390935260ff919091166040840152151560608301521515608082015260a00190565b60405180910390a48151604051821515815285908c907f7340510d24b7ec9b5c100f5500d93429d80d00d46f0d18e4e85d0c4cc22b99249060200160405180910390a45051919350909150505b94509492505050565b5f611050611a9660018461214d565b612e1b565b5f80611aa960018585612e5e565b91509150811561119357837fbe17755d8d836ad67bfaf8e5b3869aedb4cba03f295a167c5547feddd9ef50ad82604051611ae591815260200190565b60405180910390a250505050565b611afb61552e565b611b0660018361214d565b604080516101e0810182528254815260018084015460208301526002840154928201929092526003830154606082015260048301546080820152600583015460a0820152600683015460c0820152600783015460e082015260088301546001600160a01b038116610100830152600160a01b900467ffffffffffffffff9081166101208301526009840154908116610140830152909291610160840191600160401b900460ff1690811115611bbd57611bbd615b03565b6001811115611bce57611bce615b03565b81526009919091015460ff600160481b8204811660208401526a01000000000000000000008204161515604083015267ffffffffffffffff6b0100000000000000000000009091041660609091015292915050565b5f8260ff165f03611c3557505f611050565b8160ff168360ff1611611c4a57506001611050565b611c5582600161606d565b60ff168360ff1603611c6957506002611050565b6040517fae0da57800000000000000000000000000000000000000000000000000000000815260ff8085166004830152831660248201526044016106b7565b611cef6040518061010001604052805f81526020015f81526020015f81526020015f81526020015f81526020015f60ff1681526020015f151581526020015f151581525090565b5f5f611cfe8a8a8a8a89612e82565b915091505f611d0e838b896133d7565b90505f611d1c83838d613519565b90508515611db6575f611d2e8261354b565b335f90815260038f016020908152604080832084845290915290205490915060ff1615611d90576040517f5a46ac3a000000000000000000000000000000000000000000000000000000008152336004820152602481018290526044016106b7565b335f90815260038e016020908152604080832093835292905220805460ff191660011790555b611dc08c826135b8565b9c9b505050505050505050505050565b6040516001600160a01b03808516602483015283166044820152606481018290526111939085907f23b872dd00000000000000000000000000000000000000000000000000000000906084015b60408051601f198184030181529190526020810180517bffffffffffffffffffffffffffffffffffffffffffffffffffffffff167fffffffff000000000000000000000000000000000000000000000000000000009093169290921790915261399b565b5f815f03611e9057505f919050565b5f611e9c600184616099565b929092161592915050565b5f81815260208390526040812060080154600160a01b900467ffffffffffffffff16611ee85760405162a7b02b60e01b8152600481018390526024016106b7565b5f828152602084905260408120611efe906122f8565b5f818152600186016020526040812054919250819003611f4a576040517fda10f67c00000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b6040516815539492559053115160ba1b6020820152602901604051602081830303815290604052805190602001208103611fb3575f84815260208690526040902060080154611faa90600160a01b900467ffffffffffffffff1643616099565b92505050611050565b5f81815260208690526040902060080154600160a01b900467ffffffffffffffff16611ff45760405162a7b02b60e01b8152600481018290526024016106b7565b5f81815260208690526040808220600890810154878452919092209091015467ffffffffffffffff600160a01b9283900481169290910416808211156120495761203e8183616099565b945050505050611050565b5f945050505050611050565b5f828152602084905260408120600901546b010000000000000000000000900467ffffffffffffffff168281106120c2576040517fd1f5928100000000000000000000000000000000000000000000000000000000815260048101829052602481018490526044016106b7565b90505b9392505050565b5f6120d7838361276d565b80156120c557505f8281526020849052604090206120f490612e1b565b6001149392505050565b5f5f61210a848461214d565b90505b6009810154600160481b900460ff16156121455780545f90815260018501602052604090205461213d858261214d565b91505061210d565b549392505050565b5f81815260208390526040812060080154600160a01b900467ffffffffffffffff1661218e5760405162a7b02b60e01b8152600481018390526024016106b7565b505f9081526020919091526040902090565b60016009820154600160401b900460ff1660018111156121c2576121c2615b03565b14612213576121d08161286d565b60098201546040517fef1267b40000000000000000000000000000000000000000000000000000000081526106b79291600160401b900460ff1690600401616210565b61221c8161284a565b6122295761151f8161286d565b60098101546a0100000000000000000000900460ff161515600103612286576122518161286d565b6040517f307f76690000000000000000000000000000000000000000000000000000000081526004016106b791815260200190565b60090180546aff0000000000000000000019166a0100000000000000000000179055565b6040516001600160a01b0383166024820152604481018290526122f39084907fa9059cbb0000000000000000000000000000000000000000000000000000000090606401611e1d565b505050565b6009810154815460028301546001840154600485015460408051600160481b90960460f81b6001600160f81b0319166020808801919091526021870195909552604186019390935260618501919091526081808501919091528151808503909101815260a1909301905281519101205f90611050565b5f5f5f61237b8888611ea7565b905061238988888888613a7f565b5f868152602089905260409020600901546123bd906b010000000000000000000000900467ffffffffffffffff1682616224565b90506123cb88888387613c39565b92509250505b9550959350505050565b5f8b815260208d90526040902060080154600160a01b900467ffffffffffffffff1661241c5760405162a7b02b60e01b8152600481018c90526024016106b7565b60025f8c815260208e9052604090206009015461244390600160481b900460ff1685611c23565b600281111561245457612454615b03565b146124a9575f8b815260208d90526040908190206009015490517f348aefdf000000000000000000000000000000000000000000000000000000008152600160481b90910460ff1660048201526024016106b7565b5f8b815260208d9052604090206124bf90612e1b565b600114612511575f8b815260208d9052604090206124dc90612e1b565b6040517f6b595e500000000000000000000000000000000000000000000000000000000081526004016106b791815260200190565b5f8b815260208d905260409020600201548b825b60018f5f015f8481526020019081526020015f2060090160099054906101000a900460ff1660ff1611156125c0575f8f5f015f8481526020019081526020015f205f015490508f6001015f8281526020019081526020015f205492508f5f015f8481526020019081526020015f2060020154826125a29190616237565b6125ac9085616224565b93506125b88683616237565b915050612525565b50506126188d5f015f8e81526020019081526020015f20600101548b5f0135838b8b808060200260200160405190810160405280939291908181526020018383602002808284375f92019190915250613cce92505050565b5f8b6001600160a01b031663b5112fd28b848e5f01358f806020019061263e9190615c6d565b6040518663ffffffff1660e01b815260040161265e95949392919061624e565b602060405180830381865afa158015612679573d5f5f3e3d5ffd5b505050506040513d601f19601f8201168201806040525081019061269d91906162af565b90506126fe8e5f015f8f81526020019081526020015f2060030154828460016126c69190616224565b8a8a808060200260200160405190810160405280939291908181526020018383602002808284375f92019190915250613cce92505050565b5f8d815260208f90526040902061271490613d53565b61271e8e8e613dee565b5050505f998a5250505060209790975250506040909320600901805472ffffffffffffffff0000000000000000000000191672ffffffffffffffff000000000000000000000017905550505050565b5f81815260208390526040812060080154600160a01b900467ffffffffffffffff166127ae5760405162a7b02b60e01b8152600481018390526024016106b7565b5f8281526020849052604081206127c4906122f8565b5f818152600186016020526040812054919250819003612810576040517fda10f67c00000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b6040516815539492559053115160ba1b602082015260290160408051601f1981840301815291905280516020909101201415949350505050565b60078101545f9015801590611050575050600801546001600160a01b0316151590565b60098101548154600283015460018401546004850154600386015460408051600160481b90970460f81b6001600160f81b0319166020808901919091526021880196909652604187019490945260618601929092526081808601919091528251808603909101815260a18501835280519084012060c185015260e18085019190915281518085039091018152610101909301905281519101205f90611050565b5f83815260208590526040812060080154600160a01b900467ffffffffffffffff1661294e5760405162a7b02b60e01b8152600481018590526024016106b7565b5f6129598686613e6e565b905061296f67ffffffffffffffff851682616224565b90508267ffffffffffffffff168110156129c8576040517f11a8d4d00000000000000000000000000000000000000000000000000000000081526004810182905267ffffffffffffffff841660248201526044016106b7565b5f8581526020879052604090206129de90613d53565b6129e88686613dee565b95945050505050565b60408051610100810182525f80825260208201819052918101829052606081018290526080810182905260a0810182905260c0810182905260e08101829052612a776040518061010001604052805f81526020015f81526020015f81526020015f81526020015f81526020015f60ff1681526020015f151581526020015f151581525090565b5f5f87815260208990526040902060090154600160401b900460ff166001811115612aa457612aa4615b03565b14612afb575f86815260208890526040908190206009015490517f23f8405d0000000000000000000000000000000000000000000000000000000081526106b7918891600160401b90910460ff1690600401616210565b612b05878761276d565b612b3e576040517f80e07e45000000000000000000000000000000000000000000000000000000008152600481018790526024016106b7565b5f868152602088905260408120604080516101e0810182528254815260018084015460208301526002840154928201929092526003830154606082015260048301546080820152600583015460a0820152600683015460c0820152600783015460e082015260088301546001600160a01b038116610100830152600160a01b900467ffffffffffffffff9081166101208301526009840154908116610140830152909291610160840191600160401b900460ff1690811115612c0257612c02615b03565b6001811115612c1357612c13615b03565b815260099190910154600160481b810460ff90811660208401526a010000000000000000000082041615156040808401919091526b01000000000000000000000090910467ffffffffffffffff1660609092019190915281015160808201519192505f91612c819190613ef9565b90505f5f87806020019051810190612c999190616321565b9092509050612cc989612cad856001616224565b60608701516080880151612cc2906001616224565b8686613fa2565b505060408051610100810182525f80825260208201819052918101829052606081018290526080810182905260a0810182905260c0810182905260e081018290525f612d29855f0151866020015187604001518d888a61018001516142c3565b9050612d348161435b565b5f81815260208e90526040902060080154909350600160a01b900467ffffffffffffffff16612d6a57612d678c826135b8565b91505b50612db26040518061010001604052805f81526020015f81526020015f81526020015f81526020015f81526020015f60ff1681526020015f151581526020015f151581525090565b5f612dd1865f01518c8789606001518a608001518b61018001516142c3565b9050612ddd8d826135b8565b915050612e0983825f01518e5f015f8f81526020019081526020015f206143f29092919063ffffffff16565b919b909a509098509650505050505050565b5f5f82600201548360040154612e319190616099565b9050805f0361105057612e438361286d565b60405162a7b02b60e01b81526004016106b791815260200190565b5f5f612e758585612e6f8888613e6e565b86613c39565b915091505b935093915050565b612ea460405180606001604052805f81526020015f8152602001606081525090565b5f80612ebc612eb66020890189615c54565b85611c23565b6002811115612ecd57612ecd615b03565b036131e157602085015185515f03612f11576040517fe96bc61a00000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b8551606088013514612f5f5785516040517f5b177a3c0000000000000000000000000000000000000000000000000000000081526004810191909152606088013560248201526044016106b7565b8560400151612f9a576040517fc169243600000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b8560600151612fd5576040517fb45d1c3a00000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b612fe260a0880188615c6d565b90505f0361300357604051630c9ccac560e41b815260040160405180910390fd5b5f61301160a0890189615c6d565b81019061301e9190615f15565b509091505f9050876080015160200151600281111561303f5761303f615b03565b03613076576040517f46365e5200000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b5f8760a0015160200151600281111561309157613091615b03565b036130c8576040517f8999857d00000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b5f866001600160a01b031663c39619c46130e58a60800151614472565b6040518263ffffffff1660e01b81526004016131019190616386565b602060405180830381865afa15801561311c573d5f5f3e3d5ffd5b505050506040513d601f19601f8201168201806040525081019061314091906162af565b90505f876001600160a01b031663c39619c461315f8b60a00151614472565b6040518263ffffffff1660e01b815260040161317b9190616386565b602060405180830381865afa158015613196573d5f5f3e3d5ffd5b505050506040513d601f19601f820116820180604052508101906131ba91906162af565b60408051606081018252938452602084019190915282019290925293509091506123d19050565b6131ef8787606001356120cc565b61322b576040517fff6d9bd7000000000000000000000000000000000000000000000000000000008152606087013560048201526024016106b7565b60608601355f90815260208890526040812090613247826122f8565b90505f6009830154600160401b900460ff16600181111561326a5761326a615b03565b146132a1576040517f12459ffd00000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b60098201546132ba90600160481b900460ff16866144ac565b60ff166132ca60208a018a615c54565b60ff161461332c576132df6020890189615c54565b60098301546040517fac9e611600000000000000000000000000000000000000000000000000000000815260ff9283166004820152600160481b90910490911660248201526044016106b7565b61333960a0890189615c6d565b90505f0361335a57604051630c9ccac560e41b815260040160405180910390fd5b5f8080808061336c60a08e018e615c6d565b81019061337991906163b3565b94509450945094509450613397876001015486896002015486613cce565b6133ab876003015485896004015485613cce565b6040518060600160405280868152602001858152602001828152508698509850505050505050506123d1565b604080515f8082526020820190925281906133fc906133f79087516144cd565b614502565b905061340783611e81565b61342757604051633abfb6ff60e21b8152600481018490526024016106b7565b8284604001351461347157604080517fdfcc62bc000000000000000000000000000000000000000000000000000000008152908501356004820152602481018490526044016106b7565b61348d8460200135866020015186604001358860400151613cce565b61349a6080850185615c6d565b90505f036134d4576040517f342a075200000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b5f806134e36080870187615c6d565b8101906134f09190616454565b909250905061350e8360016020890135612cc260408b013583616224565b509095945050505050565b61352161552e565b6120c284845f602086018035906040880135906060890135903390613546908b615c54565b614692565b61018081015181516040808401516020808601516080870151845160f89790971b6001600160f81b031916878401526021870195909552604186019290925260618501919091526081808501939093528151808503909301835260a1909301905280519101205f90611050565b6135ff6040518061010001604052805f81526020015f81526020015f81526020015f81526020015f81526020015f60ff1681526020015f151581526020015f151581525090565b5f6136098361435b565b5f81815260208690526040902060080154909150600160a01b900467ffffffffffffffff1615613668576040517fbcedf3de000000000000000000000000000000000000000000000000000000008152600481018290526024016106b7565b5f81815260208581526040918290208551815590850151600180830191909155918501516002820155606085015160038201556080850151600482015560a0850151600582015560c0850151600682015560e0850151600782015561010085015160088201805461012088015167ffffffffffffffff908116600160a01b027fffffffff000000000000000000000000000000000000000000000000000000009092166001600160a01b03909416939093171790556101408601516009830180549190921667ffffffffffffffff19821681178355610160880151889590939268ffffffffffffffffff191690911790600160401b90849081111561376f5761376f615b03565b02179055506101808281015160099290920180546101a08501516101c09095015167ffffffffffffffff166b0100000000000000000000000272ffffffffffffffff0000000000000000000000199515156a0100000000000000000000026aff000000000000000000001960ff909616600160481b02959095167fffffffffffffffffffffffffffffffffffffffffff0000ffffffffffffffffff909216919091179390931793909316919091179091558301518351604080860151602080880151608089015184516001600160f81b031960f89890981b97909716878401526021870195909552604186019290925260618501919091526081808501939093528151808503909301835260a1909301905280519101205f905f8181526001870160205260408120549192508190036138e5576040516815539492559053115160ba1b602082015260290160408051601f1981840301815291815281516020928301205f85815260018a0190935291205561392c565b6040516815539492559053115160ba1b602082015260290160405160208183030381529060405280519060200120810361392c575f82815260018701602052604090208390555b6040805161010081018252848152602080820185905287518284015260e088015160608301525f8681529089905291909120608082019061396c90612e1b565b815261018087015160ff166020820152911515604083015260e090950151151560609091015250919392505050565b5f6139ef826040518060400160405280602081526020017f5361666545524332303a206c6f772d6c6576656c2063616c6c206661696c6564815250856001600160a01b03166147c99092919063ffffffff16565b8051909150156122f35780806020019051810190613a0d9190615c35565b6122f35760405162461bcd60e51b815260206004820152602a60248201527f5361666545524332303a204552433230206f7065726174696f6e20646964206e60448201527f6f7420737563636565640000000000000000000000000000000000000000000060648201526084016106b7565b5f828152602085905260409020600701548314613ae5575f82815260208590526040908190206007015490517fc2adc3e80000000000000000000000000000000000000000000000000000000081526106b7918591600401918252602082015260400190565b5f82815260208590526040808220548583529120613b02906122f8565b14613b67575f838152602085905260409020613b1d906122f8565b5f83815260208690526040908190205490517fe2e27f87000000000000000000000000000000000000000000000000000000008152600481019290925260248201526044016106b7565b5f82815260208590526040808220600990810154868452919092209091015460ff600160481b92839004811692613ba0920416836144ac565b60ff1614611193575f8381526020859052604090206009015483908390613bd190600160481b900460ff16846144ac565b5f85815260208890526040908190206009015490517f7e726d150000000000000000000000000000000000000000000000000000000081526004810194909452602484019290925260ff9081166044840152600160481b9091041660648201526084016106b7565b5f5f5f613c47878786612055565b905067ffffffffffffffff8511613c5e5784613c68565b67ffffffffffffffff5b945080851115613cc1575050505f838152602085905260409020600901805472ffffffffffffffff000000000000000000000019166b01000000000000000000000067ffffffffffffffff851602179055600182611a7e565b5f97909650945050505050565b5f613d02828486604051602001613ce791815260200190565b604051602081830303815290604052805190602001206147d7565b90508085146113295760405162461bcd60e51b815260206004820152601760248201527f496e76616c696420696e636c7573696f6e2070726f6f6600000000000000000060448201526064016106b7565b5f6009820154600160401b900460ff166001811115613d7457613d74615b03565b14613dc557613d828161286d565b60098201546040517f23f8405d0000000000000000000000000000000000000000000000000000000081526106b79291600160401b900460ff1690600401616210565b600901805467ffffffffffffffff431668ffffffffffffffffff1990911617600160401b179055565b5f818152602083905260408120613e04906122f8565b5f8181526002850160205260409020549091508015613e59576040517fdd7028f000000000000000000000000000000000000000000000000000000000815260048101849052602481018290526044016106b7565b505f9081526002909201602052604090912055565b5f5f613e7a8484611ea7565b5f84815260208690526040902060050154909150156120c5575f8381526020859052604080822060058101548352818320600990810154600690920154845291909220015467ffffffffffffffff6b0100000000000000000000009283900481169290910416808210613eed5780613eef565b815b6118c79084616224565b5f6002613f068484616099565b1015613f48576040517f9029859400000000000000000000000000000000000000000000000000000000815260048101849052602481018390526044016106b7565b613f528383616099565b600203613f6b57613f64836001616224565b9050611050565b5f83613f78600185616099565b1890505f613f858261488a565b90505f19811b80613f97600187616099565b169695505050505050565b5f8511613ff15760405162461bcd60e51b815260206004820152601460248201527f5072652d73697a652063616e6e6f74206265203000000000000000000000000060448201526064016106b7565b85613ffb83614502565b146140485760405162461bcd60e51b815260206004820152601b60248201527f50726520657870616e73696f6e20726f6f74206d69736d61746368000000000060448201526064016106b7565b84614052836149c4565b146140c55760405162461bcd60e51b815260206004820152602160248201527f5072652073697a6520646f6573206e6f74206d6174636820657870616e73696f60448201527f6e0000000000000000000000000000000000000000000000000000000000000060648201526084016106b7565b8285106141145760405162461bcd60e51b815260206004820181905260248201527f5072652073697a65206e6f74206c657373207468616e20706f73742073697a6560448201526064016106b7565b5f8590505f5f90505f614129855f8751614a13565b90505b858310156141eb575f61413f8488614b87565b9050845183106141915760405162461bcd60e51b815260206004820152601260248201527f496e646578206f7574206f662072616e6765000000000000000000000000000060448201526064016106b7565b6141b582828786815181106141a8576141a8616045565b6020026020010151614c6e565b91506001811b6141c58186616224565b9450878511156141d7576141d76164af565b836141e1816164c3565b945050505061412c565b866141f582614502565b146142685760405162461bcd60e51b815260206004820152602260248201527f506f737420657870616e73696f6e20726f6f74206e6f7420657175616c20706f60448201527f737400000000000000000000000000000000000000000000000000000000000060648201526084016106b7565b835182146142b85760405162461bcd60e51b815260206004820152601660248201527f496e636f6d706c6574652070726f6f662075736167650000000000000000000060448201526064016106b7565b505050505050505050565b6142cb61552e565b6142d887878787876151d6565b50604080516101e081018252968752602087019590955293850192909252606084015260808301525f60a0830181905260c0830181905260e08301819052610100830181905267ffffffffffffffff43166101208401526101408301819052610160830181905260ff9091166101808301526101a082018190526101c082015290565b610180810151815160408084015160208086015160808701516060880151855160f89890981b6001600160f81b031916888501526021880196909652604187019390935260618601526081808601929092528251808603909201825260a18501835281519181019190912060c185015260e18085019390935281518085039093018352610101909301905280519101205f90611050565b60058301541515806144075750600683015415155b15614462576144158361286d565b600584015460068501546040517f8b0e71d00000000000000000000000000000000000000000000000000000000081526004810193909352602483019190915260448201526064016106b7565b6005830191909155600690910155565b61447a6155c5565b6040518060400160405280835f01518152602001836020015160028111156144a4576144a4615b03565b905292915050565b5f806144b984600161606d565b90506144c58184611c23565b509392505050565b60606120c5835f846040516020016144e791815260200190565b60405160208183030381529060405280519060200120614c6e565b5f5f8251116145535760405162461bcd60e51b815260206004820152601660248201527f456d707479206d65726b6c6520657870616e73696f6e0000000000000000000060448201526064016106b7565b6040825111156145a55760405162461bcd60e51b815260206004820152601a60248201527f4d65726b6c6520657870616e73696f6e20746f6f206c6172676500000000000060448201526064016106b7565b5f805b835181101561468b575f8482815181106145c4576145c4616045565b60200260200101519050825f5f1b0361462e57801561462957809250600185516145ee9190616099565b8214614629576040516146109084905f90602001918252602082015260400190565b6040516020818303038152906040528051906020012092505b614682565b801561464d576040805160208101839052908101849052606001614610565b6040516146699084905f90602001918252602082015260400190565b6040516020818303038152906040528051906020012092505b506001016145a8565b5092915050565b61469a61552e565b6001600160a01b0383166146da576040517ff289e65700000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b5f849003614714576040517f6932bcfd00000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b61472189898989896151d6565b604051806101e001604052808a81526020018981526020018881526020018781526020018681526020015f5f1b81526020015f5f1b8152602001858152602001846001600160a01b031681526020014367ffffffffffffffff1681526020015f67ffffffffffffffff1681526020015f60018111156147a2576147a2615b03565b815260ff841660208201525f60408201819052606090910152905098975050505050505050565b60606120c284845f856152c7565b82515f90610100811115614822576040517ffdac331e0000000000000000000000000000000000000000000000000000000081526004810182905261010060248201526044016106b7565b825f5b82811015614880575f87828151811061484057614840616045565b60200260200101519050816001901b87165f0361486957825f528060205260405f209250614877565b805f528260205260405f2092505b50600101614825565b5095945050505050565b5f815f036148da5760405162461bcd60e51b815260206004820152601c60248201527f5a65726f20686173206e6f207369676e69666963616e7420626974730000000060448201526064016106b7565b700100000000000000000000000000000000821061490557608091821c916149029082616224565b90505b600160401b821061492357604091821c916149209082616224565b90505b640100000000821061494257602091821c9161493f9082616224565b90505b62010000821061495f57601091821c9161495c9082616224565b90505b610100821061497b57600891821c916149789082616224565b90505b6010821061499657600491821c916149939082616224565b90505b600482106149b157600291821c916149ae9082616224565b90505b600282106110ed57611050600182616224565b5f80805b835181101561468b578381815181106149e3576149e3616045565b60200260200101515f5f1b14614a0b576149fe8160026165b6565b614a089083616224565b91505b6001016149c8565b6060818310614a645760405162461bcd60e51b815260206004820152601760248201527f5374617274206e6f74206c657373207468616e20656e6400000000000000000060448201526064016106b7565b8351821115614adb5760405162461bcd60e51b815260206004820152602160248201527f456e64206e6f74206c657373206f7220657175616c207468616e206c656e677460448201527f680000000000000000000000000000000000000000000000000000000000000060648201526084016106b7565b5f614ae68484616099565b67ffffffffffffffff811115614afe57614afe615cce565b604051908082528060200260200182016040528015614b27578160200160208202803683370190505b509050835b83811015614b7e57858181518110614b4657614b46616045565b6020026020010151828683614b5b9190616099565b81518110614b6b57614b6b616045565b6020908102919091010152600101614b2c565b50949350505050565b5f818310614bd75760405162461bcd60e51b815260206004820152601760248201527f5374617274206e6f74206c657373207468616e20656e6400000000000000000060448201526064016106b7565b5f614be383851861488a565b90505f6001614bf28382616224565b6001901b614c009190616099565b90508481168482168115614c175761203e82615400565b8015614c265761203e8161488a565b60405162461bcd60e51b815260206004820152601b60248201527f426f7468207920616e64207a2063616e6e6f74206265207a65726f000000000060448201526064016106b7565b606060408310614cc05760405162461bcd60e51b815260206004820152600e60248201527f4c6576656c20746f6f206869676800000000000000000000000000000000000060448201526064016106b7565b5f829003614d105760405162461bcd60e51b815260206004820152601b60248201527f43616e6e6f7420617070656e6420656d7074792073756274726565000000000060448201526064016106b7565b604084511115614d625760405162461bcd60e51b815260206004820152601a60248201527f4d65726b6c6520657870616e73696f6e20746f6f206c6172676500000000000060448201526064016106b7565b83515f03614ddf575f614d76846001616224565b67ffffffffffffffff811115614d8e57614d8e615cce565b604051908082528060200260200182016040528015614db7578160200160208202803683370190505b50905082818581518110614dcd57614dcd616045565b602090810291909101015290506120c5565b83518310614e555760405162461bcd60e51b815260206004820152603560248201527f4c6576656c2067726561746572207468616e2068696768657374206c6576656c60448201527f206f662063757272656e7420657870616e73696f6e000000000000000000000060648201526084016106b7565b815f614e60866149c4565b90505f614e6e8660026165b6565b614e789083616224565b90505f614e848361488a565b614e8d8361488a565b11614edb57875167ffffffffffffffff811115614eac57614eac615cce565b604051908082528060200260200182016040528015614ed5578160200160208202803683370190505b50614f2b565b8751614ee8906001616224565b67ffffffffffffffff811115614f0057614f00615cce565b604051908082528060200260200182016040528015614f29578160200160208202803683370190505b505b9050604081511115614f7f5760405162461bcd60e51b815260206004820152601c60248201527f417070656e642063726561746573206f76657273697a6520747265650000000060448201526064016106b7565b5f5b885181101561512b578781101561502757888181518110614fa457614fa4616045565b60200260200101515f5f1b146150225760405162461bcd60e51b815260206004820152602260248201527f417070656e642061626f7665206c65617374207369676e69666963616e74206260448201527f697400000000000000000000000000000000000000000000000000000000000060648201526084016106b7565b615123565b5f85900361506c5788818151811061504157615041616045565b602002602001015182828151811061505b5761505b616045565b602002602001018181525050615123565b88818151811061507e5761507e616045565b60200260200101515f5f1b036150b457848282815181106150a1576150a1616045565b60209081029190910101525f9450615123565b5f5f1b8282815181106150c9576150c9616045565b6020026020010181815250508881815181106150e7576150e7616045565b60200260200101518560405160200161510a929190918252602082015260400190565b6040516020818303038152906040528051906020012094505b600101614f81565b50831561515f578381600183516151429190616099565b8151811061515257615152616045565b6020026020010181815250505b806001825161516e9190616099565b8151811061517e5761517e616045565b60200260200101515f5f1b0361056c5760405162461bcd60e51b815260206004820152600f60248201527f4c61737420656e747279207a65726f000000000000000000000000000000000060448201526064016106b7565b5f859003615210576040517f8d79dbbc00000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b828111615253576040517f2060faf400000000000000000000000000000000000000000000000000000000815260048101849052602481018290526044016106b7565b5f84900361528d576040517f83c683e400000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b5f829003611329576040517f5cb6e5bb00000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b60608247101561533f5760405162461bcd60e51b815260206004820152602660248201527f416464726573733a20696e73756666696369656e742062616c616e636520666f60448201527f722063616c6c000000000000000000000000000000000000000000000000000060648201526084016106b7565b6001600160a01b0385163b6153965760405162461bcd60e51b815260206004820152601d60248201527f416464726573733a2063616c6c20746f206e6f6e2d636f6e747261637400000060448201526064016106b7565b5f5f866001600160a01b031685876040516153b191906165c1565b5f6040518083038185875af1925050503d805f81146153eb576040519150601f19603f3d011682016040523d82523d5f602084013e6153f0565b606091505b509150915061056c82828661546b565b5f5f82116154505760405162461bcd60e51b815260206004820152601c60248201527f5a65726f20686173206e6f207369676e69666963616e7420626974730000000060448201526064016106b7565b5f828061545e600182616099565b161890506120c58161488a565b6060831561547a5750816120c5565b82511561548a5782518084602001fd5b8160405162461bcd60e51b81526004016106b791906165d7565b6040518060c001604052805f81526020015f81526020015f151581526020015f151581526020016154d36155e3565b81526020016154e06155e3565b905290565b828054828255905f5260205f2090810192821561551e579160200282015b8281111561551e578235825591602001919060010190615503565b5061552a929150615608565b5090565b604051806101e001604052805f81526020015f81526020015f81526020015f81526020015f81526020015f81526020015f81526020015f81526020015f6001600160a01b031681526020015f67ffffffffffffffff1681526020015f67ffffffffffffffff1681526020015f60018111156155ab576155ab615b03565b81525f602082018190526040820181905260609091015290565b60405180604001604052806155d861561c565b81526020015f905290565b60405180606001604052806155f661561c565b81526020015f81526020015f81525090565b5b8082111561552a575f8155600101615609565b604051806040016040528061562f615638565b81526020016154e05b60405180604001604052806002906020820280368337509192915050565b803560ff811681146110ed575f5ffd5b5f5f5f5f5f5f60c0878903121561567b575f5ffd5b61568487615656565b9860208801359850604088013597606081013597506080810135965060a00135945092505050565b5f602082840312156156bc575f5ffd5b813567ffffffffffffffff8111156156d2575f5ffd5b820160c081850312156120c5575f5ffd5b6001600160a01b03811681146156f7575f5ffd5b50565b67ffffffffffffffff811681146156f7575f5ffd5b80356110ed816156e3565b5f5f83601f84011261572a575f5ffd5b50813567ffffffffffffffff811115615741575f5ffd5b6020830191508360208260051b850101111561575b575f5ffd5b9250929050565b5f5f5f5f5f5f5f5f5f5f5f6101408c8e03121561577d575f5ffd5b8b35615788816156e3565b9a5060208c0135615798816156fa565b995060408c01356157a8816156e3565b985060608c0135975060808c0135965060a08c0135955060c08c01356157cd816156e3565b94506157db60e08d0161570f565b93506157ea6101008d01615656565b92506101208c013567ffffffffffffffff811115615806575f5ffd5b6158128e828f0161571a565b915080935050809150509295989b509295989b9093969950565b5f6020828403121561583c575f5ffd5b5035919050565b600381106156f7575f5ffd5b80356110ed81615843565b5f6020828403121561586a575f5ffd5b81356120c581615843565b5f5f5f60408486031215615887575f5ffd5b833567ffffffffffffffff81111561589d575f5ffd5b6158a98682870161571a565b909790965060209590950135949350505050565b5f5f604083850312156158ce575f5ffd5b82356158d9816156e3565b946020939093013593505050565b5f5f5f606084860312156158f9575f5ffd5b505081359360208301359350604090920135919050565b5f5f5f5f5f5f5f878903610120811215615928575f5ffd5b88359750602089013567ffffffffffffffff811115615945575f5ffd5b89016040818c031215615956575f5ffd5b965060a07fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc082011215615987575f5ffd5b5060408801945060e088013567ffffffffffffffff8111156159a7575f5ffd5b6159b38a828b0161571a565b90955093505061010088013567ffffffffffffffff8111156159d3575f5ffd5b6159df8a828b0161571a565b989b979a50959850939692959293505050565b5f5f828403610120811215615a05575f5ffd5b83359250610100601f1982011215615a1b575f5ffd5b506020830190509250929050565b5f5f5f5f5f60a08688031215615a3d575f5ffd5b615a4686615656565b97602087013597506040870135966060810135965060800135945092505050565b5f5f5f5f60608587031215615a7a575f5ffd5b8435935060208501359250604085013567ffffffffffffffff811115615a9e575f5ffd5b8501601f81018713615aae575f5ffd5b803567ffffffffffffffff811115615ac4575f5ffd5b876020828401011115615ad5575f5ffd5b949793965060200194505050565b5f5f60408385031215615af4575f5ffd5b50508035926020909101359150565b634e487b7160e01b5f52602160045260245ffd5b60028110615b2757615b27615b03565b9052565b5f6101e082019050825182526020830151602083015260408301516040830152606083015160608301526080830151608083015260a083015160a083015260c083015160c083015260e083015160e0830152610100830151615b996101008401826001600160a01b03169052565b50610120830151615bb761012084018267ffffffffffffffff169052565b50610140830151615bd561014084018267ffffffffffffffff169052565b50610160830151615bea610160840182615b17565b50610180830151615c0161018084018260ff169052565b506101a0830151615c176101a084018215159052565b506101c083015161468b6101c084018267ffffffffffffffff169052565b5f60208284031215615c45575f5ffd5b815180151581146120c5575f5ffd5b5f60208284031215615c64575f5ffd5b6120c582615656565b5f5f83357fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe1843603018112615ca0575f5ffd5b83018035915067ffffffffffffffff821115615cba575f5ffd5b60200191503681900382131561575b575f5ffd5b634e487b7160e01b5f52604160045260245ffd5b6040516060810167ffffffffffffffff81118282101715615d0557615d05615cce565b60405290565b6040805190810167ffffffffffffffff81118282101715615d0557615d05615cce565b604051601f8201601f1916810167ffffffffffffffff81118282101715615d5757615d57615cce565b604052919050565b5f67ffffffffffffffff821115615d7857615d78615cce565b5060051b60200190565b5f82601f830112615d91575f5ffd5b8135615da4615d9f82615d5f565b615d2e565b8082825260208201915060208360051b860101925085831115615dc5575f5ffd5b602085015b83811015614880578035835260209283019201615dca565b5f82601f830112615df1575f5ffd5b615dfb6040615d2e565b806040840185811115615e0c575f5ffd5b845b8181101561350e578035615e21816156fa565b845260209384019301615e0e565b5f818303610100811215615e41575f5ffd5b615e49615ce2565b915060c0811215615e58575f5ffd5b615e60615ce2565b6080821215615e6d575f5ffd5b615e75615d0b565b915084601f850112615e85575f5ffd5b615e8f6040615d2e565b806040860187811115615ea0575f5ffd5b865b81811015615eba578035845260209384019301615ea2565b50818552615ec88882615de2565b6020860152505050818152615edf6080850161584f565b60208281019190915260a085013560408084019190915291845260c08501359084015260e0909301359282019290925292915050565b5f5f5f6102208486031215615f28575f5ffd5b833567ffffffffffffffff811115615f3e575f5ffd5b615f4a86828701615d82565b935050615f5a8560208601615e2f565b9150615f6a856101208601615e2f565b90509250925092565b8051825f5b6002811015615f97578251825260209283019290910190600101615f78565b5050506020810151604083015f5b600281101561132957825167ffffffffffffffff16825260209283019290910190600101615fa5565b600381106156f7576156f7615b03565b5f61012082019050858252615ff7602083018651615f73565b602085015161600581615fce565b60a08301526040949094015160c082015260e081019290925261010090910152919050565b5f6020828403121561603a575f5ffd5b81516120c5816156fa565b634e487b7160e01b5f52603260045260245ffd5b634e487b7160e01b5f52601160045260245ffd5b60ff818116838216019081111561105057611050616059565b6020810161609383615fce565b91905290565b8181038181111561105057611050616059565b828152813560208083019190915282013560408083019190915260c08201908301356160d7816156e3565b6001600160a01b03811660608401525060608301356160f5816156fa565b67ffffffffffffffff81166080840152506080830135616114816156fa565b67ffffffffffffffff811660a0840152509392505050565b5f6020828403121561613c575f5ffd5b81356120c5816156fa565b5f60208284031215616157575f5ffd5b81516120c5816156e3565b8481526101208101604085602084013760608201604086015f5b60028110156161af578135616190816156fa565b67ffffffffffffffff168352602092830192919091019060010161617c565b50505060808501356161c081615843565b6161c981615fce565b60a083810191909152949094013560c082015260e081019290925261010090910152919050565b67ffffffffffffffff828116828216039081111561105057611050616059565b828152604081016120c56020830184615b17565b8082018082111561105057611050616059565b808202811582820484141761105057611050616059565b855181526001600160a01b0360208701511660208201526040860151604082015284606082015283608082015260c060a08201528160c0820152818360e08301375f81830160e090810191909152601f909201601f19160101949350505050565b5f602082840312156162bf575f5ffd5b5051919050565b5f82601f8301126162d5575f5ffd5b81516162e3615d9f82615d5f565b8082825260208201915060208360051b860101925085831115616304575f5ffd5b602085015b83811015614880578051835260209283019201616309565b5f5f60408385031215616332575f5ffd5b825167ffffffffffffffff811115616348575f5ffd5b616354858286016162c6565b925050602083015167ffffffffffffffff811115616370575f5ffd5b61637c858286016162c6565b9150509250929050565b5f60a082019050616398828451615f73565b60208301516163a681615fce565b8060808401525092915050565b5f5f5f5f5f60a086880312156163c7575f5ffd5b8535945060208601359350604086013567ffffffffffffffff8111156163eb575f5ffd5b6163f788828901615d82565b935050606086013567ffffffffffffffff811115616413575f5ffd5b61641f88828901615d82565b925050608086013567ffffffffffffffff81111561643b575f5ffd5b61644788828901615d82565b9150509295509295909350565b5f5f60408385031215616465575f5ffd5b823567ffffffffffffffff81111561647b575f5ffd5b61648785828601615d82565b925050602083013567ffffffffffffffff8111156164a3575f5ffd5b61637c85828601615d82565b634e487b7160e01b5f52600160045260245ffd5b5f600182016164d4576164d4616059565b5060010190565b6001815b6001841115612e7a578085048111156164fa576164fa616059565b600184161561650857908102905b60019390931c9280026164df565b5f8261652457506001611050565b8161653057505f611050565b816001811461654657600281146165505761656c565b6001915050611050565b60ff84111561656157616561616059565b50506001821b611050565b5060208310610133831016604e8410600b841016171561658f575081810a611050565b61659b5f1984846164db565b805f19048211156165ae576165ae616059565b029392505050565b5f6120c58383616516565b5f82518060208501845e5f920191825250919050565b602081525f82518060208401528060208501604085015e5f604082850101526040601f19601f8301168401019150509291505056fea26469706673582212207d5df4a80d58a52352e9efc07a006f66c944826899b9419b94d6deb8c4e114d164736f6c634300081c0033
    /// ```
    #[rustfmt::skip]
    #[allow(clippy::all)]
    pub static DEPLOYED_BYTECODE: alloy_sol_types::private::Bytes = alloy_sol_types::private::Bytes::from_static(
        b"`\x80`@R4\x80\x15a\0\x0FW__\xFD[P`\x046\x10a\x01\xE6W_5`\xE0\x1C\x80ce[B\xF3\x11a\x01\tW\x80c\xC3-\x8Cc\x11a\0\x9EW\x80c\xEA\xE02\x8B\x11a\0nW\x80c\xEA\xE02\x8B\x14a\x04\xA6W\x80c\xED\xAA\xB5J\x14a\x04\xB9W\x80c\xF8\xEEw\xD6\x14a\x04\xCCW\x80c\xFD\xA2\x89.\x14a\x04\xD5W__\xFD[\x80c\xC3-\x8Cc\x14a\x049W\x80c\xC8\xBCNC\x14a\x04LW\x80c\xE5\xB1#\xDA\x14a\x04tW\x80c\xE9N\x05\x1E\x14a\x04\x93W__\xFD[\x80c\x8C\x1B:@\x11a\0\xD9W\x80c\x8C\x1B:@\x14a\x03\xE1W\x80c\x90\x85\x17\xE9\x14a\x03\xF4W\x80c\xB2\xA1@\x8E\x14a\x04\x07W\x80c\xBC\xE6\xF5O\x14a\x04\x1AW__\xFD[\x80ce[B\xF3\x14a\x03pW\x80ct\x89&\xF3\x14a\x03\xA8W\x80cu\x0E\x0C\x0F\x14a\x03\xBBW\x80c\x88&\xA3p\x14a\x03\xCEW__\xFD[\x80cC+\xB7\x8A\x11a\x01\x7FW\x80cQ\xEDj0\x11a\x01OW\x80cQ\xEDj0\x14a\x03\x08W\x80cT\xB6AQ\x14a\x03\x1BW\x80cZH\xE0\xF4\x14a\x03>W\x80c]\x9E$D\x14a\x03QW__\xFD[\x80cC+\xB7\x8A\x14a\x02\x83W\x80cF\xC2x\x1A\x14a\x02\x96W\x80cH\x92;\xC5\x14a\x02\xC3W\x80cH\xDD)$\x14a\x02\xEEW__\xFD[\x80c\x1D\xCEQf\x11a\x01\xBAW\x80c\x1D\xCEQf\x14a\x02KW\x80c>5\xF5\xE8\x14a\x02TW\x80cAnfW\x14a\x02gW\x80cB\xE1\xAA\xA8\x14a\x02pW__\xFD[\x80bM\x8E\xFE\x14a\x01\xEAW\x80c\x05\xFA\xE1A\x14a\x02\x10W\x80c\x1Ar\xD5L\x14a\x02#W\x80c\x1C\x1BO:\x14a\x028W[__\xFD[a\x01\xFDa\x01\xF86`\x04aVfV[a\x04\xF5V[`@Q\x90\x81R` \x01[`@Q\x80\x91\x03\x90\xF3[a\x01\xFDa\x02\x1E6`\x04aV\xACV[a\x05wV[a\x026a\x0216`\x04aWbV[a\x0B\xB8V[\0[a\x01\xFDa\x02F6`\x04aX,V[a\x10%V[a\x01\xFD`\nT\x81V[a\x01\xFDa\x02b6`\x04aX,V[a\x10DV[a\x01\xFD`\x0BT\x81V[a\x01\xFDa\x02~6`\x04aXZV[a\x10VV[a\x026a\x02\x916`\x04aXuV[a\x10\xF2V[`\x08Ta\x02\xAA\x90g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x81V[`@Qg\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x90\x91\x16\x81R` \x01a\x02\x07V[`\tTa\x02\xD6\x90`\x01`\x01`\xA0\x1B\x03\x16\x81V[`@Q`\x01`\x01`\xA0\x1B\x03\x90\x91\x16\x81R` \x01a\x02\x07V[`\x08Ta\x02\xD6\x90`\x01`@\x1B\x90\x04`\x01`\x01`\xA0\x1B\x03\x16\x81V[`\x06Ta\x02\xD6\x90`\x01`\x01`\xA0\x1B\x03\x16\x81V[a\x03.a\x03)6`\x04aX,V[a\x11\x99V[`@Q\x90\x15\x15\x81R` \x01a\x02\x07V[a\x01\xFDa\x03L6`\x04aX,V[a\x11\xA5V[`\rTa\x03^\x90`\xFF\x16\x81V[`@Q`\xFF\x90\x91\x16\x81R` \x01a\x02\x07V[a\x03.a\x03~6`\x04aX\xBDV[`\x01`\x01`\xA0\x1B\x03\x91\x90\x91\x16_\x90\x81R`\x04` \x90\x81R`@\x80\x83 \x93\x83R\x92\x90R T`\xFF\x16\x90V[a\x026a\x03\xB66`\x04aX,V[a\x11\xB1V[a\x03.a\x03\xC96`\x04aX,V[a\x12\xA0V[a\x026a\x03\xDC6`\x04aX\xE7V[a\x12\xC9V[a\x026a\x03\xEF6`\x04aY\x10V[a\x130V[a\x03.a\x04\x026`\x04aX,V[a\x14\xEFV[a\x026a\x04\x156`\x04aY\xF2V[a\x14\xFBV[a\x01\xFDa\x04(6`\x04aX,V[_\x90\x81R`\x02` R`@\x90 T\x90V[a\x01\xFDa\x04G6`\x04aZ)V[a\x18tV[a\x04_a\x04Z6`\x04aZgV[a\x18\xD1V[`@\x80Q\x92\x83R` \x83\x01\x91\x90\x91R\x01a\x02\x07V[a\x01\xFDa\x04\x826`\x04aX,V[_\x90\x81R`\x03` R`@\x90 T\x90V[`\x05Ta\x02\xD6\x90`\x01`\x01`\xA0\x1B\x03\x16\x81V[a\x01\xFDa\x04\xB46`\x04aX,V[a\x1A\x87V[a\x026a\x04\xC76`\x04aZ\xE3V[a\x1A\x9BV[a\x01\xFD`\x0CT\x81V[a\x04\xE8a\x04\xE36`\x04aX,V[a\x1A\xF3V[`@Qa\x02\x07\x91\x90a[+V[`@\x80Q`\xF8\x88\x90\x1B`\x01`\x01`\xF8\x1B\x03\x19\x16` \x80\x83\x01\x91\x90\x91R`!\x82\x01\x88\x90R`A\x82\x01\x87\x90R`a\x82\x01\x86\x90R`\x81\x80\x83\x01\x86\x90R\x83Q\x80\x84\x03\x90\x91\x01\x81R`\xA1\x83\x01\x84R\x80Q\x90\x82\x01 `\xC1\x83\x01R`\xE1\x80\x83\x01\x85\x90R\x83Q\x80\x84\x03\x90\x91\x01\x81Ra\x01\x01\x90\x92\x01\x90\x92R\x80Q\x91\x01 _\x90[\x97\x96PPPPPPPV[__`\x08\x80T\x90a\x01\0\n\x90\x04`\x01`\x01`\xA0\x1B\x03\x16`\x01`\x01`\xA0\x1B\x03\x16c\x12\xAB=;`@Q\x81c\xFF\xFF\xFF\xFF\x16`\xE0\x1B\x81R`\x04\x01` `@Q\x80\x83\x03\x81\x86Z\xFA\x15\x80\x15a\x05\xC8W=__>=_\xFD[PPPP`@Q=`\x1F\x19`\x1F\x82\x01\x16\x82\x01\x80`@RP\x81\x01\x90a\x05\xEC\x91\x90a\\5V[\x15\x90P\x80\x80\x15a\x06\x82WP`\x08T`@Q\x7F\xFA\xCDt;\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R3`\x04\x82\x01R`\x01`@\x1B\x90\x91\x04`\x01`\x01`\xA0\x1B\x03\x16\x90c\xFA\xCDt;\x90`$\x01` `@Q\x80\x83\x03\x81\x86Z\xFA\x15\x80\x15a\x06\\W=__>=_\xFD[PPPP`@Q=`\x1F\x19`\x1F\x82\x01\x16\x82\x01\x80`@RP\x81\x01\x90a\x06\x80\x91\x90a\\5V[\x15[\x15a\x06\xC0W`@Q\x7F\xED=\xB8\xAC\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R3`\x04\x82\x01R`$\x01[`@Q\x80\x91\x03\x90\xFD[a\x07\x07`@Q\x80a\x01\0\x01`@R\x80_\x81R` \x01_\x81R` \x01_\x81R` \x01_\x81R` \x01_\x81R` \x01_`\xFF\x16\x81R` \x01_\x15\x15\x81R` \x01_\x15\x15\x81RP\x90V[_a\x07#a\x07\x18` \x87\x01\x87a\\TV[`\rT`\xFF\x16a\x1C#V[\x90P_a\x07/\x82a\x10VV[\x90Pa\x079aT\xA4V[_\x83`\x02\x81\x11\x15a\x07LWa\x07La[\x03V[\x03a\nkWa\x07^`\xA0\x88\x01\x88a\\mV[\x90P_\x03a\x07\x7FW`@Qc\x0C\x9C\xCA\xC5`\xE4\x1B\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[_\x80a\x07\x8E`\xA0\x8A\x01\x8Aa\\mV[\x81\x01\x90a\x07\x9B\x91\x90a_\x15V[\x92P\x92PP`\x08\x80T\x90a\x01\0\n\x90\x04`\x01`\x01`\xA0\x1B\x03\x16`\x01`\x01`\xA0\x1B\x03\x16c\xE5\x10\x19\xA6\x8A``\x015\x83_\x01Q\x84` \x01Q\x85`@\x01Q`@Q\x85c\xFF\xFF\xFF\xFF\x16`\xE0\x1B\x81R`\x04\x01a\x07\xF4\x94\x93\x92\x91\x90a_\xDEV[_`@Q\x80\x83\x03\x81\x86\x80;\x15\x80\x15a\x08\nW__\xFD[PZ\xFA\x15\x80\x15a\x08\x1CW=__>=_\xFD[PP`\x08T` \x84\x81\x01Q\x86Q\x91\x87\x01Q`@\x80\x89\x01Q\x90Q\x7F\xE5\x10\x19\xA6\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x01`@\x1B\x90\x95\x04`\x01`\x01`\xA0\x1B\x03\x16\x96Pc\xE5\x10\x19\xA6\x95Pa\x08\x81\x94\x92\x93\x92`\x04\x01a_\xDEV[_`@Q\x80\x83\x03\x81\x86\x80;\x15\x80\x15a\x08\x97W__\xFD[PZ\xFA\x15\x80\x15a\x08\xA9W=__>=_\xFD[PPPP\x80_\x01Q`@\x01Q\x89` \x015\x14a\t\x06W\x80Q`@\x90\x81\x01Q\x90Q\x7F:c\xE9\x9A\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R` \x8B\x015`\x04\x82\x01R`$\x81\x01\x91\x90\x91R`D\x01a\x06\xB7V[`@\x80Q`\xC0\x81\x01\x82R``\x8B\x015\x80\x82R` \x84\x81\x01Q\x90\x83\x01R`\x08T\x83Q\x7F\xE51\xD8\xC7\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x81\x01\x92\x90\x92R\x91\x92\x83\x01\x91`\x01`@\x1B\x90\x04`\x01`\x01`\xA0\x1B\x03\x16\x90c\xE51\xD8\xC7\x90`$\x01` `@Q\x80\x83\x03\x81\x86Z\xFA\x15\x80\x15a\t\x8CW=__>=_\xFD[PPPP`@Q=`\x1F\x19`\x1F\x82\x01\x16\x82\x01\x80`@RP\x81\x01\x90a\t\xB0\x91\x90a\\5V[\x15\x15\x81R`\x08T` \x84\x81\x01Q`@Q\x7FV\xBB\xC9\xE6\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x81\x01\x91\x90\x91R\x92\x01\x91_\x91`\x01`@\x1B\x90\x04`\x01`\x01`\xA0\x1B\x03\x16\x90cV\xBB\xC9\xE6\x90`$\x01` `@Q\x80\x83\x03\x81\x86Z\xFA\x15\x80\x15a\n%W=__>=_\xFD[PPPP`@Q=`\x1F\x19`\x1F\x82\x01\x16\x82\x01\x80`@RP\x81\x01\x90a\nI\x91\x90a`*V[g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x11\x81R\x92Q` \x84\x01R\x90Q`@\x90\x92\x01\x91\x90\x91R\x90P[`\tT`\rTa\n\x93\x91`\x01\x91\x8A\x91\x85\x91`\x01`\x01`\xA0\x1B\x03\x90\x91\x16\x90\x87\x90`\xFF\x16\x8Ba\x1C\xA8V[`\x06T\x90\x94P`\x01`\x01`\xA0\x1B\x03\x16_`\x07a\n\xB2` \x8B\x01\x8Ba\\TV[`\xFF\x16\x81T\x81\x10a\n\xC5Wa\n\xC5a`EV[_\x91\x82R` \x90\x91 \x01T\x90P`\x01`\x01`\xA0\x1B\x03\x82\x16\x15\x80\x15\x90a\n\xE9WP\x80\x15\x15[\x15a\x0B$W_\x86`\xC0\x01Qa\n\xFEW0a\x0B\x0BV[`\x05T`\x01`\x01`\xA0\x1B\x03\x16[\x90Pa\x0B\"`\x01`\x01`\xA0\x1B\x03\x84\x163\x83\x85a\x1D\xD0V[P[\x85`@\x01Q\x86` \x01Q\x87_\x01Q\x7F\xAAKf\xB1\xCE\x93\x8C\x06\xE2\xA3\xF8Fk\xAE\x10\xEFb\xE7Gc\x0E8Y\x88\x9FG\x19\xFCd'\xB5\xA4\x89``\x01Q\x8A`\x80\x01Q\x8B`\xA0\x01Q\x8C`\xC0\x01Q\x8D`\xE0\x01Q`@Qa\x0B\xA2\x95\x94\x93\x92\x91\x90\x94\x85R` \x85\x01\x93\x90\x93R`\xFF\x91\x90\x91\x16`@\x84\x01R\x15\x15``\x83\x01R\x15\x15`\x80\x82\x01R`\xA0\x01\x90V[`@Q\x80\x91\x03\x90\xA4PP\x92Q\x96\x95PPPPPPV[_Ta\x01\0\x90\x04`\xFF\x16\x15\x80\x80\x15a\x0B\xD6WP_T`\x01`\xFF\x90\x91\x16\x10[\x80a\x0B\xEFWP0;\x15\x80\x15a\x0B\xEFWP_T`\xFF\x16`\x01\x14[a\x0CaW`@QbF\x1B\xCD`\xE5\x1B\x81R` `\x04\x82\x01R`.`$\x82\x01R\x7FInitializable: contract is alrea`D\x82\x01R\x7Fdy initialized\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0`d\x82\x01R`\x84\x01a\x06\xB7V[_\x80T`\xFF\x19\x16`\x01\x17\x90U\x80\x15a\x0C\x82W_\x80Ta\xFF\0\x19\x16a\x01\0\x17\x90U[`\x01`\x01`\xA0\x1B\x03\x8C\x16a\x0C\xC2W`@Q\x7F\xC8>\x08b\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[`\x08\x80T`\x01`\x01`\xA0\x1B\x03\x80\x8F\x16`\x01`@\x1B\x02\x7F\xFF\xFF\xFF\xFF\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x90\x92\x16\x91\x90\x91\x17\x90\x91U\x8A\x16a\r:W`@Q\x7F\xFB`\xB0\xEF\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[`\t\x80Ts\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x19\x16`\x01`\x01`\xA0\x1B\x03\x8C\x16\x17\x90Ug\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x8B\x16_\x03a\r\xA5W`@Q\x7F\x8A\x0E\xED\xCC\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[`\x08\x80Tg\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x19\x16g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x8D\x16\x17\x90U`\x06\x80Ts\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x19\x16`\x01`\x01`\xA0\x1B\x03\x88\x81\x16\x91\x90\x91\x17\x90\x91U\x85\x16a\x0E'W`@Q\x7F\x0F\x0E\xC8\xA8\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[`\x05\x80Ts\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x19\x16`\x01`\x01`\xA0\x1B\x03\x87\x16\x17\x90Ua\x0EX\x89a\x1E\x81V[a\x0ExW`@Qc:\xBF\xB6\xFF`\xE2\x1B\x81R`\x04\x81\x01\x8A\x90R`$\x01a\x06\xB7V[`\n\x89\x90Ua\x0E\x86\x88a\x1E\x81V[a\x0E\xA6W`@Qc:\xBF\xB6\xFF`\xE2\x1B\x81R`\x04\x81\x01\x89\x90R`$\x01a\x06\xB7V[`\x0B\x88\x90Ua\x0E\xB4\x87a\x1E\x81V[a\x0E\xD4W`@Qc:\xBF\xB6\xFF`\xE2\x1B\x81R`\x04\x81\x01\x88\x90R`$\x01a\x06\xB7V[`\x0C\x87\x90U`\xFF\x84\x16_\x03a\x0F\x15W`@Q\x7F\xA8c\xD6\xE4\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[`\xFD\x84`\xFF\x16\x11\x15a\x0FXW`@Q\x7F@\xD2;\xF0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\xFF\x85\x16`\x04\x82\x01R`$\x01a\x06\xB7V[`\r\x80T`\xFF\x19\x16`\xFF\x86\x16\x17\x90U\x81a\x0Fs\x85`\x02a`mV[`\xFF\x16\x14a\x0F\xC5W\x81a\x0F\x87\x85`\x02a`mV[`@Q\x7F\n\xEC\xE9\xC0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x81\x01\x92\x90\x92R`\xFF\x16`$\x82\x01R`D\x01a\x06\xB7V[a\x0F\xD1`\x07\x84\x84aT\xE5V[P\x80\x15a\x10\x17W_\x80Ta\xFF\0\x19\x16\x90U`@Q`\x01\x81R\x7F\x7F&\xB8?\xF9n\x1F+jh/\x138R\xF6y\x8A\t\xC4e\xDA\x95\x92\x14`\xCE\xFB8G@$\x98\x90` \x01`@Q\x80\x91\x03\x90\xA1[PPPPPPPPPPPPV[`\x07\x81\x81T\x81\x10a\x104W_\x80\xFD[_\x91\x82R` \x90\x91 \x01T\x90P\x81V[_a\x10P`\x01\x83a\x1E\xA7V[\x92\x91PPV[_\x80\x82`\x02\x81\x11\x15a\x10jWa\x10ja[\x03V[\x03a\x10wWPP`\nT\x90V[`\x01\x82`\x02\x81\x11\x15a\x10\x8BWa\x10\x8Ba[\x03V[\x03a\x10\x98WPP`\x0BT\x90V[`\x02\x82`\x02\x81\x11\x15a\x10\xACWa\x10\xACa[\x03V[\x03a\x10\xB9WPP`\x0CT\x90V[\x81`@Q\x7F;\xF2\xE1\xEC\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01a\x06\xB7\x91\x90a`\x86V[\x91\x90PV[_\x82\x90\x03a\x11,W`@Q\x7FR\x12\x99\xA9\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[a\x11]\x83\x83a\x11<`\x01\x82a`\x99V[\x81\x81\x10a\x11KWa\x11Ka`EV[`\x01\x92` \x90\x91\x02\x015\x90P\x83a UV[P_[\x82\x81\x10\x15a\x11\x93Wa\x11\x8B\x84\x84\x83\x81\x81\x10a\x11}Wa\x11}a`EV[\x90P` \x02\x015_\x19a\x1A\x9BV[`\x01\x01a\x11`V[PPPPV[_a\x10P`\x01\x83a \xCCV[_a\x10P`\x01\x83a \xFEV[_a\x11\xBD`\x01\x83a!MV[\x90Pa\x11\xC8\x81a!\xA0V[`\x06T`\t\x82\x01T`\x07\x80T`\x01`\x01`\xA0\x1B\x03\x90\x93\x16\x92_\x92`\x01`H\x1B\x90\x04`\xFF\x16\x90\x81\x10a\x11\xFBWa\x11\xFBa`EV[_\x91\x82R` \x90\x91 \x01T\x90P`\x01`\x01`\xA0\x1B\x03\x82\x16\x15\x80\x15\x90a\x12\x1FWP\x80\x15\x15[\x15a\x12@W`\x08\x83\x01Ta\x12@\x90`\x01`\x01`\xA0\x1B\x03\x84\x81\x16\x91\x16\x83a\"\xAAV[_\x84\x81R`\x01` R`@\x90 a\x12V\x90a\"\xF8V[`@\x80Q`\x01`\x01`\xA0\x1B\x03\x85\x16\x81R` \x81\x01\x84\x90R\x86\x91\x7F\xA659\x89Y\xDD\xB5\xCE;\x14S~\xDF\xC2[.g\x12t\xC9\xB8\xCA\xD0\xF4\xBDcGR\xE6\x90\x07\xB6\x91\x01`@Q\x80\x91\x03\x90\xA3PPPPV[_\x81\x81R`\x01` R`@\x81 `\x08\x01T`\x01`\xA0\x1B\x90\x04g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x15\x15a\x10PV[`\rT_\x90\x81\x90a\x12\xE4\x90`\x01\x90\x87\x90\x87\x90`\xFF\x16\x87a#nV[\x91P\x91P\x81\x15a\x13)W\x84\x7F\xBE\x17u]\x8D\x83j\xD6{\xFA\xF8\xE5\xB3\x86\x9A\xED\xB4\xCB\xA0?)Z\x16|UG\xFE\xDD\xD9\xEFP\xAD\x82`@Qa\x13 \x91\x81R` \x01\x90V[`@Q\x80\x91\x03\x90\xA2[PPPPPV[_a\x13<`\x01\x89a \xFEV[`\x08T`@Q\x7F\x04\x97*\xF9\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R\x91\x92P`\x01`@\x1B\x90\x04`\x01`\x01`\xA0\x1B\x03\x16\x90c\x04\x97*\xF9\x90a\x13\x8F\x90\x84\x90\x8A\x90`\x04\x01a`\xACV[_`@Q\x80\x83\x03\x81\x86\x80;\x15\x80\x15a\x13\xA5W__\xFD[PZ\xFA\x15\x80\x15a\x13\xB7W=__>=_\xFD[PPPP_`@Q\x80``\x01`@R\x80\x88`\x80\x01` \x81\x01\x90a\x13\xDA\x91\x90aa,V[g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x81R` \x01`\x08\x80T\x90a\x01\0\n\x90\x04`\x01`\x01`\xA0\x1B\x03\x16`\x01`\x01`\xA0\x1B\x03\x16c\xE7\x8C\xEA\x92`@Q\x81c\xFF\xFF\xFF\xFF\x16`\xE0\x1B\x81R`\x04\x01` `@Q\x80\x83\x03\x81\x86Z\xFA\x15\x80\x15a\x148W=__>=_\xFD[PPPP`@Q=`\x1F\x19`\x1F\x82\x01\x16\x82\x01\x80`@RP\x81\x01\x90a\x14\\\x91\x90aaGV[`\x01`\x01`\xA0\x1B\x03\x90\x81\x16\x82R\x895` \x90\x92\x01\x91\x90\x91R`\tT`\rT`\x0BT`\x0CT\x94\x95Pa\x14\xA4\x94`\x01\x94\x8F\x94\x16\x92\x8E\x92\x88\x92\x8E\x92\x8E\x92\x8E\x92\x8E\x92`\xFF\x16\x91\x90a#\xDBV[_\x89\x81R`\x01` R`@\x90 a\x14\xBA\x90a\"\xF8V[`@Q\x8A\x90\x7F\xE1\x1D\xB4\xB2{\xC8\xC6\xEAYC\xEC\xBB Z\xE1\xCA\x8DV\xC4,q\x97\x17\xAA\xF8\xA5=C\xD0\xCE\xE7\xC2\x90_\x90\xA3PPPPPPPPPV[_a\x10P`\x01\x83a'mV[_a\x15\x07`\x01\x84a!MV[\x90Pa\x15\x12\x81a(JV[a\x15tWa\x15\x1F\x81a(mV[`\x08\x82\x01T`\x07\x83\x01T`@Q\x7F\xE5\x8C\x83\x08\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x81\x01\x93\x90\x93R`\x01`\x01`\xA0\x1B\x03\x90\x91\x16`$\x83\x01R`D\x82\x01R`d\x01a\x06\xB7V[_\x80\x80`\t\x84\x01T`\rTa\x15\x96\x91`\xFF`\x01`H\x1B\x90\x91\x04\x81\x16\x91\x16a\x1C#V[`\x02\x81\x11\x15a\x15\xA7Wa\x15\xA7a[\x03V[\x14\x90P\x80\x80\x15a\x16BWP`\x08T`\x07\x84\x01T`@Q\x7F0\x83b(\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x81\x01\x91\x90\x91R`\x01`@\x1B\x90\x91\x04`\x01`\x01`\xA0\x1B\x03\x16\x90c0\x83b(\x90`$\x01` `@Q\x80\x83\x03\x81\x86Z\xFA\x15\x80\x15a\x16\x1EW=__>=_\xFD[PPPP`@Q=`\x1F\x19`\x1F\x82\x01\x16\x82\x01\x80`@RP\x81\x01\x90a\x16B\x91\x90a\\5V[\x15a\x17\xFAW`\x08T`\x07\x84\x01T`@Q\x7F\xE5\x10\x19\xA6\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x01`@\x1B\x90\x92\x04`\x01`\x01`\xA0\x1B\x03\x16\x91c\xE5\x10\x19\xA6\x91a\x16\xA7\x91\x88\x90`\xC0\x82\x015\x90`\xE0\x83\x015\x90`\x04\x01aabV[_`@Q\x80\x83\x03\x81\x86\x80;\x15\x80\x15a\x16\xBDW__\xFD[PZ\xFA\x15\x80\x15a\x16\xCFW=__>=_\xFD[PP`\x08T`@Q\x7F\x11qU\x85\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\xC0\x88\x015`\x04\x82\x01R`\x01`@\x1B\x90\x91\x04`\x01`\x01`\xA0\x1B\x03\x16\x92Pc\x11qU\x85\x91P`$\x01` `@Q\x80\x83\x03\x81\x86Z\xFA\x15\x80\x15a\x17<W=__>=_\xFD[PPPP`@Q=`\x1F\x19`\x1F\x82\x01\x16\x82\x01\x80`@RP\x81\x01\x90a\x17`\x91\x90a`*V[`\x08T`@Q\x7FV\xBB\xC9\xE6\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\xC0\x87\x015`\x04\x82\x01R`\x01`@\x1B\x90\x91\x04`\x01`\x01`\xA0\x1B\x03\x16\x90cV\xBB\xC9\xE6\x90`$\x01` `@Q\x80\x83\x03\x81\x86Z\xFA\x15\x80\x15a\x17\xC9W=__>=_\xFD[PPPP`@Q=`\x1F\x19`\x1F\x82\x01\x16\x82\x01\x80`@RP\x81\x01\x90a\x17\xED\x91\x90a`*V[a\x17\xF7\x91\x90aa\xF0V[\x91P[`\x08T_\x90a\x18\x19\x90`\x01\x90\x88\x90\x86\x90g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16a)\rV[_\x87\x81R`\x01` R`@\x90 \x90\x91Pa\x182\x90a\"\xF8V[\x86\x7F.\x08\x08\x83\n\" L\xB3\xFB\x8F\x8DxK(\xBC\x97\xE9\xCE.9\xD2\xF9\xCD\xE2\x86\r\xE0\x95}h\xEB\x83`@Qa\x18d\x91\x81R` \x01\x90V[`@Q\x80\x91\x03\x90\xA3PPPPPPV[`@\x80Q`\xF8\x87\x90\x1B`\x01`\x01`\xF8\x1B\x03\x19\x16` \x80\x83\x01\x91\x90\x91R`!\x82\x01\x87\x90R`A\x82\x01\x86\x90R`a\x82\x01\x85\x90R`\x81\x80\x83\x01\x85\x90R\x83Q\x80\x84\x03\x90\x91\x01\x81R`\xA1\x90\x92\x01\x90\x92R\x80Q\x91\x01 _\x90[\x96\x95PPPPPPV[_____a\x19\x1C\x89\x89\x89\x89\x80\x80`\x1F\x01` \x80\x91\x04\x02` \x01`@Q\x90\x81\x01`@R\x80\x93\x92\x91\x90\x81\x81R` \x01\x83\x83\x80\x82\x847_\x92\x01\x91\x90\x91RP`\x01\x95\x94\x93\x92PPa)\xF1\x90PV[\x81Q\x92\x95P\x90\x93P\x91P\x15\x80a\x19\xB3W\x82`@\x01Q\x83` \x01Q\x84_\x01Q\x7F\xAAKf\xB1\xCE\x93\x8C\x06\xE2\xA3\xF8Fk\xAE\x10\xEFb\xE7Gc\x0E8Y\x88\x9FG\x19\xFCd'\xB5\xA4\x86``\x01Q\x87`\x80\x01Q\x88`\xA0\x01Q\x89`\xC0\x01Q\x8A`\xE0\x01Q`@Qa\x19\xAA\x95\x94\x93\x92\x91\x90\x94\x85R` \x85\x01\x93\x90\x93R`\xFF\x91\x90\x91\x16`@\x84\x01R\x15\x15``\x83\x01R\x15\x15`\x80\x82\x01R`\xA0\x01\x90V[`@Q\x80\x91\x03\x90\xA4[\x81`@\x01Q\x82` \x01Q\x83_\x01Q\x7F\xAAKf\xB1\xCE\x93\x8C\x06\xE2\xA3\xF8Fk\xAE\x10\xEFb\xE7Gc\x0E8Y\x88\x9FG\x19\xFCd'\xB5\xA4\x85``\x01Q\x86`\x80\x01Q\x87`\xA0\x01Q\x88`\xC0\x01Q\x89`\xE0\x01Q`@Qa\x1A1\x95\x94\x93\x92\x91\x90\x94\x85R` \x85\x01\x93\x90\x93R`\xFF\x91\x90\x91\x16`@\x84\x01R\x15\x15``\x83\x01R\x15\x15`\x80\x82\x01R`\xA0\x01\x90V[`@Q\x80\x91\x03\x90\xA4\x81Q`@Q\x82\x15\x15\x81R\x85\x90\x8C\x90\x7Fs@Q\r$\xB7\xEC\x9B\\\x10\x0FU\0\xD94)\xD8\r\0\xD4o\r\x18\xE4\xE8]\x0CL\xC2+\x99$\x90` \x01`@Q\x80\x91\x03\x90\xA4PQ\x91\x93P\x90\x91PP[\x94P\x94\x92PPPV[_a\x10Pa\x1A\x96`\x01\x84a!MV[a.\x1BV[_\x80a\x1A\xA9`\x01\x85\x85a.^V[\x91P\x91P\x81\x15a\x11\x93W\x83\x7F\xBE\x17u]\x8D\x83j\xD6{\xFA\xF8\xE5\xB3\x86\x9A\xED\xB4\xCB\xA0?)Z\x16|UG\xFE\xDD\xD9\xEFP\xAD\x82`@Qa\x1A\xE5\x91\x81R` \x01\x90V[`@Q\x80\x91\x03\x90\xA2PPPPV[a\x1A\xFBaU.V[a\x1B\x06`\x01\x83a!MV[`@\x80Qa\x01\xE0\x81\x01\x82R\x82T\x81R`\x01\x80\x84\x01T` \x83\x01R`\x02\x84\x01T\x92\x82\x01\x92\x90\x92R`\x03\x83\x01T``\x82\x01R`\x04\x83\x01T`\x80\x82\x01R`\x05\x83\x01T`\xA0\x82\x01R`\x06\x83\x01T`\xC0\x82\x01R`\x07\x83\x01T`\xE0\x82\x01R`\x08\x83\x01T`\x01`\x01`\xA0\x1B\x03\x81\x16a\x01\0\x83\x01R`\x01`\xA0\x1B\x90\x04g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x90\x81\x16a\x01 \x83\x01R`\t\x84\x01T\x90\x81\x16a\x01@\x83\x01R\x90\x92\x91a\x01`\x84\x01\x91`\x01`@\x1B\x90\x04`\xFF\x16\x90\x81\x11\x15a\x1B\xBDWa\x1B\xBDa[\x03V[`\x01\x81\x11\x15a\x1B\xCEWa\x1B\xCEa[\x03V[\x81R`\t\x91\x90\x91\x01T`\xFF`\x01`H\x1B\x82\x04\x81\x16` \x84\x01Rj\x01\0\0\0\0\0\0\0\0\0\0\x82\x04\x16\x15\x15`@\x83\x01Rg\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFFk\x01\0\0\0\0\0\0\0\0\0\0\0\x90\x91\x04\x16``\x90\x91\x01R\x92\x91PPV[_\x82`\xFF\x16_\x03a\x1C5WP_a\x10PV[\x81`\xFF\x16\x83`\xFF\x16\x11a\x1CJWP`\x01a\x10PV[a\x1CU\x82`\x01a`mV[`\xFF\x16\x83`\xFF\x16\x03a\x1CiWP`\x02a\x10PV[`@Q\x7F\xAE\r\xA5x\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\xFF\x80\x85\x16`\x04\x83\x01R\x83\x16`$\x82\x01R`D\x01a\x06\xB7V[a\x1C\xEF`@Q\x80a\x01\0\x01`@R\x80_\x81R` \x01_\x81R` \x01_\x81R` \x01_\x81R` \x01_\x81R` \x01_`\xFF\x16\x81R` \x01_\x15\x15\x81R` \x01_\x15\x15\x81RP\x90V[__a\x1C\xFE\x8A\x8A\x8A\x8A\x89a.\x82V[\x91P\x91P_a\x1D\x0E\x83\x8B\x89a3\xD7V[\x90P_a\x1D\x1C\x83\x83\x8Da5\x19V[\x90P\x85\x15a\x1D\xB6W_a\x1D.\x82a5KV[3_\x90\x81R`\x03\x8F\x01` \x90\x81R`@\x80\x83 \x84\x84R\x90\x91R\x90 T\x90\x91P`\xFF\x16\x15a\x1D\x90W`@Q\x7FZF\xAC:\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R3`\x04\x82\x01R`$\x81\x01\x82\x90R`D\x01a\x06\xB7V[3_\x90\x81R`\x03\x8E\x01` \x90\x81R`@\x80\x83 \x93\x83R\x92\x90R \x80T`\xFF\x19\x16`\x01\x17\x90U[a\x1D\xC0\x8C\x82a5\xB8V[\x9C\x9BPPPPPPPPPPPPV[`@Q`\x01`\x01`\xA0\x1B\x03\x80\x85\x16`$\x83\x01R\x83\x16`D\x82\x01R`d\x81\x01\x82\x90Ra\x11\x93\x90\x85\x90\x7F#\xB8r\xDD\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x90`\x84\x01[`@\x80Q`\x1F\x19\x81\x84\x03\x01\x81R\x91\x90R` \x81\x01\x80Q{\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x7F\xFF\xFF\xFF\xFF\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x90\x93\x16\x92\x90\x92\x17\x90\x91Ra9\x9BV[_\x81_\x03a\x1E\x90WP_\x91\x90PV[_a\x1E\x9C`\x01\x84a`\x99V[\x92\x90\x92\x16\x15\x92\x91PPV[_\x81\x81R` \x83\x90R`@\x81 `\x08\x01T`\x01`\xA0\x1B\x90\x04g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16a\x1E\xE8W`@Qb\xA7\xB0+`\xE0\x1B\x81R`\x04\x81\x01\x83\x90R`$\x01a\x06\xB7V[_\x82\x81R` \x84\x90R`@\x81 a\x1E\xFE\x90a\"\xF8V[_\x81\x81R`\x01\x86\x01` R`@\x81 T\x91\x92P\x81\x90\x03a\x1FJW`@Q\x7F\xDA\x10\xF6|\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[`@Qh\x15S\x94\x92U\x90S\x11Q`\xBA\x1B` \x82\x01R`)\x01`@Q` \x81\x83\x03\x03\x81R\x90`@R\x80Q\x90` \x01 \x81\x03a\x1F\xB3W_\x84\x81R` \x86\x90R`@\x90 `\x08\x01Ta\x1F\xAA\x90`\x01`\xA0\x1B\x90\x04g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16Ca`\x99V[\x92PPPa\x10PV[_\x81\x81R` \x86\x90R`@\x90 `\x08\x01T`\x01`\xA0\x1B\x90\x04g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16a\x1F\xF4W`@Qb\xA7\xB0+`\xE0\x1B\x81R`\x04\x81\x01\x82\x90R`$\x01a\x06\xB7V[_\x81\x81R` \x86\x90R`@\x80\x82 `\x08\x90\x81\x01T\x87\x84R\x91\x90\x92 \x90\x91\x01Tg\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF`\x01`\xA0\x1B\x92\x83\x90\x04\x81\x16\x92\x90\x91\x04\x16\x80\x82\x11\x15a IWa >\x81\x83a`\x99V[\x94PPPPPa\x10PV[_\x94PPPPPa\x10PV[_\x82\x81R` \x84\x90R`@\x81 `\t\x01Tk\x01\0\0\0\0\0\0\0\0\0\0\0\x90\x04g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x82\x81\x10a \xC2W`@Q\x7F\xD1\xF5\x92\x81\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x81\x01\x82\x90R`$\x81\x01\x84\x90R`D\x01a\x06\xB7V[\x90P[\x93\x92PPPV[_a \xD7\x83\x83a'mV[\x80\x15a \xC5WP_\x82\x81R` \x84\x90R`@\x90 a \xF4\x90a.\x1BV[`\x01\x14\x93\x92PPPV[__a!\n\x84\x84a!MV[\x90P[`\t\x81\x01T`\x01`H\x1B\x90\x04`\xFF\x16\x15a!EW\x80T_\x90\x81R`\x01\x85\x01` R`@\x90 Ta!=\x85\x82a!MV[\x91PPa!\rV[T\x93\x92PPPV[_\x81\x81R` \x83\x90R`@\x81 `\x08\x01T`\x01`\xA0\x1B\x90\x04g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16a!\x8EW`@Qb\xA7\xB0+`\xE0\x1B\x81R`\x04\x81\x01\x83\x90R`$\x01a\x06\xB7V[P_\x90\x81R` \x91\x90\x91R`@\x90 \x90V[`\x01`\t\x82\x01T`\x01`@\x1B\x90\x04`\xFF\x16`\x01\x81\x11\x15a!\xC2Wa!\xC2a[\x03V[\x14a\"\x13Wa!\xD0\x81a(mV[`\t\x82\x01T`@Q\x7F\xEF\x12g\xB4\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81Ra\x06\xB7\x92\x91`\x01`@\x1B\x90\x04`\xFF\x16\x90`\x04\x01ab\x10V[a\"\x1C\x81a(JV[a\")Wa\x15\x1F\x81a(mV[`\t\x81\x01Tj\x01\0\0\0\0\0\0\0\0\0\0\x90\x04`\xFF\x16\x15\x15`\x01\x03a\"\x86Wa\"Q\x81a(mV[`@Q\x7F0\x7Fvi\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01a\x06\xB7\x91\x81R` \x01\x90V[`\t\x01\x80Tj\xFF\0\0\0\0\0\0\0\0\0\0\x19\x16j\x01\0\0\0\0\0\0\0\0\0\0\x17\x90UV[`@Q`\x01`\x01`\xA0\x1B\x03\x83\x16`$\x82\x01R`D\x81\x01\x82\x90Ra\"\xF3\x90\x84\x90\x7F\xA9\x05\x9C\xBB\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x90`d\x01a\x1E\x1DV[PPPV[`\t\x81\x01T\x81T`\x02\x83\x01T`\x01\x84\x01T`\x04\x85\x01T`@\x80Q`\x01`H\x1B\x90\x96\x04`\xF8\x1B`\x01`\x01`\xF8\x1B\x03\x19\x16` \x80\x88\x01\x91\x90\x91R`!\x87\x01\x95\x90\x95R`A\x86\x01\x93\x90\x93R`a\x85\x01\x91\x90\x91R`\x81\x80\x85\x01\x91\x90\x91R\x81Q\x80\x85\x03\x90\x91\x01\x81R`\xA1\x90\x93\x01\x90R\x81Q\x91\x01 _\x90a\x10PV[___a#{\x88\x88a\x1E\xA7V[\x90Pa#\x89\x88\x88\x88\x88a:\x7FV[_\x86\x81R` \x89\x90R`@\x90 `\t\x01Ta#\xBD\x90k\x01\0\0\0\0\0\0\0\0\0\0\0\x90\x04g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x82ab$V[\x90Pa#\xCB\x88\x88\x83\x87a<9V[\x92P\x92PP[\x95P\x95\x93PPPPV[_\x8B\x81R` \x8D\x90R`@\x90 `\x08\x01T`\x01`\xA0\x1B\x90\x04g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16a$\x1CW`@Qb\xA7\xB0+`\xE0\x1B\x81R`\x04\x81\x01\x8C\x90R`$\x01a\x06\xB7V[`\x02_\x8C\x81R` \x8E\x90R`@\x90 `\t\x01Ta$C\x90`\x01`H\x1B\x90\x04`\xFF\x16\x85a\x1C#V[`\x02\x81\x11\x15a$TWa$Ta[\x03V[\x14a$\xA9W_\x8B\x81R` \x8D\x90R`@\x90\x81\x90 `\t\x01T\x90Q\x7F4\x8A\xEF\xDF\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x01`H\x1B\x90\x91\x04`\xFF\x16`\x04\x82\x01R`$\x01a\x06\xB7V[_\x8B\x81R` \x8D\x90R`@\x90 a$\xBF\x90a.\x1BV[`\x01\x14a%\x11W_\x8B\x81R` \x8D\x90R`@\x90 a$\xDC\x90a.\x1BV[`@Q\x7FkY^P\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01a\x06\xB7\x91\x81R` \x01\x90V[_\x8B\x81R` \x8D\x90R`@\x90 `\x02\x01T\x8B\x82[`\x01\x8F_\x01_\x84\x81R` \x01\x90\x81R` \x01_ `\t\x01`\t\x90T\x90a\x01\0\n\x90\x04`\xFF\x16`\xFF\x16\x11\x15a%\xC0W_\x8F_\x01_\x84\x81R` \x01\x90\x81R` \x01_ _\x01T\x90P\x8F`\x01\x01_\x82\x81R` \x01\x90\x81R` \x01_ T\x92P\x8F_\x01_\x84\x81R` \x01\x90\x81R` \x01_ `\x02\x01T\x82a%\xA2\x91\x90ab7V[a%\xAC\x90\x85ab$V[\x93Pa%\xB8\x86\x83ab7V[\x91PPa%%V[PPa&\x18\x8D_\x01_\x8E\x81R` \x01\x90\x81R` \x01_ `\x01\x01T\x8B_\x015\x83\x8B\x8B\x80\x80` \x02` \x01`@Q\x90\x81\x01`@R\x80\x93\x92\x91\x90\x81\x81R` \x01\x83\x83` \x02\x80\x82\x847_\x92\x01\x91\x90\x91RPa<\xCE\x92PPPV[_\x8B`\x01`\x01`\xA0\x1B\x03\x16c\xB5\x11/\xD2\x8B\x84\x8E_\x015\x8F\x80` \x01\x90a&>\x91\x90a\\mV[`@Q\x86c\xFF\xFF\xFF\xFF\x16`\xE0\x1B\x81R`\x04\x01a&^\x95\x94\x93\x92\x91\x90abNV[` `@Q\x80\x83\x03\x81\x86Z\xFA\x15\x80\x15a&yW=__>=_\xFD[PPPP`@Q=`\x1F\x19`\x1F\x82\x01\x16\x82\x01\x80`@RP\x81\x01\x90a&\x9D\x91\x90ab\xAFV[\x90Pa&\xFE\x8E_\x01_\x8F\x81R` \x01\x90\x81R` \x01_ `\x03\x01T\x82\x84`\x01a&\xC6\x91\x90ab$V[\x8A\x8A\x80\x80` \x02` \x01`@Q\x90\x81\x01`@R\x80\x93\x92\x91\x90\x81\x81R` \x01\x83\x83` \x02\x80\x82\x847_\x92\x01\x91\x90\x91RPa<\xCE\x92PPPV[_\x8D\x81R` \x8F\x90R`@\x90 a'\x14\x90a=SV[a'\x1E\x8E\x8Ea=\xEEV[PPP_\x99\x8ARPPP` \x97\x90\x97RPP`@\x90\x93 `\t\x01\x80Tr\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\0\0\0\0\0\0\0\0\0\0\0\x19\x16r\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\0\0\0\0\0\0\0\0\0\0\0\x17\x90UPPPPV[_\x81\x81R` \x83\x90R`@\x81 `\x08\x01T`\x01`\xA0\x1B\x90\x04g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16a'\xAEW`@Qb\xA7\xB0+`\xE0\x1B\x81R`\x04\x81\x01\x83\x90R`$\x01a\x06\xB7V[_\x82\x81R` \x84\x90R`@\x81 a'\xC4\x90a\"\xF8V[_\x81\x81R`\x01\x86\x01` R`@\x81 T\x91\x92P\x81\x90\x03a(\x10W`@Q\x7F\xDA\x10\xF6|\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[`@Qh\x15S\x94\x92U\x90S\x11Q`\xBA\x1B` \x82\x01R`)\x01`@\x80Q`\x1F\x19\x81\x84\x03\x01\x81R\x91\x90R\x80Q` \x90\x91\x01 \x14\x15\x94\x93PPPPV[`\x07\x81\x01T_\x90\x15\x80\x15\x90a\x10PWPP`\x08\x01T`\x01`\x01`\xA0\x1B\x03\x16\x15\x15\x90V[`\t\x81\x01T\x81T`\x02\x83\x01T`\x01\x84\x01T`\x04\x85\x01T`\x03\x86\x01T`@\x80Q`\x01`H\x1B\x90\x97\x04`\xF8\x1B`\x01`\x01`\xF8\x1B\x03\x19\x16` \x80\x89\x01\x91\x90\x91R`!\x88\x01\x96\x90\x96R`A\x87\x01\x94\x90\x94R`a\x86\x01\x92\x90\x92R`\x81\x80\x86\x01\x91\x90\x91R\x82Q\x80\x86\x03\x90\x91\x01\x81R`\xA1\x85\x01\x83R\x80Q\x90\x84\x01 `\xC1\x85\x01R`\xE1\x80\x85\x01\x91\x90\x91R\x81Q\x80\x85\x03\x90\x91\x01\x81Ra\x01\x01\x90\x93\x01\x90R\x81Q\x91\x01 _\x90a\x10PV[_\x83\x81R` \x85\x90R`@\x81 `\x08\x01T`\x01`\xA0\x1B\x90\x04g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16a)NW`@Qb\xA7\xB0+`\xE0\x1B\x81R`\x04\x81\x01\x85\x90R`$\x01a\x06\xB7V[_a)Y\x86\x86a>nV[\x90Pa)og\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x85\x16\x82ab$V[\x90P\x82g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x81\x10\x15a)\xC8W`@Q\x7F\x11\xA8\xD4\xD0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x81\x01\x82\x90Rg\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x84\x16`$\x82\x01R`D\x01a\x06\xB7V[_\x85\x81R` \x87\x90R`@\x90 a)\xDE\x90a=SV[a)\xE8\x86\x86a=\xEEV[\x95\x94PPPPPV[`@\x80Qa\x01\0\x81\x01\x82R_\x80\x82R` \x82\x01\x81\x90R\x91\x81\x01\x82\x90R``\x81\x01\x82\x90R`\x80\x81\x01\x82\x90R`\xA0\x81\x01\x82\x90R`\xC0\x81\x01\x82\x90R`\xE0\x81\x01\x82\x90Ra*w`@Q\x80a\x01\0\x01`@R\x80_\x81R` \x01_\x81R` \x01_\x81R` \x01_\x81R` \x01_\x81R` \x01_`\xFF\x16\x81R` \x01_\x15\x15\x81R` \x01_\x15\x15\x81RP\x90V[__\x87\x81R` \x89\x90R`@\x90 `\t\x01T`\x01`@\x1B\x90\x04`\xFF\x16`\x01\x81\x11\x15a*\xA4Wa*\xA4a[\x03V[\x14a*\xFBW_\x86\x81R` \x88\x90R`@\x90\x81\x90 `\t\x01T\x90Q\x7F#\xF8@]\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81Ra\x06\xB7\x91\x88\x91`\x01`@\x1B\x90\x91\x04`\xFF\x16\x90`\x04\x01ab\x10V[a+\x05\x87\x87a'mV[a+>W`@Q\x7F\x80\xE0~E\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x81\x01\x87\x90R`$\x01a\x06\xB7V[_\x86\x81R` \x88\x90R`@\x81 `@\x80Qa\x01\xE0\x81\x01\x82R\x82T\x81R`\x01\x80\x84\x01T` \x83\x01R`\x02\x84\x01T\x92\x82\x01\x92\x90\x92R`\x03\x83\x01T``\x82\x01R`\x04\x83\x01T`\x80\x82\x01R`\x05\x83\x01T`\xA0\x82\x01R`\x06\x83\x01T`\xC0\x82\x01R`\x07\x83\x01T`\xE0\x82\x01R`\x08\x83\x01T`\x01`\x01`\xA0\x1B\x03\x81\x16a\x01\0\x83\x01R`\x01`\xA0\x1B\x90\x04g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x90\x81\x16a\x01 \x83\x01R`\t\x84\x01T\x90\x81\x16a\x01@\x83\x01R\x90\x92\x91a\x01`\x84\x01\x91`\x01`@\x1B\x90\x04`\xFF\x16\x90\x81\x11\x15a,\x02Wa,\x02a[\x03V[`\x01\x81\x11\x15a,\x13Wa,\x13a[\x03V[\x81R`\t\x91\x90\x91\x01T`\x01`H\x1B\x81\x04`\xFF\x90\x81\x16` \x84\x01Rj\x01\0\0\0\0\0\0\0\0\0\0\x82\x04\x16\x15\x15`@\x80\x84\x01\x91\x90\x91Rk\x01\0\0\0\0\0\0\0\0\0\0\0\x90\x91\x04g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16``\x90\x92\x01\x91\x90\x91R\x81\x01Q`\x80\x82\x01Q\x91\x92P_\x91a,\x81\x91\x90a>\xF9V[\x90P__\x87\x80` \x01\x90Q\x81\x01\x90a,\x99\x91\x90ac!V[\x90\x92P\x90Pa,\xC9\x89a,\xAD\x85`\x01ab$V[``\x87\x01Q`\x80\x88\x01Qa,\xC2\x90`\x01ab$V[\x86\x86a?\xA2V[PP`@\x80Qa\x01\0\x81\x01\x82R_\x80\x82R` \x82\x01\x81\x90R\x91\x81\x01\x82\x90R``\x81\x01\x82\x90R`\x80\x81\x01\x82\x90R`\xA0\x81\x01\x82\x90R`\xC0\x81\x01\x82\x90R`\xE0\x81\x01\x82\x90R_a-)\x85_\x01Q\x86` \x01Q\x87`@\x01Q\x8D\x88\x8Aa\x01\x80\x01QaB\xC3V[\x90Pa-4\x81aC[V[_\x81\x81R` \x8E\x90R`@\x90 `\x08\x01T\x90\x93P`\x01`\xA0\x1B\x90\x04g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16a-jWa-g\x8C\x82a5\xB8V[\x91P[Pa-\xB2`@Q\x80a\x01\0\x01`@R\x80_\x81R` \x01_\x81R` \x01_\x81R` \x01_\x81R` \x01_\x81R` \x01_`\xFF\x16\x81R` \x01_\x15\x15\x81R` \x01_\x15\x15\x81RP\x90V[_a-\xD1\x86_\x01Q\x8C\x87\x89``\x01Q\x8A`\x80\x01Q\x8Ba\x01\x80\x01QaB\xC3V[\x90Pa-\xDD\x8D\x82a5\xB8V[\x91PPa.\t\x83\x82_\x01Q\x8E_\x01_\x8F\x81R` \x01\x90\x81R` \x01_ aC\xF2\x90\x92\x91\x90c\xFF\xFF\xFF\xFF\x16V[\x91\x9B\x90\x9AP\x90\x98P\x96PPPPPPPV[__\x82`\x02\x01T\x83`\x04\x01Ta.1\x91\x90a`\x99V[\x90P\x80_\x03a\x10PWa.C\x83a(mV[`@Qb\xA7\xB0+`\xE0\x1B\x81R`\x04\x01a\x06\xB7\x91\x81R` \x01\x90V[__a.u\x85\x85a.o\x88\x88a>nV[\x86a<9V[\x91P\x91P[\x93P\x93\x91PPV[a.\xA4`@Q\x80``\x01`@R\x80_\x81R` \x01_\x81R` \x01``\x81RP\x90V[_\x80a.\xBCa.\xB6` \x89\x01\x89a\\TV[\x85a\x1C#V[`\x02\x81\x11\x15a.\xCDWa.\xCDa[\x03V[\x03a1\xE1W` \x85\x01Q\x85Q_\x03a/\x11W`@Q\x7F\xE9k\xC6\x1A\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[\x85Q``\x88\x015\x14a/_W\x85Q`@Q\x7F[\x17z<\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x81\x01\x91\x90\x91R``\x88\x015`$\x82\x01R`D\x01a\x06\xB7V[\x85`@\x01Qa/\x9AW`@Q\x7F\xC1i$6\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[\x85``\x01Qa/\xD5W`@Q\x7F\xB4]\x1C:\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[a/\xE2`\xA0\x88\x01\x88a\\mV[\x90P_\x03a0\x03W`@Qc\x0C\x9C\xCA\xC5`\xE4\x1B\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[_a0\x11`\xA0\x89\x01\x89a\\mV[\x81\x01\x90a0\x1E\x91\x90a_\x15V[P\x90\x91P_\x90P\x87`\x80\x01Q` \x01Q`\x02\x81\x11\x15a0?Wa0?a[\x03V[\x03a0vW`@Q\x7FF6^R\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[_\x87`\xA0\x01Q` \x01Q`\x02\x81\x11\x15a0\x91Wa0\x91a[\x03V[\x03a0\xC8W`@Q\x7F\x89\x99\x85}\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[_\x86`\x01`\x01`\xA0\x1B\x03\x16c\xC3\x96\x19\xC4a0\xE5\x8A`\x80\x01QaDrV[`@Q\x82c\xFF\xFF\xFF\xFF\x16`\xE0\x1B\x81R`\x04\x01a1\x01\x91\x90ac\x86V[` `@Q\x80\x83\x03\x81\x86Z\xFA\x15\x80\x15a1\x1CW=__>=_\xFD[PPPP`@Q=`\x1F\x19`\x1F\x82\x01\x16\x82\x01\x80`@RP\x81\x01\x90a1@\x91\x90ab\xAFV[\x90P_\x87`\x01`\x01`\xA0\x1B\x03\x16c\xC3\x96\x19\xC4a1_\x8B`\xA0\x01QaDrV[`@Q\x82c\xFF\xFF\xFF\xFF\x16`\xE0\x1B\x81R`\x04\x01a1{\x91\x90ac\x86V[` `@Q\x80\x83\x03\x81\x86Z\xFA\x15\x80\x15a1\x96W=__>=_\xFD[PPPP`@Q=`\x1F\x19`\x1F\x82\x01\x16\x82\x01\x80`@RP\x81\x01\x90a1\xBA\x91\x90ab\xAFV[`@\x80Q``\x81\x01\x82R\x93\x84R` \x84\x01\x91\x90\x91R\x82\x01\x92\x90\x92R\x93P\x90\x91Pa#\xD1\x90PV[a1\xEF\x87\x87``\x015a \xCCV[a2+W`@Q\x7F\xFFm\x9B\xD7\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R``\x87\x015`\x04\x82\x01R`$\x01a\x06\xB7V[``\x86\x015_\x90\x81R` \x88\x90R`@\x81 \x90a2G\x82a\"\xF8V[\x90P_`\t\x83\x01T`\x01`@\x1B\x90\x04`\xFF\x16`\x01\x81\x11\x15a2jWa2ja[\x03V[\x14a2\xA1W`@Q\x7F\x12E\x9F\xFD\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[`\t\x82\x01Ta2\xBA\x90`\x01`H\x1B\x90\x04`\xFF\x16\x86aD\xACV[`\xFF\x16a2\xCA` \x8A\x01\x8Aa\\TV[`\xFF\x16\x14a3,Wa2\xDF` \x89\x01\x89a\\TV[`\t\x83\x01T`@Q\x7F\xAC\x9Ea\x16\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\xFF\x92\x83\x16`\x04\x82\x01R`\x01`H\x1B\x90\x91\x04\x90\x91\x16`$\x82\x01R`D\x01a\x06\xB7V[a39`\xA0\x89\x01\x89a\\mV[\x90P_\x03a3ZW`@Qc\x0C\x9C\xCA\xC5`\xE4\x1B\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[_\x80\x80\x80\x80a3l`\xA0\x8E\x01\x8Ea\\mV[\x81\x01\x90a3y\x91\x90ac\xB3V[\x94P\x94P\x94P\x94P\x94Pa3\x97\x87`\x01\x01T\x86\x89`\x02\x01T\x86a<\xCEV[a3\xAB\x87`\x03\x01T\x85\x89`\x04\x01T\x85a<\xCEV[`@Q\x80``\x01`@R\x80\x86\x81R` \x01\x85\x81R` \x01\x82\x81RP\x86\x98P\x98PPPPPPPPa#\xD1V[`@\x80Q_\x80\x82R` \x82\x01\x90\x92R\x81\x90a3\xFC\x90a3\xF7\x90\x87QaD\xCDV[aE\x02V[\x90Pa4\x07\x83a\x1E\x81V[a4'W`@Qc:\xBF\xB6\xFF`\xE2\x1B\x81R`\x04\x81\x01\x84\x90R`$\x01a\x06\xB7V[\x82\x84`@\x015\x14a4qW`@\x80Q\x7F\xDF\xCCb\xBC\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R\x90\x85\x015`\x04\x82\x01R`$\x81\x01\x84\x90R`D\x01a\x06\xB7V[a4\x8D\x84` \x015\x86` \x01Q\x86`@\x015\x88`@\x01Qa<\xCEV[a4\x9A`\x80\x85\x01\x85a\\mV[\x90P_\x03a4\xD4W`@Q\x7F4*\x07R\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[_\x80a4\xE3`\x80\x87\x01\x87a\\mV[\x81\x01\x90a4\xF0\x91\x90adTV[\x90\x92P\x90Pa5\x0E\x83`\x01` \x89\x015a,\xC2`@\x8B\x015\x83ab$V[P\x90\x95\x94PPPPPV[a5!aU.V[a \xC2\x84\x84_` \x86\x01\x805\x90`@\x88\x015\x90``\x89\x015\x903\x90a5F\x90\x8Ba\\TV[aF\x92V[a\x01\x80\x81\x01Q\x81Q`@\x80\x84\x01Q` \x80\x86\x01Q`\x80\x87\x01Q\x84Q`\xF8\x97\x90\x97\x1B`\x01`\x01`\xF8\x1B\x03\x19\x16\x87\x84\x01R`!\x87\x01\x95\x90\x95R`A\x86\x01\x92\x90\x92R`a\x85\x01\x91\x90\x91R`\x81\x80\x85\x01\x93\x90\x93R\x81Q\x80\x85\x03\x90\x93\x01\x83R`\xA1\x90\x93\x01\x90R\x80Q\x91\x01 _\x90a\x10PV[a5\xFF`@Q\x80a\x01\0\x01`@R\x80_\x81R` \x01_\x81R` \x01_\x81R` \x01_\x81R` \x01_\x81R` \x01_`\xFF\x16\x81R` \x01_\x15\x15\x81R` \x01_\x15\x15\x81RP\x90V[_a6\t\x83aC[V[_\x81\x81R` \x86\x90R`@\x90 `\x08\x01T\x90\x91P`\x01`\xA0\x1B\x90\x04g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x15a6hW`@Q\x7F\xBC\xED\xF3\xDE\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x81\x01\x82\x90R`$\x01a\x06\xB7V[_\x81\x81R` \x85\x81R`@\x91\x82\x90 \x85Q\x81U\x90\x85\x01Q`\x01\x80\x83\x01\x91\x90\x91U\x91\x85\x01Q`\x02\x82\x01U``\x85\x01Q`\x03\x82\x01U`\x80\x85\x01Q`\x04\x82\x01U`\xA0\x85\x01Q`\x05\x82\x01U`\xC0\x85\x01Q`\x06\x82\x01U`\xE0\x85\x01Q`\x07\x82\x01Ua\x01\0\x85\x01Q`\x08\x82\x01\x80Ta\x01 \x88\x01Qg\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x90\x81\x16`\x01`\xA0\x1B\x02\x7F\xFF\xFF\xFF\xFF\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x90\x92\x16`\x01`\x01`\xA0\x1B\x03\x90\x94\x16\x93\x90\x93\x17\x17\x90Ua\x01@\x86\x01Q`\t\x83\x01\x80T\x91\x90\x92\x16g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x19\x82\x16\x81\x17\x83Ua\x01`\x88\x01Q\x88\x95\x90\x93\x92h\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x19\x16\x90\x91\x17\x90`\x01`@\x1B\x90\x84\x90\x81\x11\x15a7oWa7oa[\x03V[\x02\x17\x90UPa\x01\x80\x82\x81\x01Q`\t\x92\x90\x92\x01\x80Ta\x01\xA0\x85\x01Qa\x01\xC0\x90\x95\x01Qg\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16k\x01\0\0\0\0\0\0\0\0\0\0\0\x02r\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\0\0\0\0\0\0\0\0\0\0\0\x19\x95\x15\x15j\x01\0\0\0\0\0\0\0\0\0\0\x02j\xFF\0\0\0\0\0\0\0\0\0\0\x19`\xFF\x90\x96\x16`\x01`H\x1B\x02\x95\x90\x95\x16\x7F\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\0\0\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x90\x92\x16\x91\x90\x91\x17\x93\x90\x93\x17\x93\x90\x93\x16\x91\x90\x91\x17\x90\x91U\x83\x01Q\x83Q`@\x80\x86\x01Q` \x80\x88\x01Q`\x80\x89\x01Q\x84Q`\x01`\x01`\xF8\x1B\x03\x19`\xF8\x98\x90\x98\x1B\x97\x90\x97\x16\x87\x84\x01R`!\x87\x01\x95\x90\x95R`A\x86\x01\x92\x90\x92R`a\x85\x01\x91\x90\x91R`\x81\x80\x85\x01\x93\x90\x93R\x81Q\x80\x85\x03\x90\x93\x01\x83R`\xA1\x90\x93\x01\x90R\x80Q\x91\x01 _\x90_\x81\x81R`\x01\x87\x01` R`@\x81 T\x91\x92P\x81\x90\x03a8\xE5W`@Qh\x15S\x94\x92U\x90S\x11Q`\xBA\x1B` \x82\x01R`)\x01`@\x80Q`\x1F\x19\x81\x84\x03\x01\x81R\x91\x81R\x81Q` \x92\x83\x01 _\x85\x81R`\x01\x8A\x01\x90\x93R\x91 Ua9,V[`@Qh\x15S\x94\x92U\x90S\x11Q`\xBA\x1B` \x82\x01R`)\x01`@Q` \x81\x83\x03\x03\x81R\x90`@R\x80Q\x90` \x01 \x81\x03a9,W_\x82\x81R`\x01\x87\x01` R`@\x90 \x83\x90U[`@\x80Qa\x01\0\x81\x01\x82R\x84\x81R` \x80\x82\x01\x85\x90R\x87Q\x82\x84\x01R`\xE0\x88\x01Q``\x83\x01R_\x86\x81R\x90\x89\x90R\x91\x90\x91 `\x80\x82\x01\x90a9l\x90a.\x1BV[\x81Ra\x01\x80\x87\x01Q`\xFF\x16` \x82\x01R\x91\x15\x15`@\x83\x01R`\xE0\x90\x95\x01Q\x15\x15``\x90\x91\x01RP\x91\x93\x92PPPV[_a9\xEF\x82`@Q\x80`@\x01`@R\x80` \x81R` \x01\x7FSafeERC20: low-level call failed\x81RP\x85`\x01`\x01`\xA0\x1B\x03\x16aG\xC9\x90\x92\x91\x90c\xFF\xFF\xFF\xFF\x16V[\x80Q\x90\x91P\x15a\"\xF3W\x80\x80` \x01\x90Q\x81\x01\x90a:\r\x91\x90a\\5V[a\"\xF3W`@QbF\x1B\xCD`\xE5\x1B\x81R` `\x04\x82\x01R`*`$\x82\x01R\x7FSafeERC20: ERC20 operation did n`D\x82\x01R\x7Fot succeed\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0`d\x82\x01R`\x84\x01a\x06\xB7V[_\x82\x81R` \x85\x90R`@\x90 `\x07\x01T\x83\x14a:\xE5W_\x82\x81R` \x85\x90R`@\x90\x81\x90 `\x07\x01T\x90Q\x7F\xC2\xAD\xC3\xE8\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81Ra\x06\xB7\x91\x85\x91`\x04\x01\x91\x82R` \x82\x01R`@\x01\x90V[_\x82\x81R` \x85\x90R`@\x80\x82 T\x85\x83R\x91 a;\x02\x90a\"\xF8V[\x14a;gW_\x83\x81R` \x85\x90R`@\x90 a;\x1D\x90a\"\xF8V[_\x83\x81R` \x86\x90R`@\x90\x81\x90 T\x90Q\x7F\xE2\xE2\x7F\x87\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x81\x01\x92\x90\x92R`$\x82\x01R`D\x01a\x06\xB7V[_\x82\x81R` \x85\x90R`@\x80\x82 `\t\x90\x81\x01T\x86\x84R\x91\x90\x92 \x90\x91\x01T`\xFF`\x01`H\x1B\x92\x83\x90\x04\x81\x16\x92a;\xA0\x92\x04\x16\x83aD\xACV[`\xFF\x16\x14a\x11\x93W_\x83\x81R` \x85\x90R`@\x90 `\t\x01T\x83\x90\x83\x90a;\xD1\x90`\x01`H\x1B\x90\x04`\xFF\x16\x84aD\xACV[_\x85\x81R` \x88\x90R`@\x90\x81\x90 `\t\x01T\x90Q\x7F~rm\x15\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x81\x01\x94\x90\x94R`$\x84\x01\x92\x90\x92R`\xFF\x90\x81\x16`D\x84\x01R`\x01`H\x1B\x90\x91\x04\x16`d\x82\x01R`\x84\x01a\x06\xB7V[___a<G\x87\x87\x86a UV[\x90Pg\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x85\x11a<^W\x84a<hV[g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF[\x94P\x80\x85\x11\x15a<\xC1WPPP_\x83\x81R` \x85\x90R`@\x90 `\t\x01\x80Tr\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\0\0\0\0\0\0\0\0\0\0\0\x19\x16k\x01\0\0\0\0\0\0\0\0\0\0\0g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x85\x16\x02\x17\x90U`\x01\x82a\x1A~V[_\x97\x90\x96P\x94PPPPPV[_a=\x02\x82\x84\x86`@Q` \x01a<\xE7\x91\x81R` \x01\x90V[`@Q` \x81\x83\x03\x03\x81R\x90`@R\x80Q\x90` \x01 aG\xD7V[\x90P\x80\x85\x14a\x13)W`@QbF\x1B\xCD`\xE5\x1B\x81R` `\x04\x82\x01R`\x17`$\x82\x01R\x7FInvalid inclusion proof\0\0\0\0\0\0\0\0\0`D\x82\x01R`d\x01a\x06\xB7V[_`\t\x82\x01T`\x01`@\x1B\x90\x04`\xFF\x16`\x01\x81\x11\x15a=tWa=ta[\x03V[\x14a=\xC5Wa=\x82\x81a(mV[`\t\x82\x01T`@Q\x7F#\xF8@]\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81Ra\x06\xB7\x92\x91`\x01`@\x1B\x90\x04`\xFF\x16\x90`\x04\x01ab\x10V[`\t\x01\x80Tg\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFFC\x16h\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x19\x90\x91\x16\x17`\x01`@\x1B\x17\x90UV[_\x81\x81R` \x83\x90R`@\x81 a>\x04\x90a\"\xF8V[_\x81\x81R`\x02\x85\x01` R`@\x90 T\x90\x91P\x80\x15a>YW`@Q\x7F\xDDp(\xF0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x81\x01\x84\x90R`$\x81\x01\x82\x90R`D\x01a\x06\xB7V[P_\x90\x81R`\x02\x90\x92\x01` R`@\x90\x91 UV[__a>z\x84\x84a\x1E\xA7V[_\x84\x81R` \x86\x90R`@\x90 `\x05\x01T\x90\x91P\x15a \xC5W_\x83\x81R` \x85\x90R`@\x80\x82 `\x05\x81\x01T\x83R\x81\x83 `\t\x90\x81\x01T`\x06\x90\x92\x01T\x84R\x91\x90\x92 \x01Tg\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFFk\x01\0\0\0\0\0\0\0\0\0\0\0\x92\x83\x90\x04\x81\x16\x92\x90\x91\x04\x16\x80\x82\x10a>\xEDW\x80a>\xEFV[\x81[a\x18\xC7\x90\x84ab$V[_`\x02a?\x06\x84\x84a`\x99V[\x10\x15a?HW`@Q\x7F\x90)\x85\x94\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x81\x01\x84\x90R`$\x81\x01\x83\x90R`D\x01a\x06\xB7V[a?R\x83\x83a`\x99V[`\x02\x03a?kWa?d\x83`\x01ab$V[\x90Pa\x10PV[_\x83a?x`\x01\x85a`\x99V[\x18\x90P_a?\x85\x82aH\x8AV[\x90P_\x19\x81\x1B\x80a?\x97`\x01\x87a`\x99V[\x16\x96\x95PPPPPPV[_\x85\x11a?\xF1W`@QbF\x1B\xCD`\xE5\x1B\x81R` `\x04\x82\x01R`\x14`$\x82\x01R\x7FPre-size cannot be 0\0\0\0\0\0\0\0\0\0\0\0\0`D\x82\x01R`d\x01a\x06\xB7V[\x85a?\xFB\x83aE\x02V[\x14a@HW`@QbF\x1B\xCD`\xE5\x1B\x81R` `\x04\x82\x01R`\x1B`$\x82\x01R\x7FPre expansion root mismatch\0\0\0\0\0`D\x82\x01R`d\x01a\x06\xB7V[\x84a@R\x83aI\xC4V[\x14a@\xC5W`@QbF\x1B\xCD`\xE5\x1B\x81R` `\x04\x82\x01R`!`$\x82\x01R\x7FPre size does not match expansio`D\x82\x01R\x7Fn\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0`d\x82\x01R`\x84\x01a\x06\xB7V[\x82\x85\x10aA\x14W`@QbF\x1B\xCD`\xE5\x1B\x81R` `\x04\x82\x01\x81\x90R`$\x82\x01R\x7FPre size not less than post size`D\x82\x01R`d\x01a\x06\xB7V[_\x85\x90P__\x90P_aA)\x85_\x87QaJ\x13V[\x90P[\x85\x83\x10\x15aA\xEBW_aA?\x84\x88aK\x87V[\x90P\x84Q\x83\x10aA\x91W`@QbF\x1B\xCD`\xE5\x1B\x81R` `\x04\x82\x01R`\x12`$\x82\x01R\x7FIndex out of range\0\0\0\0\0\0\0\0\0\0\0\0\0\0`D\x82\x01R`d\x01a\x06\xB7V[aA\xB5\x82\x82\x87\x86\x81Q\x81\x10aA\xA8WaA\xA8a`EV[` \x02` \x01\x01QaLnV[\x91P`\x01\x81\x1BaA\xC5\x81\x86ab$V[\x94P\x87\x85\x11\x15aA\xD7WaA\xD7ad\xAFV[\x83aA\xE1\x81ad\xC3V[\x94PPPPaA,V[\x86aA\xF5\x82aE\x02V[\x14aBhW`@QbF\x1B\xCD`\xE5\x1B\x81R` `\x04\x82\x01R`\"`$\x82\x01R\x7FPost expansion root not equal po`D\x82\x01R\x7Fst\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0`d\x82\x01R`\x84\x01a\x06\xB7V[\x83Q\x82\x14aB\xB8W`@QbF\x1B\xCD`\xE5\x1B\x81R` `\x04\x82\x01R`\x16`$\x82\x01R\x7FIncomplete proof usage\0\0\0\0\0\0\0\0\0\0`D\x82\x01R`d\x01a\x06\xB7V[PPPPPPPPPV[aB\xCBaU.V[aB\xD8\x87\x87\x87\x87\x87aQ\xD6V[P`@\x80Qa\x01\xE0\x81\x01\x82R\x96\x87R` \x87\x01\x95\x90\x95R\x93\x85\x01\x92\x90\x92R``\x84\x01R`\x80\x83\x01R_`\xA0\x83\x01\x81\x90R`\xC0\x83\x01\x81\x90R`\xE0\x83\x01\x81\x90Ra\x01\0\x83\x01\x81\x90Rg\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFFC\x16a\x01 \x84\x01Ra\x01@\x83\x01\x81\x90Ra\x01`\x83\x01\x81\x90R`\xFF\x90\x91\x16a\x01\x80\x83\x01Ra\x01\xA0\x82\x01\x81\x90Ra\x01\xC0\x82\x01R\x90V[a\x01\x80\x81\x01Q\x81Q`@\x80\x84\x01Q` \x80\x86\x01Q`\x80\x87\x01Q``\x88\x01Q\x85Q`\xF8\x98\x90\x98\x1B`\x01`\x01`\xF8\x1B\x03\x19\x16\x88\x85\x01R`!\x88\x01\x96\x90\x96R`A\x87\x01\x93\x90\x93R`a\x86\x01R`\x81\x80\x86\x01\x92\x90\x92R\x82Q\x80\x86\x03\x90\x92\x01\x82R`\xA1\x85\x01\x83R\x81Q\x91\x81\x01\x91\x90\x91 `\xC1\x85\x01R`\xE1\x80\x85\x01\x93\x90\x93R\x81Q\x80\x85\x03\x90\x93\x01\x83Ra\x01\x01\x90\x93\x01\x90R\x80Q\x91\x01 _\x90a\x10PV[`\x05\x83\x01T\x15\x15\x80aD\x07WP`\x06\x83\x01T\x15\x15[\x15aDbWaD\x15\x83a(mV[`\x05\x84\x01T`\x06\x85\x01T`@Q\x7F\x8B\x0Eq\xD0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x81\x01\x93\x90\x93R`$\x83\x01\x91\x90\x91R`D\x82\x01R`d\x01a\x06\xB7V[`\x05\x83\x01\x91\x90\x91U`\x06\x90\x91\x01UV[aDzaU\xC5V[`@Q\x80`@\x01`@R\x80\x83_\x01Q\x81R` \x01\x83` \x01Q`\x02\x81\x11\x15aD\xA4WaD\xA4a[\x03V[\x90R\x92\x91PPV[_\x80aD\xB9\x84`\x01a`mV[\x90PaD\xC5\x81\x84a\x1C#V[P\x93\x92PPPV[``a \xC5\x83_\x84`@Q` \x01aD\xE7\x91\x81R` \x01\x90V[`@Q` \x81\x83\x03\x03\x81R\x90`@R\x80Q\x90` \x01 aLnV[__\x82Q\x11aESW`@QbF\x1B\xCD`\xE5\x1B\x81R` `\x04\x82\x01R`\x16`$\x82\x01R\x7FEmpty merkle expansion\0\0\0\0\0\0\0\0\0\0`D\x82\x01R`d\x01a\x06\xB7V[`@\x82Q\x11\x15aE\xA5W`@QbF\x1B\xCD`\xE5\x1B\x81R` `\x04\x82\x01R`\x1A`$\x82\x01R\x7FMerkle expansion too large\0\0\0\0\0\0`D\x82\x01R`d\x01a\x06\xB7V[_\x80[\x83Q\x81\x10\x15aF\x8BW_\x84\x82\x81Q\x81\x10aE\xC4WaE\xC4a`EV[` \x02` \x01\x01Q\x90P\x82__\x1B\x03aF.W\x80\x15aF)W\x80\x92P`\x01\x85QaE\xEE\x91\x90a`\x99V[\x82\x14aF)W`@QaF\x10\x90\x84\x90_\x90` \x01\x91\x82R` \x82\x01R`@\x01\x90V[`@Q` \x81\x83\x03\x03\x81R\x90`@R\x80Q\x90` \x01 \x92P[aF\x82V[\x80\x15aFMW`@\x80Q` \x81\x01\x83\x90R\x90\x81\x01\x84\x90R``\x01aF\x10V[`@QaFi\x90\x84\x90_\x90` \x01\x91\x82R` \x82\x01R`@\x01\x90V[`@Q` \x81\x83\x03\x03\x81R\x90`@R\x80Q\x90` \x01 \x92P[P`\x01\x01aE\xA8V[P\x92\x91PPV[aF\x9AaU.V[`\x01`\x01`\xA0\x1B\x03\x83\x16aF\xDAW`@Q\x7F\xF2\x89\xE6W\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[_\x84\x90\x03aG\x14W`@Q\x7Fi2\xBC\xFD\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[aG!\x89\x89\x89\x89\x89aQ\xD6V[`@Q\x80a\x01\xE0\x01`@R\x80\x8A\x81R` \x01\x89\x81R` \x01\x88\x81R` \x01\x87\x81R` \x01\x86\x81R` \x01__\x1B\x81R` \x01__\x1B\x81R` \x01\x85\x81R` \x01\x84`\x01`\x01`\xA0\x1B\x03\x16\x81R` \x01Cg\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x81R` \x01_g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x81R` \x01_`\x01\x81\x11\x15aG\xA2WaG\xA2a[\x03V[\x81R`\xFF\x84\x16` \x82\x01R_`@\x82\x01\x81\x90R``\x90\x91\x01R\x90P\x98\x97PPPPPPPPV[``a \xC2\x84\x84_\x85aR\xC7V[\x82Q_\x90a\x01\0\x81\x11\x15aH\"W`@Q\x7F\xFD\xAC3\x1E\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x81\x01\x82\x90Ra\x01\0`$\x82\x01R`D\x01a\x06\xB7V[\x82_[\x82\x81\x10\x15aH\x80W_\x87\x82\x81Q\x81\x10aH@WaH@a`EV[` \x02` \x01\x01Q\x90P\x81`\x01\x90\x1B\x87\x16_\x03aHiW\x82_R\x80` R`@_ \x92PaHwV[\x80_R\x82` R`@_ \x92P[P`\x01\x01aH%V[P\x95\x94PPPPPV[_\x81_\x03aH\xDAW`@QbF\x1B\xCD`\xE5\x1B\x81R` `\x04\x82\x01R`\x1C`$\x82\x01R\x7FZero has no significant bits\0\0\0\0`D\x82\x01R`d\x01a\x06\xB7V[p\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x82\x10aI\x05W`\x80\x91\x82\x1C\x91aI\x02\x90\x82ab$V[\x90P[`\x01`@\x1B\x82\x10aI#W`@\x91\x82\x1C\x91aI \x90\x82ab$V[\x90P[d\x01\0\0\0\0\x82\x10aIBW` \x91\x82\x1C\x91aI?\x90\x82ab$V[\x90P[b\x01\0\0\x82\x10aI_W`\x10\x91\x82\x1C\x91aI\\\x90\x82ab$V[\x90P[a\x01\0\x82\x10aI{W`\x08\x91\x82\x1C\x91aIx\x90\x82ab$V[\x90P[`\x10\x82\x10aI\x96W`\x04\x91\x82\x1C\x91aI\x93\x90\x82ab$V[\x90P[`\x04\x82\x10aI\xB1W`\x02\x91\x82\x1C\x91aI\xAE\x90\x82ab$V[\x90P[`\x02\x82\x10a\x10\xEDWa\x10P`\x01\x82ab$V[_\x80\x80[\x83Q\x81\x10\x15aF\x8BW\x83\x81\x81Q\x81\x10aI\xE3WaI\xE3a`EV[` \x02` \x01\x01Q__\x1B\x14aJ\x0BWaI\xFE\x81`\x02ae\xB6V[aJ\x08\x90\x83ab$V[\x91P[`\x01\x01aI\xC8V[``\x81\x83\x10aJdW`@QbF\x1B\xCD`\xE5\x1B\x81R` `\x04\x82\x01R`\x17`$\x82\x01R\x7FStart not less than end\0\0\0\0\0\0\0\0\0`D\x82\x01R`d\x01a\x06\xB7V[\x83Q\x82\x11\x15aJ\xDBW`@QbF\x1B\xCD`\xE5\x1B\x81R` `\x04\x82\x01R`!`$\x82\x01R\x7FEnd not less or equal than lengt`D\x82\x01R\x7Fh\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0`d\x82\x01R`\x84\x01a\x06\xB7V[_aJ\xE6\x84\x84a`\x99V[g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x11\x15aJ\xFEWaJ\xFEa\\\xCEV[`@Q\x90\x80\x82R\x80` \x02` \x01\x82\x01`@R\x80\x15aK'W\x81` \x01` \x82\x02\x806\x837\x01\x90P[P\x90P\x83[\x83\x81\x10\x15aK~W\x85\x81\x81Q\x81\x10aKFWaKFa`EV[` \x02` \x01\x01Q\x82\x86\x83aK[\x91\x90a`\x99V[\x81Q\x81\x10aKkWaKka`EV[` \x90\x81\x02\x91\x90\x91\x01\x01R`\x01\x01aK,V[P\x94\x93PPPPV[_\x81\x83\x10aK\xD7W`@QbF\x1B\xCD`\xE5\x1B\x81R` `\x04\x82\x01R`\x17`$\x82\x01R\x7FStart not less than end\0\0\0\0\0\0\0\0\0`D\x82\x01R`d\x01a\x06\xB7V[_aK\xE3\x83\x85\x18aH\x8AV[\x90P_`\x01aK\xF2\x83\x82ab$V[`\x01\x90\x1BaL\0\x91\x90a`\x99V[\x90P\x84\x81\x16\x84\x82\x16\x81\x15aL\x17Wa >\x82aT\0V[\x80\x15aL&Wa >\x81aH\x8AV[`@QbF\x1B\xCD`\xE5\x1B\x81R` `\x04\x82\x01R`\x1B`$\x82\x01R\x7FBoth y and z cannot be zero\0\0\0\0\0`D\x82\x01R`d\x01a\x06\xB7V[```@\x83\x10aL\xC0W`@QbF\x1B\xCD`\xE5\x1B\x81R` `\x04\x82\x01R`\x0E`$\x82\x01R\x7FLevel too high\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0`D\x82\x01R`d\x01a\x06\xB7V[_\x82\x90\x03aM\x10W`@QbF\x1B\xCD`\xE5\x1B\x81R` `\x04\x82\x01R`\x1B`$\x82\x01R\x7FCannot append empty subtree\0\0\0\0\0`D\x82\x01R`d\x01a\x06\xB7V[`@\x84Q\x11\x15aMbW`@QbF\x1B\xCD`\xE5\x1B\x81R` `\x04\x82\x01R`\x1A`$\x82\x01R\x7FMerkle expansion too large\0\0\0\0\0\0`D\x82\x01R`d\x01a\x06\xB7V[\x83Q_\x03aM\xDFW_aMv\x84`\x01ab$V[g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x11\x15aM\x8EWaM\x8Ea\\\xCEV[`@Q\x90\x80\x82R\x80` \x02` \x01\x82\x01`@R\x80\x15aM\xB7W\x81` \x01` \x82\x02\x806\x837\x01\x90P[P\x90P\x82\x81\x85\x81Q\x81\x10aM\xCDWaM\xCDa`EV[` \x90\x81\x02\x91\x90\x91\x01\x01R\x90Pa \xC5V[\x83Q\x83\x10aNUW`@QbF\x1B\xCD`\xE5\x1B\x81R` `\x04\x82\x01R`5`$\x82\x01R\x7FLevel greater than highest level`D\x82\x01R\x7F of current expansion\0\0\0\0\0\0\0\0\0\0\0`d\x82\x01R`\x84\x01a\x06\xB7V[\x81_aN`\x86aI\xC4V[\x90P_aNn\x86`\x02ae\xB6V[aNx\x90\x83ab$V[\x90P_aN\x84\x83aH\x8AV[aN\x8D\x83aH\x8AV[\x11aN\xDBW\x87Qg\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x11\x15aN\xACWaN\xACa\\\xCEV[`@Q\x90\x80\x82R\x80` \x02` \x01\x82\x01`@R\x80\x15aN\xD5W\x81` \x01` \x82\x02\x806\x837\x01\x90P[PaO+V[\x87QaN\xE8\x90`\x01ab$V[g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x11\x15aO\0WaO\0a\\\xCEV[`@Q\x90\x80\x82R\x80` \x02` \x01\x82\x01`@R\x80\x15aO)W\x81` \x01` \x82\x02\x806\x837\x01\x90P[P[\x90P`@\x81Q\x11\x15aO\x7FW`@QbF\x1B\xCD`\xE5\x1B\x81R` `\x04\x82\x01R`\x1C`$\x82\x01R\x7FAppend creates oversize tree\0\0\0\0`D\x82\x01R`d\x01a\x06\xB7V[_[\x88Q\x81\x10\x15aQ+W\x87\x81\x10\x15aP'W\x88\x81\x81Q\x81\x10aO\xA4WaO\xA4a`EV[` \x02` \x01\x01Q__\x1B\x14aP\"W`@QbF\x1B\xCD`\xE5\x1B\x81R` `\x04\x82\x01R`\"`$\x82\x01R\x7FAppend above least significant b`D\x82\x01R\x7Fit\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0`d\x82\x01R`\x84\x01a\x06\xB7V[aQ#V[_\x85\x90\x03aPlW\x88\x81\x81Q\x81\x10aPAWaPAa`EV[` \x02` \x01\x01Q\x82\x82\x81Q\x81\x10aP[WaP[a`EV[` \x02` \x01\x01\x81\x81RPPaQ#V[\x88\x81\x81Q\x81\x10aP~WaP~a`EV[` \x02` \x01\x01Q__\x1B\x03aP\xB4W\x84\x82\x82\x81Q\x81\x10aP\xA1WaP\xA1a`EV[` \x90\x81\x02\x91\x90\x91\x01\x01R_\x94PaQ#V[__\x1B\x82\x82\x81Q\x81\x10aP\xC9WaP\xC9a`EV[` \x02` \x01\x01\x81\x81RPP\x88\x81\x81Q\x81\x10aP\xE7WaP\xE7a`EV[` \x02` \x01\x01Q\x85`@Q` \x01aQ\n\x92\x91\x90\x91\x82R` \x82\x01R`@\x01\x90V[`@Q` \x81\x83\x03\x03\x81R\x90`@R\x80Q\x90` \x01 \x94P[`\x01\x01aO\x81V[P\x83\x15aQ_W\x83\x81`\x01\x83QaQB\x91\x90a`\x99V[\x81Q\x81\x10aQRWaQRa`EV[` \x02` \x01\x01\x81\x81RPP[\x80`\x01\x82QaQn\x91\x90a`\x99V[\x81Q\x81\x10aQ~WaQ~a`EV[` \x02` \x01\x01Q__\x1B\x03a\x05lW`@QbF\x1B\xCD`\xE5\x1B\x81R` `\x04\x82\x01R`\x0F`$\x82\x01R\x7FLast entry zero\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0`D\x82\x01R`d\x01a\x06\xB7V[_\x85\x90\x03aR\x10W`@Q\x7F\x8Dy\xDB\xBC\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[\x82\x81\x11aRSW`@Q\x7F `\xFA\xF4\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x81\x01\x84\x90R`$\x81\x01\x82\x90R`D\x01a\x06\xB7V[_\x84\x90\x03aR\x8DW`@Q\x7F\x83\xC6\x83\xE4\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[_\x82\x90\x03a\x13)W`@Q\x7F\\\xB6\xE5\xBB\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[``\x82G\x10\x15aS?W`@QbF\x1B\xCD`\xE5\x1B\x81R` `\x04\x82\x01R`&`$\x82\x01R\x7FAddress: insufficient balance fo`D\x82\x01R\x7Fr call\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0`d\x82\x01R`\x84\x01a\x06\xB7V[`\x01`\x01`\xA0\x1B\x03\x85\x16;aS\x96W`@QbF\x1B\xCD`\xE5\x1B\x81R` `\x04\x82\x01R`\x1D`$\x82\x01R\x7FAddress: call to non-contract\0\0\0`D\x82\x01R`d\x01a\x06\xB7V[__\x86`\x01`\x01`\xA0\x1B\x03\x16\x85\x87`@QaS\xB1\x91\x90ae\xC1V[_`@Q\x80\x83\x03\x81\x85\x87Z\xF1\x92PPP=\x80_\x81\x14aS\xEBW`@Q\x91P`\x1F\x19`?=\x01\x16\x82\x01`@R=\x82R=_` \x84\x01>aS\xF0V[``\x91P[P\x91P\x91Pa\x05l\x82\x82\x86aTkV[__\x82\x11aTPW`@QbF\x1B\xCD`\xE5\x1B\x81R` `\x04\x82\x01R`\x1C`$\x82\x01R\x7FZero has no significant bits\0\0\0\0`D\x82\x01R`d\x01a\x06\xB7V[_\x82\x80aT^`\x01\x82a`\x99V[\x16\x18\x90Pa \xC5\x81aH\x8AV[``\x83\x15aTzWP\x81a \xC5V[\x82Q\x15aT\x8AW\x82Q\x80\x84` \x01\xFD[\x81`@QbF\x1B\xCD`\xE5\x1B\x81R`\x04\x01a\x06\xB7\x91\x90ae\xD7V[`@Q\x80`\xC0\x01`@R\x80_\x81R` \x01_\x81R` \x01_\x15\x15\x81R` \x01_\x15\x15\x81R` \x01aT\xD3aU\xE3V[\x81R` \x01aT\xE0aU\xE3V[\x90R\x90V[\x82\x80T\x82\x82U\x90_R` _ \x90\x81\x01\x92\x82\x15aU\x1EW\x91` \x02\x82\x01[\x82\x81\x11\x15aU\x1EW\x825\x82U\x91` \x01\x91\x90`\x01\x01\x90aU\x03V[PaU*\x92\x91PaV\x08V[P\x90V[`@Q\x80a\x01\xE0\x01`@R\x80_\x81R` \x01_\x81R` \x01_\x81R` \x01_\x81R` \x01_\x81R` \x01_\x81R` \x01_\x81R` \x01_\x81R` \x01_`\x01`\x01`\xA0\x1B\x03\x16\x81R` \x01_g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x81R` \x01_g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x81R` \x01_`\x01\x81\x11\x15aU\xABWaU\xABa[\x03V[\x81R_` \x82\x01\x81\x90R`@\x82\x01\x81\x90R``\x90\x91\x01R\x90V[`@Q\x80`@\x01`@R\x80aU\xD8aV\x1CV[\x81R` \x01_\x90R\x90V[`@Q\x80``\x01`@R\x80aU\xF6aV\x1CV[\x81R` \x01_\x81R` \x01_\x81RP\x90V[[\x80\x82\x11\x15aU*W_\x81U`\x01\x01aV\tV[`@Q\x80`@\x01`@R\x80aV/aV8V[\x81R` \x01aT\xE0[`@Q\x80`@\x01`@R\x80`\x02\x90` \x82\x02\x806\x837P\x91\x92\x91PPV[\x805`\xFF\x81\x16\x81\x14a\x10\xEDW__\xFD[______`\xC0\x87\x89\x03\x12\x15aV{W__\xFD[aV\x84\x87aVVV[\x98` \x88\x015\x98P`@\x88\x015\x97``\x81\x015\x97P`\x80\x81\x015\x96P`\xA0\x015\x94P\x92PPPV[_` \x82\x84\x03\x12\x15aV\xBCW__\xFD[\x815g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x11\x15aV\xD2W__\xFD[\x82\x01`\xC0\x81\x85\x03\x12\x15a \xC5W__\xFD[`\x01`\x01`\xA0\x1B\x03\x81\x16\x81\x14aV\xF7W__\xFD[PV[g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x16\x81\x14aV\xF7W__\xFD[\x805a\x10\xED\x81aV\xE3V[__\x83`\x1F\x84\x01\x12aW*W__\xFD[P\x815g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x11\x15aWAW__\xFD[` \x83\x01\x91P\x83` \x82`\x05\x1B\x85\x01\x01\x11\x15aW[W__\xFD[\x92P\x92\x90PV[___________a\x01@\x8C\x8E\x03\x12\x15aW}W__\xFD[\x8B5aW\x88\x81aV\xE3V[\x9AP` \x8C\x015aW\x98\x81aV\xFAV[\x99P`@\x8C\x015aW\xA8\x81aV\xE3V[\x98P``\x8C\x015\x97P`\x80\x8C\x015\x96P`\xA0\x8C\x015\x95P`\xC0\x8C\x015aW\xCD\x81aV\xE3V[\x94PaW\xDB`\xE0\x8D\x01aW\x0FV[\x93PaW\xEAa\x01\0\x8D\x01aVVV[\x92Pa\x01 \x8C\x015g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x11\x15aX\x06W__\xFD[aX\x12\x8E\x82\x8F\x01aW\x1AV[\x91P\x80\x93PP\x80\x91PP\x92\x95\x98\x9BP\x92\x95\x98\x9B\x90\x93\x96\x99PV[_` \x82\x84\x03\x12\x15aX<W__\xFD[P5\x91\x90PV[`\x03\x81\x10aV\xF7W__\xFD[\x805a\x10\xED\x81aXCV[_` \x82\x84\x03\x12\x15aXjW__\xFD[\x815a \xC5\x81aXCV[___`@\x84\x86\x03\x12\x15aX\x87W__\xFD[\x835g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x11\x15aX\x9DW__\xFD[aX\xA9\x86\x82\x87\x01aW\x1AV[\x90\x97\x90\x96P` \x95\x90\x95\x015\x94\x93PPPPV[__`@\x83\x85\x03\x12\x15aX\xCEW__\xFD[\x825aX\xD9\x81aV\xE3V[\x94` \x93\x90\x93\x015\x93PPPV[___``\x84\x86\x03\x12\x15aX\xF9W__\xFD[PP\x815\x93` \x83\x015\x93P`@\x90\x92\x015\x91\x90PV[_______\x87\x89\x03a\x01 \x81\x12\x15aY(W__\xFD[\x885\x97P` \x89\x015g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x11\x15aYEW__\xFD[\x89\x01`@\x81\x8C\x03\x12\x15aYVW__\xFD[\x96P`\xA0\x7F\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xC0\x82\x01\x12\x15aY\x87W__\xFD[P`@\x88\x01\x94P`\xE0\x88\x015g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x11\x15aY\xA7W__\xFD[aY\xB3\x8A\x82\x8B\x01aW\x1AV[\x90\x95P\x93PPa\x01\0\x88\x015g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x11\x15aY\xD3W__\xFD[aY\xDF\x8A\x82\x8B\x01aW\x1AV[\x98\x9B\x97\x9AP\x95\x98P\x93\x96\x92\x95\x92\x93PPPV[__\x82\x84\x03a\x01 \x81\x12\x15aZ\x05W__\xFD[\x835\x92Pa\x01\0`\x1F\x19\x82\x01\x12\x15aZ\x1BW__\xFD[P` \x83\x01\x90P\x92P\x92\x90PV[_____`\xA0\x86\x88\x03\x12\x15aZ=W__\xFD[aZF\x86aVVV[\x97` \x87\x015\x97P`@\x87\x015\x96``\x81\x015\x96P`\x80\x015\x94P\x92PPPV[____``\x85\x87\x03\x12\x15aZzW__\xFD[\x845\x93P` \x85\x015\x92P`@\x85\x015g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x11\x15aZ\x9EW__\xFD[\x85\x01`\x1F\x81\x01\x87\x13aZ\xAEW__\xFD[\x805g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x11\x15aZ\xC4W__\xFD[\x87` \x82\x84\x01\x01\x11\x15aZ\xD5W__\xFD[\x94\x97\x93\x96P` \x01\x94PPPV[__`@\x83\x85\x03\x12\x15aZ\xF4W__\xFD[PP\x805\x92` \x90\x91\x015\x91PV[cNH{q`\xE0\x1B_R`!`\x04R`$_\xFD[`\x02\x81\x10a['Wa['a[\x03V[\x90RV[_a\x01\xE0\x82\x01\x90P\x82Q\x82R` \x83\x01Q` \x83\x01R`@\x83\x01Q`@\x83\x01R``\x83\x01Q``\x83\x01R`\x80\x83\x01Q`\x80\x83\x01R`\xA0\x83\x01Q`\xA0\x83\x01R`\xC0\x83\x01Q`\xC0\x83\x01R`\xE0\x83\x01Q`\xE0\x83\x01Ra\x01\0\x83\x01Qa[\x99a\x01\0\x84\x01\x82`\x01`\x01`\xA0\x1B\x03\x16\x90RV[Pa\x01 \x83\x01Qa[\xB7a\x01 \x84\x01\x82g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x90RV[Pa\x01@\x83\x01Qa[\xD5a\x01@\x84\x01\x82g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x90RV[Pa\x01`\x83\x01Qa[\xEAa\x01`\x84\x01\x82a[\x17V[Pa\x01\x80\x83\x01Qa\\\x01a\x01\x80\x84\x01\x82`\xFF\x16\x90RV[Pa\x01\xA0\x83\x01Qa\\\x17a\x01\xA0\x84\x01\x82\x15\x15\x90RV[Pa\x01\xC0\x83\x01QaF\x8Ba\x01\xC0\x84\x01\x82g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x90RV[_` \x82\x84\x03\x12\x15a\\EW__\xFD[\x81Q\x80\x15\x15\x81\x14a \xC5W__\xFD[_` \x82\x84\x03\x12\x15a\\dW__\xFD[a \xC5\x82aVVV[__\x835\x7F\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xE1\x846\x03\x01\x81\x12a\\\xA0W__\xFD[\x83\x01\x805\x91Pg\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x82\x11\x15a\\\xBAW__\xFD[` \x01\x91P6\x81\x90\x03\x82\x13\x15aW[W__\xFD[cNH{q`\xE0\x1B_R`A`\x04R`$_\xFD[`@Q``\x81\x01g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x11\x82\x82\x10\x17\x15a]\x05Wa]\x05a\\\xCEV[`@R\x90V[`@\x80Q\x90\x81\x01g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x11\x82\x82\x10\x17\x15a]\x05Wa]\x05a\\\xCEV[`@Q`\x1F\x82\x01`\x1F\x19\x16\x81\x01g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x11\x82\x82\x10\x17\x15a]WWa]Wa\\\xCEV[`@R\x91\x90PV[_g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x82\x11\x15a]xWa]xa\\\xCEV[P`\x05\x1B` \x01\x90V[_\x82`\x1F\x83\x01\x12a]\x91W__\xFD[\x815a]\xA4a]\x9F\x82a]_V[a].V[\x80\x82\x82R` \x82\x01\x91P` \x83`\x05\x1B\x86\x01\x01\x92P\x85\x83\x11\x15a]\xC5W__\xFD[` \x85\x01[\x83\x81\x10\x15aH\x80W\x805\x83R` \x92\x83\x01\x92\x01a]\xCAV[_\x82`\x1F\x83\x01\x12a]\xF1W__\xFD[a]\xFB`@a].V[\x80`@\x84\x01\x85\x81\x11\x15a^\x0CW__\xFD[\x84[\x81\x81\x10\x15a5\x0EW\x805a^!\x81aV\xFAV[\x84R` \x93\x84\x01\x93\x01a^\x0EV[_\x81\x83\x03a\x01\0\x81\x12\x15a^AW__\xFD[a^Ia\\\xE2V[\x91P`\xC0\x81\x12\x15a^XW__\xFD[a^`a\\\xE2V[`\x80\x82\x12\x15a^mW__\xFD[a^ua]\x0BV[\x91P\x84`\x1F\x85\x01\x12a^\x85W__\xFD[a^\x8F`@a].V[\x80`@\x86\x01\x87\x81\x11\x15a^\xA0W__\xFD[\x86[\x81\x81\x10\x15a^\xBAW\x805\x84R` \x93\x84\x01\x93\x01a^\xA2V[P\x81\x85Ra^\xC8\x88\x82a]\xE2V[` \x86\x01RPPP\x81\x81Ra^\xDF`\x80\x85\x01aXOV[` \x82\x81\x01\x91\x90\x91R`\xA0\x85\x015`@\x80\x84\x01\x91\x90\x91R\x91\x84R`\xC0\x85\x015\x90\x84\x01R`\xE0\x90\x93\x015\x92\x82\x01\x92\x90\x92R\x92\x91PPV[___a\x02 \x84\x86\x03\x12\x15a_(W__\xFD[\x835g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x11\x15a_>W__\xFD[a_J\x86\x82\x87\x01a]\x82V[\x93PPa_Z\x85` \x86\x01a^/V[\x91Pa_j\x85a\x01 \x86\x01a^/V[\x90P\x92P\x92P\x92V[\x80Q\x82_[`\x02\x81\x10\x15a_\x97W\x82Q\x82R` \x92\x83\x01\x92\x90\x91\x01\x90`\x01\x01a_xV[PPP` \x81\x01Q`@\x83\x01_[`\x02\x81\x10\x15a\x13)W\x82Qg\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x82R` \x92\x83\x01\x92\x90\x91\x01\x90`\x01\x01a_\xA5V[`\x03\x81\x10aV\xF7WaV\xF7a[\x03V[_a\x01 \x82\x01\x90P\x85\x82Ra_\xF7` \x83\x01\x86Qa_sV[` \x85\x01Qa`\x05\x81a_\xCEV[`\xA0\x83\x01R`@\x94\x90\x94\x01Q`\xC0\x82\x01R`\xE0\x81\x01\x92\x90\x92Ra\x01\0\x90\x91\x01R\x91\x90PV[_` \x82\x84\x03\x12\x15a`:W__\xFD[\x81Qa \xC5\x81aV\xFAV[cNH{q`\xE0\x1B_R`2`\x04R`$_\xFD[cNH{q`\xE0\x1B_R`\x11`\x04R`$_\xFD[`\xFF\x81\x81\x16\x83\x82\x16\x01\x90\x81\x11\x15a\x10PWa\x10Pa`YV[` \x81\x01a`\x93\x83a_\xCEV[\x91\x90R\x90V[\x81\x81\x03\x81\x81\x11\x15a\x10PWa\x10Pa`YV[\x82\x81R\x815` \x80\x83\x01\x91\x90\x91R\x82\x015`@\x80\x83\x01\x91\x90\x91R`\xC0\x82\x01\x90\x83\x015a`\xD7\x81aV\xE3V[`\x01`\x01`\xA0\x1B\x03\x81\x16``\x84\x01RP``\x83\x015a`\xF5\x81aV\xFAV[g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x16`\x80\x84\x01RP`\x80\x83\x015aa\x14\x81aV\xFAV[g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x16`\xA0\x84\x01RP\x93\x92PPPV[_` \x82\x84\x03\x12\x15aa<W__\xFD[\x815a \xC5\x81aV\xFAV[_` \x82\x84\x03\x12\x15aaWW__\xFD[\x81Qa \xC5\x81aV\xE3V[\x84\x81Ra\x01 \x81\x01`@\x85` \x84\x017``\x82\x01`@\x86\x01_[`\x02\x81\x10\x15aa\xAFW\x815aa\x90\x81aV\xFAV[g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x83R` \x92\x83\x01\x92\x91\x90\x91\x01\x90`\x01\x01aa|V[PPP`\x80\x85\x015aa\xC0\x81aXCV[aa\xC9\x81a_\xCEV[`\xA0\x83\x81\x01\x91\x90\x91R\x94\x90\x94\x015`\xC0\x82\x01R`\xE0\x81\x01\x92\x90\x92Ra\x01\0\x90\x91\x01R\x91\x90PV[g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x82\x81\x16\x82\x82\x16\x03\x90\x81\x11\x15a\x10PWa\x10Pa`YV[\x82\x81R`@\x81\x01a \xC5` \x83\x01\x84a[\x17V[\x80\x82\x01\x80\x82\x11\x15a\x10PWa\x10Pa`YV[\x80\x82\x02\x81\x15\x82\x82\x04\x84\x14\x17a\x10PWa\x10Pa`YV[\x85Q\x81R`\x01`\x01`\xA0\x1B\x03` \x87\x01Q\x16` \x82\x01R`@\x86\x01Q`@\x82\x01R\x84``\x82\x01R\x83`\x80\x82\x01R`\xC0`\xA0\x82\x01R\x81`\xC0\x82\x01R\x81\x83`\xE0\x83\x017_\x81\x83\x01`\xE0\x90\x81\x01\x91\x90\x91R`\x1F\x90\x92\x01`\x1F\x19\x16\x01\x01\x94\x93PPPPV[_` \x82\x84\x03\x12\x15ab\xBFW__\xFD[PQ\x91\x90PV[_\x82`\x1F\x83\x01\x12ab\xD5W__\xFD[\x81Qab\xE3a]\x9F\x82a]_V[\x80\x82\x82R` \x82\x01\x91P` \x83`\x05\x1B\x86\x01\x01\x92P\x85\x83\x11\x15ac\x04W__\xFD[` \x85\x01[\x83\x81\x10\x15aH\x80W\x80Q\x83R` \x92\x83\x01\x92\x01ac\tV[__`@\x83\x85\x03\x12\x15ac2W__\xFD[\x82Qg\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x11\x15acHW__\xFD[acT\x85\x82\x86\x01ab\xC6V[\x92PP` \x83\x01Qg\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x11\x15acpW__\xFD[ac|\x85\x82\x86\x01ab\xC6V[\x91PP\x92P\x92\x90PV[_`\xA0\x82\x01\x90Pac\x98\x82\x84Qa_sV[` \x83\x01Qac\xA6\x81a_\xCEV[\x80`\x80\x84\x01RP\x92\x91PPV[_____`\xA0\x86\x88\x03\x12\x15ac\xC7W__\xFD[\x855\x94P` \x86\x015\x93P`@\x86\x015g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x11\x15ac\xEBW__\xFD[ac\xF7\x88\x82\x89\x01a]\x82V[\x93PP``\x86\x015g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x11\x15ad\x13W__\xFD[ad\x1F\x88\x82\x89\x01a]\x82V[\x92PP`\x80\x86\x015g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x11\x15ad;W__\xFD[adG\x88\x82\x89\x01a]\x82V[\x91PP\x92\x95P\x92\x95\x90\x93PV[__`@\x83\x85\x03\x12\x15adeW__\xFD[\x825g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x11\x15ad{W__\xFD[ad\x87\x85\x82\x86\x01a]\x82V[\x92PP` \x83\x015g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x11\x15ad\xA3W__\xFD[ac|\x85\x82\x86\x01a]\x82V[cNH{q`\xE0\x1B_R`\x01`\x04R`$_\xFD[_`\x01\x82\x01ad\xD4Wad\xD4a`YV[P`\x01\x01\x90V[`\x01\x81[`\x01\x84\x11\x15a.zW\x80\x85\x04\x81\x11\x15ad\xFAWad\xFAa`YV[`\x01\x84\x16\x15ae\x08W\x90\x81\x02\x90[`\x01\x93\x90\x93\x1C\x92\x80\x02ad\xDFV[_\x82ae$WP`\x01a\x10PV[\x81ae0WP_a\x10PV[\x81`\x01\x81\x14aeFW`\x02\x81\x14aePWaelV[`\x01\x91PPa\x10PV[`\xFF\x84\x11\x15aeaWaeaa`YV[PP`\x01\x82\x1Ba\x10PV[P` \x83\x10a\x013\x83\x10\x16`N\x84\x10`\x0B\x84\x10\x16\x17\x15ae\x8FWP\x81\x81\na\x10PV[ae\x9B_\x19\x84\x84ad\xDBV[\x80_\x19\x04\x82\x11\x15ae\xAEWae\xAEa`YV[\x02\x93\x92PPPV[_a \xC5\x83\x83ae\x16V[_\x82Q\x80` \x85\x01\x84^_\x92\x01\x91\x82RP\x91\x90PV[` \x81R_\x82Q\x80` \x84\x01R\x80` \x85\x01`@\x85\x01^_`@\x82\x85\x01\x01R`@`\x1F\x19`\x1F\x83\x01\x16\x84\x01\x01\x91PP\x92\x91PPV\xFE\xA2dipfsX\"\x12 }]\xF4\xA8\rX\xA5#R\xE9\xEF\xC0z\0of\xC9D\x82h\x99\xB9A\x9B\x94\xD6\xDE\xB8\xC4\xE1\x14\xD1dsolcC\0\x08\x1C\x003",
    );
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct EdgeStatus(u8);
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[automatically_derived]
        impl alloy_sol_types::private::SolTypeValue<EdgeStatus> for u8 {
            #[inline]
            fn stv_to_tokens(
                &self,
            ) -> <alloy::sol_types::sol_data::Uint<
                8,
            > as alloy_sol_types::SolType>::Token<'_> {
                alloy_sol_types::private::SolTypeValue::<
                    alloy::sol_types::sol_data::Uint<8>,
                >::stv_to_tokens(self)
            }
            #[inline]
            fn stv_eip712_data_word(&self) -> alloy_sol_types::Word {
                <alloy::sol_types::sol_data::Uint<
                    8,
                > as alloy_sol_types::SolType>::tokenize(self)
                    .0
            }
            #[inline]
            fn stv_abi_encode_packed_to(
                &self,
                out: &mut alloy_sol_types::private::Vec<u8>,
            ) {
                <alloy::sol_types::sol_data::Uint<
                    8,
                > as alloy_sol_types::SolType>::abi_encode_packed_to(self, out)
            }
            #[inline]
            fn stv_abi_packed_encoded_size(&self) -> usize {
                <alloy::sol_types::sol_data::Uint<
                    8,
                > as alloy_sol_types::SolType>::abi_encoded_size(self)
            }
        }
        #[automatically_derived]
        impl EdgeStatus {
            /// The Solidity type name.
            pub const NAME: &'static str = stringify!(@ name);
            /// Convert from the underlying value type.
            #[inline]
            pub const fn from(value: u8) -> Self {
                Self(value)
            }
            /// Return the underlying value.
            #[inline]
            pub const fn into(self) -> u8 {
                self.0
            }
            /// Return the single encoding of this value, delegating to the
            /// underlying type.
            #[inline]
            pub fn abi_encode(&self) -> alloy_sol_types::private::Vec<u8> {
                <Self as alloy_sol_types::SolType>::abi_encode(&self.0)
            }
            /// Return the packed encoding of this value, delegating to the
            /// underlying type.
            #[inline]
            pub fn abi_encode_packed(&self) -> alloy_sol_types::private::Vec<u8> {
                <Self as alloy_sol_types::SolType>::abi_encode_packed(&self.0)
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolType for EdgeStatus {
            type RustType = u8;
            type Token<'a> = <alloy::sol_types::sol_data::Uint<
                8,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SOL_NAME: &'static str = Self::NAME;
            const ENCODED_SIZE: Option<usize> = <alloy::sol_types::sol_data::Uint<
                8,
            > as alloy_sol_types::SolType>::ENCODED_SIZE;
            const PACKED_ENCODED_SIZE: Option<usize> = <alloy::sol_types::sol_data::Uint<
                8,
            > as alloy_sol_types::SolType>::PACKED_ENCODED_SIZE;
            #[inline]
            fn valid_token(token: &Self::Token<'_>) -> bool {
                Self::type_check(token).is_ok()
            }
            #[inline]
            fn type_check(token: &Self::Token<'_>) -> alloy_sol_types::Result<()> {
                <alloy::sol_types::sol_data::Uint<
                    8,
                > as alloy_sol_types::SolType>::type_check(token)
            }
            #[inline]
            fn detokenize(token: Self::Token<'_>) -> Self::RustType {
                <alloy::sol_types::sol_data::Uint<
                    8,
                > as alloy_sol_types::SolType>::detokenize(token)
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::EventTopic for EdgeStatus {
            #[inline]
            fn topic_preimage_length(rust: &Self::RustType) -> usize {
                <alloy::sol_types::sol_data::Uint<
                    8,
                > as alloy_sol_types::EventTopic>::topic_preimage_length(rust)
            }
            #[inline]
            fn encode_topic_preimage(
                rust: &Self::RustType,
                out: &mut alloy_sol_types::private::Vec<u8>,
            ) {
                <alloy::sol_types::sol_data::Uint<
                    8,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(rust, out)
            }
            #[inline]
            fn encode_topic(
                rust: &Self::RustType,
            ) -> alloy_sol_types::abi::token::WordToken {
                <alloy::sol_types::sol_data::Uint<
                    8,
                > as alloy_sol_types::EventTopic>::encode_topic(rust)
            }
        }
    };
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct EdgeType(u8);
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[automatically_derived]
        impl alloy_sol_types::private::SolTypeValue<EdgeType> for u8 {
            #[inline]
            fn stv_to_tokens(
                &self,
            ) -> <alloy::sol_types::sol_data::Uint<
                8,
            > as alloy_sol_types::SolType>::Token<'_> {
                alloy_sol_types::private::SolTypeValue::<
                    alloy::sol_types::sol_data::Uint<8>,
                >::stv_to_tokens(self)
            }
            #[inline]
            fn stv_eip712_data_word(&self) -> alloy_sol_types::Word {
                <alloy::sol_types::sol_data::Uint<
                    8,
                > as alloy_sol_types::SolType>::tokenize(self)
                    .0
            }
            #[inline]
            fn stv_abi_encode_packed_to(
                &self,
                out: &mut alloy_sol_types::private::Vec<u8>,
            ) {
                <alloy::sol_types::sol_data::Uint<
                    8,
                > as alloy_sol_types::SolType>::abi_encode_packed_to(self, out)
            }
            #[inline]
            fn stv_abi_packed_encoded_size(&self) -> usize {
                <alloy::sol_types::sol_data::Uint<
                    8,
                > as alloy_sol_types::SolType>::abi_encoded_size(self)
            }
        }
        #[automatically_derived]
        impl EdgeType {
            /// The Solidity type name.
            pub const NAME: &'static str = stringify!(@ name);
            /// Convert from the underlying value type.
            #[inline]
            pub const fn from(value: u8) -> Self {
                Self(value)
            }
            /// Return the underlying value.
            #[inline]
            pub const fn into(self) -> u8 {
                self.0
            }
            /// Return the single encoding of this value, delegating to the
            /// underlying type.
            #[inline]
            pub fn abi_encode(&self) -> alloy_sol_types::private::Vec<u8> {
                <Self as alloy_sol_types::SolType>::abi_encode(&self.0)
            }
            /// Return the packed encoding of this value, delegating to the
            /// underlying type.
            #[inline]
            pub fn abi_encode_packed(&self) -> alloy_sol_types::private::Vec<u8> {
                <Self as alloy_sol_types::SolType>::abi_encode_packed(&self.0)
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolType for EdgeType {
            type RustType = u8;
            type Token<'a> = <alloy::sol_types::sol_data::Uint<
                8,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SOL_NAME: &'static str = Self::NAME;
            const ENCODED_SIZE: Option<usize> = <alloy::sol_types::sol_data::Uint<
                8,
            > as alloy_sol_types::SolType>::ENCODED_SIZE;
            const PACKED_ENCODED_SIZE: Option<usize> = <alloy::sol_types::sol_data::Uint<
                8,
            > as alloy_sol_types::SolType>::PACKED_ENCODED_SIZE;
            #[inline]
            fn valid_token(token: &Self::Token<'_>) -> bool {
                Self::type_check(token).is_ok()
            }
            #[inline]
            fn type_check(token: &Self::Token<'_>) -> alloy_sol_types::Result<()> {
                <alloy::sol_types::sol_data::Uint<
                    8,
                > as alloy_sol_types::SolType>::type_check(token)
            }
            #[inline]
            fn detokenize(token: Self::Token<'_>) -> Self::RustType {
                <alloy::sol_types::sol_data::Uint<
                    8,
                > as alloy_sol_types::SolType>::detokenize(token)
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::EventTopic for EdgeType {
            #[inline]
            fn topic_preimage_length(rust: &Self::RustType) -> usize {
                <alloy::sol_types::sol_data::Uint<
                    8,
                > as alloy_sol_types::EventTopic>::topic_preimage_length(rust)
            }
            #[inline]
            fn encode_topic_preimage(
                rust: &Self::RustType,
                out: &mut alloy_sol_types::private::Vec<u8>,
            ) {
                <alloy::sol_types::sol_data::Uint<
                    8,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(rust, out)
            }
            #[inline]
            fn encode_topic(
                rust: &Self::RustType,
            ) -> alloy_sol_types::abi::token::WordToken {
                <alloy::sol_types::sol_data::Uint<
                    8,
                > as alloy_sol_types::EventTopic>::encode_topic(rust)
            }
        }
    };
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct MachineStatus(u8);
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[automatically_derived]
        impl alloy_sol_types::private::SolTypeValue<MachineStatus> for u8 {
            #[inline]
            fn stv_to_tokens(
                &self,
            ) -> <alloy::sol_types::sol_data::Uint<
                8,
            > as alloy_sol_types::SolType>::Token<'_> {
                alloy_sol_types::private::SolTypeValue::<
                    alloy::sol_types::sol_data::Uint<8>,
                >::stv_to_tokens(self)
            }
            #[inline]
            fn stv_eip712_data_word(&self) -> alloy_sol_types::Word {
                <alloy::sol_types::sol_data::Uint<
                    8,
                > as alloy_sol_types::SolType>::tokenize(self)
                    .0
            }
            #[inline]
            fn stv_abi_encode_packed_to(
                &self,
                out: &mut alloy_sol_types::private::Vec<u8>,
            ) {
                <alloy::sol_types::sol_data::Uint<
                    8,
                > as alloy_sol_types::SolType>::abi_encode_packed_to(self, out)
            }
            #[inline]
            fn stv_abi_packed_encoded_size(&self) -> usize {
                <alloy::sol_types::sol_data::Uint<
                    8,
                > as alloy_sol_types::SolType>::abi_encoded_size(self)
            }
        }
        #[automatically_derived]
        impl MachineStatus {
            /// The Solidity type name.
            pub const NAME: &'static str = stringify!(@ name);
            /// Convert from the underlying value type.
            #[inline]
            pub const fn from(value: u8) -> Self {
                Self(value)
            }
            /// Return the underlying value.
            #[inline]
            pub const fn into(self) -> u8 {
                self.0
            }
            /// Return the single encoding of this value, delegating to the
            /// underlying type.
            #[inline]
            pub fn abi_encode(&self) -> alloy_sol_types::private::Vec<u8> {
                <Self as alloy_sol_types::SolType>::abi_encode(&self.0)
            }
            /// Return the packed encoding of this value, delegating to the
            /// underlying type.
            #[inline]
            pub fn abi_encode_packed(&self) -> alloy_sol_types::private::Vec<u8> {
                <Self as alloy_sol_types::SolType>::abi_encode_packed(&self.0)
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolType for MachineStatus {
            type RustType = u8;
            type Token<'a> = <alloy::sol_types::sol_data::Uint<
                8,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SOL_NAME: &'static str = Self::NAME;
            const ENCODED_SIZE: Option<usize> = <alloy::sol_types::sol_data::Uint<
                8,
            > as alloy_sol_types::SolType>::ENCODED_SIZE;
            const PACKED_ENCODED_SIZE: Option<usize> = <alloy::sol_types::sol_data::Uint<
                8,
            > as alloy_sol_types::SolType>::PACKED_ENCODED_SIZE;
            #[inline]
            fn valid_token(token: &Self::Token<'_>) -> bool {
                Self::type_check(token).is_ok()
            }
            #[inline]
            fn type_check(token: &Self::Token<'_>) -> alloy_sol_types::Result<()> {
                <alloy::sol_types::sol_data::Uint<
                    8,
                > as alloy_sol_types::SolType>::type_check(token)
            }
            #[inline]
            fn detokenize(token: Self::Token<'_>) -> Self::RustType {
                <alloy::sol_types::sol_data::Uint<
                    8,
                > as alloy_sol_types::SolType>::detokenize(token)
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::EventTopic for MachineStatus {
            #[inline]
            fn topic_preimage_length(rust: &Self::RustType) -> usize {
                <alloy::sol_types::sol_data::Uint<
                    8,
                > as alloy_sol_types::EventTopic>::topic_preimage_length(rust)
            }
            #[inline]
            fn encode_topic_preimage(
                rust: &Self::RustType,
                out: &mut alloy_sol_types::private::Vec<u8>,
            ) {
                <alloy::sol_types::sol_data::Uint<
                    8,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(rust, out)
            }
            #[inline]
            fn encode_topic(
                rust: &Self::RustType,
            ) -> alloy_sol_types::abi::token::WordToken {
                <alloy::sol_types::sol_data::Uint<
                    8,
                > as alloy_sol_types::EventTopic>::encode_topic(rust)
            }
        }
    };
    /**```solidity
struct AssertionState { GlobalState globalState; MachineStatus machineStatus; bytes32 endHistoryRoot; }
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct AssertionState {
        #[allow(missing_docs)]
        pub globalState: <GlobalState as alloy::sol_types::SolType>::RustType,
        #[allow(missing_docs)]
        pub machineStatus: <MachineStatus as alloy::sol_types::SolType>::RustType,
        #[allow(missing_docs)]
        pub endHistoryRoot: alloy::sol_types::private::FixedBytes<32>,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = (
            GlobalState,
            MachineStatus,
            alloy::sol_types::sol_data::FixedBytes<32>,
        );
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = (
            <GlobalState as alloy::sol_types::SolType>::RustType,
            <MachineStatus as alloy::sol_types::SolType>::RustType,
            alloy::sol_types::private::FixedBytes<32>,
        );
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<AssertionState> for UnderlyingRustTuple<'_> {
            fn from(value: AssertionState) -> Self {
                (value.globalState, value.machineStatus, value.endHistoryRoot)
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for AssertionState {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self {
                    globalState: tuple.0,
                    machineStatus: tuple.1,
                    endHistoryRoot: tuple.2,
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolValue for AssertionState {
            type SolType = Self;
        }
        #[automatically_derived]
        impl alloy_sol_types::private::SolTypeValue<Self> for AssertionState {
            #[inline]
            fn stv_to_tokens(&self) -> <Self as alloy_sol_types::SolType>::Token<'_> {
                (
                    <GlobalState as alloy_sol_types::SolType>::tokenize(
                        &self.globalState,
                    ),
                    <MachineStatus as alloy_sol_types::SolType>::tokenize(
                        &self.machineStatus,
                    ),
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.endHistoryRoot),
                )
            }
            #[inline]
            fn stv_abi_encoded_size(&self) -> usize {
                if let Some(size) = <Self as alloy_sol_types::SolType>::ENCODED_SIZE {
                    return size;
                }
                let tuple = <UnderlyingRustTuple<
                    '_,
                > as ::core::convert::From<Self>>::from(self.clone());
                <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_encoded_size(&tuple)
            }
            #[inline]
            fn stv_eip712_data_word(&self) -> alloy_sol_types::Word {
                <Self as alloy_sol_types::SolStruct>::eip712_hash_struct(self)
            }
            #[inline]
            fn stv_abi_encode_packed_to(
                &self,
                out: &mut alloy_sol_types::private::Vec<u8>,
            ) {
                let tuple = <UnderlyingRustTuple<
                    '_,
                > as ::core::convert::From<Self>>::from(self.clone());
                <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_encode_packed_to(&tuple, out)
            }
            #[inline]
            fn stv_abi_packed_encoded_size(&self) -> usize {
                if let Some(size) = <Self as alloy_sol_types::SolType>::PACKED_ENCODED_SIZE {
                    return size;
                }
                let tuple = <UnderlyingRustTuple<
                    '_,
                > as ::core::convert::From<Self>>::from(self.clone());
                <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_packed_encoded_size(&tuple)
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolType for AssertionState {
            type RustType = Self;
            type Token<'a> = <UnderlyingSolTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SOL_NAME: &'static str = <Self as alloy_sol_types::SolStruct>::NAME;
            const ENCODED_SIZE: Option<usize> = <UnderlyingSolTuple<
                '_,
            > as alloy_sol_types::SolType>::ENCODED_SIZE;
            const PACKED_ENCODED_SIZE: Option<usize> = <UnderlyingSolTuple<
                '_,
            > as alloy_sol_types::SolType>::PACKED_ENCODED_SIZE;
            #[inline]
            fn valid_token(token: &Self::Token<'_>) -> bool {
                <UnderlyingSolTuple<'_> as alloy_sol_types::SolType>::valid_token(token)
            }
            #[inline]
            fn detokenize(token: Self::Token<'_>) -> Self::RustType {
                let tuple = <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::detokenize(token);
                <Self as ::core::convert::From<UnderlyingRustTuple<'_>>>::from(tuple)
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolStruct for AssertionState {
            const NAME: &'static str = "AssertionState";
            #[inline]
            fn eip712_root_type() -> alloy_sol_types::private::Cow<'static, str> {
                alloy_sol_types::private::Cow::Borrowed(
                    "AssertionState(GlobalState globalState,uint8 machineStatus,bytes32 endHistoryRoot)",
                )
            }
            #[inline]
            fn eip712_components() -> alloy_sol_types::private::Vec<
                alloy_sol_types::private::Cow<'static, str>,
            > {
                let mut components = alloy_sol_types::private::Vec::with_capacity(1);
                components
                    .push(
                        <GlobalState as alloy_sol_types::SolStruct>::eip712_root_type(),
                    );
                components
                    .extend(
                        <GlobalState as alloy_sol_types::SolStruct>::eip712_components(),
                    );
                components
            }
            #[inline]
            fn eip712_encode_data(&self) -> alloy_sol_types::private::Vec<u8> {
                [
                    <GlobalState as alloy_sol_types::SolType>::eip712_data_word(
                            &self.globalState,
                        )
                        .0,
                    <MachineStatus as alloy_sol_types::SolType>::eip712_data_word(
                            &self.machineStatus,
                        )
                        .0,
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::eip712_data_word(
                            &self.endHistoryRoot,
                        )
                        .0,
                ]
                    .concat()
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::EventTopic for AssertionState {
            #[inline]
            fn topic_preimage_length(rust: &Self::RustType) -> usize {
                0usize
                    + <GlobalState as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.globalState,
                    )
                    + <MachineStatus as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.machineStatus,
                    )
                    + <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.endHistoryRoot,
                    )
            }
            #[inline]
            fn encode_topic_preimage(
                rust: &Self::RustType,
                out: &mut alloy_sol_types::private::Vec<u8>,
            ) {
                out.reserve(
                    <Self as alloy_sol_types::EventTopic>::topic_preimage_length(rust),
                );
                <GlobalState as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.globalState,
                    out,
                );
                <MachineStatus as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.machineStatus,
                    out,
                );
                <alloy::sol_types::sol_data::FixedBytes<
                    32,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.endHistoryRoot,
                    out,
                );
            }
            #[inline]
            fn encode_topic(
                rust: &Self::RustType,
            ) -> alloy_sol_types::abi::token::WordToken {
                let mut out = alloy_sol_types::private::Vec::new();
                <Self as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    rust,
                    &mut out,
                );
                alloy_sol_types::abi::token::WordToken(
                    alloy_sol_types::private::keccak256(out),
                )
            }
        }
    };
    /**```solidity
struct AssertionStateData { AssertionState assertionState; bytes32 prevAssertionHash; bytes32 inboxAcc; }
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct AssertionStateData {
        #[allow(missing_docs)]
        pub assertionState: <AssertionState as alloy::sol_types::SolType>::RustType,
        #[allow(missing_docs)]
        pub prevAssertionHash: alloy::sol_types::private::FixedBytes<32>,
        #[allow(missing_docs)]
        pub inboxAcc: alloy::sol_types::private::FixedBytes<32>,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = (
            AssertionState,
            alloy::sol_types::sol_data::FixedBytes<32>,
            alloy::sol_types::sol_data::FixedBytes<32>,
        );
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = (
            <AssertionState as alloy::sol_types::SolType>::RustType,
            alloy::sol_types::private::FixedBytes<32>,
            alloy::sol_types::private::FixedBytes<32>,
        );
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<AssertionStateData> for UnderlyingRustTuple<'_> {
            fn from(value: AssertionStateData) -> Self {
                (value.assertionState, value.prevAssertionHash, value.inboxAcc)
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for AssertionStateData {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self {
                    assertionState: tuple.0,
                    prevAssertionHash: tuple.1,
                    inboxAcc: tuple.2,
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolValue for AssertionStateData {
            type SolType = Self;
        }
        #[automatically_derived]
        impl alloy_sol_types::private::SolTypeValue<Self> for AssertionStateData {
            #[inline]
            fn stv_to_tokens(&self) -> <Self as alloy_sol_types::SolType>::Token<'_> {
                (
                    <AssertionState as alloy_sol_types::SolType>::tokenize(
                        &self.assertionState,
                    ),
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.prevAssertionHash),
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.inboxAcc),
                )
            }
            #[inline]
            fn stv_abi_encoded_size(&self) -> usize {
                if let Some(size) = <Self as alloy_sol_types::SolType>::ENCODED_SIZE {
                    return size;
                }
                let tuple = <UnderlyingRustTuple<
                    '_,
                > as ::core::convert::From<Self>>::from(self.clone());
                <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_encoded_size(&tuple)
            }
            #[inline]
            fn stv_eip712_data_word(&self) -> alloy_sol_types::Word {
                <Self as alloy_sol_types::SolStruct>::eip712_hash_struct(self)
            }
            #[inline]
            fn stv_abi_encode_packed_to(
                &self,
                out: &mut alloy_sol_types::private::Vec<u8>,
            ) {
                let tuple = <UnderlyingRustTuple<
                    '_,
                > as ::core::convert::From<Self>>::from(self.clone());
                <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_encode_packed_to(&tuple, out)
            }
            #[inline]
            fn stv_abi_packed_encoded_size(&self) -> usize {
                if let Some(size) = <Self as alloy_sol_types::SolType>::PACKED_ENCODED_SIZE {
                    return size;
                }
                let tuple = <UnderlyingRustTuple<
                    '_,
                > as ::core::convert::From<Self>>::from(self.clone());
                <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_packed_encoded_size(&tuple)
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolType for AssertionStateData {
            type RustType = Self;
            type Token<'a> = <UnderlyingSolTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SOL_NAME: &'static str = <Self as alloy_sol_types::SolStruct>::NAME;
            const ENCODED_SIZE: Option<usize> = <UnderlyingSolTuple<
                '_,
            > as alloy_sol_types::SolType>::ENCODED_SIZE;
            const PACKED_ENCODED_SIZE: Option<usize> = <UnderlyingSolTuple<
                '_,
            > as alloy_sol_types::SolType>::PACKED_ENCODED_SIZE;
            #[inline]
            fn valid_token(token: &Self::Token<'_>) -> bool {
                <UnderlyingSolTuple<'_> as alloy_sol_types::SolType>::valid_token(token)
            }
            #[inline]
            fn detokenize(token: Self::Token<'_>) -> Self::RustType {
                let tuple = <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::detokenize(token);
                <Self as ::core::convert::From<UnderlyingRustTuple<'_>>>::from(tuple)
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolStruct for AssertionStateData {
            const NAME: &'static str = "AssertionStateData";
            #[inline]
            fn eip712_root_type() -> alloy_sol_types::private::Cow<'static, str> {
                alloy_sol_types::private::Cow::Borrowed(
                    "AssertionStateData(AssertionState assertionState,bytes32 prevAssertionHash,bytes32 inboxAcc)",
                )
            }
            #[inline]
            fn eip712_components() -> alloy_sol_types::private::Vec<
                alloy_sol_types::private::Cow<'static, str>,
            > {
                let mut components = alloy_sol_types::private::Vec::with_capacity(1);
                components
                    .push(
                        <AssertionState as alloy_sol_types::SolStruct>::eip712_root_type(),
                    );
                components
                    .extend(
                        <AssertionState as alloy_sol_types::SolStruct>::eip712_components(),
                    );
                components
            }
            #[inline]
            fn eip712_encode_data(&self) -> alloy_sol_types::private::Vec<u8> {
                [
                    <AssertionState as alloy_sol_types::SolType>::eip712_data_word(
                            &self.assertionState,
                        )
                        .0,
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::eip712_data_word(
                            &self.prevAssertionHash,
                        )
                        .0,
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::eip712_data_word(&self.inboxAcc)
                        .0,
                ]
                    .concat()
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::EventTopic for AssertionStateData {
            #[inline]
            fn topic_preimage_length(rust: &Self::RustType) -> usize {
                0usize
                    + <AssertionState as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.assertionState,
                    )
                    + <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.prevAssertionHash,
                    )
                    + <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.inboxAcc,
                    )
            }
            #[inline]
            fn encode_topic_preimage(
                rust: &Self::RustType,
                out: &mut alloy_sol_types::private::Vec<u8>,
            ) {
                out.reserve(
                    <Self as alloy_sol_types::EventTopic>::topic_preimage_length(rust),
                );
                <AssertionState as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.assertionState,
                    out,
                );
                <alloy::sol_types::sol_data::FixedBytes<
                    32,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.prevAssertionHash,
                    out,
                );
                <alloy::sol_types::sol_data::FixedBytes<
                    32,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.inboxAcc,
                    out,
                );
            }
            #[inline]
            fn encode_topic(
                rust: &Self::RustType,
            ) -> alloy_sol_types::abi::token::WordToken {
                let mut out = alloy_sol_types::private::Vec::new();
                <Self as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    rust,
                    &mut out,
                );
                alloy_sol_types::abi::token::WordToken(
                    alloy_sol_types::private::keccak256(out),
                )
            }
        }
    };
    /**```solidity
struct ChallengeEdge { bytes32 originId; bytes32 startHistoryRoot; uint256 startHeight; bytes32 endHistoryRoot; uint256 endHeight; bytes32 lowerChildId; bytes32 upperChildId; bytes32 claimId; address staker; uint64 createdAtBlock; uint64 confirmedAtBlock; EdgeStatus status; uint8 level; bool refunded; uint64 totalTimeUnrivaledCache; }
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct ChallengeEdge {
        #[allow(missing_docs)]
        pub originId: alloy::sol_types::private::FixedBytes<32>,
        #[allow(missing_docs)]
        pub startHistoryRoot: alloy::sol_types::private::FixedBytes<32>,
        #[allow(missing_docs)]
        pub startHeight: alloy::sol_types::private::primitives::aliases::U256,
        #[allow(missing_docs)]
        pub endHistoryRoot: alloy::sol_types::private::FixedBytes<32>,
        #[allow(missing_docs)]
        pub endHeight: alloy::sol_types::private::primitives::aliases::U256,
        #[allow(missing_docs)]
        pub lowerChildId: alloy::sol_types::private::FixedBytes<32>,
        #[allow(missing_docs)]
        pub upperChildId: alloy::sol_types::private::FixedBytes<32>,
        #[allow(missing_docs)]
        pub claimId: alloy::sol_types::private::FixedBytes<32>,
        #[allow(missing_docs)]
        pub staker: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub createdAtBlock: u64,
        #[allow(missing_docs)]
        pub confirmedAtBlock: u64,
        #[allow(missing_docs)]
        pub status: <EdgeStatus as alloy::sol_types::SolType>::RustType,
        #[allow(missing_docs)]
        pub level: u8,
        #[allow(missing_docs)]
        pub refunded: bool,
        #[allow(missing_docs)]
        pub totalTimeUnrivaledCache: u64,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = (
            alloy::sol_types::sol_data::FixedBytes<32>,
            alloy::sol_types::sol_data::FixedBytes<32>,
            alloy::sol_types::sol_data::Uint<256>,
            alloy::sol_types::sol_data::FixedBytes<32>,
            alloy::sol_types::sol_data::Uint<256>,
            alloy::sol_types::sol_data::FixedBytes<32>,
            alloy::sol_types::sol_data::FixedBytes<32>,
            alloy::sol_types::sol_data::FixedBytes<32>,
            alloy::sol_types::sol_data::Address,
            alloy::sol_types::sol_data::Uint<64>,
            alloy::sol_types::sol_data::Uint<64>,
            EdgeStatus,
            alloy::sol_types::sol_data::Uint<8>,
            alloy::sol_types::sol_data::Bool,
            alloy::sol_types::sol_data::Uint<64>,
        );
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = (
            alloy::sol_types::private::FixedBytes<32>,
            alloy::sol_types::private::FixedBytes<32>,
            alloy::sol_types::private::primitives::aliases::U256,
            alloy::sol_types::private::FixedBytes<32>,
            alloy::sol_types::private::primitives::aliases::U256,
            alloy::sol_types::private::FixedBytes<32>,
            alloy::sol_types::private::FixedBytes<32>,
            alloy::sol_types::private::FixedBytes<32>,
            alloy::sol_types::private::Address,
            u64,
            u64,
            <EdgeStatus as alloy::sol_types::SolType>::RustType,
            u8,
            bool,
            u64,
        );
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<ChallengeEdge> for UnderlyingRustTuple<'_> {
            fn from(value: ChallengeEdge) -> Self {
                (
                    value.originId,
                    value.startHistoryRoot,
                    value.startHeight,
                    value.endHistoryRoot,
                    value.endHeight,
                    value.lowerChildId,
                    value.upperChildId,
                    value.claimId,
                    value.staker,
                    value.createdAtBlock,
                    value.confirmedAtBlock,
                    value.status,
                    value.level,
                    value.refunded,
                    value.totalTimeUnrivaledCache,
                )
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for ChallengeEdge {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self {
                    originId: tuple.0,
                    startHistoryRoot: tuple.1,
                    startHeight: tuple.2,
                    endHistoryRoot: tuple.3,
                    endHeight: tuple.4,
                    lowerChildId: tuple.5,
                    upperChildId: tuple.6,
                    claimId: tuple.7,
                    staker: tuple.8,
                    createdAtBlock: tuple.9,
                    confirmedAtBlock: tuple.10,
                    status: tuple.11,
                    level: tuple.12,
                    refunded: tuple.13,
                    totalTimeUnrivaledCache: tuple.14,
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolValue for ChallengeEdge {
            type SolType = Self;
        }
        #[automatically_derived]
        impl alloy_sol_types::private::SolTypeValue<Self> for ChallengeEdge {
            #[inline]
            fn stv_to_tokens(&self) -> <Self as alloy_sol_types::SolType>::Token<'_> {
                (
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.originId),
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.startHistoryRoot),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.startHeight),
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.endHistoryRoot),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.endHeight),
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.lowerChildId),
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.upperChildId),
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.claimId),
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.staker,
                    ),
                    <alloy::sol_types::sol_data::Uint<
                        64,
                    > as alloy_sol_types::SolType>::tokenize(&self.createdAtBlock),
                    <alloy::sol_types::sol_data::Uint<
                        64,
                    > as alloy_sol_types::SolType>::tokenize(&self.confirmedAtBlock),
                    <EdgeStatus as alloy_sol_types::SolType>::tokenize(&self.status),
                    <alloy::sol_types::sol_data::Uint<
                        8,
                    > as alloy_sol_types::SolType>::tokenize(&self.level),
                    <alloy::sol_types::sol_data::Bool as alloy_sol_types::SolType>::tokenize(
                        &self.refunded,
                    ),
                    <alloy::sol_types::sol_data::Uint<
                        64,
                    > as alloy_sol_types::SolType>::tokenize(
                        &self.totalTimeUnrivaledCache,
                    ),
                )
            }
            #[inline]
            fn stv_abi_encoded_size(&self) -> usize {
                if let Some(size) = <Self as alloy_sol_types::SolType>::ENCODED_SIZE {
                    return size;
                }
                let tuple = <UnderlyingRustTuple<
                    '_,
                > as ::core::convert::From<Self>>::from(self.clone());
                <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_encoded_size(&tuple)
            }
            #[inline]
            fn stv_eip712_data_word(&self) -> alloy_sol_types::Word {
                <Self as alloy_sol_types::SolStruct>::eip712_hash_struct(self)
            }
            #[inline]
            fn stv_abi_encode_packed_to(
                &self,
                out: &mut alloy_sol_types::private::Vec<u8>,
            ) {
                let tuple = <UnderlyingRustTuple<
                    '_,
                > as ::core::convert::From<Self>>::from(self.clone());
                <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_encode_packed_to(&tuple, out)
            }
            #[inline]
            fn stv_abi_packed_encoded_size(&self) -> usize {
                if let Some(size) = <Self as alloy_sol_types::SolType>::PACKED_ENCODED_SIZE {
                    return size;
                }
                let tuple = <UnderlyingRustTuple<
                    '_,
                > as ::core::convert::From<Self>>::from(self.clone());
                <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_packed_encoded_size(&tuple)
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolType for ChallengeEdge {
            type RustType = Self;
            type Token<'a> = <UnderlyingSolTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SOL_NAME: &'static str = <Self as alloy_sol_types::SolStruct>::NAME;
            const ENCODED_SIZE: Option<usize> = <UnderlyingSolTuple<
                '_,
            > as alloy_sol_types::SolType>::ENCODED_SIZE;
            const PACKED_ENCODED_SIZE: Option<usize> = <UnderlyingSolTuple<
                '_,
            > as alloy_sol_types::SolType>::PACKED_ENCODED_SIZE;
            #[inline]
            fn valid_token(token: &Self::Token<'_>) -> bool {
                <UnderlyingSolTuple<'_> as alloy_sol_types::SolType>::valid_token(token)
            }
            #[inline]
            fn detokenize(token: Self::Token<'_>) -> Self::RustType {
                let tuple = <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::detokenize(token);
                <Self as ::core::convert::From<UnderlyingRustTuple<'_>>>::from(tuple)
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolStruct for ChallengeEdge {
            const NAME: &'static str = "ChallengeEdge";
            #[inline]
            fn eip712_root_type() -> alloy_sol_types::private::Cow<'static, str> {
                alloy_sol_types::private::Cow::Borrowed(
                    "ChallengeEdge(bytes32 originId,bytes32 startHistoryRoot,uint256 startHeight,bytes32 endHistoryRoot,uint256 endHeight,bytes32 lowerChildId,bytes32 upperChildId,bytes32 claimId,address staker,uint64 createdAtBlock,uint64 confirmedAtBlock,uint8 status,uint8 level,bool refunded,uint64 totalTimeUnrivaledCache)",
                )
            }
            #[inline]
            fn eip712_components() -> alloy_sol_types::private::Vec<
                alloy_sol_types::private::Cow<'static, str>,
            > {
                alloy_sol_types::private::Vec::new()
            }
            #[inline]
            fn eip712_encode_type() -> alloy_sol_types::private::Cow<'static, str> {
                <Self as alloy_sol_types::SolStruct>::eip712_root_type()
            }
            #[inline]
            fn eip712_encode_data(&self) -> alloy_sol_types::private::Vec<u8> {
                [
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::eip712_data_word(&self.originId)
                        .0,
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::eip712_data_word(
                            &self.startHistoryRoot,
                        )
                        .0,
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::eip712_data_word(&self.startHeight)
                        .0,
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::eip712_data_word(
                            &self.endHistoryRoot,
                        )
                        .0,
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::eip712_data_word(&self.endHeight)
                        .0,
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::eip712_data_word(&self.lowerChildId)
                        .0,
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::eip712_data_word(&self.upperChildId)
                        .0,
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::eip712_data_word(&self.claimId)
                        .0,
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::eip712_data_word(
                            &self.staker,
                        )
                        .0,
                    <alloy::sol_types::sol_data::Uint<
                        64,
                    > as alloy_sol_types::SolType>::eip712_data_word(
                            &self.createdAtBlock,
                        )
                        .0,
                    <alloy::sol_types::sol_data::Uint<
                        64,
                    > as alloy_sol_types::SolType>::eip712_data_word(
                            &self.confirmedAtBlock,
                        )
                        .0,
                    <EdgeStatus as alloy_sol_types::SolType>::eip712_data_word(
                            &self.status,
                        )
                        .0,
                    <alloy::sol_types::sol_data::Uint<
                        8,
                    > as alloy_sol_types::SolType>::eip712_data_word(&self.level)
                        .0,
                    <alloy::sol_types::sol_data::Bool as alloy_sol_types::SolType>::eip712_data_word(
                            &self.refunded,
                        )
                        .0,
                    <alloy::sol_types::sol_data::Uint<
                        64,
                    > as alloy_sol_types::SolType>::eip712_data_word(
                            &self.totalTimeUnrivaledCache,
                        )
                        .0,
                ]
                    .concat()
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::EventTopic for ChallengeEdge {
            #[inline]
            fn topic_preimage_length(rust: &Self::RustType) -> usize {
                0usize
                    + <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.originId,
                    )
                    + <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.startHistoryRoot,
                    )
                    + <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.startHeight,
                    )
                    + <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.endHistoryRoot,
                    )
                    + <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.endHeight,
                    )
                    + <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.lowerChildId,
                    )
                    + <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.upperChildId,
                    )
                    + <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.claimId,
                    )
                    + <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.staker,
                    )
                    + <alloy::sol_types::sol_data::Uint<
                        64,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.createdAtBlock,
                    )
                    + <alloy::sol_types::sol_data::Uint<
                        64,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.confirmedAtBlock,
                    )
                    + <EdgeStatus as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.status,
                    )
                    + <alloy::sol_types::sol_data::Uint<
                        8,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(&rust.level)
                    + <alloy::sol_types::sol_data::Bool as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.refunded,
                    )
                    + <alloy::sol_types::sol_data::Uint<
                        64,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.totalTimeUnrivaledCache,
                    )
            }
            #[inline]
            fn encode_topic_preimage(
                rust: &Self::RustType,
                out: &mut alloy_sol_types::private::Vec<u8>,
            ) {
                out.reserve(
                    <Self as alloy_sol_types::EventTopic>::topic_preimage_length(rust),
                );
                <alloy::sol_types::sol_data::FixedBytes<
                    32,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.originId,
                    out,
                );
                <alloy::sol_types::sol_data::FixedBytes<
                    32,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.startHistoryRoot,
                    out,
                );
                <alloy::sol_types::sol_data::Uint<
                    256,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.startHeight,
                    out,
                );
                <alloy::sol_types::sol_data::FixedBytes<
                    32,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.endHistoryRoot,
                    out,
                );
                <alloy::sol_types::sol_data::Uint<
                    256,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.endHeight,
                    out,
                );
                <alloy::sol_types::sol_data::FixedBytes<
                    32,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.lowerChildId,
                    out,
                );
                <alloy::sol_types::sol_data::FixedBytes<
                    32,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.upperChildId,
                    out,
                );
                <alloy::sol_types::sol_data::FixedBytes<
                    32,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.claimId,
                    out,
                );
                <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.staker,
                    out,
                );
                <alloy::sol_types::sol_data::Uint<
                    64,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.createdAtBlock,
                    out,
                );
                <alloy::sol_types::sol_data::Uint<
                    64,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.confirmedAtBlock,
                    out,
                );
                <EdgeStatus as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.status,
                    out,
                );
                <alloy::sol_types::sol_data::Uint<
                    8,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.level,
                    out,
                );
                <alloy::sol_types::sol_data::Bool as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.refunded,
                    out,
                );
                <alloy::sol_types::sol_data::Uint<
                    64,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.totalTimeUnrivaledCache,
                    out,
                );
            }
            #[inline]
            fn encode_topic(
                rust: &Self::RustType,
            ) -> alloy_sol_types::abi::token::WordToken {
                let mut out = alloy_sol_types::private::Vec::new();
                <Self as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    rust,
                    &mut out,
                );
                alloy_sol_types::abi::token::WordToken(
                    alloy_sol_types::private::keccak256(out),
                )
            }
        }
    };
    /**```solidity
struct ConfigData { bytes32 wasmModuleRoot; uint256 requiredStake; address challengeManager; uint64 confirmPeriodBlocks; uint64 nextInboxPosition; }
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct ConfigData {
        #[allow(missing_docs)]
        pub wasmModuleRoot: alloy::sol_types::private::FixedBytes<32>,
        #[allow(missing_docs)]
        pub requiredStake: alloy::sol_types::private::primitives::aliases::U256,
        #[allow(missing_docs)]
        pub challengeManager: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub confirmPeriodBlocks: u64,
        #[allow(missing_docs)]
        pub nextInboxPosition: u64,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = (
            alloy::sol_types::sol_data::FixedBytes<32>,
            alloy::sol_types::sol_data::Uint<256>,
            alloy::sol_types::sol_data::Address,
            alloy::sol_types::sol_data::Uint<64>,
            alloy::sol_types::sol_data::Uint<64>,
        );
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = (
            alloy::sol_types::private::FixedBytes<32>,
            alloy::sol_types::private::primitives::aliases::U256,
            alloy::sol_types::private::Address,
            u64,
            u64,
        );
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<ConfigData> for UnderlyingRustTuple<'_> {
            fn from(value: ConfigData) -> Self {
                (
                    value.wasmModuleRoot,
                    value.requiredStake,
                    value.challengeManager,
                    value.confirmPeriodBlocks,
                    value.nextInboxPosition,
                )
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for ConfigData {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self {
                    wasmModuleRoot: tuple.0,
                    requiredStake: tuple.1,
                    challengeManager: tuple.2,
                    confirmPeriodBlocks: tuple.3,
                    nextInboxPosition: tuple.4,
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolValue for ConfigData {
            type SolType = Self;
        }
        #[automatically_derived]
        impl alloy_sol_types::private::SolTypeValue<Self> for ConfigData {
            #[inline]
            fn stv_to_tokens(&self) -> <Self as alloy_sol_types::SolType>::Token<'_> {
                (
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.wasmModuleRoot),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.requiredStake),
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.challengeManager,
                    ),
                    <alloy::sol_types::sol_data::Uint<
                        64,
                    > as alloy_sol_types::SolType>::tokenize(&self.confirmPeriodBlocks),
                    <alloy::sol_types::sol_data::Uint<
                        64,
                    > as alloy_sol_types::SolType>::tokenize(&self.nextInboxPosition),
                )
            }
            #[inline]
            fn stv_abi_encoded_size(&self) -> usize {
                if let Some(size) = <Self as alloy_sol_types::SolType>::ENCODED_SIZE {
                    return size;
                }
                let tuple = <UnderlyingRustTuple<
                    '_,
                > as ::core::convert::From<Self>>::from(self.clone());
                <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_encoded_size(&tuple)
            }
            #[inline]
            fn stv_eip712_data_word(&self) -> alloy_sol_types::Word {
                <Self as alloy_sol_types::SolStruct>::eip712_hash_struct(self)
            }
            #[inline]
            fn stv_abi_encode_packed_to(
                &self,
                out: &mut alloy_sol_types::private::Vec<u8>,
            ) {
                let tuple = <UnderlyingRustTuple<
                    '_,
                > as ::core::convert::From<Self>>::from(self.clone());
                <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_encode_packed_to(&tuple, out)
            }
            #[inline]
            fn stv_abi_packed_encoded_size(&self) -> usize {
                if let Some(size) = <Self as alloy_sol_types::SolType>::PACKED_ENCODED_SIZE {
                    return size;
                }
                let tuple = <UnderlyingRustTuple<
                    '_,
                > as ::core::convert::From<Self>>::from(self.clone());
                <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_packed_encoded_size(&tuple)
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolType for ConfigData {
            type RustType = Self;
            type Token<'a> = <UnderlyingSolTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SOL_NAME: &'static str = <Self as alloy_sol_types::SolStruct>::NAME;
            const ENCODED_SIZE: Option<usize> = <UnderlyingSolTuple<
                '_,
            > as alloy_sol_types::SolType>::ENCODED_SIZE;
            const PACKED_ENCODED_SIZE: Option<usize> = <UnderlyingSolTuple<
                '_,
            > as alloy_sol_types::SolType>::PACKED_ENCODED_SIZE;
            #[inline]
            fn valid_token(token: &Self::Token<'_>) -> bool {
                <UnderlyingSolTuple<'_> as alloy_sol_types::SolType>::valid_token(token)
            }
            #[inline]
            fn detokenize(token: Self::Token<'_>) -> Self::RustType {
                let tuple = <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::detokenize(token);
                <Self as ::core::convert::From<UnderlyingRustTuple<'_>>>::from(tuple)
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolStruct for ConfigData {
            const NAME: &'static str = "ConfigData";
            #[inline]
            fn eip712_root_type() -> alloy_sol_types::private::Cow<'static, str> {
                alloy_sol_types::private::Cow::Borrowed(
                    "ConfigData(bytes32 wasmModuleRoot,uint256 requiredStake,address challengeManager,uint64 confirmPeriodBlocks,uint64 nextInboxPosition)",
                )
            }
            #[inline]
            fn eip712_components() -> alloy_sol_types::private::Vec<
                alloy_sol_types::private::Cow<'static, str>,
            > {
                alloy_sol_types::private::Vec::new()
            }
            #[inline]
            fn eip712_encode_type() -> alloy_sol_types::private::Cow<'static, str> {
                <Self as alloy_sol_types::SolStruct>::eip712_root_type()
            }
            #[inline]
            fn eip712_encode_data(&self) -> alloy_sol_types::private::Vec<u8> {
                [
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::eip712_data_word(
                            &self.wasmModuleRoot,
                        )
                        .0,
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::eip712_data_word(&self.requiredStake)
                        .0,
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::eip712_data_word(
                            &self.challengeManager,
                        )
                        .0,
                    <alloy::sol_types::sol_data::Uint<
                        64,
                    > as alloy_sol_types::SolType>::eip712_data_word(
                            &self.confirmPeriodBlocks,
                        )
                        .0,
                    <alloy::sol_types::sol_data::Uint<
                        64,
                    > as alloy_sol_types::SolType>::eip712_data_word(
                            &self.nextInboxPosition,
                        )
                        .0,
                ]
                    .concat()
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::EventTopic for ConfigData {
            #[inline]
            fn topic_preimage_length(rust: &Self::RustType) -> usize {
                0usize
                    + <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.wasmModuleRoot,
                    )
                    + <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.requiredStake,
                    )
                    + <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.challengeManager,
                    )
                    + <alloy::sol_types::sol_data::Uint<
                        64,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.confirmPeriodBlocks,
                    )
                    + <alloy::sol_types::sol_data::Uint<
                        64,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.nextInboxPosition,
                    )
            }
            #[inline]
            fn encode_topic_preimage(
                rust: &Self::RustType,
                out: &mut alloy_sol_types::private::Vec<u8>,
            ) {
                out.reserve(
                    <Self as alloy_sol_types::EventTopic>::topic_preimage_length(rust),
                );
                <alloy::sol_types::sol_data::FixedBytes<
                    32,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.wasmModuleRoot,
                    out,
                );
                <alloy::sol_types::sol_data::Uint<
                    256,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.requiredStake,
                    out,
                );
                <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.challengeManager,
                    out,
                );
                <alloy::sol_types::sol_data::Uint<
                    64,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.confirmPeriodBlocks,
                    out,
                );
                <alloy::sol_types::sol_data::Uint<
                    64,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.nextInboxPosition,
                    out,
                );
            }
            #[inline]
            fn encode_topic(
                rust: &Self::RustType,
            ) -> alloy_sol_types::abi::token::WordToken {
                let mut out = alloy_sol_types::private::Vec::new();
                <Self as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    rust,
                    &mut out,
                );
                alloy_sol_types::abi::token::WordToken(
                    alloy_sol_types::private::keccak256(out),
                )
            }
        }
    };
    /**```solidity
struct CreateEdgeArgs { uint8 level; bytes32 endHistoryRoot; uint256 endHeight; bytes32 claimId; bytes prefixProof; bytes proof; }
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct CreateEdgeArgs {
        #[allow(missing_docs)]
        pub level: u8,
        #[allow(missing_docs)]
        pub endHistoryRoot: alloy::sol_types::private::FixedBytes<32>,
        #[allow(missing_docs)]
        pub endHeight: alloy::sol_types::private::primitives::aliases::U256,
        #[allow(missing_docs)]
        pub claimId: alloy::sol_types::private::FixedBytes<32>,
        #[allow(missing_docs)]
        pub prefixProof: alloy::sol_types::private::Bytes,
        #[allow(missing_docs)]
        pub proof: alloy::sol_types::private::Bytes,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = (
            alloy::sol_types::sol_data::Uint<8>,
            alloy::sol_types::sol_data::FixedBytes<32>,
            alloy::sol_types::sol_data::Uint<256>,
            alloy::sol_types::sol_data::FixedBytes<32>,
            alloy::sol_types::sol_data::Bytes,
            alloy::sol_types::sol_data::Bytes,
        );
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = (
            u8,
            alloy::sol_types::private::FixedBytes<32>,
            alloy::sol_types::private::primitives::aliases::U256,
            alloy::sol_types::private::FixedBytes<32>,
            alloy::sol_types::private::Bytes,
            alloy::sol_types::private::Bytes,
        );
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<CreateEdgeArgs> for UnderlyingRustTuple<'_> {
            fn from(value: CreateEdgeArgs) -> Self {
                (
                    value.level,
                    value.endHistoryRoot,
                    value.endHeight,
                    value.claimId,
                    value.prefixProof,
                    value.proof,
                )
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for CreateEdgeArgs {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self {
                    level: tuple.0,
                    endHistoryRoot: tuple.1,
                    endHeight: tuple.2,
                    claimId: tuple.3,
                    prefixProof: tuple.4,
                    proof: tuple.5,
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolValue for CreateEdgeArgs {
            type SolType = Self;
        }
        #[automatically_derived]
        impl alloy_sol_types::private::SolTypeValue<Self> for CreateEdgeArgs {
            #[inline]
            fn stv_to_tokens(&self) -> <Self as alloy_sol_types::SolType>::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        8,
                    > as alloy_sol_types::SolType>::tokenize(&self.level),
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.endHistoryRoot),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.endHeight),
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.claimId),
                    <alloy::sol_types::sol_data::Bytes as alloy_sol_types::SolType>::tokenize(
                        &self.prefixProof,
                    ),
                    <alloy::sol_types::sol_data::Bytes as alloy_sol_types::SolType>::tokenize(
                        &self.proof,
                    ),
                )
            }
            #[inline]
            fn stv_abi_encoded_size(&self) -> usize {
                if let Some(size) = <Self as alloy_sol_types::SolType>::ENCODED_SIZE {
                    return size;
                }
                let tuple = <UnderlyingRustTuple<
                    '_,
                > as ::core::convert::From<Self>>::from(self.clone());
                <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_encoded_size(&tuple)
            }
            #[inline]
            fn stv_eip712_data_word(&self) -> alloy_sol_types::Word {
                <Self as alloy_sol_types::SolStruct>::eip712_hash_struct(self)
            }
            #[inline]
            fn stv_abi_encode_packed_to(
                &self,
                out: &mut alloy_sol_types::private::Vec<u8>,
            ) {
                let tuple = <UnderlyingRustTuple<
                    '_,
                > as ::core::convert::From<Self>>::from(self.clone());
                <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_encode_packed_to(&tuple, out)
            }
            #[inline]
            fn stv_abi_packed_encoded_size(&self) -> usize {
                if let Some(size) = <Self as alloy_sol_types::SolType>::PACKED_ENCODED_SIZE {
                    return size;
                }
                let tuple = <UnderlyingRustTuple<
                    '_,
                > as ::core::convert::From<Self>>::from(self.clone());
                <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_packed_encoded_size(&tuple)
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolType for CreateEdgeArgs {
            type RustType = Self;
            type Token<'a> = <UnderlyingSolTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SOL_NAME: &'static str = <Self as alloy_sol_types::SolStruct>::NAME;
            const ENCODED_SIZE: Option<usize> = <UnderlyingSolTuple<
                '_,
            > as alloy_sol_types::SolType>::ENCODED_SIZE;
            const PACKED_ENCODED_SIZE: Option<usize> = <UnderlyingSolTuple<
                '_,
            > as alloy_sol_types::SolType>::PACKED_ENCODED_SIZE;
            #[inline]
            fn valid_token(token: &Self::Token<'_>) -> bool {
                <UnderlyingSolTuple<'_> as alloy_sol_types::SolType>::valid_token(token)
            }
            #[inline]
            fn detokenize(token: Self::Token<'_>) -> Self::RustType {
                let tuple = <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::detokenize(token);
                <Self as ::core::convert::From<UnderlyingRustTuple<'_>>>::from(tuple)
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolStruct for CreateEdgeArgs {
            const NAME: &'static str = "CreateEdgeArgs";
            #[inline]
            fn eip712_root_type() -> alloy_sol_types::private::Cow<'static, str> {
                alloy_sol_types::private::Cow::Borrowed(
                    "CreateEdgeArgs(uint8 level,bytes32 endHistoryRoot,uint256 endHeight,bytes32 claimId,bytes prefixProof,bytes proof)",
                )
            }
            #[inline]
            fn eip712_components() -> alloy_sol_types::private::Vec<
                alloy_sol_types::private::Cow<'static, str>,
            > {
                alloy_sol_types::private::Vec::new()
            }
            #[inline]
            fn eip712_encode_type() -> alloy_sol_types::private::Cow<'static, str> {
                <Self as alloy_sol_types::SolStruct>::eip712_root_type()
            }
            #[inline]
            fn eip712_encode_data(&self) -> alloy_sol_types::private::Vec<u8> {
                [
                    <alloy::sol_types::sol_data::Uint<
                        8,
                    > as alloy_sol_types::SolType>::eip712_data_word(&self.level)
                        .0,
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::eip712_data_word(
                            &self.endHistoryRoot,
                        )
                        .0,
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::eip712_data_word(&self.endHeight)
                        .0,
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::eip712_data_word(&self.claimId)
                        .0,
                    <alloy::sol_types::sol_data::Bytes as alloy_sol_types::SolType>::eip712_data_word(
                            &self.prefixProof,
                        )
                        .0,
                    <alloy::sol_types::sol_data::Bytes as alloy_sol_types::SolType>::eip712_data_word(
                            &self.proof,
                        )
                        .0,
                ]
                    .concat()
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::EventTopic for CreateEdgeArgs {
            #[inline]
            fn topic_preimage_length(rust: &Self::RustType) -> usize {
                0usize
                    + <alloy::sol_types::sol_data::Uint<
                        8,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(&rust.level)
                    + <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.endHistoryRoot,
                    )
                    + <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.endHeight,
                    )
                    + <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.claimId,
                    )
                    + <alloy::sol_types::sol_data::Bytes as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.prefixProof,
                    )
                    + <alloy::sol_types::sol_data::Bytes as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.proof,
                    )
            }
            #[inline]
            fn encode_topic_preimage(
                rust: &Self::RustType,
                out: &mut alloy_sol_types::private::Vec<u8>,
            ) {
                out.reserve(
                    <Self as alloy_sol_types::EventTopic>::topic_preimage_length(rust),
                );
                <alloy::sol_types::sol_data::Uint<
                    8,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.level,
                    out,
                );
                <alloy::sol_types::sol_data::FixedBytes<
                    32,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.endHistoryRoot,
                    out,
                );
                <alloy::sol_types::sol_data::Uint<
                    256,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.endHeight,
                    out,
                );
                <alloy::sol_types::sol_data::FixedBytes<
                    32,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.claimId,
                    out,
                );
                <alloy::sol_types::sol_data::Bytes as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.prefixProof,
                    out,
                );
                <alloy::sol_types::sol_data::Bytes as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.proof,
                    out,
                );
            }
            #[inline]
            fn encode_topic(
                rust: &Self::RustType,
            ) -> alloy_sol_types::abi::token::WordToken {
                let mut out = alloy_sol_types::private::Vec::new();
                <Self as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    rust,
                    &mut out,
                );
                alloy_sol_types::abi::token::WordToken(
                    alloy_sol_types::private::keccak256(out),
                )
            }
        }
    };
    /**```solidity
struct GlobalState { bytes32[2] bytes32Vals; uint64[2] u64Vals; }
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct GlobalState {
        #[allow(missing_docs)]
        pub bytes32Vals: [alloy::sol_types::private::FixedBytes<32>; 2usize],
        #[allow(missing_docs)]
        pub u64Vals: [u64; 2usize],
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = (
            alloy::sol_types::sol_data::FixedArray<
                alloy::sol_types::sol_data::FixedBytes<32>,
                2usize,
            >,
            alloy::sol_types::sol_data::FixedArray<
                alloy::sol_types::sol_data::Uint<64>,
                2usize,
            >,
        );
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = (
            [alloy::sol_types::private::FixedBytes<32>; 2usize],
            [u64; 2usize],
        );
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<GlobalState> for UnderlyingRustTuple<'_> {
            fn from(value: GlobalState) -> Self {
                (value.bytes32Vals, value.u64Vals)
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for GlobalState {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self {
                    bytes32Vals: tuple.0,
                    u64Vals: tuple.1,
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolValue for GlobalState {
            type SolType = Self;
        }
        #[automatically_derived]
        impl alloy_sol_types::private::SolTypeValue<Self> for GlobalState {
            #[inline]
            fn stv_to_tokens(&self) -> <Self as alloy_sol_types::SolType>::Token<'_> {
                (
                    <alloy::sol_types::sol_data::FixedArray<
                        alloy::sol_types::sol_data::FixedBytes<32>,
                        2usize,
                    > as alloy_sol_types::SolType>::tokenize(&self.bytes32Vals),
                    <alloy::sol_types::sol_data::FixedArray<
                        alloy::sol_types::sol_data::Uint<64>,
                        2usize,
                    > as alloy_sol_types::SolType>::tokenize(&self.u64Vals),
                )
            }
            #[inline]
            fn stv_abi_encoded_size(&self) -> usize {
                if let Some(size) = <Self as alloy_sol_types::SolType>::ENCODED_SIZE {
                    return size;
                }
                let tuple = <UnderlyingRustTuple<
                    '_,
                > as ::core::convert::From<Self>>::from(self.clone());
                <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_encoded_size(&tuple)
            }
            #[inline]
            fn stv_eip712_data_word(&self) -> alloy_sol_types::Word {
                <Self as alloy_sol_types::SolStruct>::eip712_hash_struct(self)
            }
            #[inline]
            fn stv_abi_encode_packed_to(
                &self,
                out: &mut alloy_sol_types::private::Vec<u8>,
            ) {
                let tuple = <UnderlyingRustTuple<
                    '_,
                > as ::core::convert::From<Self>>::from(self.clone());
                <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_encode_packed_to(&tuple, out)
            }
            #[inline]
            fn stv_abi_packed_encoded_size(&self) -> usize {
                if let Some(size) = <Self as alloy_sol_types::SolType>::PACKED_ENCODED_SIZE {
                    return size;
                }
                let tuple = <UnderlyingRustTuple<
                    '_,
                > as ::core::convert::From<Self>>::from(self.clone());
                <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_packed_encoded_size(&tuple)
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolType for GlobalState {
            type RustType = Self;
            type Token<'a> = <UnderlyingSolTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SOL_NAME: &'static str = <Self as alloy_sol_types::SolStruct>::NAME;
            const ENCODED_SIZE: Option<usize> = <UnderlyingSolTuple<
                '_,
            > as alloy_sol_types::SolType>::ENCODED_SIZE;
            const PACKED_ENCODED_SIZE: Option<usize> = <UnderlyingSolTuple<
                '_,
            > as alloy_sol_types::SolType>::PACKED_ENCODED_SIZE;
            #[inline]
            fn valid_token(token: &Self::Token<'_>) -> bool {
                <UnderlyingSolTuple<'_> as alloy_sol_types::SolType>::valid_token(token)
            }
            #[inline]
            fn detokenize(token: Self::Token<'_>) -> Self::RustType {
                let tuple = <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::detokenize(token);
                <Self as ::core::convert::From<UnderlyingRustTuple<'_>>>::from(tuple)
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolStruct for GlobalState {
            const NAME: &'static str = "GlobalState";
            #[inline]
            fn eip712_root_type() -> alloy_sol_types::private::Cow<'static, str> {
                alloy_sol_types::private::Cow::Borrowed(
                    "GlobalState(bytes32[2] bytes32Vals,uint64[2] u64Vals)",
                )
            }
            #[inline]
            fn eip712_components() -> alloy_sol_types::private::Vec<
                alloy_sol_types::private::Cow<'static, str>,
            > {
                alloy_sol_types::private::Vec::new()
            }
            #[inline]
            fn eip712_encode_type() -> alloy_sol_types::private::Cow<'static, str> {
                <Self as alloy_sol_types::SolStruct>::eip712_root_type()
            }
            #[inline]
            fn eip712_encode_data(&self) -> alloy_sol_types::private::Vec<u8> {
                [
                    <alloy::sol_types::sol_data::FixedArray<
                        alloy::sol_types::sol_data::FixedBytes<32>,
                        2usize,
                    > as alloy_sol_types::SolType>::eip712_data_word(&self.bytes32Vals)
                        .0,
                    <alloy::sol_types::sol_data::FixedArray<
                        alloy::sol_types::sol_data::Uint<64>,
                        2usize,
                    > as alloy_sol_types::SolType>::eip712_data_word(&self.u64Vals)
                        .0,
                ]
                    .concat()
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::EventTopic for GlobalState {
            #[inline]
            fn topic_preimage_length(rust: &Self::RustType) -> usize {
                0usize
                    + <alloy::sol_types::sol_data::FixedArray<
                        alloy::sol_types::sol_data::FixedBytes<32>,
                        2usize,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.bytes32Vals,
                    )
                    + <alloy::sol_types::sol_data::FixedArray<
                        alloy::sol_types::sol_data::Uint<64>,
                        2usize,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.u64Vals,
                    )
            }
            #[inline]
            fn encode_topic_preimage(
                rust: &Self::RustType,
                out: &mut alloy_sol_types::private::Vec<u8>,
            ) {
                out.reserve(
                    <Self as alloy_sol_types::EventTopic>::topic_preimage_length(rust),
                );
                <alloy::sol_types::sol_data::FixedArray<
                    alloy::sol_types::sol_data::FixedBytes<32>,
                    2usize,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.bytes32Vals,
                    out,
                );
                <alloy::sol_types::sol_data::FixedArray<
                    alloy::sol_types::sol_data::Uint<64>,
                    2usize,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.u64Vals,
                    out,
                );
            }
            #[inline]
            fn encode_topic(
                rust: &Self::RustType,
            ) -> alloy_sol_types::abi::token::WordToken {
                let mut out = alloy_sol_types::private::Vec::new();
                <Self as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    rust,
                    &mut out,
                );
                alloy_sol_types::abi::token::WordToken(
                    alloy_sol_types::private::keccak256(out),
                )
            }
        }
    };
    /**```solidity
struct OneStepData { bytes32 beforeHash; bytes proof; }
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct OneStepData {
        #[allow(missing_docs)]
        pub beforeHash: alloy::sol_types::private::FixedBytes<32>,
        #[allow(missing_docs)]
        pub proof: alloy::sol_types::private::Bytes,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = (
            alloy::sol_types::sol_data::FixedBytes<32>,
            alloy::sol_types::sol_data::Bytes,
        );
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = (
            alloy::sol_types::private::FixedBytes<32>,
            alloy::sol_types::private::Bytes,
        );
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<OneStepData> for UnderlyingRustTuple<'_> {
            fn from(value: OneStepData) -> Self {
                (value.beforeHash, value.proof)
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for OneStepData {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self {
                    beforeHash: tuple.0,
                    proof: tuple.1,
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolValue for OneStepData {
            type SolType = Self;
        }
        #[automatically_derived]
        impl alloy_sol_types::private::SolTypeValue<Self> for OneStepData {
            #[inline]
            fn stv_to_tokens(&self) -> <Self as alloy_sol_types::SolType>::Token<'_> {
                (
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.beforeHash),
                    <alloy::sol_types::sol_data::Bytes as alloy_sol_types::SolType>::tokenize(
                        &self.proof,
                    ),
                )
            }
            #[inline]
            fn stv_abi_encoded_size(&self) -> usize {
                if let Some(size) = <Self as alloy_sol_types::SolType>::ENCODED_SIZE {
                    return size;
                }
                let tuple = <UnderlyingRustTuple<
                    '_,
                > as ::core::convert::From<Self>>::from(self.clone());
                <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_encoded_size(&tuple)
            }
            #[inline]
            fn stv_eip712_data_word(&self) -> alloy_sol_types::Word {
                <Self as alloy_sol_types::SolStruct>::eip712_hash_struct(self)
            }
            #[inline]
            fn stv_abi_encode_packed_to(
                &self,
                out: &mut alloy_sol_types::private::Vec<u8>,
            ) {
                let tuple = <UnderlyingRustTuple<
                    '_,
                > as ::core::convert::From<Self>>::from(self.clone());
                <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_encode_packed_to(&tuple, out)
            }
            #[inline]
            fn stv_abi_packed_encoded_size(&self) -> usize {
                if let Some(size) = <Self as alloy_sol_types::SolType>::PACKED_ENCODED_SIZE {
                    return size;
                }
                let tuple = <UnderlyingRustTuple<
                    '_,
                > as ::core::convert::From<Self>>::from(self.clone());
                <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_packed_encoded_size(&tuple)
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolType for OneStepData {
            type RustType = Self;
            type Token<'a> = <UnderlyingSolTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SOL_NAME: &'static str = <Self as alloy_sol_types::SolStruct>::NAME;
            const ENCODED_SIZE: Option<usize> = <UnderlyingSolTuple<
                '_,
            > as alloy_sol_types::SolType>::ENCODED_SIZE;
            const PACKED_ENCODED_SIZE: Option<usize> = <UnderlyingSolTuple<
                '_,
            > as alloy_sol_types::SolType>::PACKED_ENCODED_SIZE;
            #[inline]
            fn valid_token(token: &Self::Token<'_>) -> bool {
                <UnderlyingSolTuple<'_> as alloy_sol_types::SolType>::valid_token(token)
            }
            #[inline]
            fn detokenize(token: Self::Token<'_>) -> Self::RustType {
                let tuple = <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::detokenize(token);
                <Self as ::core::convert::From<UnderlyingRustTuple<'_>>>::from(tuple)
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolStruct for OneStepData {
            const NAME: &'static str = "OneStepData";
            #[inline]
            fn eip712_root_type() -> alloy_sol_types::private::Cow<'static, str> {
                alloy_sol_types::private::Cow::Borrowed(
                    "OneStepData(bytes32 beforeHash,bytes proof)",
                )
            }
            #[inline]
            fn eip712_components() -> alloy_sol_types::private::Vec<
                alloy_sol_types::private::Cow<'static, str>,
            > {
                alloy_sol_types::private::Vec::new()
            }
            #[inline]
            fn eip712_encode_type() -> alloy_sol_types::private::Cow<'static, str> {
                <Self as alloy_sol_types::SolStruct>::eip712_root_type()
            }
            #[inline]
            fn eip712_encode_data(&self) -> alloy_sol_types::private::Vec<u8> {
                [
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::eip712_data_word(&self.beforeHash)
                        .0,
                    <alloy::sol_types::sol_data::Bytes as alloy_sol_types::SolType>::eip712_data_word(
                            &self.proof,
                        )
                        .0,
                ]
                    .concat()
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::EventTopic for OneStepData {
            #[inline]
            fn topic_preimage_length(rust: &Self::RustType) -> usize {
                0usize
                    + <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.beforeHash,
                    )
                    + <alloy::sol_types::sol_data::Bytes as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.proof,
                    )
            }
            #[inline]
            fn encode_topic_preimage(
                rust: &Self::RustType,
                out: &mut alloy_sol_types::private::Vec<u8>,
            ) {
                out.reserve(
                    <Self as alloy_sol_types::EventTopic>::topic_preimage_length(rust),
                );
                <alloy::sol_types::sol_data::FixedBytes<
                    32,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.beforeHash,
                    out,
                );
                <alloy::sol_types::sol_data::Bytes as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.proof,
                    out,
                );
            }
            #[inline]
            fn encode_topic(
                rust: &Self::RustType,
            ) -> alloy_sol_types::abi::token::WordToken {
                let mut out = alloy_sol_types::private::Vec::new();
                <Self as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    rust,
                    &mut out,
                );
                alloy_sol_types::abi::token::WordToken(
                    alloy_sol_types::private::keccak256(out),
                )
            }
        }
    };
    /**Custom error with signature `AccountHasMadeLayerZeroRival(address,bytes32)` and selector `0x5a46ac3a`.
```solidity
error AccountHasMadeLayerZeroRival(address account, bytes32 mutualId);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct AccountHasMadeLayerZeroRival {
        #[allow(missing_docs)]
        pub account: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub mutualId: alloy::sol_types::private::FixedBytes<32>,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = (
            alloy::sol_types::sol_data::Address,
            alloy::sol_types::sol_data::FixedBytes<32>,
        );
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = (
            alloy::sol_types::private::Address,
            alloy::sol_types::private::FixedBytes<32>,
        );
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<AccountHasMadeLayerZeroRival>
        for UnderlyingRustTuple<'_> {
            fn from(value: AccountHasMadeLayerZeroRival) -> Self {
                (value.account, value.mutualId)
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>>
        for AccountHasMadeLayerZeroRival {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self {
                    account: tuple.0,
                    mutualId: tuple.1,
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for AccountHasMadeLayerZeroRival {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "AccountHasMadeLayerZeroRival(address,bytes32)";
            const SELECTOR: [u8; 4] = [90u8, 70u8, 172u8, 58u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.account,
                    ),
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.mutualId),
                )
            }
        }
    };
    /**Custom error with signature `AssertionHashEmpty()` and selector `0xe96bc61a`.
```solidity
error AssertionHashEmpty();
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct AssertionHashEmpty {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = ();
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = ();
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<AssertionHashEmpty> for UnderlyingRustTuple<'_> {
            fn from(value: AssertionHashEmpty) -> Self {
                ()
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for AssertionHashEmpty {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self {}
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for AssertionHashEmpty {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "AssertionHashEmpty()";
            const SELECTOR: [u8; 4] = [233u8, 107u8, 198u8, 26u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
        }
    };
    /**Custom error with signature `AssertionHashMismatch(bytes32,bytes32)` and selector `0x5b177a3c`.
```solidity
error AssertionHashMismatch(bytes32 h1, bytes32 h2);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct AssertionHashMismatch {
        #[allow(missing_docs)]
        pub h1: alloy::sol_types::private::FixedBytes<32>,
        #[allow(missing_docs)]
        pub h2: alloy::sol_types::private::FixedBytes<32>,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = (
            alloy::sol_types::sol_data::FixedBytes<32>,
            alloy::sol_types::sol_data::FixedBytes<32>,
        );
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = (
            alloy::sol_types::private::FixedBytes<32>,
            alloy::sol_types::private::FixedBytes<32>,
        );
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<AssertionHashMismatch> for UnderlyingRustTuple<'_> {
            fn from(value: AssertionHashMismatch) -> Self {
                (value.h1, value.h2)
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for AssertionHashMismatch {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self { h1: tuple.0, h2: tuple.1 }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for AssertionHashMismatch {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "AssertionHashMismatch(bytes32,bytes32)";
            const SELECTOR: [u8; 4] = [91u8, 23u8, 122u8, 60u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.h1),
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.h2),
                )
            }
        }
    };
    /**Custom error with signature `AssertionNoSibling()` and selector `0xb45d1c3a`.
```solidity
error AssertionNoSibling();
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct AssertionNoSibling {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = ();
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = ();
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<AssertionNoSibling> for UnderlyingRustTuple<'_> {
            fn from(value: AssertionNoSibling) -> Self {
                ()
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for AssertionNoSibling {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self {}
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for AssertionNoSibling {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "AssertionNoSibling()";
            const SELECTOR: [u8; 4] = [180u8, 93u8, 28u8, 58u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
        }
    };
    /**Custom error with signature `AssertionNotPending()` and selector `0xc1692436`.
```solidity
error AssertionNotPending();
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct AssertionNotPending {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = ();
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = ();
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<AssertionNotPending> for UnderlyingRustTuple<'_> {
            fn from(value: AssertionNotPending) -> Self {
                ()
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for AssertionNotPending {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self {}
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for AssertionNotPending {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "AssertionNotPending()";
            const SELECTOR: [u8; 4] = [193u8, 105u8, 36u8, 54u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
        }
    };
    /**Custom error with signature `BigStepLevelsTooMany(uint8)` and selector `0x40d23bf0`.
```solidity
error BigStepLevelsTooMany(uint8 levels);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct BigStepLevelsTooMany {
        #[allow(missing_docs)]
        pub levels: u8,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<8>,);
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = (u8,);
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<BigStepLevelsTooMany> for UnderlyingRustTuple<'_> {
            fn from(value: BigStepLevelsTooMany) -> Self {
                (value.levels,)
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for BigStepLevelsTooMany {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self { levels: tuple.0 }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for BigStepLevelsTooMany {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "BigStepLevelsTooMany(uint8)";
            const SELECTOR: [u8; 4] = [64u8, 210u8, 59u8, 240u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        8,
                    > as alloy_sol_types::SolType>::tokenize(&self.levels),
                )
            }
        }
    };
    /**Custom error with signature `CachedTimeSufficient(uint256,uint256)` and selector `0xd1f59281`.
```solidity
error CachedTimeSufficient(uint256 actual, uint256 expected);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct CachedTimeSufficient {
        #[allow(missing_docs)]
        pub actual: alloy::sol_types::private::primitives::aliases::U256,
        #[allow(missing_docs)]
        pub expected: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = (
            alloy::sol_types::sol_data::Uint<256>,
            alloy::sol_types::sol_data::Uint<256>,
        );
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = (
            alloy::sol_types::private::primitives::aliases::U256,
            alloy::sol_types::private::primitives::aliases::U256,
        );
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<CachedTimeSufficient> for UnderlyingRustTuple<'_> {
            fn from(value: CachedTimeSufficient) -> Self {
                (value.actual, value.expected)
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for CachedTimeSufficient {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self {
                    actual: tuple.0,
                    expected: tuple.1,
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for CachedTimeSufficient {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "CachedTimeSufficient(uint256,uint256)";
            const SELECTOR: [u8; 4] = [209u8, 245u8, 146u8, 129u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.actual),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.expected),
                )
            }
        }
    };
    /**Custom error with signature `ChildrenAlreadySet(bytes32,bytes32,bytes32)` and selector `0x8b0e71d0`.
```solidity
error ChildrenAlreadySet(bytes32 edgeId, bytes32 lowerChildId, bytes32 upperChildId);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct ChildrenAlreadySet {
        #[allow(missing_docs)]
        pub edgeId: alloy::sol_types::private::FixedBytes<32>,
        #[allow(missing_docs)]
        pub lowerChildId: alloy::sol_types::private::FixedBytes<32>,
        #[allow(missing_docs)]
        pub upperChildId: alloy::sol_types::private::FixedBytes<32>,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = (
            alloy::sol_types::sol_data::FixedBytes<32>,
            alloy::sol_types::sol_data::FixedBytes<32>,
            alloy::sol_types::sol_data::FixedBytes<32>,
        );
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = (
            alloy::sol_types::private::FixedBytes<32>,
            alloy::sol_types::private::FixedBytes<32>,
            alloy::sol_types::private::FixedBytes<32>,
        );
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<ChildrenAlreadySet> for UnderlyingRustTuple<'_> {
            fn from(value: ChildrenAlreadySet) -> Self {
                (value.edgeId, value.lowerChildId, value.upperChildId)
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for ChildrenAlreadySet {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self {
                    edgeId: tuple.0,
                    lowerChildId: tuple.1,
                    upperChildId: tuple.2,
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for ChildrenAlreadySet {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "ChildrenAlreadySet(bytes32,bytes32,bytes32)";
            const SELECTOR: [u8; 4] = [139u8, 14u8, 113u8, 208u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.edgeId),
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.lowerChildId),
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.upperChildId),
                )
            }
        }
    };
    /**Custom error with signature `ClaimEdgeInvalidLevel(uint8,uint8)` and selector `0xac9e6116`.
```solidity
error ClaimEdgeInvalidLevel(uint8 argLevel, uint8 claimLevel);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct ClaimEdgeInvalidLevel {
        #[allow(missing_docs)]
        pub argLevel: u8,
        #[allow(missing_docs)]
        pub claimLevel: u8,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = (
            alloy::sol_types::sol_data::Uint<8>,
            alloy::sol_types::sol_data::Uint<8>,
        );
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = (u8, u8);
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<ClaimEdgeInvalidLevel> for UnderlyingRustTuple<'_> {
            fn from(value: ClaimEdgeInvalidLevel) -> Self {
                (value.argLevel, value.claimLevel)
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for ClaimEdgeInvalidLevel {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self {
                    argLevel: tuple.0,
                    claimLevel: tuple.1,
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for ClaimEdgeInvalidLevel {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "ClaimEdgeInvalidLevel(uint8,uint8)";
            const SELECTOR: [u8; 4] = [172u8, 158u8, 97u8, 22u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        8,
                    > as alloy_sol_types::SolType>::tokenize(&self.argLevel),
                    <alloy::sol_types::sol_data::Uint<
                        8,
                    > as alloy_sol_types::SolType>::tokenize(&self.claimLevel),
                )
            }
        }
    };
    /**Custom error with signature `ClaimEdgeNotLengthOneRival(bytes32)` and selector `0xff6d9bd7`.
```solidity
error ClaimEdgeNotLengthOneRival(bytes32 claimId);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct ClaimEdgeNotLengthOneRival {
        #[allow(missing_docs)]
        pub claimId: alloy::sol_types::private::FixedBytes<32>,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::FixedBytes<32>,);
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = (alloy::sol_types::private::FixedBytes<32>,);
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<ClaimEdgeNotLengthOneRival>
        for UnderlyingRustTuple<'_> {
            fn from(value: ClaimEdgeNotLengthOneRival) -> Self {
                (value.claimId,)
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>>
        for ClaimEdgeNotLengthOneRival {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self { claimId: tuple.0 }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for ClaimEdgeNotLengthOneRival {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "ClaimEdgeNotLengthOneRival(bytes32)";
            const SELECTOR: [u8; 4] = [255u8, 109u8, 155u8, 215u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.claimId),
                )
            }
        }
    };
    /**Custom error with signature `ClaimEdgeNotPending()` and selector `0x12459ffd`.
```solidity
error ClaimEdgeNotPending();
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct ClaimEdgeNotPending {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = ();
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = ();
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<ClaimEdgeNotPending> for UnderlyingRustTuple<'_> {
            fn from(value: ClaimEdgeNotPending) -> Self {
                ()
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for ClaimEdgeNotPending {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self {}
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for ClaimEdgeNotPending {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "ClaimEdgeNotPending()";
            const SELECTOR: [u8; 4] = [18u8, 69u8, 159u8, 253u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
        }
    };
    /**Custom error with signature `EdgeAlreadyExists(bytes32)` and selector `0xbcedf3de`.
```solidity
error EdgeAlreadyExists(bytes32 edgeId);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct EdgeAlreadyExists {
        #[allow(missing_docs)]
        pub edgeId: alloy::sol_types::private::FixedBytes<32>,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::FixedBytes<32>,);
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = (alloy::sol_types::private::FixedBytes<32>,);
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<EdgeAlreadyExists> for UnderlyingRustTuple<'_> {
            fn from(value: EdgeAlreadyExists) -> Self {
                (value.edgeId,)
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for EdgeAlreadyExists {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self { edgeId: tuple.0 }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for EdgeAlreadyExists {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "EdgeAlreadyExists(bytes32)";
            const SELECTOR: [u8; 4] = [188u8, 237u8, 243u8, 222u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.edgeId),
                )
            }
        }
    };
    /**Custom error with signature `EdgeAlreadyRefunded(bytes32)` and selector `0x307f7669`.
```solidity
error EdgeAlreadyRefunded(bytes32 edgeId);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct EdgeAlreadyRefunded {
        #[allow(missing_docs)]
        pub edgeId: alloy::sol_types::private::FixedBytes<32>,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::FixedBytes<32>,);
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = (alloy::sol_types::private::FixedBytes<32>,);
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<EdgeAlreadyRefunded> for UnderlyingRustTuple<'_> {
            fn from(value: EdgeAlreadyRefunded) -> Self {
                (value.edgeId,)
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for EdgeAlreadyRefunded {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self { edgeId: tuple.0 }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for EdgeAlreadyRefunded {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "EdgeAlreadyRefunded(bytes32)";
            const SELECTOR: [u8; 4] = [48u8, 127u8, 118u8, 105u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.edgeId),
                )
            }
        }
    };
    /**Custom error with signature `EdgeClaimMismatch(bytes32,bytes32)` and selector `0xc2adc3e8`.
```solidity
error EdgeClaimMismatch(bytes32 edgeId, bytes32 claimingEdgeId);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct EdgeClaimMismatch {
        #[allow(missing_docs)]
        pub edgeId: alloy::sol_types::private::FixedBytes<32>,
        #[allow(missing_docs)]
        pub claimingEdgeId: alloy::sol_types::private::FixedBytes<32>,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = (
            alloy::sol_types::sol_data::FixedBytes<32>,
            alloy::sol_types::sol_data::FixedBytes<32>,
        );
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = (
            alloy::sol_types::private::FixedBytes<32>,
            alloy::sol_types::private::FixedBytes<32>,
        );
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<EdgeClaimMismatch> for UnderlyingRustTuple<'_> {
            fn from(value: EdgeClaimMismatch) -> Self {
                (value.edgeId, value.claimingEdgeId)
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for EdgeClaimMismatch {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self {
                    edgeId: tuple.0,
                    claimingEdgeId: tuple.1,
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for EdgeClaimMismatch {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "EdgeClaimMismatch(bytes32,bytes32)";
            const SELECTOR: [u8; 4] = [194u8, 173u8, 195u8, 232u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.edgeId),
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.claimingEdgeId),
                )
            }
        }
    };
    /**Custom error with signature `EdgeLevelInvalid(bytes32,bytes32,uint8,uint8)` and selector `0x7e726d15`.
```solidity
error EdgeLevelInvalid(bytes32 edgeId1, bytes32 edgeId2, uint8 level1, uint8 level2);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct EdgeLevelInvalid {
        #[allow(missing_docs)]
        pub edgeId1: alloy::sol_types::private::FixedBytes<32>,
        #[allow(missing_docs)]
        pub edgeId2: alloy::sol_types::private::FixedBytes<32>,
        #[allow(missing_docs)]
        pub level1: u8,
        #[allow(missing_docs)]
        pub level2: u8,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = (
            alloy::sol_types::sol_data::FixedBytes<32>,
            alloy::sol_types::sol_data::FixedBytes<32>,
            alloy::sol_types::sol_data::Uint<8>,
            alloy::sol_types::sol_data::Uint<8>,
        );
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = (
            alloy::sol_types::private::FixedBytes<32>,
            alloy::sol_types::private::FixedBytes<32>,
            u8,
            u8,
        );
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<EdgeLevelInvalid> for UnderlyingRustTuple<'_> {
            fn from(value: EdgeLevelInvalid) -> Self {
                (value.edgeId1, value.edgeId2, value.level1, value.level2)
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for EdgeLevelInvalid {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self {
                    edgeId1: tuple.0,
                    edgeId2: tuple.1,
                    level1: tuple.2,
                    level2: tuple.3,
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for EdgeLevelInvalid {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "EdgeLevelInvalid(bytes32,bytes32,uint8,uint8)";
            const SELECTOR: [u8; 4] = [126u8, 114u8, 109u8, 21u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.edgeId1),
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.edgeId2),
                    <alloy::sol_types::sol_data::Uint<
                        8,
                    > as alloy_sol_types::SolType>::tokenize(&self.level1),
                    <alloy::sol_types::sol_data::Uint<
                        8,
                    > as alloy_sol_types::SolType>::tokenize(&self.level2),
                )
            }
        }
    };
    /**Custom error with signature `EdgeNotConfirmed(bytes32,uint8)` and selector `0xef1267b4`.
```solidity
error EdgeNotConfirmed(bytes32 edgeId, EdgeStatus);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct EdgeNotConfirmed {
        #[allow(missing_docs)]
        pub edgeId: alloy::sol_types::private::FixedBytes<32>,
        #[allow(missing_docs)]
        pub _1: <EdgeStatus as alloy::sol_types::SolType>::RustType,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = (
            alloy::sol_types::sol_data::FixedBytes<32>,
            EdgeStatus,
        );
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = (
            alloy::sol_types::private::FixedBytes<32>,
            <EdgeStatus as alloy::sol_types::SolType>::RustType,
        );
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<EdgeNotConfirmed> for UnderlyingRustTuple<'_> {
            fn from(value: EdgeNotConfirmed) -> Self {
                (value.edgeId, value._1)
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for EdgeNotConfirmed {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self {
                    edgeId: tuple.0,
                    _1: tuple.1,
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for EdgeNotConfirmed {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "EdgeNotConfirmed(bytes32,uint8)";
            const SELECTOR: [u8; 4] = [239u8, 18u8, 103u8, 180u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.edgeId),
                    <EdgeStatus as alloy_sol_types::SolType>::tokenize(&self._1),
                )
            }
        }
    };
    /**Custom error with signature `EdgeNotExists(bytes32)` and selector `0x00a7b02b`.
```solidity
error EdgeNotExists(bytes32 edgeId);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct EdgeNotExists {
        #[allow(missing_docs)]
        pub edgeId: alloy::sol_types::private::FixedBytes<32>,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::FixedBytes<32>,);
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = (alloy::sol_types::private::FixedBytes<32>,);
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<EdgeNotExists> for UnderlyingRustTuple<'_> {
            fn from(value: EdgeNotExists) -> Self {
                (value.edgeId,)
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for EdgeNotExists {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self { edgeId: tuple.0 }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for EdgeNotExists {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "EdgeNotExists(bytes32)";
            const SELECTOR: [u8; 4] = [0u8, 167u8, 176u8, 43u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.edgeId),
                )
            }
        }
    };
    /**Custom error with signature `EdgeNotLayerZero(bytes32,address,bytes32)` and selector `0xe58c8308`.
```solidity
error EdgeNotLayerZero(bytes32 edgeId, address staker, bytes32 claimId);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct EdgeNotLayerZero {
        #[allow(missing_docs)]
        pub edgeId: alloy::sol_types::private::FixedBytes<32>,
        #[allow(missing_docs)]
        pub staker: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub claimId: alloy::sol_types::private::FixedBytes<32>,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = (
            alloy::sol_types::sol_data::FixedBytes<32>,
            alloy::sol_types::sol_data::Address,
            alloy::sol_types::sol_data::FixedBytes<32>,
        );
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = (
            alloy::sol_types::private::FixedBytes<32>,
            alloy::sol_types::private::Address,
            alloy::sol_types::private::FixedBytes<32>,
        );
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<EdgeNotLayerZero> for UnderlyingRustTuple<'_> {
            fn from(value: EdgeNotLayerZero) -> Self {
                (value.edgeId, value.staker, value.claimId)
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for EdgeNotLayerZero {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self {
                    edgeId: tuple.0,
                    staker: tuple.1,
                    claimId: tuple.2,
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for EdgeNotLayerZero {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "EdgeNotLayerZero(bytes32,address,bytes32)";
            const SELECTOR: [u8; 4] = [229u8, 140u8, 131u8, 8u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.edgeId),
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.staker,
                    ),
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.claimId),
                )
            }
        }
    };
    /**Custom error with signature `EdgeNotLengthOne(uint256)` and selector `0x6b595e50`.
```solidity
error EdgeNotLengthOne(uint256 length);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct EdgeNotLengthOne {
        #[allow(missing_docs)]
        pub length: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = (
            alloy::sol_types::private::primitives::aliases::U256,
        );
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<EdgeNotLengthOne> for UnderlyingRustTuple<'_> {
            fn from(value: EdgeNotLengthOne) -> Self {
                (value.length,)
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for EdgeNotLengthOne {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self { length: tuple.0 }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for EdgeNotLengthOne {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "EdgeNotLengthOne(uint256)";
            const SELECTOR: [u8; 4] = [107u8, 89u8, 94u8, 80u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.length),
                )
            }
        }
    };
    /**Custom error with signature `EdgeNotPending(bytes32,uint8)` and selector `0x23f8405d`.
```solidity
error EdgeNotPending(bytes32 edgeId, EdgeStatus status);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct EdgeNotPending {
        #[allow(missing_docs)]
        pub edgeId: alloy::sol_types::private::FixedBytes<32>,
        #[allow(missing_docs)]
        pub status: <EdgeStatus as alloy::sol_types::SolType>::RustType,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = (
            alloy::sol_types::sol_data::FixedBytes<32>,
            EdgeStatus,
        );
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = (
            alloy::sol_types::private::FixedBytes<32>,
            <EdgeStatus as alloy::sol_types::SolType>::RustType,
        );
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<EdgeNotPending> for UnderlyingRustTuple<'_> {
            fn from(value: EdgeNotPending) -> Self {
                (value.edgeId, value.status)
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for EdgeNotPending {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self {
                    edgeId: tuple.0,
                    status: tuple.1,
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for EdgeNotPending {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "EdgeNotPending(bytes32,uint8)";
            const SELECTOR: [u8; 4] = [35u8, 248u8, 64u8, 93u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.edgeId),
                    <EdgeStatus as alloy_sol_types::SolType>::tokenize(&self.status),
                )
            }
        }
    };
    /**Custom error with signature `EdgeTypeNotSmallStep(uint8)` and selector `0x348aefdf`.
```solidity
error EdgeTypeNotSmallStep(uint8 level);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct EdgeTypeNotSmallStep {
        #[allow(missing_docs)]
        pub level: u8,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<8>,);
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = (u8,);
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<EdgeTypeNotSmallStep> for UnderlyingRustTuple<'_> {
            fn from(value: EdgeTypeNotSmallStep) -> Self {
                (value.level,)
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for EdgeTypeNotSmallStep {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self { level: tuple.0 }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for EdgeTypeNotSmallStep {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "EdgeTypeNotSmallStep(uint8)";
            const SELECTOR: [u8; 4] = [52u8, 138u8, 239u8, 223u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        8,
                    > as alloy_sol_types::SolType>::tokenize(&self.level),
                )
            }
        }
    };
    /**Custom error with signature `EdgeUnrivaled(bytes32)` and selector `0x80e07e45`.
```solidity
error EdgeUnrivaled(bytes32 edgeId);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct EdgeUnrivaled {
        #[allow(missing_docs)]
        pub edgeId: alloy::sol_types::private::FixedBytes<32>,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::FixedBytes<32>,);
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = (alloy::sol_types::private::FixedBytes<32>,);
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<EdgeUnrivaled> for UnderlyingRustTuple<'_> {
            fn from(value: EdgeUnrivaled) -> Self {
                (value.edgeId,)
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for EdgeUnrivaled {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self { edgeId: tuple.0 }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for EdgeUnrivaled {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "EdgeUnrivaled(bytes32)";
            const SELECTOR: [u8; 4] = [128u8, 224u8, 126u8, 69u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.edgeId),
                )
            }
        }
    };
    /**Custom error with signature `EmptyArray()` and selector `0x521299a9`.
```solidity
error EmptyArray();
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct EmptyArray {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = ();
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = ();
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<EmptyArray> for UnderlyingRustTuple<'_> {
            fn from(value: EmptyArray) -> Self {
                ()
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for EmptyArray {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self {}
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for EmptyArray {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "EmptyArray()";
            const SELECTOR: [u8; 4] = [82u8, 18u8, 153u8, 169u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
        }
    };
    /**Custom error with signature `EmptyAssertionChain()` and selector `0xc83e0862`.
```solidity
error EmptyAssertionChain();
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct EmptyAssertionChain {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = ();
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = ();
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<EmptyAssertionChain> for UnderlyingRustTuple<'_> {
            fn from(value: EmptyAssertionChain) -> Self {
                ()
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for EmptyAssertionChain {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self {}
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for EmptyAssertionChain {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "EmptyAssertionChain()";
            const SELECTOR: [u8; 4] = [200u8, 62u8, 8u8, 98u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
        }
    };
    /**Custom error with signature `EmptyChallengePeriod()` and selector `0x8a0eedcc`.
```solidity
error EmptyChallengePeriod();
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct EmptyChallengePeriod {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = ();
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = ();
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<EmptyChallengePeriod> for UnderlyingRustTuple<'_> {
            fn from(value: EmptyChallengePeriod) -> Self {
                ()
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for EmptyChallengePeriod {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self {}
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for EmptyChallengePeriod {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "EmptyChallengePeriod()";
            const SELECTOR: [u8; 4] = [138u8, 14u8, 237u8, 204u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
        }
    };
    /**Custom error with signature `EmptyClaimId()` and selector `0x6932bcfd`.
```solidity
error EmptyClaimId();
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct EmptyClaimId {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = ();
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = ();
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<EmptyClaimId> for UnderlyingRustTuple<'_> {
            fn from(value: EmptyClaimId) -> Self {
                ()
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for EmptyClaimId {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self {}
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for EmptyClaimId {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "EmptyClaimId()";
            const SELECTOR: [u8; 4] = [105u8, 50u8, 188u8, 253u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
        }
    };
    /**Custom error with signature `EmptyEdgeSpecificProof()` and selector `0xc9ccac50`.
```solidity
error EmptyEdgeSpecificProof();
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct EmptyEdgeSpecificProof {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = ();
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = ();
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<EmptyEdgeSpecificProof> for UnderlyingRustTuple<'_> {
            fn from(value: EmptyEdgeSpecificProof) -> Self {
                ()
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for EmptyEdgeSpecificProof {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self {}
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for EmptyEdgeSpecificProof {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "EmptyEdgeSpecificProof()";
            const SELECTOR: [u8; 4] = [201u8, 204u8, 172u8, 80u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
        }
    };
    /**Custom error with signature `EmptyEndMachineStatus()` and selector `0x8999857d`.
```solidity
error EmptyEndMachineStatus();
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct EmptyEndMachineStatus {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = ();
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = ();
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<EmptyEndMachineStatus> for UnderlyingRustTuple<'_> {
            fn from(value: EmptyEndMachineStatus) -> Self {
                ()
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for EmptyEndMachineStatus {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self {}
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for EmptyEndMachineStatus {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "EmptyEndMachineStatus()";
            const SELECTOR: [u8; 4] = [137u8, 153u8, 133u8, 125u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
        }
    };
    /**Custom error with signature `EmptyEndRoot()` and selector `0x5cb6e5bb`.
```solidity
error EmptyEndRoot();
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct EmptyEndRoot {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = ();
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = ();
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<EmptyEndRoot> for UnderlyingRustTuple<'_> {
            fn from(value: EmptyEndRoot) -> Self {
                ()
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for EmptyEndRoot {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self {}
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for EmptyEndRoot {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "EmptyEndRoot()";
            const SELECTOR: [u8; 4] = [92u8, 182u8, 229u8, 187u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
        }
    };
    /**Custom error with signature `EmptyFirstRival()` and selector `0xda10f67c`.
```solidity
error EmptyFirstRival();
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct EmptyFirstRival {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = ();
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = ();
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<EmptyFirstRival> for UnderlyingRustTuple<'_> {
            fn from(value: EmptyFirstRival) -> Self {
                ()
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for EmptyFirstRival {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self {}
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for EmptyFirstRival {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "EmptyFirstRival()";
            const SELECTOR: [u8; 4] = [218u8, 16u8, 246u8, 124u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
        }
    };
    /**Custom error with signature `EmptyOneStepProofEntry()` and selector `0xfb60b0ef`.
```solidity
error EmptyOneStepProofEntry();
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct EmptyOneStepProofEntry {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = ();
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = ();
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<EmptyOneStepProofEntry> for UnderlyingRustTuple<'_> {
            fn from(value: EmptyOneStepProofEntry) -> Self {
                ()
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for EmptyOneStepProofEntry {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self {}
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for EmptyOneStepProofEntry {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "EmptyOneStepProofEntry()";
            const SELECTOR: [u8; 4] = [251u8, 96u8, 176u8, 239u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
        }
    };
    /**Custom error with signature `EmptyOriginId()` and selector `0x8d79dbbc`.
```solidity
error EmptyOriginId();
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct EmptyOriginId {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = ();
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = ();
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<EmptyOriginId> for UnderlyingRustTuple<'_> {
            fn from(value: EmptyOriginId) -> Self {
                ()
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for EmptyOriginId {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self {}
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for EmptyOriginId {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "EmptyOriginId()";
            const SELECTOR: [u8; 4] = [141u8, 121u8, 219u8, 188u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
        }
    };
    /**Custom error with signature `EmptyPrefixProof()` and selector `0x342a0752`.
```solidity
error EmptyPrefixProof();
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct EmptyPrefixProof {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = ();
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = ();
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<EmptyPrefixProof> for UnderlyingRustTuple<'_> {
            fn from(value: EmptyPrefixProof) -> Self {
                ()
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for EmptyPrefixProof {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self {}
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for EmptyPrefixProof {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "EmptyPrefixProof()";
            const SELECTOR: [u8; 4] = [52u8, 42u8, 7u8, 82u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
        }
    };
    /**Custom error with signature `EmptyStakeReceiver()` and selector `0x0f0ec8a8`.
```solidity
error EmptyStakeReceiver();
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct EmptyStakeReceiver {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = ();
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = ();
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<EmptyStakeReceiver> for UnderlyingRustTuple<'_> {
            fn from(value: EmptyStakeReceiver) -> Self {
                ()
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for EmptyStakeReceiver {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self {}
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for EmptyStakeReceiver {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "EmptyStakeReceiver()";
            const SELECTOR: [u8; 4] = [15u8, 14u8, 200u8, 168u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
        }
    };
    /**Custom error with signature `EmptyStaker()` and selector `0xf289e657`.
```solidity
error EmptyStaker();
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct EmptyStaker {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = ();
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = ();
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<EmptyStaker> for UnderlyingRustTuple<'_> {
            fn from(value: EmptyStaker) -> Self {
                ()
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for EmptyStaker {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self {}
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for EmptyStaker {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "EmptyStaker()";
            const SELECTOR: [u8; 4] = [242u8, 137u8, 230u8, 87u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
        }
    };
    /**Custom error with signature `EmptyStartMachineStatus()` and selector `0x46365e52`.
```solidity
error EmptyStartMachineStatus();
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct EmptyStartMachineStatus {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = ();
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = ();
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<EmptyStartMachineStatus> for UnderlyingRustTuple<'_> {
            fn from(value: EmptyStartMachineStatus) -> Self {
                ()
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for EmptyStartMachineStatus {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self {}
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for EmptyStartMachineStatus {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "EmptyStartMachineStatus()";
            const SELECTOR: [u8; 4] = [70u8, 54u8, 94u8, 82u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
        }
    };
    /**Custom error with signature `EmptyStartRoot()` and selector `0x83c683e4`.
```solidity
error EmptyStartRoot();
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct EmptyStartRoot {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = ();
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = ();
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<EmptyStartRoot> for UnderlyingRustTuple<'_> {
            fn from(value: EmptyStartRoot) -> Self {
                ()
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for EmptyStartRoot {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self {}
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for EmptyStartRoot {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "EmptyStartRoot()";
            const SELECTOR: [u8; 4] = [131u8, 198u8, 131u8, 228u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
        }
    };
    /**Custom error with signature `EndHistoryRootMismatch(bytes32,bytes32)` and selector `0x3a63e99a`.
```solidity
error EndHistoryRootMismatch(bytes32 endHistoryRoot, bytes32 assertionEndRoot);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct EndHistoryRootMismatch {
        #[allow(missing_docs)]
        pub endHistoryRoot: alloy::sol_types::private::FixedBytes<32>,
        #[allow(missing_docs)]
        pub assertionEndRoot: alloy::sol_types::private::FixedBytes<32>,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = (
            alloy::sol_types::sol_data::FixedBytes<32>,
            alloy::sol_types::sol_data::FixedBytes<32>,
        );
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = (
            alloy::sol_types::private::FixedBytes<32>,
            alloy::sol_types::private::FixedBytes<32>,
        );
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<EndHistoryRootMismatch> for UnderlyingRustTuple<'_> {
            fn from(value: EndHistoryRootMismatch) -> Self {
                (value.endHistoryRoot, value.assertionEndRoot)
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for EndHistoryRootMismatch {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self {
                    endHistoryRoot: tuple.0,
                    assertionEndRoot: tuple.1,
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for EndHistoryRootMismatch {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "EndHistoryRootMismatch(bytes32,bytes32)";
            const SELECTOR: [u8; 4] = [58u8, 99u8, 233u8, 154u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.endHistoryRoot),
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.assertionEndRoot),
                )
            }
        }
    };
    /**Custom error with signature `HeightDiffLtTwo(uint256,uint256)` and selector `0x90298594`.
```solidity
error HeightDiffLtTwo(uint256 h1, uint256 h2);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct HeightDiffLtTwo {
        #[allow(missing_docs)]
        pub h1: alloy::sol_types::private::primitives::aliases::U256,
        #[allow(missing_docs)]
        pub h2: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = (
            alloy::sol_types::sol_data::Uint<256>,
            alloy::sol_types::sol_data::Uint<256>,
        );
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = (
            alloy::sol_types::private::primitives::aliases::U256,
            alloy::sol_types::private::primitives::aliases::U256,
        );
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<HeightDiffLtTwo> for UnderlyingRustTuple<'_> {
            fn from(value: HeightDiffLtTwo) -> Self {
                (value.h1, value.h2)
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for HeightDiffLtTwo {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self { h1: tuple.0, h2: tuple.1 }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for HeightDiffLtTwo {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "HeightDiffLtTwo(uint256,uint256)";
            const SELECTOR: [u8; 4] = [144u8, 41u8, 133u8, 148u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.h1),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.h2),
                )
            }
        }
    };
    /**Custom error with signature `InsufficientConfirmationBlocks(uint256,uint256)` and selector `0x11a8d4d0`.
```solidity
error InsufficientConfirmationBlocks(uint256 totalBlocks, uint256 thresholdBlocks);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct InsufficientConfirmationBlocks {
        #[allow(missing_docs)]
        pub totalBlocks: alloy::sol_types::private::primitives::aliases::U256,
        #[allow(missing_docs)]
        pub thresholdBlocks: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = (
            alloy::sol_types::sol_data::Uint<256>,
            alloy::sol_types::sol_data::Uint<256>,
        );
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = (
            alloy::sol_types::private::primitives::aliases::U256,
            alloy::sol_types::private::primitives::aliases::U256,
        );
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<InsufficientConfirmationBlocks>
        for UnderlyingRustTuple<'_> {
            fn from(value: InsufficientConfirmationBlocks) -> Self {
                (value.totalBlocks, value.thresholdBlocks)
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>>
        for InsufficientConfirmationBlocks {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self {
                    totalBlocks: tuple.0,
                    thresholdBlocks: tuple.1,
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for InsufficientConfirmationBlocks {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "InsufficientConfirmationBlocks(uint256,uint256)";
            const SELECTOR: [u8; 4] = [17u8, 168u8, 212u8, 208u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.totalBlocks),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.thresholdBlocks),
                )
            }
        }
    };
    /**Custom error with signature `InvalidEdgeType(uint8)` and selector `0x3bf2e1ec`.
```solidity
error InvalidEdgeType(EdgeType edgeType);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct InvalidEdgeType {
        #[allow(missing_docs)]
        pub edgeType: <EdgeType as alloy::sol_types::SolType>::RustType,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = (EdgeType,);
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = (
            <EdgeType as alloy::sol_types::SolType>::RustType,
        );
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<InvalidEdgeType> for UnderlyingRustTuple<'_> {
            fn from(value: InvalidEdgeType) -> Self {
                (value.edgeType,)
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for InvalidEdgeType {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self { edgeType: tuple.0 }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for InvalidEdgeType {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "InvalidEdgeType(uint8)";
            const SELECTOR: [u8; 4] = [59u8, 242u8, 225u8, 236u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (<EdgeType as alloy_sol_types::SolType>::tokenize(&self.edgeType),)
            }
        }
    };
    /**Custom error with signature `InvalidEndHeight(uint256,uint256)` and selector `0xdfcc62bc`.
```solidity
error InvalidEndHeight(uint256 actualHeight, uint256 expectedHeight);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct InvalidEndHeight {
        #[allow(missing_docs)]
        pub actualHeight: alloy::sol_types::private::primitives::aliases::U256,
        #[allow(missing_docs)]
        pub expectedHeight: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = (
            alloy::sol_types::sol_data::Uint<256>,
            alloy::sol_types::sol_data::Uint<256>,
        );
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = (
            alloy::sol_types::private::primitives::aliases::U256,
            alloy::sol_types::private::primitives::aliases::U256,
        );
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<InvalidEndHeight> for UnderlyingRustTuple<'_> {
            fn from(value: InvalidEndHeight) -> Self {
                (value.actualHeight, value.expectedHeight)
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for InvalidEndHeight {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self {
                    actualHeight: tuple.0,
                    expectedHeight: tuple.1,
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for InvalidEndHeight {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "InvalidEndHeight(uint256,uint256)";
            const SELECTOR: [u8; 4] = [223u8, 204u8, 98u8, 188u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.actualHeight),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.expectedHeight),
                )
            }
        }
    };
    /**Custom error with signature `InvalidHeights(uint256,uint256)` and selector `0x2060faf4`.
```solidity
error InvalidHeights(uint256 start, uint256 end);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct InvalidHeights {
        #[allow(missing_docs)]
        pub start: alloy::sol_types::private::primitives::aliases::U256,
        #[allow(missing_docs)]
        pub end: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = (
            alloy::sol_types::sol_data::Uint<256>,
            alloy::sol_types::sol_data::Uint<256>,
        );
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = (
            alloy::sol_types::private::primitives::aliases::U256,
            alloy::sol_types::private::primitives::aliases::U256,
        );
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<InvalidHeights> for UnderlyingRustTuple<'_> {
            fn from(value: InvalidHeights) -> Self {
                (value.start, value.end)
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for InvalidHeights {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self {
                    start: tuple.0,
                    end: tuple.1,
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for InvalidHeights {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "InvalidHeights(uint256,uint256)";
            const SELECTOR: [u8; 4] = [32u8, 96u8, 250u8, 244u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.start),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.end),
                )
            }
        }
    };
    /**Custom error with signature `LevelTooHigh(uint8,uint8)` and selector `0xae0da578`.
```solidity
error LevelTooHigh(uint8 level, uint8 numBigStepLevels);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct LevelTooHigh {
        #[allow(missing_docs)]
        pub level: u8,
        #[allow(missing_docs)]
        pub numBigStepLevels: u8,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = (
            alloy::sol_types::sol_data::Uint<8>,
            alloy::sol_types::sol_data::Uint<8>,
        );
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = (u8, u8);
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<LevelTooHigh> for UnderlyingRustTuple<'_> {
            fn from(value: LevelTooHigh) -> Self {
                (value.level, value.numBigStepLevels)
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for LevelTooHigh {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self {
                    level: tuple.0,
                    numBigStepLevels: tuple.1,
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for LevelTooHigh {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "LevelTooHigh(uint8,uint8)";
            const SELECTOR: [u8; 4] = [174u8, 13u8, 165u8, 120u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        8,
                    > as alloy_sol_types::SolType>::tokenize(&self.level),
                    <alloy::sol_types::sol_data::Uint<
                        8,
                    > as alloy_sol_types::SolType>::tokenize(&self.numBigStepLevels),
                )
            }
        }
    };
    /**Custom error with signature `MerkleProofTooLong(uint256,uint256)` and selector `0xfdac331e`.
```solidity
error MerkleProofTooLong(uint256 actualLength, uint256 maxProofLength);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct MerkleProofTooLong {
        #[allow(missing_docs)]
        pub actualLength: alloy::sol_types::private::primitives::aliases::U256,
        #[allow(missing_docs)]
        pub maxProofLength: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = (
            alloy::sol_types::sol_data::Uint<256>,
            alloy::sol_types::sol_data::Uint<256>,
        );
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = (
            alloy::sol_types::private::primitives::aliases::U256,
            alloy::sol_types::private::primitives::aliases::U256,
        );
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<MerkleProofTooLong> for UnderlyingRustTuple<'_> {
            fn from(value: MerkleProofTooLong) -> Self {
                (value.actualLength, value.maxProofLength)
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for MerkleProofTooLong {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self {
                    actualLength: tuple.0,
                    maxProofLength: tuple.1,
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for MerkleProofTooLong {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "MerkleProofTooLong(uint256,uint256)";
            const SELECTOR: [u8; 4] = [253u8, 172u8, 51u8, 30u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.actualLength),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.maxProofLength),
                )
            }
        }
    };
    /**Custom error with signature `NotPowerOfTwo(uint256)` and selector `0xeafedbfc`.
```solidity
error NotPowerOfTwo(uint256 val);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct NotPowerOfTwo {
        #[allow(missing_docs)]
        pub val: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = (
            alloy::sol_types::private::primitives::aliases::U256,
        );
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<NotPowerOfTwo> for UnderlyingRustTuple<'_> {
            fn from(value: NotPowerOfTwo) -> Self {
                (value.val,)
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for NotPowerOfTwo {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self { val: tuple.0 }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for NotPowerOfTwo {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "NotPowerOfTwo(uint256)";
            const SELECTOR: [u8; 4] = [234u8, 254u8, 219u8, 252u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.val),
                )
            }
        }
    };
    /**Custom error with signature `NotValidator(address)` and selector `0xed3db8ac`.
```solidity
error NotValidator(address account);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct NotValidator {
        #[allow(missing_docs)]
        pub account: alloy::sol_types::private::Address,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Address,);
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = (alloy::sol_types::private::Address,);
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<NotValidator> for UnderlyingRustTuple<'_> {
            fn from(value: NotValidator) -> Self {
                (value.account,)
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for NotValidator {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self { account: tuple.0 }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for NotValidator {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "NotValidator(address)";
            const SELECTOR: [u8; 4] = [237u8, 61u8, 184u8, 172u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.account,
                    ),
                )
            }
        }
    };
    /**Custom error with signature `OriginIdMutualIdMismatch(bytes32,bytes32)` and selector `0xe2e27f87`.
```solidity
error OriginIdMutualIdMismatch(bytes32 mutualId, bytes32 originId);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct OriginIdMutualIdMismatch {
        #[allow(missing_docs)]
        pub mutualId: alloy::sol_types::private::FixedBytes<32>,
        #[allow(missing_docs)]
        pub originId: alloy::sol_types::private::FixedBytes<32>,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = (
            alloy::sol_types::sol_data::FixedBytes<32>,
            alloy::sol_types::sol_data::FixedBytes<32>,
        );
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = (
            alloy::sol_types::private::FixedBytes<32>,
            alloy::sol_types::private::FixedBytes<32>,
        );
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<OriginIdMutualIdMismatch>
        for UnderlyingRustTuple<'_> {
            fn from(value: OriginIdMutualIdMismatch) -> Self {
                (value.mutualId, value.originId)
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>>
        for OriginIdMutualIdMismatch {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self {
                    mutualId: tuple.0,
                    originId: tuple.1,
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for OriginIdMutualIdMismatch {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "OriginIdMutualIdMismatch(bytes32,bytes32)";
            const SELECTOR: [u8; 4] = [226u8, 226u8, 127u8, 135u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.mutualId),
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.originId),
                )
            }
        }
    };
    /**Custom error with signature `RivalEdgeConfirmed(bytes32,bytes32)` and selector `0xdd7028f0`.
```solidity
error RivalEdgeConfirmed(bytes32 edgeId, bytes32 confirmedRivalId);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct RivalEdgeConfirmed {
        #[allow(missing_docs)]
        pub edgeId: alloy::sol_types::private::FixedBytes<32>,
        #[allow(missing_docs)]
        pub confirmedRivalId: alloy::sol_types::private::FixedBytes<32>,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = (
            alloy::sol_types::sol_data::FixedBytes<32>,
            alloy::sol_types::sol_data::FixedBytes<32>,
        );
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = (
            alloy::sol_types::private::FixedBytes<32>,
            alloy::sol_types::private::FixedBytes<32>,
        );
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<RivalEdgeConfirmed> for UnderlyingRustTuple<'_> {
            fn from(value: RivalEdgeConfirmed) -> Self {
                (value.edgeId, value.confirmedRivalId)
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for RivalEdgeConfirmed {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self {
                    edgeId: tuple.0,
                    confirmedRivalId: tuple.1,
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for RivalEdgeConfirmed {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "RivalEdgeConfirmed(bytes32,bytes32)";
            const SELECTOR: [u8; 4] = [221u8, 112u8, 40u8, 240u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.edgeId),
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.confirmedRivalId),
                )
            }
        }
    };
    /**Custom error with signature `StakeAmountsMismatch(uint256,uint256)` and selector `0x0aece9c0`.
```solidity
error StakeAmountsMismatch(uint256 stakeLevels, uint256 numLevels);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct StakeAmountsMismatch {
        #[allow(missing_docs)]
        pub stakeLevels: alloy::sol_types::private::primitives::aliases::U256,
        #[allow(missing_docs)]
        pub numLevels: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = (
            alloy::sol_types::sol_data::Uint<256>,
            alloy::sol_types::sol_data::Uint<256>,
        );
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = (
            alloy::sol_types::private::primitives::aliases::U256,
            alloy::sol_types::private::primitives::aliases::U256,
        );
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<StakeAmountsMismatch> for UnderlyingRustTuple<'_> {
            fn from(value: StakeAmountsMismatch) -> Self {
                (value.stakeLevels, value.numLevels)
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for StakeAmountsMismatch {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self {
                    stakeLevels: tuple.0,
                    numLevels: tuple.1,
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for StakeAmountsMismatch {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "StakeAmountsMismatch(uint256,uint256)";
            const SELECTOR: [u8; 4] = [10u8, 236u8, 233u8, 192u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.stakeLevels),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.numLevels),
                )
            }
        }
    };
    /**Custom error with signature `ZeroBigStepLevels()` and selector `0xa863d6e4`.
```solidity
error ZeroBigStepLevels();
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct ZeroBigStepLevels {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = ();
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = ();
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<ZeroBigStepLevels> for UnderlyingRustTuple<'_> {
            fn from(value: ZeroBigStepLevels) -> Self {
                ()
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for ZeroBigStepLevels {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self {}
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for ZeroBigStepLevels {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "ZeroBigStepLevels()";
            const SELECTOR: [u8; 4] = [168u8, 99u8, 214u8, 228u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
        }
    };
    /**Event with signature `EdgeAdded(bytes32,bytes32,bytes32,bytes32,uint256,uint8,bool,bool)` and selector `0xaa4b66b1ce938c06e2a3f8466bae10ef62e747630e3859889f4719fc6427b5a4`.
```solidity
event EdgeAdded(bytes32 indexed edgeId, bytes32 indexed mutualId, bytes32 indexed originId, bytes32 claimId, uint256 length, uint8 level, bool hasRival, bool isLayerZero);
```*/
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    #[derive(Clone)]
    pub struct EdgeAdded {
        #[allow(missing_docs)]
        pub edgeId: alloy::sol_types::private::FixedBytes<32>,
        #[allow(missing_docs)]
        pub mutualId: alloy::sol_types::private::FixedBytes<32>,
        #[allow(missing_docs)]
        pub originId: alloy::sol_types::private::FixedBytes<32>,
        #[allow(missing_docs)]
        pub claimId: alloy::sol_types::private::FixedBytes<32>,
        #[allow(missing_docs)]
        pub length: alloy::sol_types::private::primitives::aliases::U256,
        #[allow(missing_docs)]
        pub level: u8,
        #[allow(missing_docs)]
        pub hasRival: bool,
        #[allow(missing_docs)]
        pub isLayerZero: bool,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[automatically_derived]
        impl alloy_sol_types::SolEvent for EdgeAdded {
            type DataTuple<'a> = (
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Uint<8>,
                alloy::sol_types::sol_data::Bool,
                alloy::sol_types::sol_data::Bool,
            );
            type DataToken<'a> = <Self::DataTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type TopicList = (
                alloy_sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<32>,
            );
            const SIGNATURE: &'static str = "EdgeAdded(bytes32,bytes32,bytes32,bytes32,uint256,uint8,bool,bool)";
            const SIGNATURE_HASH: alloy_sol_types::private::B256 = alloy_sol_types::private::B256::new([
                170u8,
                75u8,
                102u8,
                177u8,
                206u8,
                147u8,
                140u8,
                6u8,
                226u8,
                163u8,
                248u8,
                70u8,
                107u8,
                174u8,
                16u8,
                239u8,
                98u8,
                231u8,
                71u8,
                99u8,
                14u8,
                56u8,
                89u8,
                136u8,
                159u8,
                71u8,
                25u8,
                252u8,
                100u8,
                39u8,
                181u8,
                164u8,
            ]);
            const ANONYMOUS: bool = false;
            #[allow(unused_variables)]
            #[inline]
            fn new(
                topics: <Self::TopicList as alloy_sol_types::SolType>::RustType,
                data: <Self::DataTuple<'_> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                Self {
                    edgeId: topics.1,
                    mutualId: topics.2,
                    originId: topics.3,
                    claimId: data.0,
                    length: data.1,
                    level: data.2,
                    hasRival: data.3,
                    isLayerZero: data.4,
                }
            }
            #[inline]
            fn check_signature(
                topics: &<Self::TopicList as alloy_sol_types::SolType>::RustType,
            ) -> alloy_sol_types::Result<()> {
                if topics.0 != Self::SIGNATURE_HASH {
                    return Err(
                        alloy_sol_types::Error::invalid_event_signature_hash(
                            Self::SIGNATURE,
                            topics.0,
                            Self::SIGNATURE_HASH,
                        ),
                    );
                }
                Ok(())
            }
            #[inline]
            fn tokenize_body(&self) -> Self::DataToken<'_> {
                (
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.claimId),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.length),
                    <alloy::sol_types::sol_data::Uint<
                        8,
                    > as alloy_sol_types::SolType>::tokenize(&self.level),
                    <alloy::sol_types::sol_data::Bool as alloy_sol_types::SolType>::tokenize(
                        &self.hasRival,
                    ),
                    <alloy::sol_types::sol_data::Bool as alloy_sol_types::SolType>::tokenize(
                        &self.isLayerZero,
                    ),
                )
            }
            #[inline]
            fn topics(&self) -> <Self::TopicList as alloy_sol_types::SolType>::RustType {
                (
                    Self::SIGNATURE_HASH.into(),
                    self.edgeId.clone(),
                    self.mutualId.clone(),
                    self.originId.clone(),
                )
            }
            #[inline]
            fn encode_topics_raw(
                &self,
                out: &mut [alloy_sol_types::abi::token::WordToken],
            ) -> alloy_sol_types::Result<()> {
                if out.len() < <Self::TopicList as alloy_sol_types::TopicList>::COUNT {
                    return Err(alloy_sol_types::Error::Overrun);
                }
                out[0usize] = alloy_sol_types::abi::token::WordToken(
                    Self::SIGNATURE_HASH,
                );
                out[1usize] = <alloy::sol_types::sol_data::FixedBytes<
                    32,
                > as alloy_sol_types::EventTopic>::encode_topic(&self.edgeId);
                out[2usize] = <alloy::sol_types::sol_data::FixedBytes<
                    32,
                > as alloy_sol_types::EventTopic>::encode_topic(&self.mutualId);
                out[3usize] = <alloy::sol_types::sol_data::FixedBytes<
                    32,
                > as alloy_sol_types::EventTopic>::encode_topic(&self.originId);
                Ok(())
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::private::IntoLogData for EdgeAdded {
            fn to_log_data(&self) -> alloy_sol_types::private::LogData {
                From::from(self)
            }
            fn into_log_data(self) -> alloy_sol_types::private::LogData {
                From::from(&self)
            }
        }
        #[automatically_derived]
        impl From<&EdgeAdded> for alloy_sol_types::private::LogData {
            #[inline]
            fn from(this: &EdgeAdded) -> alloy_sol_types::private::LogData {
                alloy_sol_types::SolEvent::encode_log_data(this)
            }
        }
    };
    /**Event with signature `EdgeBisected(bytes32,bytes32,bytes32,bool)` and selector `0x7340510d24b7ec9b5c100f5500d93429d80d00d46f0d18e4e85d0c4cc22b9924`.
```solidity
event EdgeBisected(bytes32 indexed edgeId, bytes32 indexed lowerChildId, bytes32 indexed upperChildId, bool lowerChildAlreadyExists);
```*/
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    #[derive(Clone)]
    pub struct EdgeBisected {
        #[allow(missing_docs)]
        pub edgeId: alloy::sol_types::private::FixedBytes<32>,
        #[allow(missing_docs)]
        pub lowerChildId: alloy::sol_types::private::FixedBytes<32>,
        #[allow(missing_docs)]
        pub upperChildId: alloy::sol_types::private::FixedBytes<32>,
        #[allow(missing_docs)]
        pub lowerChildAlreadyExists: bool,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[automatically_derived]
        impl alloy_sol_types::SolEvent for EdgeBisected {
            type DataTuple<'a> = (alloy::sol_types::sol_data::Bool,);
            type DataToken<'a> = <Self::DataTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type TopicList = (
                alloy_sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<32>,
            );
            const SIGNATURE: &'static str = "EdgeBisected(bytes32,bytes32,bytes32,bool)";
            const SIGNATURE_HASH: alloy_sol_types::private::B256 = alloy_sol_types::private::B256::new([
                115u8,
                64u8,
                81u8,
                13u8,
                36u8,
                183u8,
                236u8,
                155u8,
                92u8,
                16u8,
                15u8,
                85u8,
                0u8,
                217u8,
                52u8,
                41u8,
                216u8,
                13u8,
                0u8,
                212u8,
                111u8,
                13u8,
                24u8,
                228u8,
                232u8,
                93u8,
                12u8,
                76u8,
                194u8,
                43u8,
                153u8,
                36u8,
            ]);
            const ANONYMOUS: bool = false;
            #[allow(unused_variables)]
            #[inline]
            fn new(
                topics: <Self::TopicList as alloy_sol_types::SolType>::RustType,
                data: <Self::DataTuple<'_> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                Self {
                    edgeId: topics.1,
                    lowerChildId: topics.2,
                    upperChildId: topics.3,
                    lowerChildAlreadyExists: data.0,
                }
            }
            #[inline]
            fn check_signature(
                topics: &<Self::TopicList as alloy_sol_types::SolType>::RustType,
            ) -> alloy_sol_types::Result<()> {
                if topics.0 != Self::SIGNATURE_HASH {
                    return Err(
                        alloy_sol_types::Error::invalid_event_signature_hash(
                            Self::SIGNATURE,
                            topics.0,
                            Self::SIGNATURE_HASH,
                        ),
                    );
                }
                Ok(())
            }
            #[inline]
            fn tokenize_body(&self) -> Self::DataToken<'_> {
                (
                    <alloy::sol_types::sol_data::Bool as alloy_sol_types::SolType>::tokenize(
                        &self.lowerChildAlreadyExists,
                    ),
                )
            }
            #[inline]
            fn topics(&self) -> <Self::TopicList as alloy_sol_types::SolType>::RustType {
                (
                    Self::SIGNATURE_HASH.into(),
                    self.edgeId.clone(),
                    self.lowerChildId.clone(),
                    self.upperChildId.clone(),
                )
            }
            #[inline]
            fn encode_topics_raw(
                &self,
                out: &mut [alloy_sol_types::abi::token::WordToken],
            ) -> alloy_sol_types::Result<()> {
                if out.len() < <Self::TopicList as alloy_sol_types::TopicList>::COUNT {
                    return Err(alloy_sol_types::Error::Overrun);
                }
                out[0usize] = alloy_sol_types::abi::token::WordToken(
                    Self::SIGNATURE_HASH,
                );
                out[1usize] = <alloy::sol_types::sol_data::FixedBytes<
                    32,
                > as alloy_sol_types::EventTopic>::encode_topic(&self.edgeId);
                out[2usize] = <alloy::sol_types::sol_data::FixedBytes<
                    32,
                > as alloy_sol_types::EventTopic>::encode_topic(&self.lowerChildId);
                out[3usize] = <alloy::sol_types::sol_data::FixedBytes<
                    32,
                > as alloy_sol_types::EventTopic>::encode_topic(&self.upperChildId);
                Ok(())
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::private::IntoLogData for EdgeBisected {
            fn to_log_data(&self) -> alloy_sol_types::private::LogData {
                From::from(self)
            }
            fn into_log_data(self) -> alloy_sol_types::private::LogData {
                From::from(&self)
            }
        }
        #[automatically_derived]
        impl From<&EdgeBisected> for alloy_sol_types::private::LogData {
            #[inline]
            fn from(this: &EdgeBisected) -> alloy_sol_types::private::LogData {
                alloy_sol_types::SolEvent::encode_log_data(this)
            }
        }
    };
    /**Event with signature `EdgeConfirmedByOneStepProof(bytes32,bytes32)` and selector `0xe11db4b27bc8c6ea5943ecbb205ae1ca8d56c42c719717aaf8a53d43d0cee7c2`.
```solidity
event EdgeConfirmedByOneStepProof(bytes32 indexed edgeId, bytes32 indexed mutualId);
```*/
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    #[derive(Clone)]
    pub struct EdgeConfirmedByOneStepProof {
        #[allow(missing_docs)]
        pub edgeId: alloy::sol_types::private::FixedBytes<32>,
        #[allow(missing_docs)]
        pub mutualId: alloy::sol_types::private::FixedBytes<32>,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[automatically_derived]
        impl alloy_sol_types::SolEvent for EdgeConfirmedByOneStepProof {
            type DataTuple<'a> = ();
            type DataToken<'a> = <Self::DataTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type TopicList = (
                alloy_sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<32>,
            );
            const SIGNATURE: &'static str = "EdgeConfirmedByOneStepProof(bytes32,bytes32)";
            const SIGNATURE_HASH: alloy_sol_types::private::B256 = alloy_sol_types::private::B256::new([
                225u8,
                29u8,
                180u8,
                178u8,
                123u8,
                200u8,
                198u8,
                234u8,
                89u8,
                67u8,
                236u8,
                187u8,
                32u8,
                90u8,
                225u8,
                202u8,
                141u8,
                86u8,
                196u8,
                44u8,
                113u8,
                151u8,
                23u8,
                170u8,
                248u8,
                165u8,
                61u8,
                67u8,
                208u8,
                206u8,
                231u8,
                194u8,
            ]);
            const ANONYMOUS: bool = false;
            #[allow(unused_variables)]
            #[inline]
            fn new(
                topics: <Self::TopicList as alloy_sol_types::SolType>::RustType,
                data: <Self::DataTuple<'_> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                Self {
                    edgeId: topics.1,
                    mutualId: topics.2,
                }
            }
            #[inline]
            fn check_signature(
                topics: &<Self::TopicList as alloy_sol_types::SolType>::RustType,
            ) -> alloy_sol_types::Result<()> {
                if topics.0 != Self::SIGNATURE_HASH {
                    return Err(
                        alloy_sol_types::Error::invalid_event_signature_hash(
                            Self::SIGNATURE,
                            topics.0,
                            Self::SIGNATURE_HASH,
                        ),
                    );
                }
                Ok(())
            }
            #[inline]
            fn tokenize_body(&self) -> Self::DataToken<'_> {
                ()
            }
            #[inline]
            fn topics(&self) -> <Self::TopicList as alloy_sol_types::SolType>::RustType {
                (Self::SIGNATURE_HASH.into(), self.edgeId.clone(), self.mutualId.clone())
            }
            #[inline]
            fn encode_topics_raw(
                &self,
                out: &mut [alloy_sol_types::abi::token::WordToken],
            ) -> alloy_sol_types::Result<()> {
                if out.len() < <Self::TopicList as alloy_sol_types::TopicList>::COUNT {
                    return Err(alloy_sol_types::Error::Overrun);
                }
                out[0usize] = alloy_sol_types::abi::token::WordToken(
                    Self::SIGNATURE_HASH,
                );
                out[1usize] = <alloy::sol_types::sol_data::FixedBytes<
                    32,
                > as alloy_sol_types::EventTopic>::encode_topic(&self.edgeId);
                out[2usize] = <alloy::sol_types::sol_data::FixedBytes<
                    32,
                > as alloy_sol_types::EventTopic>::encode_topic(&self.mutualId);
                Ok(())
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::private::IntoLogData for EdgeConfirmedByOneStepProof {
            fn to_log_data(&self) -> alloy_sol_types::private::LogData {
                From::from(self)
            }
            fn into_log_data(self) -> alloy_sol_types::private::LogData {
                From::from(&self)
            }
        }
        #[automatically_derived]
        impl From<&EdgeConfirmedByOneStepProof> for alloy_sol_types::private::LogData {
            #[inline]
            fn from(
                this: &EdgeConfirmedByOneStepProof,
            ) -> alloy_sol_types::private::LogData {
                alloy_sol_types::SolEvent::encode_log_data(this)
            }
        }
    };
    /**Event with signature `EdgeConfirmedByTime(bytes32,bytes32,uint256)` and selector `0x2e0808830a22204cb3fb8f8d784b28bc97e9ce2e39d2f9cde2860de0957d68eb`.
```solidity
event EdgeConfirmedByTime(bytes32 indexed edgeId, bytes32 indexed mutualId, uint256 totalTimeUnrivaled);
```*/
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    #[derive(Clone)]
    pub struct EdgeConfirmedByTime {
        #[allow(missing_docs)]
        pub edgeId: alloy::sol_types::private::FixedBytes<32>,
        #[allow(missing_docs)]
        pub mutualId: alloy::sol_types::private::FixedBytes<32>,
        #[allow(missing_docs)]
        pub totalTimeUnrivaled: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[automatically_derived]
        impl alloy_sol_types::SolEvent for EdgeConfirmedByTime {
            type DataTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type DataToken<'a> = <Self::DataTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type TopicList = (
                alloy_sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<32>,
            );
            const SIGNATURE: &'static str = "EdgeConfirmedByTime(bytes32,bytes32,uint256)";
            const SIGNATURE_HASH: alloy_sol_types::private::B256 = alloy_sol_types::private::B256::new([
                46u8,
                8u8,
                8u8,
                131u8,
                10u8,
                34u8,
                32u8,
                76u8,
                179u8,
                251u8,
                143u8,
                141u8,
                120u8,
                75u8,
                40u8,
                188u8,
                151u8,
                233u8,
                206u8,
                46u8,
                57u8,
                210u8,
                249u8,
                205u8,
                226u8,
                134u8,
                13u8,
                224u8,
                149u8,
                125u8,
                104u8,
                235u8,
            ]);
            const ANONYMOUS: bool = false;
            #[allow(unused_variables)]
            #[inline]
            fn new(
                topics: <Self::TopicList as alloy_sol_types::SolType>::RustType,
                data: <Self::DataTuple<'_> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                Self {
                    edgeId: topics.1,
                    mutualId: topics.2,
                    totalTimeUnrivaled: data.0,
                }
            }
            #[inline]
            fn check_signature(
                topics: &<Self::TopicList as alloy_sol_types::SolType>::RustType,
            ) -> alloy_sol_types::Result<()> {
                if topics.0 != Self::SIGNATURE_HASH {
                    return Err(
                        alloy_sol_types::Error::invalid_event_signature_hash(
                            Self::SIGNATURE,
                            topics.0,
                            Self::SIGNATURE_HASH,
                        ),
                    );
                }
                Ok(())
            }
            #[inline]
            fn tokenize_body(&self) -> Self::DataToken<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.totalTimeUnrivaled),
                )
            }
            #[inline]
            fn topics(&self) -> <Self::TopicList as alloy_sol_types::SolType>::RustType {
                (Self::SIGNATURE_HASH.into(), self.edgeId.clone(), self.mutualId.clone())
            }
            #[inline]
            fn encode_topics_raw(
                &self,
                out: &mut [alloy_sol_types::abi::token::WordToken],
            ) -> alloy_sol_types::Result<()> {
                if out.len() < <Self::TopicList as alloy_sol_types::TopicList>::COUNT {
                    return Err(alloy_sol_types::Error::Overrun);
                }
                out[0usize] = alloy_sol_types::abi::token::WordToken(
                    Self::SIGNATURE_HASH,
                );
                out[1usize] = <alloy::sol_types::sol_data::FixedBytes<
                    32,
                > as alloy_sol_types::EventTopic>::encode_topic(&self.edgeId);
                out[2usize] = <alloy::sol_types::sol_data::FixedBytes<
                    32,
                > as alloy_sol_types::EventTopic>::encode_topic(&self.mutualId);
                Ok(())
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::private::IntoLogData for EdgeConfirmedByTime {
            fn to_log_data(&self) -> alloy_sol_types::private::LogData {
                From::from(self)
            }
            fn into_log_data(self) -> alloy_sol_types::private::LogData {
                From::from(&self)
            }
        }
        #[automatically_derived]
        impl From<&EdgeConfirmedByTime> for alloy_sol_types::private::LogData {
            #[inline]
            fn from(this: &EdgeConfirmedByTime) -> alloy_sol_types::private::LogData {
                alloy_sol_types::SolEvent::encode_log_data(this)
            }
        }
    };
    /**Event with signature `EdgeRefunded(bytes32,bytes32,address,uint256)` and selector `0xa635398959ddb5ce3b14537edfc25b2e671274c9b8cad0f4bd634752e69007b6`.
```solidity
event EdgeRefunded(bytes32 indexed edgeId, bytes32 indexed mutualId, address stakeToken, uint256 stakeAmount);
```*/
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    #[derive(Clone)]
    pub struct EdgeRefunded {
        #[allow(missing_docs)]
        pub edgeId: alloy::sol_types::private::FixedBytes<32>,
        #[allow(missing_docs)]
        pub mutualId: alloy::sol_types::private::FixedBytes<32>,
        #[allow(missing_docs)]
        pub stakeToken: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub stakeAmount: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[automatically_derived]
        impl alloy_sol_types::SolEvent for EdgeRefunded {
            type DataTuple<'a> = (
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Uint<256>,
            );
            type DataToken<'a> = <Self::DataTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type TopicList = (
                alloy_sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<32>,
            );
            const SIGNATURE: &'static str = "EdgeRefunded(bytes32,bytes32,address,uint256)";
            const SIGNATURE_HASH: alloy_sol_types::private::B256 = alloy_sol_types::private::B256::new([
                166u8,
                53u8,
                57u8,
                137u8,
                89u8,
                221u8,
                181u8,
                206u8,
                59u8,
                20u8,
                83u8,
                126u8,
                223u8,
                194u8,
                91u8,
                46u8,
                103u8,
                18u8,
                116u8,
                201u8,
                184u8,
                202u8,
                208u8,
                244u8,
                189u8,
                99u8,
                71u8,
                82u8,
                230u8,
                144u8,
                7u8,
                182u8,
            ]);
            const ANONYMOUS: bool = false;
            #[allow(unused_variables)]
            #[inline]
            fn new(
                topics: <Self::TopicList as alloy_sol_types::SolType>::RustType,
                data: <Self::DataTuple<'_> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                Self {
                    edgeId: topics.1,
                    mutualId: topics.2,
                    stakeToken: data.0,
                    stakeAmount: data.1,
                }
            }
            #[inline]
            fn check_signature(
                topics: &<Self::TopicList as alloy_sol_types::SolType>::RustType,
            ) -> alloy_sol_types::Result<()> {
                if topics.0 != Self::SIGNATURE_HASH {
                    return Err(
                        alloy_sol_types::Error::invalid_event_signature_hash(
                            Self::SIGNATURE,
                            topics.0,
                            Self::SIGNATURE_HASH,
                        ),
                    );
                }
                Ok(())
            }
            #[inline]
            fn tokenize_body(&self) -> Self::DataToken<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.stakeToken,
                    ),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.stakeAmount),
                )
            }
            #[inline]
            fn topics(&self) -> <Self::TopicList as alloy_sol_types::SolType>::RustType {
                (Self::SIGNATURE_HASH.into(), self.edgeId.clone(), self.mutualId.clone())
            }
            #[inline]
            fn encode_topics_raw(
                &self,
                out: &mut [alloy_sol_types::abi::token::WordToken],
            ) -> alloy_sol_types::Result<()> {
                if out.len() < <Self::TopicList as alloy_sol_types::TopicList>::COUNT {
                    return Err(alloy_sol_types::Error::Overrun);
                }
                out[0usize] = alloy_sol_types::abi::token::WordToken(
                    Self::SIGNATURE_HASH,
                );
                out[1usize] = <alloy::sol_types::sol_data::FixedBytes<
                    32,
                > as alloy_sol_types::EventTopic>::encode_topic(&self.edgeId);
                out[2usize] = <alloy::sol_types::sol_data::FixedBytes<
                    32,
                > as alloy_sol_types::EventTopic>::encode_topic(&self.mutualId);
                Ok(())
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::private::IntoLogData for EdgeRefunded {
            fn to_log_data(&self) -> alloy_sol_types::private::LogData {
                From::from(self)
            }
            fn into_log_data(self) -> alloy_sol_types::private::LogData {
                From::from(&self)
            }
        }
        #[automatically_derived]
        impl From<&EdgeRefunded> for alloy_sol_types::private::LogData {
            #[inline]
            fn from(this: &EdgeRefunded) -> alloy_sol_types::private::LogData {
                alloy_sol_types::SolEvent::encode_log_data(this)
            }
        }
    };
    /**Event with signature `Initialized(uint8)` and selector `0x7f26b83ff96e1f2b6a682f133852f6798a09c465da95921460cefb3847402498`.
```solidity
event Initialized(uint8 version);
```*/
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    #[derive(Clone)]
    pub struct Initialized {
        #[allow(missing_docs)]
        pub version: u8,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[automatically_derived]
        impl alloy_sol_types::SolEvent for Initialized {
            type DataTuple<'a> = (alloy::sol_types::sol_data::Uint<8>,);
            type DataToken<'a> = <Self::DataTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type TopicList = (alloy_sol_types::sol_data::FixedBytes<32>,);
            const SIGNATURE: &'static str = "Initialized(uint8)";
            const SIGNATURE_HASH: alloy_sol_types::private::B256 = alloy_sol_types::private::B256::new([
                127u8,
                38u8,
                184u8,
                63u8,
                249u8,
                110u8,
                31u8,
                43u8,
                106u8,
                104u8,
                47u8,
                19u8,
                56u8,
                82u8,
                246u8,
                121u8,
                138u8,
                9u8,
                196u8,
                101u8,
                218u8,
                149u8,
                146u8,
                20u8,
                96u8,
                206u8,
                251u8,
                56u8,
                71u8,
                64u8,
                36u8,
                152u8,
            ]);
            const ANONYMOUS: bool = false;
            #[allow(unused_variables)]
            #[inline]
            fn new(
                topics: <Self::TopicList as alloy_sol_types::SolType>::RustType,
                data: <Self::DataTuple<'_> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                Self { version: data.0 }
            }
            #[inline]
            fn check_signature(
                topics: &<Self::TopicList as alloy_sol_types::SolType>::RustType,
            ) -> alloy_sol_types::Result<()> {
                if topics.0 != Self::SIGNATURE_HASH {
                    return Err(
                        alloy_sol_types::Error::invalid_event_signature_hash(
                            Self::SIGNATURE,
                            topics.0,
                            Self::SIGNATURE_HASH,
                        ),
                    );
                }
                Ok(())
            }
            #[inline]
            fn tokenize_body(&self) -> Self::DataToken<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        8,
                    > as alloy_sol_types::SolType>::tokenize(&self.version),
                )
            }
            #[inline]
            fn topics(&self) -> <Self::TopicList as alloy_sol_types::SolType>::RustType {
                (Self::SIGNATURE_HASH.into(),)
            }
            #[inline]
            fn encode_topics_raw(
                &self,
                out: &mut [alloy_sol_types::abi::token::WordToken],
            ) -> alloy_sol_types::Result<()> {
                if out.len() < <Self::TopicList as alloy_sol_types::TopicList>::COUNT {
                    return Err(alloy_sol_types::Error::Overrun);
                }
                out[0usize] = alloy_sol_types::abi::token::WordToken(
                    Self::SIGNATURE_HASH,
                );
                Ok(())
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::private::IntoLogData for Initialized {
            fn to_log_data(&self) -> alloy_sol_types::private::LogData {
                From::from(self)
            }
            fn into_log_data(self) -> alloy_sol_types::private::LogData {
                From::from(&self)
            }
        }
        #[automatically_derived]
        impl From<&Initialized> for alloy_sol_types::private::LogData {
            #[inline]
            fn from(this: &Initialized) -> alloy_sol_types::private::LogData {
                alloy_sol_types::SolEvent::encode_log_data(this)
            }
        }
    };
    /**Event with signature `TimerCacheUpdated(bytes32,uint256)` and selector `0xbe17755d8d836ad67bfaf8e5b3869aedb4cba03f295a167c5547feddd9ef50ad`.
```solidity
event TimerCacheUpdated(bytes32 indexed edgeId, uint256 newValue);
```*/
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    #[derive(Clone)]
    pub struct TimerCacheUpdated {
        #[allow(missing_docs)]
        pub edgeId: alloy::sol_types::private::FixedBytes<32>,
        #[allow(missing_docs)]
        pub newValue: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[automatically_derived]
        impl alloy_sol_types::SolEvent for TimerCacheUpdated {
            type DataTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type DataToken<'a> = <Self::DataTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type TopicList = (
                alloy_sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<32>,
            );
            const SIGNATURE: &'static str = "TimerCacheUpdated(bytes32,uint256)";
            const SIGNATURE_HASH: alloy_sol_types::private::B256 = alloy_sol_types::private::B256::new([
                190u8,
                23u8,
                117u8,
                93u8,
                141u8,
                131u8,
                106u8,
                214u8,
                123u8,
                250u8,
                248u8,
                229u8,
                179u8,
                134u8,
                154u8,
                237u8,
                180u8,
                203u8,
                160u8,
                63u8,
                41u8,
                90u8,
                22u8,
                124u8,
                85u8,
                71u8,
                254u8,
                221u8,
                217u8,
                239u8,
                80u8,
                173u8,
            ]);
            const ANONYMOUS: bool = false;
            #[allow(unused_variables)]
            #[inline]
            fn new(
                topics: <Self::TopicList as alloy_sol_types::SolType>::RustType,
                data: <Self::DataTuple<'_> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                Self {
                    edgeId: topics.1,
                    newValue: data.0,
                }
            }
            #[inline]
            fn check_signature(
                topics: &<Self::TopicList as alloy_sol_types::SolType>::RustType,
            ) -> alloy_sol_types::Result<()> {
                if topics.0 != Self::SIGNATURE_HASH {
                    return Err(
                        alloy_sol_types::Error::invalid_event_signature_hash(
                            Self::SIGNATURE,
                            topics.0,
                            Self::SIGNATURE_HASH,
                        ),
                    );
                }
                Ok(())
            }
            #[inline]
            fn tokenize_body(&self) -> Self::DataToken<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.newValue),
                )
            }
            #[inline]
            fn topics(&self) -> <Self::TopicList as alloy_sol_types::SolType>::RustType {
                (Self::SIGNATURE_HASH.into(), self.edgeId.clone())
            }
            #[inline]
            fn encode_topics_raw(
                &self,
                out: &mut [alloy_sol_types::abi::token::WordToken],
            ) -> alloy_sol_types::Result<()> {
                if out.len() < <Self::TopicList as alloy_sol_types::TopicList>::COUNT {
                    return Err(alloy_sol_types::Error::Overrun);
                }
                out[0usize] = alloy_sol_types::abi::token::WordToken(
                    Self::SIGNATURE_HASH,
                );
                out[1usize] = <alloy::sol_types::sol_data::FixedBytes<
                    32,
                > as alloy_sol_types::EventTopic>::encode_topic(&self.edgeId);
                Ok(())
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::private::IntoLogData for TimerCacheUpdated {
            fn to_log_data(&self) -> alloy_sol_types::private::LogData {
                From::from(self)
            }
            fn into_log_data(self) -> alloy_sol_types::private::LogData {
                From::from(&self)
            }
        }
        #[automatically_derived]
        impl From<&TimerCacheUpdated> for alloy_sol_types::private::LogData {
            #[inline]
            fn from(this: &TimerCacheUpdated) -> alloy_sol_types::private::LogData {
                alloy_sol_types::SolEvent::encode_log_data(this)
            }
        }
    };
    /**Constructor`.
```solidity
constructor();
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct constructorCall {}
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<constructorCall> for UnderlyingRustTuple<'_> {
                fn from(value: constructorCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for constructorCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolConstructor for constructorCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
        }
    };
    /**Function with signature `LAYERZERO_BIGSTEPEDGE_HEIGHT()` and selector `0x416e6657`.
```solidity
function LAYERZERO_BIGSTEPEDGE_HEIGHT() external view returns (uint256);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct LAYERZERO_BIGSTEPEDGE_HEIGHTCall {}
    ///Container type for the return parameters of the [`LAYERZERO_BIGSTEPEDGE_HEIGHT()`](LAYERZERO_BIGSTEPEDGE_HEIGHTCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct LAYERZERO_BIGSTEPEDGE_HEIGHTReturn {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<LAYERZERO_BIGSTEPEDGE_HEIGHTCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: LAYERZERO_BIGSTEPEDGE_HEIGHTCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for LAYERZERO_BIGSTEPEDGE_HEIGHTCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<LAYERZERO_BIGSTEPEDGE_HEIGHTReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: LAYERZERO_BIGSTEPEDGE_HEIGHTReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for LAYERZERO_BIGSTEPEDGE_HEIGHTReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for LAYERZERO_BIGSTEPEDGE_HEIGHTCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = LAYERZERO_BIGSTEPEDGE_HEIGHTReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "LAYERZERO_BIGSTEPEDGE_HEIGHT()";
            const SELECTOR: [u8; 4] = [65u8, 110u8, 102u8, 87u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `LAYERZERO_BLOCKEDGE_HEIGHT()` and selector `0x1dce5166`.
```solidity
function LAYERZERO_BLOCKEDGE_HEIGHT() external view returns (uint256);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct LAYERZERO_BLOCKEDGE_HEIGHTCall {}
    ///Container type for the return parameters of the [`LAYERZERO_BLOCKEDGE_HEIGHT()`](LAYERZERO_BLOCKEDGE_HEIGHTCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct LAYERZERO_BLOCKEDGE_HEIGHTReturn {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<LAYERZERO_BLOCKEDGE_HEIGHTCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: LAYERZERO_BLOCKEDGE_HEIGHTCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for LAYERZERO_BLOCKEDGE_HEIGHTCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<LAYERZERO_BLOCKEDGE_HEIGHTReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: LAYERZERO_BLOCKEDGE_HEIGHTReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for LAYERZERO_BLOCKEDGE_HEIGHTReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for LAYERZERO_BLOCKEDGE_HEIGHTCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = LAYERZERO_BLOCKEDGE_HEIGHTReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "LAYERZERO_BLOCKEDGE_HEIGHT()";
            const SELECTOR: [u8; 4] = [29u8, 206u8, 81u8, 102u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `LAYERZERO_SMALLSTEPEDGE_HEIGHT()` and selector `0xf8ee77d6`.
```solidity
function LAYERZERO_SMALLSTEPEDGE_HEIGHT() external view returns (uint256);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct LAYERZERO_SMALLSTEPEDGE_HEIGHTCall {}
    ///Container type for the return parameters of the [`LAYERZERO_SMALLSTEPEDGE_HEIGHT()`](LAYERZERO_SMALLSTEPEDGE_HEIGHTCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct LAYERZERO_SMALLSTEPEDGE_HEIGHTReturn {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<LAYERZERO_SMALLSTEPEDGE_HEIGHTCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: LAYERZERO_SMALLSTEPEDGE_HEIGHTCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for LAYERZERO_SMALLSTEPEDGE_HEIGHTCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<LAYERZERO_SMALLSTEPEDGE_HEIGHTReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: LAYERZERO_SMALLSTEPEDGE_HEIGHTReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for LAYERZERO_SMALLSTEPEDGE_HEIGHTReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for LAYERZERO_SMALLSTEPEDGE_HEIGHTCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = LAYERZERO_SMALLSTEPEDGE_HEIGHTReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "LAYERZERO_SMALLSTEPEDGE_HEIGHT()";
            const SELECTOR: [u8; 4] = [248u8, 238u8, 119u8, 214u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `NUM_BIGSTEP_LEVEL()` and selector `0x5d9e2444`.
```solidity
function NUM_BIGSTEP_LEVEL() external view returns (uint8);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct NUM_BIGSTEP_LEVELCall {}
    ///Container type for the return parameters of the [`NUM_BIGSTEP_LEVEL()`](NUM_BIGSTEP_LEVELCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct NUM_BIGSTEP_LEVELReturn {
        #[allow(missing_docs)]
        pub _0: u8,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<NUM_BIGSTEP_LEVELCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: NUM_BIGSTEP_LEVELCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for NUM_BIGSTEP_LEVELCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<8>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (u8,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<NUM_BIGSTEP_LEVELReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: NUM_BIGSTEP_LEVELReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for NUM_BIGSTEP_LEVELReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for NUM_BIGSTEP_LEVELCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = NUM_BIGSTEP_LEVELReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Uint<8>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "NUM_BIGSTEP_LEVEL()";
            const SELECTOR: [u8; 4] = [93u8, 158u8, 36u8, 68u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `assertionChain()` and selector `0x48dd2924`.
```solidity
function assertionChain() external view returns (address);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct assertionChainCall {}
    ///Container type for the return parameters of the [`assertionChain()`](assertionChainCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct assertionChainReturn {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::Address,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<assertionChainCall> for UnderlyingRustTuple<'_> {
                fn from(value: assertionChainCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for assertionChainCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Address,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::Address,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<assertionChainReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: assertionChainReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for assertionChainReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for assertionChainCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = assertionChainReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Address,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "assertionChain()";
            const SELECTOR: [u8; 4] = [72u8, 221u8, 41u8, 36u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `bisectEdge(bytes32,bytes32,bytes)` and selector `0xc8bc4e43`.
```solidity
function bisectEdge(bytes32 edgeId, bytes32 bisectionHistoryRoot, bytes memory prefixProof) external returns (bytes32, bytes32);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct bisectEdgeCall {
        #[allow(missing_docs)]
        pub edgeId: alloy::sol_types::private::FixedBytes<32>,
        #[allow(missing_docs)]
        pub bisectionHistoryRoot: alloy::sol_types::private::FixedBytes<32>,
        #[allow(missing_docs)]
        pub prefixProof: alloy::sol_types::private::Bytes,
    }
    ///Container type for the return parameters of the [`bisectEdge(bytes32,bytes32,bytes)`](bisectEdgeCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct bisectEdgeReturn {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::FixedBytes<32>,
        #[allow(missing_docs)]
        pub _1: alloy::sol_types::private::FixedBytes<32>,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Bytes,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::FixedBytes<32>,
                alloy::sol_types::private::FixedBytes<32>,
                alloy::sol_types::private::Bytes,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<bisectEdgeCall> for UnderlyingRustTuple<'_> {
                fn from(value: bisectEdgeCall) -> Self {
                    (value.edgeId, value.bisectionHistoryRoot, value.prefixProof)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for bisectEdgeCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        edgeId: tuple.0,
                        bisectionHistoryRoot: tuple.1,
                        prefixProof: tuple.2,
                    }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<32>,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::FixedBytes<32>,
                alloy::sol_types::private::FixedBytes<32>,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<bisectEdgeReturn> for UnderlyingRustTuple<'_> {
                fn from(value: bisectEdgeReturn) -> Self {
                    (value._0, value._1)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for bisectEdgeReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0, _1: tuple.1 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for bisectEdgeCall {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Bytes,
            );
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = bisectEdgeReturn;
            type ReturnTuple<'a> = (
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<32>,
            );
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "bisectEdge(bytes32,bytes32,bytes)";
            const SELECTOR: [u8; 4] = [200u8, 188u8, 78u8, 67u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.edgeId),
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.bisectionHistoryRoot),
                    <alloy::sol_types::sol_data::Bytes as alloy_sol_types::SolType>::tokenize(
                        &self.prefixProof,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `calculateEdgeId(uint8,bytes32,uint256,bytes32,uint256,bytes32)` and selector `0x004d8efe`.
```solidity
function calculateEdgeId(uint8 level, bytes32 originId, uint256 startHeight, bytes32 startHistoryRoot, uint256 endHeight, bytes32 endHistoryRoot) external pure returns (bytes32);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct calculateEdgeIdCall {
        #[allow(missing_docs)]
        pub level: u8,
        #[allow(missing_docs)]
        pub originId: alloy::sol_types::private::FixedBytes<32>,
        #[allow(missing_docs)]
        pub startHeight: alloy::sol_types::private::primitives::aliases::U256,
        #[allow(missing_docs)]
        pub startHistoryRoot: alloy::sol_types::private::FixedBytes<32>,
        #[allow(missing_docs)]
        pub endHeight: alloy::sol_types::private::primitives::aliases::U256,
        #[allow(missing_docs)]
        pub endHistoryRoot: alloy::sol_types::private::FixedBytes<32>,
    }
    ///Container type for the return parameters of the [`calculateEdgeId(uint8,bytes32,uint256,bytes32,uint256,bytes32)`](calculateEdgeIdCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct calculateEdgeIdReturn {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::FixedBytes<32>,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::Uint<8>,
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::FixedBytes<32>,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                u8,
                alloy::sol_types::private::FixedBytes<32>,
                alloy::sol_types::private::primitives::aliases::U256,
                alloy::sol_types::private::FixedBytes<32>,
                alloy::sol_types::private::primitives::aliases::U256,
                alloy::sol_types::private::FixedBytes<32>,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<calculateEdgeIdCall> for UnderlyingRustTuple<'_> {
                fn from(value: calculateEdgeIdCall) -> Self {
                    (
                        value.level,
                        value.originId,
                        value.startHeight,
                        value.startHistoryRoot,
                        value.endHeight,
                        value.endHistoryRoot,
                    )
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for calculateEdgeIdCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        level: tuple.0,
                        originId: tuple.1,
                        startHeight: tuple.2,
                        startHistoryRoot: tuple.3,
                        endHeight: tuple.4,
                        endHistoryRoot: tuple.5,
                    }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::FixedBytes<32>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::FixedBytes<32>,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<calculateEdgeIdReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: calculateEdgeIdReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for calculateEdgeIdReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for calculateEdgeIdCall {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::Uint<8>,
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::FixedBytes<32>,
            );
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = calculateEdgeIdReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::FixedBytes<32>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "calculateEdgeId(uint8,bytes32,uint256,bytes32,uint256,bytes32)";
            const SELECTOR: [u8; 4] = [0u8, 77u8, 142u8, 254u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        8,
                    > as alloy_sol_types::SolType>::tokenize(&self.level),
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.originId),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.startHeight),
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.startHistoryRoot),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.endHeight),
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.endHistoryRoot),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `calculateMutualId(uint8,bytes32,uint256,bytes32,uint256)` and selector `0xc32d8c63`.
```solidity
function calculateMutualId(uint8 level, bytes32 originId, uint256 startHeight, bytes32 startHistoryRoot, uint256 endHeight) external pure returns (bytes32);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct calculateMutualIdCall {
        #[allow(missing_docs)]
        pub level: u8,
        #[allow(missing_docs)]
        pub originId: alloy::sol_types::private::FixedBytes<32>,
        #[allow(missing_docs)]
        pub startHeight: alloy::sol_types::private::primitives::aliases::U256,
        #[allow(missing_docs)]
        pub startHistoryRoot: alloy::sol_types::private::FixedBytes<32>,
        #[allow(missing_docs)]
        pub endHeight: alloy::sol_types::private::primitives::aliases::U256,
    }
    ///Container type for the return parameters of the [`calculateMutualId(uint8,bytes32,uint256,bytes32,uint256)`](calculateMutualIdCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct calculateMutualIdReturn {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::FixedBytes<32>,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::Uint<8>,
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Uint<256>,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                u8,
                alloy::sol_types::private::FixedBytes<32>,
                alloy::sol_types::private::primitives::aliases::U256,
                alloy::sol_types::private::FixedBytes<32>,
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<calculateMutualIdCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: calculateMutualIdCall) -> Self {
                    (
                        value.level,
                        value.originId,
                        value.startHeight,
                        value.startHistoryRoot,
                        value.endHeight,
                    )
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for calculateMutualIdCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        level: tuple.0,
                        originId: tuple.1,
                        startHeight: tuple.2,
                        startHistoryRoot: tuple.3,
                        endHeight: tuple.4,
                    }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::FixedBytes<32>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::FixedBytes<32>,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<calculateMutualIdReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: calculateMutualIdReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for calculateMutualIdReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for calculateMutualIdCall {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::Uint<8>,
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Uint<256>,
            );
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = calculateMutualIdReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::FixedBytes<32>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "calculateMutualId(uint8,bytes32,uint256,bytes32,uint256)";
            const SELECTOR: [u8; 4] = [195u8, 45u8, 140u8, 99u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        8,
                    > as alloy_sol_types::SolType>::tokenize(&self.level),
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.originId),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.startHeight),
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.startHistoryRoot),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.endHeight),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `challengePeriodBlocks()` and selector `0x46c2781a`.
```solidity
function challengePeriodBlocks() external view returns (uint64);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct challengePeriodBlocksCall {}
    ///Container type for the return parameters of the [`challengePeriodBlocks()`](challengePeriodBlocksCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct challengePeriodBlocksReturn {
        #[allow(missing_docs)]
        pub _0: u64,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<challengePeriodBlocksCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: challengePeriodBlocksCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for challengePeriodBlocksCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<64>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (u64,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<challengePeriodBlocksReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: challengePeriodBlocksReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for challengePeriodBlocksReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for challengePeriodBlocksCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = challengePeriodBlocksReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Uint<64>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "challengePeriodBlocks()";
            const SELECTOR: [u8; 4] = [70u8, 194u8, 120u8, 26u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `confirmEdgeByOneStepProof(bytes32,(bytes32,bytes),(bytes32,uint256,address,uint64,uint64),bytes32[],bytes32[])` and selector `0x8c1b3a40`.
```solidity
function confirmEdgeByOneStepProof(bytes32 edgeId, OneStepData memory oneStepData, ConfigData memory prevConfig, bytes32[] memory beforeHistoryInclusionProof, bytes32[] memory afterHistoryInclusionProof) external;
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct confirmEdgeByOneStepProofCall {
        #[allow(missing_docs)]
        pub edgeId: alloy::sol_types::private::FixedBytes<32>,
        #[allow(missing_docs)]
        pub oneStepData: <OneStepData as alloy::sol_types::SolType>::RustType,
        #[allow(missing_docs)]
        pub prevConfig: <ConfigData as alloy::sol_types::SolType>::RustType,
        #[allow(missing_docs)]
        pub beforeHistoryInclusionProof: alloy::sol_types::private::Vec<
            alloy::sol_types::private::FixedBytes<32>,
        >,
        #[allow(missing_docs)]
        pub afterHistoryInclusionProof: alloy::sol_types::private::Vec<
            alloy::sol_types::private::FixedBytes<32>,
        >,
    }
    ///Container type for the return parameters of the [`confirmEdgeByOneStepProof(bytes32,(bytes32,bytes),(bytes32,uint256,address,uint64,uint64),bytes32[],bytes32[])`](confirmEdgeByOneStepProofCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct confirmEdgeByOneStepProofReturn {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::FixedBytes<32>,
                OneStepData,
                ConfigData,
                alloy::sol_types::sol_data::Array<
                    alloy::sol_types::sol_data::FixedBytes<32>,
                >,
                alloy::sol_types::sol_data::Array<
                    alloy::sol_types::sol_data::FixedBytes<32>,
                >,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::FixedBytes<32>,
                <OneStepData as alloy::sol_types::SolType>::RustType,
                <ConfigData as alloy::sol_types::SolType>::RustType,
                alloy::sol_types::private::Vec<
                    alloy::sol_types::private::FixedBytes<32>,
                >,
                alloy::sol_types::private::Vec<alloy::sol_types::private::FixedBytes<32>>,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<confirmEdgeByOneStepProofCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: confirmEdgeByOneStepProofCall) -> Self {
                    (
                        value.edgeId,
                        value.oneStepData,
                        value.prevConfig,
                        value.beforeHistoryInclusionProof,
                        value.afterHistoryInclusionProof,
                    )
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for confirmEdgeByOneStepProofCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        edgeId: tuple.0,
                        oneStepData: tuple.1,
                        prevConfig: tuple.2,
                        beforeHistoryInclusionProof: tuple.3,
                        afterHistoryInclusionProof: tuple.4,
                    }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<confirmEdgeByOneStepProofReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: confirmEdgeByOneStepProofReturn) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for confirmEdgeByOneStepProofReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for confirmEdgeByOneStepProofCall {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::FixedBytes<32>,
                OneStepData,
                ConfigData,
                alloy::sol_types::sol_data::Array<
                    alloy::sol_types::sol_data::FixedBytes<32>,
                >,
                alloy::sol_types::sol_data::Array<
                    alloy::sol_types::sol_data::FixedBytes<32>,
                >,
            );
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = confirmEdgeByOneStepProofReturn;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "confirmEdgeByOneStepProof(bytes32,(bytes32,bytes),(bytes32,uint256,address,uint64,uint64),bytes32[],bytes32[])";
            const SELECTOR: [u8; 4] = [140u8, 27u8, 58u8, 64u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.edgeId),
                    <OneStepData as alloy_sol_types::SolType>::tokenize(
                        &self.oneStepData,
                    ),
                    <ConfigData as alloy_sol_types::SolType>::tokenize(&self.prevConfig),
                    <alloy::sol_types::sol_data::Array<
                        alloy::sol_types::sol_data::FixedBytes<32>,
                    > as alloy_sol_types::SolType>::tokenize(
                        &self.beforeHistoryInclusionProof,
                    ),
                    <alloy::sol_types::sol_data::Array<
                        alloy::sol_types::sol_data::FixedBytes<32>,
                    > as alloy_sol_types::SolType>::tokenize(
                        &self.afterHistoryInclusionProof,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `confirmEdgeByTime(bytes32,(((bytes32[2],uint64[2]),uint8,bytes32),bytes32,bytes32))` and selector `0xb2a1408e`.
```solidity
function confirmEdgeByTime(bytes32 edgeId, AssertionStateData memory claimStateData) external;
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct confirmEdgeByTimeCall {
        #[allow(missing_docs)]
        pub edgeId: alloy::sol_types::private::FixedBytes<32>,
        #[allow(missing_docs)]
        pub claimStateData: <AssertionStateData as alloy::sol_types::SolType>::RustType,
    }
    ///Container type for the return parameters of the [`confirmEdgeByTime(bytes32,(((bytes32[2],uint64[2]),uint8,bytes32),bytes32,bytes32))`](confirmEdgeByTimeCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct confirmEdgeByTimeReturn {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::FixedBytes<32>,
                AssertionStateData,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::FixedBytes<32>,
                <AssertionStateData as alloy::sol_types::SolType>::RustType,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<confirmEdgeByTimeCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: confirmEdgeByTimeCall) -> Self {
                    (value.edgeId, value.claimStateData)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for confirmEdgeByTimeCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        edgeId: tuple.0,
                        claimStateData: tuple.1,
                    }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<confirmEdgeByTimeReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: confirmEdgeByTimeReturn) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for confirmEdgeByTimeReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for confirmEdgeByTimeCall {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::FixedBytes<32>,
                AssertionStateData,
            );
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = confirmEdgeByTimeReturn;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "confirmEdgeByTime(bytes32,(((bytes32[2],uint64[2]),uint8,bytes32),bytes32,bytes32))";
            const SELECTOR: [u8; 4] = [178u8, 161u8, 64u8, 142u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.edgeId),
                    <AssertionStateData as alloy_sol_types::SolType>::tokenize(
                        &self.claimStateData,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `confirmedRival(bytes32)` and selector `0xe5b123da`.
```solidity
function confirmedRival(bytes32 mutualId) external view returns (bytes32);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct confirmedRivalCall {
        #[allow(missing_docs)]
        pub mutualId: alloy::sol_types::private::FixedBytes<32>,
    }
    ///Container type for the return parameters of the [`confirmedRival(bytes32)`](confirmedRivalCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct confirmedRivalReturn {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::FixedBytes<32>,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::FixedBytes<32>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::FixedBytes<32>,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<confirmedRivalCall> for UnderlyingRustTuple<'_> {
                fn from(value: confirmedRivalCall) -> Self {
                    (value.mutualId,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for confirmedRivalCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { mutualId: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::FixedBytes<32>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::FixedBytes<32>,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<confirmedRivalReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: confirmedRivalReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for confirmedRivalReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for confirmedRivalCall {
            type Parameters<'a> = (alloy::sol_types::sol_data::FixedBytes<32>,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = confirmedRivalReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::FixedBytes<32>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "confirmedRival(bytes32)";
            const SELECTOR: [u8; 4] = [229u8, 177u8, 35u8, 218u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.mutualId),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `createLayerZeroEdge((uint8,bytes32,uint256,bytes32,bytes,bytes))` and selector `0x05fae141`.
```solidity
function createLayerZeroEdge(CreateEdgeArgs memory args) external returns (bytes32);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct createLayerZeroEdgeCall {
        #[allow(missing_docs)]
        pub args: <CreateEdgeArgs as alloy::sol_types::SolType>::RustType,
    }
    ///Container type for the return parameters of the [`createLayerZeroEdge((uint8,bytes32,uint256,bytes32,bytes,bytes))`](createLayerZeroEdgeCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct createLayerZeroEdgeReturn {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::FixedBytes<32>,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (CreateEdgeArgs,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                <CreateEdgeArgs as alloy::sol_types::SolType>::RustType,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<createLayerZeroEdgeCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: createLayerZeroEdgeCall) -> Self {
                    (value.args,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for createLayerZeroEdgeCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { args: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::FixedBytes<32>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::FixedBytes<32>,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<createLayerZeroEdgeReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: createLayerZeroEdgeReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for createLayerZeroEdgeReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for createLayerZeroEdgeCall {
            type Parameters<'a> = (CreateEdgeArgs,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = createLayerZeroEdgeReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::FixedBytes<32>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "createLayerZeroEdge((uint8,bytes32,uint256,bytes32,bytes,bytes))";
            const SELECTOR: [u8; 4] = [5u8, 250u8, 225u8, 65u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (<CreateEdgeArgs as alloy_sol_types::SolType>::tokenize(&self.args),)
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `edgeExists(bytes32)` and selector `0x750e0c0f`.
```solidity
function edgeExists(bytes32 edgeId) external view returns (bool);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct edgeExistsCall {
        #[allow(missing_docs)]
        pub edgeId: alloy::sol_types::private::FixedBytes<32>,
    }
    ///Container type for the return parameters of the [`edgeExists(bytes32)`](edgeExistsCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct edgeExistsReturn {
        #[allow(missing_docs)]
        pub _0: bool,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::FixedBytes<32>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::FixedBytes<32>,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<edgeExistsCall> for UnderlyingRustTuple<'_> {
                fn from(value: edgeExistsCall) -> Self {
                    (value.edgeId,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for edgeExistsCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { edgeId: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Bool,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (bool,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<edgeExistsReturn> for UnderlyingRustTuple<'_> {
                fn from(value: edgeExistsReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for edgeExistsReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for edgeExistsCall {
            type Parameters<'a> = (alloy::sol_types::sol_data::FixedBytes<32>,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = edgeExistsReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Bool,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "edgeExists(bytes32)";
            const SELECTOR: [u8; 4] = [117u8, 14u8, 12u8, 15u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.edgeId),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `edgeLength(bytes32)` and selector `0xeae0328b`.
```solidity
function edgeLength(bytes32 edgeId) external view returns (uint256);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct edgeLengthCall {
        #[allow(missing_docs)]
        pub edgeId: alloy::sol_types::private::FixedBytes<32>,
    }
    ///Container type for the return parameters of the [`edgeLength(bytes32)`](edgeLengthCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct edgeLengthReturn {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::FixedBytes<32>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::FixedBytes<32>,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<edgeLengthCall> for UnderlyingRustTuple<'_> {
                fn from(value: edgeLengthCall) -> Self {
                    (value.edgeId,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for edgeLengthCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { edgeId: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<edgeLengthReturn> for UnderlyingRustTuple<'_> {
                fn from(value: edgeLengthReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for edgeLengthReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for edgeLengthCall {
            type Parameters<'a> = (alloy::sol_types::sol_data::FixedBytes<32>,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = edgeLengthReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "edgeLength(bytes32)";
            const SELECTOR: [u8; 4] = [234u8, 224u8, 50u8, 139u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.edgeId),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `excessStakeReceiver()` and selector `0xe94e051e`.
```solidity
function excessStakeReceiver() external view returns (address);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct excessStakeReceiverCall {}
    ///Container type for the return parameters of the [`excessStakeReceiver()`](excessStakeReceiverCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct excessStakeReceiverReturn {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::Address,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<excessStakeReceiverCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: excessStakeReceiverCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for excessStakeReceiverCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Address,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::Address,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<excessStakeReceiverReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: excessStakeReceiverReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for excessStakeReceiverReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for excessStakeReceiverCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = excessStakeReceiverReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Address,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "excessStakeReceiver()";
            const SELECTOR: [u8; 4] = [233u8, 78u8, 5u8, 30u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `firstRival(bytes32)` and selector `0xbce6f54f`.
```solidity
function firstRival(bytes32 mutualId) external view returns (bytes32);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct firstRivalCall {
        #[allow(missing_docs)]
        pub mutualId: alloy::sol_types::private::FixedBytes<32>,
    }
    ///Container type for the return parameters of the [`firstRival(bytes32)`](firstRivalCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct firstRivalReturn {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::FixedBytes<32>,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::FixedBytes<32>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::FixedBytes<32>,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<firstRivalCall> for UnderlyingRustTuple<'_> {
                fn from(value: firstRivalCall) -> Self {
                    (value.mutualId,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for firstRivalCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { mutualId: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::FixedBytes<32>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::FixedBytes<32>,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<firstRivalReturn> for UnderlyingRustTuple<'_> {
                fn from(value: firstRivalReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for firstRivalReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for firstRivalCall {
            type Parameters<'a> = (alloy::sol_types::sol_data::FixedBytes<32>,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = firstRivalReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::FixedBytes<32>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "firstRival(bytes32)";
            const SELECTOR: [u8; 4] = [188u8, 230u8, 245u8, 79u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.mutualId),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `getEdge(bytes32)` and selector `0xfda2892e`.
```solidity
function getEdge(bytes32 edgeId) external view returns (ChallengeEdge memory);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct getEdgeCall {
        #[allow(missing_docs)]
        pub edgeId: alloy::sol_types::private::FixedBytes<32>,
    }
    ///Container type for the return parameters of the [`getEdge(bytes32)`](getEdgeCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct getEdgeReturn {
        #[allow(missing_docs)]
        pub _0: <ChallengeEdge as alloy::sol_types::SolType>::RustType,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::FixedBytes<32>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::FixedBytes<32>,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<getEdgeCall> for UnderlyingRustTuple<'_> {
                fn from(value: getEdgeCall) -> Self {
                    (value.edgeId,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for getEdgeCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { edgeId: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (ChallengeEdge,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                <ChallengeEdge as alloy::sol_types::SolType>::RustType,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<getEdgeReturn> for UnderlyingRustTuple<'_> {
                fn from(value: getEdgeReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for getEdgeReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for getEdgeCall {
            type Parameters<'a> = (alloy::sol_types::sol_data::FixedBytes<32>,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = getEdgeReturn;
            type ReturnTuple<'a> = (ChallengeEdge,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "getEdge(bytes32)";
            const SELECTOR: [u8; 4] = [253u8, 162u8, 137u8, 46u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.edgeId),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `getLayerZeroEndHeight(uint8)` and selector `0x42e1aaa8`.
```solidity
function getLayerZeroEndHeight(EdgeType eType) external view returns (uint256);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct getLayerZeroEndHeightCall {
        #[allow(missing_docs)]
        pub eType: <EdgeType as alloy::sol_types::SolType>::RustType,
    }
    ///Container type for the return parameters of the [`getLayerZeroEndHeight(uint8)`](getLayerZeroEndHeightCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct getLayerZeroEndHeightReturn {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (EdgeType,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                <EdgeType as alloy::sol_types::SolType>::RustType,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<getLayerZeroEndHeightCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: getLayerZeroEndHeightCall) -> Self {
                    (value.eType,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for getLayerZeroEndHeightCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { eType: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<getLayerZeroEndHeightReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: getLayerZeroEndHeightReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for getLayerZeroEndHeightReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for getLayerZeroEndHeightCall {
            type Parameters<'a> = (EdgeType,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = getLayerZeroEndHeightReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "getLayerZeroEndHeight(uint8)";
            const SELECTOR: [u8; 4] = [66u8, 225u8, 170u8, 168u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (<EdgeType as alloy_sol_types::SolType>::tokenize(&self.eType),)
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `getPrevAssertionHash(bytes32)` and selector `0x5a48e0f4`.
```solidity
function getPrevAssertionHash(bytes32 edgeId) external view returns (bytes32);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct getPrevAssertionHashCall {
        #[allow(missing_docs)]
        pub edgeId: alloy::sol_types::private::FixedBytes<32>,
    }
    ///Container type for the return parameters of the [`getPrevAssertionHash(bytes32)`](getPrevAssertionHashCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct getPrevAssertionHashReturn {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::FixedBytes<32>,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::FixedBytes<32>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::FixedBytes<32>,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<getPrevAssertionHashCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: getPrevAssertionHashCall) -> Self {
                    (value.edgeId,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for getPrevAssertionHashCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { edgeId: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::FixedBytes<32>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::FixedBytes<32>,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<getPrevAssertionHashReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: getPrevAssertionHashReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for getPrevAssertionHashReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for getPrevAssertionHashCall {
            type Parameters<'a> = (alloy::sol_types::sol_data::FixedBytes<32>,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = getPrevAssertionHashReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::FixedBytes<32>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "getPrevAssertionHash(bytes32)";
            const SELECTOR: [u8; 4] = [90u8, 72u8, 224u8, 244u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.edgeId),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `hasLengthOneRival(bytes32)` and selector `0x54b64151`.
```solidity
function hasLengthOneRival(bytes32 edgeId) external view returns (bool);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct hasLengthOneRivalCall {
        #[allow(missing_docs)]
        pub edgeId: alloy::sol_types::private::FixedBytes<32>,
    }
    ///Container type for the return parameters of the [`hasLengthOneRival(bytes32)`](hasLengthOneRivalCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct hasLengthOneRivalReturn {
        #[allow(missing_docs)]
        pub _0: bool,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::FixedBytes<32>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::FixedBytes<32>,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<hasLengthOneRivalCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: hasLengthOneRivalCall) -> Self {
                    (value.edgeId,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for hasLengthOneRivalCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { edgeId: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Bool,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (bool,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<hasLengthOneRivalReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: hasLengthOneRivalReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for hasLengthOneRivalReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for hasLengthOneRivalCall {
            type Parameters<'a> = (alloy::sol_types::sol_data::FixedBytes<32>,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = hasLengthOneRivalReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Bool,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "hasLengthOneRival(bytes32)";
            const SELECTOR: [u8; 4] = [84u8, 182u8, 65u8, 81u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.edgeId),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `hasMadeLayerZeroRival(address,bytes32)` and selector `0x655b42f3`.
```solidity
function hasMadeLayerZeroRival(address account, bytes32 mutualId) external view returns (bool);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct hasMadeLayerZeroRivalCall {
        #[allow(missing_docs)]
        pub account: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub mutualId: alloy::sol_types::private::FixedBytes<32>,
    }
    ///Container type for the return parameters of the [`hasMadeLayerZeroRival(address,bytes32)`](hasMadeLayerZeroRivalCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct hasMadeLayerZeroRivalReturn {
        #[allow(missing_docs)]
        pub _0: bool,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::FixedBytes<32>,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::Address,
                alloy::sol_types::private::FixedBytes<32>,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<hasMadeLayerZeroRivalCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: hasMadeLayerZeroRivalCall) -> Self {
                    (value.account, value.mutualId)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for hasMadeLayerZeroRivalCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        account: tuple.0,
                        mutualId: tuple.1,
                    }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Bool,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (bool,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<hasMadeLayerZeroRivalReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: hasMadeLayerZeroRivalReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for hasMadeLayerZeroRivalReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for hasMadeLayerZeroRivalCall {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::FixedBytes<32>,
            );
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = hasMadeLayerZeroRivalReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Bool,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "hasMadeLayerZeroRival(address,bytes32)";
            const SELECTOR: [u8; 4] = [101u8, 91u8, 66u8, 243u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.account,
                    ),
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.mutualId),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `hasRival(bytes32)` and selector `0x908517e9`.
```solidity
function hasRival(bytes32 edgeId) external view returns (bool);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct hasRivalCall {
        #[allow(missing_docs)]
        pub edgeId: alloy::sol_types::private::FixedBytes<32>,
    }
    ///Container type for the return parameters of the [`hasRival(bytes32)`](hasRivalCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct hasRivalReturn {
        #[allow(missing_docs)]
        pub _0: bool,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::FixedBytes<32>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::FixedBytes<32>,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<hasRivalCall> for UnderlyingRustTuple<'_> {
                fn from(value: hasRivalCall) -> Self {
                    (value.edgeId,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for hasRivalCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { edgeId: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Bool,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (bool,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<hasRivalReturn> for UnderlyingRustTuple<'_> {
                fn from(value: hasRivalReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for hasRivalReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for hasRivalCall {
            type Parameters<'a> = (alloy::sol_types::sol_data::FixedBytes<32>,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = hasRivalReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Bool,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "hasRival(bytes32)";
            const SELECTOR: [u8; 4] = [144u8, 133u8, 23u8, 233u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.edgeId),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `initialize(address,uint64,address,uint256,uint256,uint256,address,address,uint8,uint256[])` and selector `0x1a72d54c`.
```solidity
function initialize(address _assertionChain, uint64 _challengePeriodBlocks, address _oneStepProofEntry, uint256 layerZeroBlockEdgeHeight, uint256 layerZeroBigStepEdgeHeight, uint256 layerZeroSmallStepEdgeHeight, address _stakeToken, address _excessStakeReceiver, uint8 _numBigStepLevel, uint256[] memory _stakeAmounts) external;
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct initializeCall {
        #[allow(missing_docs)]
        pub _assertionChain: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub _challengePeriodBlocks: u64,
        #[allow(missing_docs)]
        pub _oneStepProofEntry: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub layerZeroBlockEdgeHeight: alloy::sol_types::private::primitives::aliases::U256,
        #[allow(missing_docs)]
        pub layerZeroBigStepEdgeHeight: alloy::sol_types::private::primitives::aliases::U256,
        #[allow(missing_docs)]
        pub layerZeroSmallStepEdgeHeight: alloy::sol_types::private::primitives::aliases::U256,
        #[allow(missing_docs)]
        pub _stakeToken: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub _excessStakeReceiver: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub _numBigStepLevel: u8,
        #[allow(missing_docs)]
        pub _stakeAmounts: alloy::sol_types::private::Vec<
            alloy::sol_types::private::primitives::aliases::U256,
        >,
    }
    ///Container type for the return parameters of the [`initialize(address,uint64,address,uint256,uint256,uint256,address,address,uint8,uint256[])`](initializeCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct initializeReturn {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Uint<64>,
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Uint<8>,
                alloy::sol_types::sol_data::Array<alloy::sol_types::sol_data::Uint<256>>,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::Address,
                u64,
                alloy::sol_types::private::Address,
                alloy::sol_types::private::primitives::aliases::U256,
                alloy::sol_types::private::primitives::aliases::U256,
                alloy::sol_types::private::primitives::aliases::U256,
                alloy::sol_types::private::Address,
                alloy::sol_types::private::Address,
                u8,
                alloy::sol_types::private::Vec<
                    alloy::sol_types::private::primitives::aliases::U256,
                >,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<initializeCall> for UnderlyingRustTuple<'_> {
                fn from(value: initializeCall) -> Self {
                    (
                        value._assertionChain,
                        value._challengePeriodBlocks,
                        value._oneStepProofEntry,
                        value.layerZeroBlockEdgeHeight,
                        value.layerZeroBigStepEdgeHeight,
                        value.layerZeroSmallStepEdgeHeight,
                        value._stakeToken,
                        value._excessStakeReceiver,
                        value._numBigStepLevel,
                        value._stakeAmounts,
                    )
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for initializeCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        _assertionChain: tuple.0,
                        _challengePeriodBlocks: tuple.1,
                        _oneStepProofEntry: tuple.2,
                        layerZeroBlockEdgeHeight: tuple.3,
                        layerZeroBigStepEdgeHeight: tuple.4,
                        layerZeroSmallStepEdgeHeight: tuple.5,
                        _stakeToken: tuple.6,
                        _excessStakeReceiver: tuple.7,
                        _numBigStepLevel: tuple.8,
                        _stakeAmounts: tuple.9,
                    }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<initializeReturn> for UnderlyingRustTuple<'_> {
                fn from(value: initializeReturn) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for initializeReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for initializeCall {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Uint<64>,
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Uint<8>,
                alloy::sol_types::sol_data::Array<alloy::sol_types::sol_data::Uint<256>>,
            );
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = initializeReturn;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "initialize(address,uint64,address,uint256,uint256,uint256,address,address,uint8,uint256[])";
            const SELECTOR: [u8; 4] = [26u8, 114u8, 213u8, 76u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self._assertionChain,
                    ),
                    <alloy::sol_types::sol_data::Uint<
                        64,
                    > as alloy_sol_types::SolType>::tokenize(
                        &self._challengePeriodBlocks,
                    ),
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self._oneStepProofEntry,
                    ),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(
                        &self.layerZeroBlockEdgeHeight,
                    ),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(
                        &self.layerZeroBigStepEdgeHeight,
                    ),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(
                        &self.layerZeroSmallStepEdgeHeight,
                    ),
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self._stakeToken,
                    ),
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self._excessStakeReceiver,
                    ),
                    <alloy::sol_types::sol_data::Uint<
                        8,
                    > as alloy_sol_types::SolType>::tokenize(&self._numBigStepLevel),
                    <alloy::sol_types::sol_data::Array<
                        alloy::sol_types::sol_data::Uint<256>,
                    > as alloy_sol_types::SolType>::tokenize(&self._stakeAmounts),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `multiUpdateTimeCacheByChildren(bytes32[],uint256)` and selector `0x432bb78a`.
```solidity
function multiUpdateTimeCacheByChildren(bytes32[] memory edgeIds, uint256 maximumCachedTime) external;
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct multiUpdateTimeCacheByChildrenCall {
        #[allow(missing_docs)]
        pub edgeIds: alloy::sol_types::private::Vec<
            alloy::sol_types::private::FixedBytes<32>,
        >,
        #[allow(missing_docs)]
        pub maximumCachedTime: alloy::sol_types::private::primitives::aliases::U256,
    }
    ///Container type for the return parameters of the [`multiUpdateTimeCacheByChildren(bytes32[],uint256)`](multiUpdateTimeCacheByChildrenCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct multiUpdateTimeCacheByChildrenReturn {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::Array<
                    alloy::sol_types::sol_data::FixedBytes<32>,
                >,
                alloy::sol_types::sol_data::Uint<256>,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::Vec<
                    alloy::sol_types::private::FixedBytes<32>,
                >,
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<multiUpdateTimeCacheByChildrenCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: multiUpdateTimeCacheByChildrenCall) -> Self {
                    (value.edgeIds, value.maximumCachedTime)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for multiUpdateTimeCacheByChildrenCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        edgeIds: tuple.0,
                        maximumCachedTime: tuple.1,
                    }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<multiUpdateTimeCacheByChildrenReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: multiUpdateTimeCacheByChildrenReturn) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for multiUpdateTimeCacheByChildrenReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for multiUpdateTimeCacheByChildrenCall {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::Array<
                    alloy::sol_types::sol_data::FixedBytes<32>,
                >,
                alloy::sol_types::sol_data::Uint<256>,
            );
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = multiUpdateTimeCacheByChildrenReturn;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "multiUpdateTimeCacheByChildren(bytes32[],uint256)";
            const SELECTOR: [u8; 4] = [67u8, 43u8, 183u8, 138u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Array<
                        alloy::sol_types::sol_data::FixedBytes<32>,
                    > as alloy_sol_types::SolType>::tokenize(&self.edgeIds),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.maximumCachedTime),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `oneStepProofEntry()` and selector `0x48923bc5`.
```solidity
function oneStepProofEntry() external view returns (address);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct oneStepProofEntryCall {}
    ///Container type for the return parameters of the [`oneStepProofEntry()`](oneStepProofEntryCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct oneStepProofEntryReturn {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::Address,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<oneStepProofEntryCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: oneStepProofEntryCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for oneStepProofEntryCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Address,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::Address,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<oneStepProofEntryReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: oneStepProofEntryReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for oneStepProofEntryReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for oneStepProofEntryCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = oneStepProofEntryReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Address,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "oneStepProofEntry()";
            const SELECTOR: [u8; 4] = [72u8, 146u8, 59u8, 197u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `refundStake(bytes32)` and selector `0x748926f3`.
```solidity
function refundStake(bytes32 edgeId) external;
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct refundStakeCall {
        #[allow(missing_docs)]
        pub edgeId: alloy::sol_types::private::FixedBytes<32>,
    }
    ///Container type for the return parameters of the [`refundStake(bytes32)`](refundStakeCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct refundStakeReturn {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::FixedBytes<32>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::FixedBytes<32>,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<refundStakeCall> for UnderlyingRustTuple<'_> {
                fn from(value: refundStakeCall) -> Self {
                    (value.edgeId,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for refundStakeCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { edgeId: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<refundStakeReturn> for UnderlyingRustTuple<'_> {
                fn from(value: refundStakeReturn) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for refundStakeReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for refundStakeCall {
            type Parameters<'a> = (alloy::sol_types::sol_data::FixedBytes<32>,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = refundStakeReturn;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "refundStake(bytes32)";
            const SELECTOR: [u8; 4] = [116u8, 137u8, 38u8, 243u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.edgeId),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `stakeAmounts(uint256)` and selector `0x1c1b4f3a`.
```solidity
function stakeAmounts(uint256) external view returns (uint256);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct stakeAmountsCall {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::primitives::aliases::U256,
    }
    ///Container type for the return parameters of the [`stakeAmounts(uint256)`](stakeAmountsCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct stakeAmountsReturn {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<stakeAmountsCall> for UnderlyingRustTuple<'_> {
                fn from(value: stakeAmountsCall) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for stakeAmountsCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<stakeAmountsReturn> for UnderlyingRustTuple<'_> {
                fn from(value: stakeAmountsReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for stakeAmountsReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for stakeAmountsCall {
            type Parameters<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = stakeAmountsReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "stakeAmounts(uint256)";
            const SELECTOR: [u8; 4] = [28u8, 27u8, 79u8, 58u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self._0),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `stakeToken()` and selector `0x51ed6a30`.
```solidity
function stakeToken() external view returns (address);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct stakeTokenCall {}
    ///Container type for the return parameters of the [`stakeToken()`](stakeTokenCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct stakeTokenReturn {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::Address,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<stakeTokenCall> for UnderlyingRustTuple<'_> {
                fn from(value: stakeTokenCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for stakeTokenCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Address,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::Address,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<stakeTokenReturn> for UnderlyingRustTuple<'_> {
                fn from(value: stakeTokenReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for stakeTokenReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for stakeTokenCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = stakeTokenReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Address,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "stakeToken()";
            const SELECTOR: [u8; 4] = [81u8, 237u8, 106u8, 48u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `timeUnrivaled(bytes32)` and selector `0x3e35f5e8`.
```solidity
function timeUnrivaled(bytes32 edgeId) external view returns (uint256);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct timeUnrivaledCall {
        #[allow(missing_docs)]
        pub edgeId: alloy::sol_types::private::FixedBytes<32>,
    }
    ///Container type for the return parameters of the [`timeUnrivaled(bytes32)`](timeUnrivaledCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct timeUnrivaledReturn {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::FixedBytes<32>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::FixedBytes<32>,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<timeUnrivaledCall> for UnderlyingRustTuple<'_> {
                fn from(value: timeUnrivaledCall) -> Self {
                    (value.edgeId,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for timeUnrivaledCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { edgeId: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<timeUnrivaledReturn> for UnderlyingRustTuple<'_> {
                fn from(value: timeUnrivaledReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for timeUnrivaledReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for timeUnrivaledCall {
            type Parameters<'a> = (alloy::sol_types::sol_data::FixedBytes<32>,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = timeUnrivaledReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "timeUnrivaled(bytes32)";
            const SELECTOR: [u8; 4] = [62u8, 53u8, 245u8, 232u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.edgeId),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `updateTimerCacheByChildren(bytes32,uint256)` and selector `0xedaab54a`.
```solidity
function updateTimerCacheByChildren(bytes32 edgeId, uint256 maximumCachedTime) external;
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct updateTimerCacheByChildrenCall {
        #[allow(missing_docs)]
        pub edgeId: alloy::sol_types::private::FixedBytes<32>,
        #[allow(missing_docs)]
        pub maximumCachedTime: alloy::sol_types::private::primitives::aliases::U256,
    }
    ///Container type for the return parameters of the [`updateTimerCacheByChildren(bytes32,uint256)`](updateTimerCacheByChildrenCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct updateTimerCacheByChildrenReturn {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Uint<256>,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::FixedBytes<32>,
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<updateTimerCacheByChildrenCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: updateTimerCacheByChildrenCall) -> Self {
                    (value.edgeId, value.maximumCachedTime)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for updateTimerCacheByChildrenCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        edgeId: tuple.0,
                        maximumCachedTime: tuple.1,
                    }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<updateTimerCacheByChildrenReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: updateTimerCacheByChildrenReturn) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for updateTimerCacheByChildrenReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for updateTimerCacheByChildrenCall {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Uint<256>,
            );
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = updateTimerCacheByChildrenReturn;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "updateTimerCacheByChildren(bytes32,uint256)";
            const SELECTOR: [u8; 4] = [237u8, 170u8, 181u8, 74u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.edgeId),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.maximumCachedTime),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `updateTimerCacheByClaim(bytes32,bytes32,uint256)` and selector `0x8826a370`.
```solidity
function updateTimerCacheByClaim(bytes32 edgeId, bytes32 claimingEdgeId, uint256 maximumCachedTime) external;
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct updateTimerCacheByClaimCall {
        #[allow(missing_docs)]
        pub edgeId: alloy::sol_types::private::FixedBytes<32>,
        #[allow(missing_docs)]
        pub claimingEdgeId: alloy::sol_types::private::FixedBytes<32>,
        #[allow(missing_docs)]
        pub maximumCachedTime: alloy::sol_types::private::primitives::aliases::U256,
    }
    ///Container type for the return parameters of the [`updateTimerCacheByClaim(bytes32,bytes32,uint256)`](updateTimerCacheByClaimCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct updateTimerCacheByClaimReturn {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Uint<256>,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::FixedBytes<32>,
                alloy::sol_types::private::FixedBytes<32>,
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<updateTimerCacheByClaimCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: updateTimerCacheByClaimCall) -> Self {
                    (value.edgeId, value.claimingEdgeId, value.maximumCachedTime)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for updateTimerCacheByClaimCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        edgeId: tuple.0,
                        claimingEdgeId: tuple.1,
                        maximumCachedTime: tuple.2,
                    }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<updateTimerCacheByClaimReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: updateTimerCacheByClaimReturn) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for updateTimerCacheByClaimReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for updateTimerCacheByClaimCall {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Uint<256>,
            );
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = updateTimerCacheByClaimReturn;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "updateTimerCacheByClaim(bytes32,bytes32,uint256)";
            const SELECTOR: [u8; 4] = [136u8, 38u8, 163u8, 112u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.edgeId),
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.claimingEdgeId),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.maximumCachedTime),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    ///Container for all the [`EdgeChallengeManager`](self) function calls.
    pub enum EdgeChallengeManagerCalls {
        #[allow(missing_docs)]
        LAYERZERO_BIGSTEPEDGE_HEIGHT(LAYERZERO_BIGSTEPEDGE_HEIGHTCall),
        #[allow(missing_docs)]
        LAYERZERO_BLOCKEDGE_HEIGHT(LAYERZERO_BLOCKEDGE_HEIGHTCall),
        #[allow(missing_docs)]
        LAYERZERO_SMALLSTEPEDGE_HEIGHT(LAYERZERO_SMALLSTEPEDGE_HEIGHTCall),
        #[allow(missing_docs)]
        NUM_BIGSTEP_LEVEL(NUM_BIGSTEP_LEVELCall),
        #[allow(missing_docs)]
        assertionChain(assertionChainCall),
        #[allow(missing_docs)]
        bisectEdge(bisectEdgeCall),
        #[allow(missing_docs)]
        calculateEdgeId(calculateEdgeIdCall),
        #[allow(missing_docs)]
        calculateMutualId(calculateMutualIdCall),
        #[allow(missing_docs)]
        challengePeriodBlocks(challengePeriodBlocksCall),
        #[allow(missing_docs)]
        confirmEdgeByOneStepProof(confirmEdgeByOneStepProofCall),
        #[allow(missing_docs)]
        confirmEdgeByTime(confirmEdgeByTimeCall),
        #[allow(missing_docs)]
        confirmedRival(confirmedRivalCall),
        #[allow(missing_docs)]
        createLayerZeroEdge(createLayerZeroEdgeCall),
        #[allow(missing_docs)]
        edgeExists(edgeExistsCall),
        #[allow(missing_docs)]
        edgeLength(edgeLengthCall),
        #[allow(missing_docs)]
        excessStakeReceiver(excessStakeReceiverCall),
        #[allow(missing_docs)]
        firstRival(firstRivalCall),
        #[allow(missing_docs)]
        getEdge(getEdgeCall),
        #[allow(missing_docs)]
        getLayerZeroEndHeight(getLayerZeroEndHeightCall),
        #[allow(missing_docs)]
        getPrevAssertionHash(getPrevAssertionHashCall),
        #[allow(missing_docs)]
        hasLengthOneRival(hasLengthOneRivalCall),
        #[allow(missing_docs)]
        hasMadeLayerZeroRival(hasMadeLayerZeroRivalCall),
        #[allow(missing_docs)]
        hasRival(hasRivalCall),
        #[allow(missing_docs)]
        initialize(initializeCall),
        #[allow(missing_docs)]
        multiUpdateTimeCacheByChildren(multiUpdateTimeCacheByChildrenCall),
        #[allow(missing_docs)]
        oneStepProofEntry(oneStepProofEntryCall),
        #[allow(missing_docs)]
        refundStake(refundStakeCall),
        #[allow(missing_docs)]
        stakeAmounts(stakeAmountsCall),
        #[allow(missing_docs)]
        stakeToken(stakeTokenCall),
        #[allow(missing_docs)]
        timeUnrivaled(timeUnrivaledCall),
        #[allow(missing_docs)]
        updateTimerCacheByChildren(updateTimerCacheByChildrenCall),
        #[allow(missing_docs)]
        updateTimerCacheByClaim(updateTimerCacheByClaimCall),
    }
    #[automatically_derived]
    impl EdgeChallengeManagerCalls {
        /// All the selectors of this enum.
        ///
        /// Note that the selectors might not be in the same order as the variants.
        /// No guarantees are made about the order of the selectors.
        ///
        /// Prefer using `SolInterface` methods instead.
        pub const SELECTORS: &'static [[u8; 4usize]] = &[
            [0u8, 77u8, 142u8, 254u8],
            [5u8, 250u8, 225u8, 65u8],
            [26u8, 114u8, 213u8, 76u8],
            [28u8, 27u8, 79u8, 58u8],
            [29u8, 206u8, 81u8, 102u8],
            [62u8, 53u8, 245u8, 232u8],
            [65u8, 110u8, 102u8, 87u8],
            [66u8, 225u8, 170u8, 168u8],
            [67u8, 43u8, 183u8, 138u8],
            [70u8, 194u8, 120u8, 26u8],
            [72u8, 146u8, 59u8, 197u8],
            [72u8, 221u8, 41u8, 36u8],
            [81u8, 237u8, 106u8, 48u8],
            [84u8, 182u8, 65u8, 81u8],
            [90u8, 72u8, 224u8, 244u8],
            [93u8, 158u8, 36u8, 68u8],
            [101u8, 91u8, 66u8, 243u8],
            [116u8, 137u8, 38u8, 243u8],
            [117u8, 14u8, 12u8, 15u8],
            [136u8, 38u8, 163u8, 112u8],
            [140u8, 27u8, 58u8, 64u8],
            [144u8, 133u8, 23u8, 233u8],
            [178u8, 161u8, 64u8, 142u8],
            [188u8, 230u8, 245u8, 79u8],
            [195u8, 45u8, 140u8, 99u8],
            [200u8, 188u8, 78u8, 67u8],
            [229u8, 177u8, 35u8, 218u8],
            [233u8, 78u8, 5u8, 30u8],
            [234u8, 224u8, 50u8, 139u8],
            [237u8, 170u8, 181u8, 74u8],
            [248u8, 238u8, 119u8, 214u8],
            [253u8, 162u8, 137u8, 46u8],
        ];
    }
    #[automatically_derived]
    impl alloy_sol_types::SolInterface for EdgeChallengeManagerCalls {
        const NAME: &'static str = "EdgeChallengeManagerCalls";
        const MIN_DATA_LENGTH: usize = 0usize;
        const COUNT: usize = 32usize;
        #[inline]
        fn selector(&self) -> [u8; 4] {
            match self {
                Self::LAYERZERO_BIGSTEPEDGE_HEIGHT(_) => {
                    <LAYERZERO_BIGSTEPEDGE_HEIGHTCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::LAYERZERO_BLOCKEDGE_HEIGHT(_) => {
                    <LAYERZERO_BLOCKEDGE_HEIGHTCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::LAYERZERO_SMALLSTEPEDGE_HEIGHT(_) => {
                    <LAYERZERO_SMALLSTEPEDGE_HEIGHTCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::NUM_BIGSTEP_LEVEL(_) => {
                    <NUM_BIGSTEP_LEVELCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::assertionChain(_) => {
                    <assertionChainCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::bisectEdge(_) => {
                    <bisectEdgeCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::calculateEdgeId(_) => {
                    <calculateEdgeIdCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::calculateMutualId(_) => {
                    <calculateMutualIdCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::challengePeriodBlocks(_) => {
                    <challengePeriodBlocksCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::confirmEdgeByOneStepProof(_) => {
                    <confirmEdgeByOneStepProofCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::confirmEdgeByTime(_) => {
                    <confirmEdgeByTimeCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::confirmedRival(_) => {
                    <confirmedRivalCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::createLayerZeroEdge(_) => {
                    <createLayerZeroEdgeCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::edgeExists(_) => {
                    <edgeExistsCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::edgeLength(_) => {
                    <edgeLengthCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::excessStakeReceiver(_) => {
                    <excessStakeReceiverCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::firstRival(_) => {
                    <firstRivalCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::getEdge(_) => <getEdgeCall as alloy_sol_types::SolCall>::SELECTOR,
                Self::getLayerZeroEndHeight(_) => {
                    <getLayerZeroEndHeightCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::getPrevAssertionHash(_) => {
                    <getPrevAssertionHashCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::hasLengthOneRival(_) => {
                    <hasLengthOneRivalCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::hasMadeLayerZeroRival(_) => {
                    <hasMadeLayerZeroRivalCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::hasRival(_) => <hasRivalCall as alloy_sol_types::SolCall>::SELECTOR,
                Self::initialize(_) => {
                    <initializeCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::multiUpdateTimeCacheByChildren(_) => {
                    <multiUpdateTimeCacheByChildrenCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::oneStepProofEntry(_) => {
                    <oneStepProofEntryCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::refundStake(_) => {
                    <refundStakeCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::stakeAmounts(_) => {
                    <stakeAmountsCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::stakeToken(_) => {
                    <stakeTokenCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::timeUnrivaled(_) => {
                    <timeUnrivaledCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::updateTimerCacheByChildren(_) => {
                    <updateTimerCacheByChildrenCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::updateTimerCacheByClaim(_) => {
                    <updateTimerCacheByClaimCall as alloy_sol_types::SolCall>::SELECTOR
                }
            }
        }
        #[inline]
        fn selector_at(i: usize) -> ::core::option::Option<[u8; 4]> {
            Self::SELECTORS.get(i).copied()
        }
        #[inline]
        fn valid_selector(selector: [u8; 4]) -> bool {
            Self::SELECTORS.binary_search(&selector).is_ok()
        }
        #[inline]
        #[allow(non_snake_case)]
        fn abi_decode_raw(
            selector: [u8; 4],
            data: &[u8],
            validate: bool,
        ) -> alloy_sol_types::Result<Self> {
            static DECODE_SHIMS: &[fn(
                &[u8],
                bool,
            ) -> alloy_sol_types::Result<EdgeChallengeManagerCalls>] = &[
                {
                    fn calculateEdgeId(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<EdgeChallengeManagerCalls> {
                        <calculateEdgeIdCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(EdgeChallengeManagerCalls::calculateEdgeId)
                    }
                    calculateEdgeId
                },
                {
                    fn createLayerZeroEdge(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<EdgeChallengeManagerCalls> {
                        <createLayerZeroEdgeCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(EdgeChallengeManagerCalls::createLayerZeroEdge)
                    }
                    createLayerZeroEdge
                },
                {
                    fn initialize(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<EdgeChallengeManagerCalls> {
                        <initializeCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(EdgeChallengeManagerCalls::initialize)
                    }
                    initialize
                },
                {
                    fn stakeAmounts(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<EdgeChallengeManagerCalls> {
                        <stakeAmountsCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(EdgeChallengeManagerCalls::stakeAmounts)
                    }
                    stakeAmounts
                },
                {
                    fn LAYERZERO_BLOCKEDGE_HEIGHT(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<EdgeChallengeManagerCalls> {
                        <LAYERZERO_BLOCKEDGE_HEIGHTCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(EdgeChallengeManagerCalls::LAYERZERO_BLOCKEDGE_HEIGHT)
                    }
                    LAYERZERO_BLOCKEDGE_HEIGHT
                },
                {
                    fn timeUnrivaled(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<EdgeChallengeManagerCalls> {
                        <timeUnrivaledCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(EdgeChallengeManagerCalls::timeUnrivaled)
                    }
                    timeUnrivaled
                },
                {
                    fn LAYERZERO_BIGSTEPEDGE_HEIGHT(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<EdgeChallengeManagerCalls> {
                        <LAYERZERO_BIGSTEPEDGE_HEIGHTCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(EdgeChallengeManagerCalls::LAYERZERO_BIGSTEPEDGE_HEIGHT)
                    }
                    LAYERZERO_BIGSTEPEDGE_HEIGHT
                },
                {
                    fn getLayerZeroEndHeight(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<EdgeChallengeManagerCalls> {
                        <getLayerZeroEndHeightCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(EdgeChallengeManagerCalls::getLayerZeroEndHeight)
                    }
                    getLayerZeroEndHeight
                },
                {
                    fn multiUpdateTimeCacheByChildren(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<EdgeChallengeManagerCalls> {
                        <multiUpdateTimeCacheByChildrenCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(
                                EdgeChallengeManagerCalls::multiUpdateTimeCacheByChildren,
                            )
                    }
                    multiUpdateTimeCacheByChildren
                },
                {
                    fn challengePeriodBlocks(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<EdgeChallengeManagerCalls> {
                        <challengePeriodBlocksCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(EdgeChallengeManagerCalls::challengePeriodBlocks)
                    }
                    challengePeriodBlocks
                },
                {
                    fn oneStepProofEntry(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<EdgeChallengeManagerCalls> {
                        <oneStepProofEntryCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(EdgeChallengeManagerCalls::oneStepProofEntry)
                    }
                    oneStepProofEntry
                },
                {
                    fn assertionChain(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<EdgeChallengeManagerCalls> {
                        <assertionChainCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(EdgeChallengeManagerCalls::assertionChain)
                    }
                    assertionChain
                },
                {
                    fn stakeToken(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<EdgeChallengeManagerCalls> {
                        <stakeTokenCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(EdgeChallengeManagerCalls::stakeToken)
                    }
                    stakeToken
                },
                {
                    fn hasLengthOneRival(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<EdgeChallengeManagerCalls> {
                        <hasLengthOneRivalCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(EdgeChallengeManagerCalls::hasLengthOneRival)
                    }
                    hasLengthOneRival
                },
                {
                    fn getPrevAssertionHash(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<EdgeChallengeManagerCalls> {
                        <getPrevAssertionHashCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(EdgeChallengeManagerCalls::getPrevAssertionHash)
                    }
                    getPrevAssertionHash
                },
                {
                    fn NUM_BIGSTEP_LEVEL(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<EdgeChallengeManagerCalls> {
                        <NUM_BIGSTEP_LEVELCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(EdgeChallengeManagerCalls::NUM_BIGSTEP_LEVEL)
                    }
                    NUM_BIGSTEP_LEVEL
                },
                {
                    fn hasMadeLayerZeroRival(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<EdgeChallengeManagerCalls> {
                        <hasMadeLayerZeroRivalCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(EdgeChallengeManagerCalls::hasMadeLayerZeroRival)
                    }
                    hasMadeLayerZeroRival
                },
                {
                    fn refundStake(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<EdgeChallengeManagerCalls> {
                        <refundStakeCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(EdgeChallengeManagerCalls::refundStake)
                    }
                    refundStake
                },
                {
                    fn edgeExists(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<EdgeChallengeManagerCalls> {
                        <edgeExistsCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(EdgeChallengeManagerCalls::edgeExists)
                    }
                    edgeExists
                },
                {
                    fn updateTimerCacheByClaim(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<EdgeChallengeManagerCalls> {
                        <updateTimerCacheByClaimCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(EdgeChallengeManagerCalls::updateTimerCacheByClaim)
                    }
                    updateTimerCacheByClaim
                },
                {
                    fn confirmEdgeByOneStepProof(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<EdgeChallengeManagerCalls> {
                        <confirmEdgeByOneStepProofCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(EdgeChallengeManagerCalls::confirmEdgeByOneStepProof)
                    }
                    confirmEdgeByOneStepProof
                },
                {
                    fn hasRival(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<EdgeChallengeManagerCalls> {
                        <hasRivalCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(EdgeChallengeManagerCalls::hasRival)
                    }
                    hasRival
                },
                {
                    fn confirmEdgeByTime(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<EdgeChallengeManagerCalls> {
                        <confirmEdgeByTimeCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(EdgeChallengeManagerCalls::confirmEdgeByTime)
                    }
                    confirmEdgeByTime
                },
                {
                    fn firstRival(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<EdgeChallengeManagerCalls> {
                        <firstRivalCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(EdgeChallengeManagerCalls::firstRival)
                    }
                    firstRival
                },
                {
                    fn calculateMutualId(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<EdgeChallengeManagerCalls> {
                        <calculateMutualIdCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(EdgeChallengeManagerCalls::calculateMutualId)
                    }
                    calculateMutualId
                },
                {
                    fn bisectEdge(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<EdgeChallengeManagerCalls> {
                        <bisectEdgeCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(EdgeChallengeManagerCalls::bisectEdge)
                    }
                    bisectEdge
                },
                {
                    fn confirmedRival(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<EdgeChallengeManagerCalls> {
                        <confirmedRivalCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(EdgeChallengeManagerCalls::confirmedRival)
                    }
                    confirmedRival
                },
                {
                    fn excessStakeReceiver(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<EdgeChallengeManagerCalls> {
                        <excessStakeReceiverCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(EdgeChallengeManagerCalls::excessStakeReceiver)
                    }
                    excessStakeReceiver
                },
                {
                    fn edgeLength(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<EdgeChallengeManagerCalls> {
                        <edgeLengthCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(EdgeChallengeManagerCalls::edgeLength)
                    }
                    edgeLength
                },
                {
                    fn updateTimerCacheByChildren(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<EdgeChallengeManagerCalls> {
                        <updateTimerCacheByChildrenCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(EdgeChallengeManagerCalls::updateTimerCacheByChildren)
                    }
                    updateTimerCacheByChildren
                },
                {
                    fn LAYERZERO_SMALLSTEPEDGE_HEIGHT(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<EdgeChallengeManagerCalls> {
                        <LAYERZERO_SMALLSTEPEDGE_HEIGHTCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(
                                EdgeChallengeManagerCalls::LAYERZERO_SMALLSTEPEDGE_HEIGHT,
                            )
                    }
                    LAYERZERO_SMALLSTEPEDGE_HEIGHT
                },
                {
                    fn getEdge(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<EdgeChallengeManagerCalls> {
                        <getEdgeCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(EdgeChallengeManagerCalls::getEdge)
                    }
                    getEdge
                },
            ];
            let Ok(idx) = Self::SELECTORS.binary_search(&selector) else {
                return Err(
                    alloy_sol_types::Error::unknown_selector(
                        <Self as alloy_sol_types::SolInterface>::NAME,
                        selector,
                    ),
                );
            };
            DECODE_SHIMS[idx](data, validate)
        }
        #[inline]
        fn abi_encoded_size(&self) -> usize {
            match self {
                Self::LAYERZERO_BIGSTEPEDGE_HEIGHT(inner) => {
                    <LAYERZERO_BIGSTEPEDGE_HEIGHTCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::LAYERZERO_BLOCKEDGE_HEIGHT(inner) => {
                    <LAYERZERO_BLOCKEDGE_HEIGHTCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::LAYERZERO_SMALLSTEPEDGE_HEIGHT(inner) => {
                    <LAYERZERO_SMALLSTEPEDGE_HEIGHTCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::NUM_BIGSTEP_LEVEL(inner) => {
                    <NUM_BIGSTEP_LEVELCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::assertionChain(inner) => {
                    <assertionChainCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::bisectEdge(inner) => {
                    <bisectEdgeCall as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::calculateEdgeId(inner) => {
                    <calculateEdgeIdCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::calculateMutualId(inner) => {
                    <calculateMutualIdCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::challengePeriodBlocks(inner) => {
                    <challengePeriodBlocksCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::confirmEdgeByOneStepProof(inner) => {
                    <confirmEdgeByOneStepProofCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::confirmEdgeByTime(inner) => {
                    <confirmEdgeByTimeCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::confirmedRival(inner) => {
                    <confirmedRivalCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::createLayerZeroEdge(inner) => {
                    <createLayerZeroEdgeCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::edgeExists(inner) => {
                    <edgeExistsCall as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::edgeLength(inner) => {
                    <edgeLengthCall as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::excessStakeReceiver(inner) => {
                    <excessStakeReceiverCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::firstRival(inner) => {
                    <firstRivalCall as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::getEdge(inner) => {
                    <getEdgeCall as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::getLayerZeroEndHeight(inner) => {
                    <getLayerZeroEndHeightCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::getPrevAssertionHash(inner) => {
                    <getPrevAssertionHashCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::hasLengthOneRival(inner) => {
                    <hasLengthOneRivalCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::hasMadeLayerZeroRival(inner) => {
                    <hasMadeLayerZeroRivalCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::hasRival(inner) => {
                    <hasRivalCall as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::initialize(inner) => {
                    <initializeCall as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::multiUpdateTimeCacheByChildren(inner) => {
                    <multiUpdateTimeCacheByChildrenCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::oneStepProofEntry(inner) => {
                    <oneStepProofEntryCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::refundStake(inner) => {
                    <refundStakeCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::stakeAmounts(inner) => {
                    <stakeAmountsCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::stakeToken(inner) => {
                    <stakeTokenCall as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::timeUnrivaled(inner) => {
                    <timeUnrivaledCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::updateTimerCacheByChildren(inner) => {
                    <updateTimerCacheByChildrenCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::updateTimerCacheByClaim(inner) => {
                    <updateTimerCacheByClaimCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
            }
        }
        #[inline]
        fn abi_encode_raw(&self, out: &mut alloy_sol_types::private::Vec<u8>) {
            match self {
                Self::LAYERZERO_BIGSTEPEDGE_HEIGHT(inner) => {
                    <LAYERZERO_BIGSTEPEDGE_HEIGHTCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::LAYERZERO_BLOCKEDGE_HEIGHT(inner) => {
                    <LAYERZERO_BLOCKEDGE_HEIGHTCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::LAYERZERO_SMALLSTEPEDGE_HEIGHT(inner) => {
                    <LAYERZERO_SMALLSTEPEDGE_HEIGHTCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::NUM_BIGSTEP_LEVEL(inner) => {
                    <NUM_BIGSTEP_LEVELCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::assertionChain(inner) => {
                    <assertionChainCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::bisectEdge(inner) => {
                    <bisectEdgeCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::calculateEdgeId(inner) => {
                    <calculateEdgeIdCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::calculateMutualId(inner) => {
                    <calculateMutualIdCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::challengePeriodBlocks(inner) => {
                    <challengePeriodBlocksCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::confirmEdgeByOneStepProof(inner) => {
                    <confirmEdgeByOneStepProofCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::confirmEdgeByTime(inner) => {
                    <confirmEdgeByTimeCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::confirmedRival(inner) => {
                    <confirmedRivalCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::createLayerZeroEdge(inner) => {
                    <createLayerZeroEdgeCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::edgeExists(inner) => {
                    <edgeExistsCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::edgeLength(inner) => {
                    <edgeLengthCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::excessStakeReceiver(inner) => {
                    <excessStakeReceiverCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::firstRival(inner) => {
                    <firstRivalCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::getEdge(inner) => {
                    <getEdgeCall as alloy_sol_types::SolCall>::abi_encode_raw(inner, out)
                }
                Self::getLayerZeroEndHeight(inner) => {
                    <getLayerZeroEndHeightCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::getPrevAssertionHash(inner) => {
                    <getPrevAssertionHashCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::hasLengthOneRival(inner) => {
                    <hasLengthOneRivalCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::hasMadeLayerZeroRival(inner) => {
                    <hasMadeLayerZeroRivalCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::hasRival(inner) => {
                    <hasRivalCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::initialize(inner) => {
                    <initializeCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::multiUpdateTimeCacheByChildren(inner) => {
                    <multiUpdateTimeCacheByChildrenCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::oneStepProofEntry(inner) => {
                    <oneStepProofEntryCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::refundStake(inner) => {
                    <refundStakeCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::stakeAmounts(inner) => {
                    <stakeAmountsCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::stakeToken(inner) => {
                    <stakeTokenCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::timeUnrivaled(inner) => {
                    <timeUnrivaledCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::updateTimerCacheByChildren(inner) => {
                    <updateTimerCacheByChildrenCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::updateTimerCacheByClaim(inner) => {
                    <updateTimerCacheByClaimCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
            }
        }
    }
    ///Container for all the [`EdgeChallengeManager`](self) custom errors.
    pub enum EdgeChallengeManagerErrors {
        #[allow(missing_docs)]
        AccountHasMadeLayerZeroRival(AccountHasMadeLayerZeroRival),
        #[allow(missing_docs)]
        AssertionHashEmpty(AssertionHashEmpty),
        #[allow(missing_docs)]
        AssertionHashMismatch(AssertionHashMismatch),
        #[allow(missing_docs)]
        AssertionNoSibling(AssertionNoSibling),
        #[allow(missing_docs)]
        AssertionNotPending(AssertionNotPending),
        #[allow(missing_docs)]
        BigStepLevelsTooMany(BigStepLevelsTooMany),
        #[allow(missing_docs)]
        CachedTimeSufficient(CachedTimeSufficient),
        #[allow(missing_docs)]
        ChildrenAlreadySet(ChildrenAlreadySet),
        #[allow(missing_docs)]
        ClaimEdgeInvalidLevel(ClaimEdgeInvalidLevel),
        #[allow(missing_docs)]
        ClaimEdgeNotLengthOneRival(ClaimEdgeNotLengthOneRival),
        #[allow(missing_docs)]
        ClaimEdgeNotPending(ClaimEdgeNotPending),
        #[allow(missing_docs)]
        EdgeAlreadyExists(EdgeAlreadyExists),
        #[allow(missing_docs)]
        EdgeAlreadyRefunded(EdgeAlreadyRefunded),
        #[allow(missing_docs)]
        EdgeClaimMismatch(EdgeClaimMismatch),
        #[allow(missing_docs)]
        EdgeLevelInvalid(EdgeLevelInvalid),
        #[allow(missing_docs)]
        EdgeNotConfirmed(EdgeNotConfirmed),
        #[allow(missing_docs)]
        EdgeNotExists(EdgeNotExists),
        #[allow(missing_docs)]
        EdgeNotLayerZero(EdgeNotLayerZero),
        #[allow(missing_docs)]
        EdgeNotLengthOne(EdgeNotLengthOne),
        #[allow(missing_docs)]
        EdgeNotPending(EdgeNotPending),
        #[allow(missing_docs)]
        EdgeTypeNotSmallStep(EdgeTypeNotSmallStep),
        #[allow(missing_docs)]
        EdgeUnrivaled(EdgeUnrivaled),
        #[allow(missing_docs)]
        EmptyArray(EmptyArray),
        #[allow(missing_docs)]
        EmptyAssertionChain(EmptyAssertionChain),
        #[allow(missing_docs)]
        EmptyChallengePeriod(EmptyChallengePeriod),
        #[allow(missing_docs)]
        EmptyClaimId(EmptyClaimId),
        #[allow(missing_docs)]
        EmptyEdgeSpecificProof(EmptyEdgeSpecificProof),
        #[allow(missing_docs)]
        EmptyEndMachineStatus(EmptyEndMachineStatus),
        #[allow(missing_docs)]
        EmptyEndRoot(EmptyEndRoot),
        #[allow(missing_docs)]
        EmptyFirstRival(EmptyFirstRival),
        #[allow(missing_docs)]
        EmptyOneStepProofEntry(EmptyOneStepProofEntry),
        #[allow(missing_docs)]
        EmptyOriginId(EmptyOriginId),
        #[allow(missing_docs)]
        EmptyPrefixProof(EmptyPrefixProof),
        #[allow(missing_docs)]
        EmptyStakeReceiver(EmptyStakeReceiver),
        #[allow(missing_docs)]
        EmptyStaker(EmptyStaker),
        #[allow(missing_docs)]
        EmptyStartMachineStatus(EmptyStartMachineStatus),
        #[allow(missing_docs)]
        EmptyStartRoot(EmptyStartRoot),
        #[allow(missing_docs)]
        EndHistoryRootMismatch(EndHistoryRootMismatch),
        #[allow(missing_docs)]
        HeightDiffLtTwo(HeightDiffLtTwo),
        #[allow(missing_docs)]
        InsufficientConfirmationBlocks(InsufficientConfirmationBlocks),
        #[allow(missing_docs)]
        InvalidEdgeType(InvalidEdgeType),
        #[allow(missing_docs)]
        InvalidEndHeight(InvalidEndHeight),
        #[allow(missing_docs)]
        InvalidHeights(InvalidHeights),
        #[allow(missing_docs)]
        LevelTooHigh(LevelTooHigh),
        #[allow(missing_docs)]
        MerkleProofTooLong(MerkleProofTooLong),
        #[allow(missing_docs)]
        NotPowerOfTwo(NotPowerOfTwo),
        #[allow(missing_docs)]
        NotValidator(NotValidator),
        #[allow(missing_docs)]
        OriginIdMutualIdMismatch(OriginIdMutualIdMismatch),
        #[allow(missing_docs)]
        RivalEdgeConfirmed(RivalEdgeConfirmed),
        #[allow(missing_docs)]
        StakeAmountsMismatch(StakeAmountsMismatch),
        #[allow(missing_docs)]
        ZeroBigStepLevels(ZeroBigStepLevels),
    }
    #[automatically_derived]
    impl EdgeChallengeManagerErrors {
        /// All the selectors of this enum.
        ///
        /// Note that the selectors might not be in the same order as the variants.
        /// No guarantees are made about the order of the selectors.
        ///
        /// Prefer using `SolInterface` methods instead.
        pub const SELECTORS: &'static [[u8; 4usize]] = &[
            [0u8, 167u8, 176u8, 43u8],
            [10u8, 236u8, 233u8, 192u8],
            [15u8, 14u8, 200u8, 168u8],
            [17u8, 168u8, 212u8, 208u8],
            [18u8, 69u8, 159u8, 253u8],
            [32u8, 96u8, 250u8, 244u8],
            [35u8, 248u8, 64u8, 93u8],
            [48u8, 127u8, 118u8, 105u8],
            [52u8, 42u8, 7u8, 82u8],
            [52u8, 138u8, 239u8, 223u8],
            [58u8, 99u8, 233u8, 154u8],
            [59u8, 242u8, 225u8, 236u8],
            [64u8, 210u8, 59u8, 240u8],
            [70u8, 54u8, 94u8, 82u8],
            [82u8, 18u8, 153u8, 169u8],
            [90u8, 70u8, 172u8, 58u8],
            [91u8, 23u8, 122u8, 60u8],
            [92u8, 182u8, 229u8, 187u8],
            [105u8, 50u8, 188u8, 253u8],
            [107u8, 89u8, 94u8, 80u8],
            [126u8, 114u8, 109u8, 21u8],
            [128u8, 224u8, 126u8, 69u8],
            [131u8, 198u8, 131u8, 228u8],
            [137u8, 153u8, 133u8, 125u8],
            [138u8, 14u8, 237u8, 204u8],
            [139u8, 14u8, 113u8, 208u8],
            [141u8, 121u8, 219u8, 188u8],
            [144u8, 41u8, 133u8, 148u8],
            [168u8, 99u8, 214u8, 228u8],
            [172u8, 158u8, 97u8, 22u8],
            [174u8, 13u8, 165u8, 120u8],
            [180u8, 93u8, 28u8, 58u8],
            [188u8, 237u8, 243u8, 222u8],
            [193u8, 105u8, 36u8, 54u8],
            [194u8, 173u8, 195u8, 232u8],
            [200u8, 62u8, 8u8, 98u8],
            [201u8, 204u8, 172u8, 80u8],
            [209u8, 245u8, 146u8, 129u8],
            [218u8, 16u8, 246u8, 124u8],
            [221u8, 112u8, 40u8, 240u8],
            [223u8, 204u8, 98u8, 188u8],
            [226u8, 226u8, 127u8, 135u8],
            [229u8, 140u8, 131u8, 8u8],
            [233u8, 107u8, 198u8, 26u8],
            [234u8, 254u8, 219u8, 252u8],
            [237u8, 61u8, 184u8, 172u8],
            [239u8, 18u8, 103u8, 180u8],
            [242u8, 137u8, 230u8, 87u8],
            [251u8, 96u8, 176u8, 239u8],
            [253u8, 172u8, 51u8, 30u8],
            [255u8, 109u8, 155u8, 215u8],
        ];
    }
    #[automatically_derived]
    impl alloy_sol_types::SolInterface for EdgeChallengeManagerErrors {
        const NAME: &'static str = "EdgeChallengeManagerErrors";
        const MIN_DATA_LENGTH: usize = 0usize;
        const COUNT: usize = 51usize;
        #[inline]
        fn selector(&self) -> [u8; 4] {
            match self {
                Self::AccountHasMadeLayerZeroRival(_) => {
                    <AccountHasMadeLayerZeroRival as alloy_sol_types::SolError>::SELECTOR
                }
                Self::AssertionHashEmpty(_) => {
                    <AssertionHashEmpty as alloy_sol_types::SolError>::SELECTOR
                }
                Self::AssertionHashMismatch(_) => {
                    <AssertionHashMismatch as alloy_sol_types::SolError>::SELECTOR
                }
                Self::AssertionNoSibling(_) => {
                    <AssertionNoSibling as alloy_sol_types::SolError>::SELECTOR
                }
                Self::AssertionNotPending(_) => {
                    <AssertionNotPending as alloy_sol_types::SolError>::SELECTOR
                }
                Self::BigStepLevelsTooMany(_) => {
                    <BigStepLevelsTooMany as alloy_sol_types::SolError>::SELECTOR
                }
                Self::CachedTimeSufficient(_) => {
                    <CachedTimeSufficient as alloy_sol_types::SolError>::SELECTOR
                }
                Self::ChildrenAlreadySet(_) => {
                    <ChildrenAlreadySet as alloy_sol_types::SolError>::SELECTOR
                }
                Self::ClaimEdgeInvalidLevel(_) => {
                    <ClaimEdgeInvalidLevel as alloy_sol_types::SolError>::SELECTOR
                }
                Self::ClaimEdgeNotLengthOneRival(_) => {
                    <ClaimEdgeNotLengthOneRival as alloy_sol_types::SolError>::SELECTOR
                }
                Self::ClaimEdgeNotPending(_) => {
                    <ClaimEdgeNotPending as alloy_sol_types::SolError>::SELECTOR
                }
                Self::EdgeAlreadyExists(_) => {
                    <EdgeAlreadyExists as alloy_sol_types::SolError>::SELECTOR
                }
                Self::EdgeAlreadyRefunded(_) => {
                    <EdgeAlreadyRefunded as alloy_sol_types::SolError>::SELECTOR
                }
                Self::EdgeClaimMismatch(_) => {
                    <EdgeClaimMismatch as alloy_sol_types::SolError>::SELECTOR
                }
                Self::EdgeLevelInvalid(_) => {
                    <EdgeLevelInvalid as alloy_sol_types::SolError>::SELECTOR
                }
                Self::EdgeNotConfirmed(_) => {
                    <EdgeNotConfirmed as alloy_sol_types::SolError>::SELECTOR
                }
                Self::EdgeNotExists(_) => {
                    <EdgeNotExists as alloy_sol_types::SolError>::SELECTOR
                }
                Self::EdgeNotLayerZero(_) => {
                    <EdgeNotLayerZero as alloy_sol_types::SolError>::SELECTOR
                }
                Self::EdgeNotLengthOne(_) => {
                    <EdgeNotLengthOne as alloy_sol_types::SolError>::SELECTOR
                }
                Self::EdgeNotPending(_) => {
                    <EdgeNotPending as alloy_sol_types::SolError>::SELECTOR
                }
                Self::EdgeTypeNotSmallStep(_) => {
                    <EdgeTypeNotSmallStep as alloy_sol_types::SolError>::SELECTOR
                }
                Self::EdgeUnrivaled(_) => {
                    <EdgeUnrivaled as alloy_sol_types::SolError>::SELECTOR
                }
                Self::EmptyArray(_) => {
                    <EmptyArray as alloy_sol_types::SolError>::SELECTOR
                }
                Self::EmptyAssertionChain(_) => {
                    <EmptyAssertionChain as alloy_sol_types::SolError>::SELECTOR
                }
                Self::EmptyChallengePeriod(_) => {
                    <EmptyChallengePeriod as alloy_sol_types::SolError>::SELECTOR
                }
                Self::EmptyClaimId(_) => {
                    <EmptyClaimId as alloy_sol_types::SolError>::SELECTOR
                }
                Self::EmptyEdgeSpecificProof(_) => {
                    <EmptyEdgeSpecificProof as alloy_sol_types::SolError>::SELECTOR
                }
                Self::EmptyEndMachineStatus(_) => {
                    <EmptyEndMachineStatus as alloy_sol_types::SolError>::SELECTOR
                }
                Self::EmptyEndRoot(_) => {
                    <EmptyEndRoot as alloy_sol_types::SolError>::SELECTOR
                }
                Self::EmptyFirstRival(_) => {
                    <EmptyFirstRival as alloy_sol_types::SolError>::SELECTOR
                }
                Self::EmptyOneStepProofEntry(_) => {
                    <EmptyOneStepProofEntry as alloy_sol_types::SolError>::SELECTOR
                }
                Self::EmptyOriginId(_) => {
                    <EmptyOriginId as alloy_sol_types::SolError>::SELECTOR
                }
                Self::EmptyPrefixProof(_) => {
                    <EmptyPrefixProof as alloy_sol_types::SolError>::SELECTOR
                }
                Self::EmptyStakeReceiver(_) => {
                    <EmptyStakeReceiver as alloy_sol_types::SolError>::SELECTOR
                }
                Self::EmptyStaker(_) => {
                    <EmptyStaker as alloy_sol_types::SolError>::SELECTOR
                }
                Self::EmptyStartMachineStatus(_) => {
                    <EmptyStartMachineStatus as alloy_sol_types::SolError>::SELECTOR
                }
                Self::EmptyStartRoot(_) => {
                    <EmptyStartRoot as alloy_sol_types::SolError>::SELECTOR
                }
                Self::EndHistoryRootMismatch(_) => {
                    <EndHistoryRootMismatch as alloy_sol_types::SolError>::SELECTOR
                }
                Self::HeightDiffLtTwo(_) => {
                    <HeightDiffLtTwo as alloy_sol_types::SolError>::SELECTOR
                }
                Self::InsufficientConfirmationBlocks(_) => {
                    <InsufficientConfirmationBlocks as alloy_sol_types::SolError>::SELECTOR
                }
                Self::InvalidEdgeType(_) => {
                    <InvalidEdgeType as alloy_sol_types::SolError>::SELECTOR
                }
                Self::InvalidEndHeight(_) => {
                    <InvalidEndHeight as alloy_sol_types::SolError>::SELECTOR
                }
                Self::InvalidHeights(_) => {
                    <InvalidHeights as alloy_sol_types::SolError>::SELECTOR
                }
                Self::LevelTooHigh(_) => {
                    <LevelTooHigh as alloy_sol_types::SolError>::SELECTOR
                }
                Self::MerkleProofTooLong(_) => {
                    <MerkleProofTooLong as alloy_sol_types::SolError>::SELECTOR
                }
                Self::NotPowerOfTwo(_) => {
                    <NotPowerOfTwo as alloy_sol_types::SolError>::SELECTOR
                }
                Self::NotValidator(_) => {
                    <NotValidator as alloy_sol_types::SolError>::SELECTOR
                }
                Self::OriginIdMutualIdMismatch(_) => {
                    <OriginIdMutualIdMismatch as alloy_sol_types::SolError>::SELECTOR
                }
                Self::RivalEdgeConfirmed(_) => {
                    <RivalEdgeConfirmed as alloy_sol_types::SolError>::SELECTOR
                }
                Self::StakeAmountsMismatch(_) => {
                    <StakeAmountsMismatch as alloy_sol_types::SolError>::SELECTOR
                }
                Self::ZeroBigStepLevels(_) => {
                    <ZeroBigStepLevels as alloy_sol_types::SolError>::SELECTOR
                }
            }
        }
        #[inline]
        fn selector_at(i: usize) -> ::core::option::Option<[u8; 4]> {
            Self::SELECTORS.get(i).copied()
        }
        #[inline]
        fn valid_selector(selector: [u8; 4]) -> bool {
            Self::SELECTORS.binary_search(&selector).is_ok()
        }
        #[inline]
        #[allow(non_snake_case)]
        fn abi_decode_raw(
            selector: [u8; 4],
            data: &[u8],
            validate: bool,
        ) -> alloy_sol_types::Result<Self> {
            static DECODE_SHIMS: &[fn(
                &[u8],
                bool,
            ) -> alloy_sol_types::Result<EdgeChallengeManagerErrors>] = &[
                {
                    fn EdgeNotExists(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<EdgeChallengeManagerErrors> {
                        <EdgeNotExists as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(EdgeChallengeManagerErrors::EdgeNotExists)
                    }
                    EdgeNotExists
                },
                {
                    fn StakeAmountsMismatch(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<EdgeChallengeManagerErrors> {
                        <StakeAmountsMismatch as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(EdgeChallengeManagerErrors::StakeAmountsMismatch)
                    }
                    StakeAmountsMismatch
                },
                {
                    fn EmptyStakeReceiver(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<EdgeChallengeManagerErrors> {
                        <EmptyStakeReceiver as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(EdgeChallengeManagerErrors::EmptyStakeReceiver)
                    }
                    EmptyStakeReceiver
                },
                {
                    fn InsufficientConfirmationBlocks(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<EdgeChallengeManagerErrors> {
                        <InsufficientConfirmationBlocks as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(
                                EdgeChallengeManagerErrors::InsufficientConfirmationBlocks,
                            )
                    }
                    InsufficientConfirmationBlocks
                },
                {
                    fn ClaimEdgeNotPending(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<EdgeChallengeManagerErrors> {
                        <ClaimEdgeNotPending as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(EdgeChallengeManagerErrors::ClaimEdgeNotPending)
                    }
                    ClaimEdgeNotPending
                },
                {
                    fn InvalidHeights(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<EdgeChallengeManagerErrors> {
                        <InvalidHeights as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(EdgeChallengeManagerErrors::InvalidHeights)
                    }
                    InvalidHeights
                },
                {
                    fn EdgeNotPending(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<EdgeChallengeManagerErrors> {
                        <EdgeNotPending as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(EdgeChallengeManagerErrors::EdgeNotPending)
                    }
                    EdgeNotPending
                },
                {
                    fn EdgeAlreadyRefunded(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<EdgeChallengeManagerErrors> {
                        <EdgeAlreadyRefunded as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(EdgeChallengeManagerErrors::EdgeAlreadyRefunded)
                    }
                    EdgeAlreadyRefunded
                },
                {
                    fn EmptyPrefixProof(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<EdgeChallengeManagerErrors> {
                        <EmptyPrefixProof as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(EdgeChallengeManagerErrors::EmptyPrefixProof)
                    }
                    EmptyPrefixProof
                },
                {
                    fn EdgeTypeNotSmallStep(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<EdgeChallengeManagerErrors> {
                        <EdgeTypeNotSmallStep as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(EdgeChallengeManagerErrors::EdgeTypeNotSmallStep)
                    }
                    EdgeTypeNotSmallStep
                },
                {
                    fn EndHistoryRootMismatch(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<EdgeChallengeManagerErrors> {
                        <EndHistoryRootMismatch as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(EdgeChallengeManagerErrors::EndHistoryRootMismatch)
                    }
                    EndHistoryRootMismatch
                },
                {
                    fn InvalidEdgeType(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<EdgeChallengeManagerErrors> {
                        <InvalidEdgeType as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(EdgeChallengeManagerErrors::InvalidEdgeType)
                    }
                    InvalidEdgeType
                },
                {
                    fn BigStepLevelsTooMany(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<EdgeChallengeManagerErrors> {
                        <BigStepLevelsTooMany as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(EdgeChallengeManagerErrors::BigStepLevelsTooMany)
                    }
                    BigStepLevelsTooMany
                },
                {
                    fn EmptyStartMachineStatus(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<EdgeChallengeManagerErrors> {
                        <EmptyStartMachineStatus as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(EdgeChallengeManagerErrors::EmptyStartMachineStatus)
                    }
                    EmptyStartMachineStatus
                },
                {
                    fn EmptyArray(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<EdgeChallengeManagerErrors> {
                        <EmptyArray as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(EdgeChallengeManagerErrors::EmptyArray)
                    }
                    EmptyArray
                },
                {
                    fn AccountHasMadeLayerZeroRival(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<EdgeChallengeManagerErrors> {
                        <AccountHasMadeLayerZeroRival as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(
                                EdgeChallengeManagerErrors::AccountHasMadeLayerZeroRival,
                            )
                    }
                    AccountHasMadeLayerZeroRival
                },
                {
                    fn AssertionHashMismatch(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<EdgeChallengeManagerErrors> {
                        <AssertionHashMismatch as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(EdgeChallengeManagerErrors::AssertionHashMismatch)
                    }
                    AssertionHashMismatch
                },
                {
                    fn EmptyEndRoot(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<EdgeChallengeManagerErrors> {
                        <EmptyEndRoot as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(EdgeChallengeManagerErrors::EmptyEndRoot)
                    }
                    EmptyEndRoot
                },
                {
                    fn EmptyClaimId(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<EdgeChallengeManagerErrors> {
                        <EmptyClaimId as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(EdgeChallengeManagerErrors::EmptyClaimId)
                    }
                    EmptyClaimId
                },
                {
                    fn EdgeNotLengthOne(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<EdgeChallengeManagerErrors> {
                        <EdgeNotLengthOne as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(EdgeChallengeManagerErrors::EdgeNotLengthOne)
                    }
                    EdgeNotLengthOne
                },
                {
                    fn EdgeLevelInvalid(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<EdgeChallengeManagerErrors> {
                        <EdgeLevelInvalid as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(EdgeChallengeManagerErrors::EdgeLevelInvalid)
                    }
                    EdgeLevelInvalid
                },
                {
                    fn EdgeUnrivaled(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<EdgeChallengeManagerErrors> {
                        <EdgeUnrivaled as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(EdgeChallengeManagerErrors::EdgeUnrivaled)
                    }
                    EdgeUnrivaled
                },
                {
                    fn EmptyStartRoot(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<EdgeChallengeManagerErrors> {
                        <EmptyStartRoot as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(EdgeChallengeManagerErrors::EmptyStartRoot)
                    }
                    EmptyStartRoot
                },
                {
                    fn EmptyEndMachineStatus(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<EdgeChallengeManagerErrors> {
                        <EmptyEndMachineStatus as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(EdgeChallengeManagerErrors::EmptyEndMachineStatus)
                    }
                    EmptyEndMachineStatus
                },
                {
                    fn EmptyChallengePeriod(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<EdgeChallengeManagerErrors> {
                        <EmptyChallengePeriod as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(EdgeChallengeManagerErrors::EmptyChallengePeriod)
                    }
                    EmptyChallengePeriod
                },
                {
                    fn ChildrenAlreadySet(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<EdgeChallengeManagerErrors> {
                        <ChildrenAlreadySet as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(EdgeChallengeManagerErrors::ChildrenAlreadySet)
                    }
                    ChildrenAlreadySet
                },
                {
                    fn EmptyOriginId(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<EdgeChallengeManagerErrors> {
                        <EmptyOriginId as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(EdgeChallengeManagerErrors::EmptyOriginId)
                    }
                    EmptyOriginId
                },
                {
                    fn HeightDiffLtTwo(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<EdgeChallengeManagerErrors> {
                        <HeightDiffLtTwo as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(EdgeChallengeManagerErrors::HeightDiffLtTwo)
                    }
                    HeightDiffLtTwo
                },
                {
                    fn ZeroBigStepLevels(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<EdgeChallengeManagerErrors> {
                        <ZeroBigStepLevels as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(EdgeChallengeManagerErrors::ZeroBigStepLevels)
                    }
                    ZeroBigStepLevels
                },
                {
                    fn ClaimEdgeInvalidLevel(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<EdgeChallengeManagerErrors> {
                        <ClaimEdgeInvalidLevel as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(EdgeChallengeManagerErrors::ClaimEdgeInvalidLevel)
                    }
                    ClaimEdgeInvalidLevel
                },
                {
                    fn LevelTooHigh(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<EdgeChallengeManagerErrors> {
                        <LevelTooHigh as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(EdgeChallengeManagerErrors::LevelTooHigh)
                    }
                    LevelTooHigh
                },
                {
                    fn AssertionNoSibling(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<EdgeChallengeManagerErrors> {
                        <AssertionNoSibling as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(EdgeChallengeManagerErrors::AssertionNoSibling)
                    }
                    AssertionNoSibling
                },
                {
                    fn EdgeAlreadyExists(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<EdgeChallengeManagerErrors> {
                        <EdgeAlreadyExists as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(EdgeChallengeManagerErrors::EdgeAlreadyExists)
                    }
                    EdgeAlreadyExists
                },
                {
                    fn AssertionNotPending(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<EdgeChallengeManagerErrors> {
                        <AssertionNotPending as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(EdgeChallengeManagerErrors::AssertionNotPending)
                    }
                    AssertionNotPending
                },
                {
                    fn EdgeClaimMismatch(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<EdgeChallengeManagerErrors> {
                        <EdgeClaimMismatch as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(EdgeChallengeManagerErrors::EdgeClaimMismatch)
                    }
                    EdgeClaimMismatch
                },
                {
                    fn EmptyAssertionChain(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<EdgeChallengeManagerErrors> {
                        <EmptyAssertionChain as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(EdgeChallengeManagerErrors::EmptyAssertionChain)
                    }
                    EmptyAssertionChain
                },
                {
                    fn EmptyEdgeSpecificProof(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<EdgeChallengeManagerErrors> {
                        <EmptyEdgeSpecificProof as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(EdgeChallengeManagerErrors::EmptyEdgeSpecificProof)
                    }
                    EmptyEdgeSpecificProof
                },
                {
                    fn CachedTimeSufficient(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<EdgeChallengeManagerErrors> {
                        <CachedTimeSufficient as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(EdgeChallengeManagerErrors::CachedTimeSufficient)
                    }
                    CachedTimeSufficient
                },
                {
                    fn EmptyFirstRival(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<EdgeChallengeManagerErrors> {
                        <EmptyFirstRival as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(EdgeChallengeManagerErrors::EmptyFirstRival)
                    }
                    EmptyFirstRival
                },
                {
                    fn RivalEdgeConfirmed(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<EdgeChallengeManagerErrors> {
                        <RivalEdgeConfirmed as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(EdgeChallengeManagerErrors::RivalEdgeConfirmed)
                    }
                    RivalEdgeConfirmed
                },
                {
                    fn InvalidEndHeight(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<EdgeChallengeManagerErrors> {
                        <InvalidEndHeight as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(EdgeChallengeManagerErrors::InvalidEndHeight)
                    }
                    InvalidEndHeight
                },
                {
                    fn OriginIdMutualIdMismatch(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<EdgeChallengeManagerErrors> {
                        <OriginIdMutualIdMismatch as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(EdgeChallengeManagerErrors::OriginIdMutualIdMismatch)
                    }
                    OriginIdMutualIdMismatch
                },
                {
                    fn EdgeNotLayerZero(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<EdgeChallengeManagerErrors> {
                        <EdgeNotLayerZero as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(EdgeChallengeManagerErrors::EdgeNotLayerZero)
                    }
                    EdgeNotLayerZero
                },
                {
                    fn AssertionHashEmpty(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<EdgeChallengeManagerErrors> {
                        <AssertionHashEmpty as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(EdgeChallengeManagerErrors::AssertionHashEmpty)
                    }
                    AssertionHashEmpty
                },
                {
                    fn NotPowerOfTwo(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<EdgeChallengeManagerErrors> {
                        <NotPowerOfTwo as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(EdgeChallengeManagerErrors::NotPowerOfTwo)
                    }
                    NotPowerOfTwo
                },
                {
                    fn NotValidator(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<EdgeChallengeManagerErrors> {
                        <NotValidator as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(EdgeChallengeManagerErrors::NotValidator)
                    }
                    NotValidator
                },
                {
                    fn EdgeNotConfirmed(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<EdgeChallengeManagerErrors> {
                        <EdgeNotConfirmed as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(EdgeChallengeManagerErrors::EdgeNotConfirmed)
                    }
                    EdgeNotConfirmed
                },
                {
                    fn EmptyStaker(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<EdgeChallengeManagerErrors> {
                        <EmptyStaker as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(EdgeChallengeManagerErrors::EmptyStaker)
                    }
                    EmptyStaker
                },
                {
                    fn EmptyOneStepProofEntry(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<EdgeChallengeManagerErrors> {
                        <EmptyOneStepProofEntry as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(EdgeChallengeManagerErrors::EmptyOneStepProofEntry)
                    }
                    EmptyOneStepProofEntry
                },
                {
                    fn MerkleProofTooLong(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<EdgeChallengeManagerErrors> {
                        <MerkleProofTooLong as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(EdgeChallengeManagerErrors::MerkleProofTooLong)
                    }
                    MerkleProofTooLong
                },
                {
                    fn ClaimEdgeNotLengthOneRival(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<EdgeChallengeManagerErrors> {
                        <ClaimEdgeNotLengthOneRival as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(EdgeChallengeManagerErrors::ClaimEdgeNotLengthOneRival)
                    }
                    ClaimEdgeNotLengthOneRival
                },
            ];
            let Ok(idx) = Self::SELECTORS.binary_search(&selector) else {
                return Err(
                    alloy_sol_types::Error::unknown_selector(
                        <Self as alloy_sol_types::SolInterface>::NAME,
                        selector,
                    ),
                );
            };
            DECODE_SHIMS[idx](data, validate)
        }
        #[inline]
        fn abi_encoded_size(&self) -> usize {
            match self {
                Self::AccountHasMadeLayerZeroRival(inner) => {
                    <AccountHasMadeLayerZeroRival as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::AssertionHashEmpty(inner) => {
                    <AssertionHashEmpty as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::AssertionHashMismatch(inner) => {
                    <AssertionHashMismatch as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::AssertionNoSibling(inner) => {
                    <AssertionNoSibling as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::AssertionNotPending(inner) => {
                    <AssertionNotPending as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::BigStepLevelsTooMany(inner) => {
                    <BigStepLevelsTooMany as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::CachedTimeSufficient(inner) => {
                    <CachedTimeSufficient as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::ChildrenAlreadySet(inner) => {
                    <ChildrenAlreadySet as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::ClaimEdgeInvalidLevel(inner) => {
                    <ClaimEdgeInvalidLevel as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::ClaimEdgeNotLengthOneRival(inner) => {
                    <ClaimEdgeNotLengthOneRival as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::ClaimEdgeNotPending(inner) => {
                    <ClaimEdgeNotPending as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::EdgeAlreadyExists(inner) => {
                    <EdgeAlreadyExists as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::EdgeAlreadyRefunded(inner) => {
                    <EdgeAlreadyRefunded as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::EdgeClaimMismatch(inner) => {
                    <EdgeClaimMismatch as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::EdgeLevelInvalid(inner) => {
                    <EdgeLevelInvalid as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::EdgeNotConfirmed(inner) => {
                    <EdgeNotConfirmed as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::EdgeNotExists(inner) => {
                    <EdgeNotExists as alloy_sol_types::SolError>::abi_encoded_size(inner)
                }
                Self::EdgeNotLayerZero(inner) => {
                    <EdgeNotLayerZero as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::EdgeNotLengthOne(inner) => {
                    <EdgeNotLengthOne as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::EdgeNotPending(inner) => {
                    <EdgeNotPending as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::EdgeTypeNotSmallStep(inner) => {
                    <EdgeTypeNotSmallStep as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::EdgeUnrivaled(inner) => {
                    <EdgeUnrivaled as alloy_sol_types::SolError>::abi_encoded_size(inner)
                }
                Self::EmptyArray(inner) => {
                    <EmptyArray as alloy_sol_types::SolError>::abi_encoded_size(inner)
                }
                Self::EmptyAssertionChain(inner) => {
                    <EmptyAssertionChain as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::EmptyChallengePeriod(inner) => {
                    <EmptyChallengePeriod as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::EmptyClaimId(inner) => {
                    <EmptyClaimId as alloy_sol_types::SolError>::abi_encoded_size(inner)
                }
                Self::EmptyEdgeSpecificProof(inner) => {
                    <EmptyEdgeSpecificProof as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::EmptyEndMachineStatus(inner) => {
                    <EmptyEndMachineStatus as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::EmptyEndRoot(inner) => {
                    <EmptyEndRoot as alloy_sol_types::SolError>::abi_encoded_size(inner)
                }
                Self::EmptyFirstRival(inner) => {
                    <EmptyFirstRival as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::EmptyOneStepProofEntry(inner) => {
                    <EmptyOneStepProofEntry as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::EmptyOriginId(inner) => {
                    <EmptyOriginId as alloy_sol_types::SolError>::abi_encoded_size(inner)
                }
                Self::EmptyPrefixProof(inner) => {
                    <EmptyPrefixProof as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::EmptyStakeReceiver(inner) => {
                    <EmptyStakeReceiver as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::EmptyStaker(inner) => {
                    <EmptyStaker as alloy_sol_types::SolError>::abi_encoded_size(inner)
                }
                Self::EmptyStartMachineStatus(inner) => {
                    <EmptyStartMachineStatus as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::EmptyStartRoot(inner) => {
                    <EmptyStartRoot as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::EndHistoryRootMismatch(inner) => {
                    <EndHistoryRootMismatch as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::HeightDiffLtTwo(inner) => {
                    <HeightDiffLtTwo as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::InsufficientConfirmationBlocks(inner) => {
                    <InsufficientConfirmationBlocks as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::InvalidEdgeType(inner) => {
                    <InvalidEdgeType as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::InvalidEndHeight(inner) => {
                    <InvalidEndHeight as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::InvalidHeights(inner) => {
                    <InvalidHeights as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::LevelTooHigh(inner) => {
                    <LevelTooHigh as alloy_sol_types::SolError>::abi_encoded_size(inner)
                }
                Self::MerkleProofTooLong(inner) => {
                    <MerkleProofTooLong as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::NotPowerOfTwo(inner) => {
                    <NotPowerOfTwo as alloy_sol_types::SolError>::abi_encoded_size(inner)
                }
                Self::NotValidator(inner) => {
                    <NotValidator as alloy_sol_types::SolError>::abi_encoded_size(inner)
                }
                Self::OriginIdMutualIdMismatch(inner) => {
                    <OriginIdMutualIdMismatch as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::RivalEdgeConfirmed(inner) => {
                    <RivalEdgeConfirmed as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::StakeAmountsMismatch(inner) => {
                    <StakeAmountsMismatch as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::ZeroBigStepLevels(inner) => {
                    <ZeroBigStepLevels as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
            }
        }
        #[inline]
        fn abi_encode_raw(&self, out: &mut alloy_sol_types::private::Vec<u8>) {
            match self {
                Self::AccountHasMadeLayerZeroRival(inner) => {
                    <AccountHasMadeLayerZeroRival as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::AssertionHashEmpty(inner) => {
                    <AssertionHashEmpty as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::AssertionHashMismatch(inner) => {
                    <AssertionHashMismatch as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::AssertionNoSibling(inner) => {
                    <AssertionNoSibling as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::AssertionNotPending(inner) => {
                    <AssertionNotPending as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::BigStepLevelsTooMany(inner) => {
                    <BigStepLevelsTooMany as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::CachedTimeSufficient(inner) => {
                    <CachedTimeSufficient as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::ChildrenAlreadySet(inner) => {
                    <ChildrenAlreadySet as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::ClaimEdgeInvalidLevel(inner) => {
                    <ClaimEdgeInvalidLevel as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::ClaimEdgeNotLengthOneRival(inner) => {
                    <ClaimEdgeNotLengthOneRival as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::ClaimEdgeNotPending(inner) => {
                    <ClaimEdgeNotPending as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::EdgeAlreadyExists(inner) => {
                    <EdgeAlreadyExists as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::EdgeAlreadyRefunded(inner) => {
                    <EdgeAlreadyRefunded as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::EdgeClaimMismatch(inner) => {
                    <EdgeClaimMismatch as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::EdgeLevelInvalid(inner) => {
                    <EdgeLevelInvalid as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::EdgeNotConfirmed(inner) => {
                    <EdgeNotConfirmed as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::EdgeNotExists(inner) => {
                    <EdgeNotExists as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::EdgeNotLayerZero(inner) => {
                    <EdgeNotLayerZero as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::EdgeNotLengthOne(inner) => {
                    <EdgeNotLengthOne as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::EdgeNotPending(inner) => {
                    <EdgeNotPending as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::EdgeTypeNotSmallStep(inner) => {
                    <EdgeTypeNotSmallStep as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::EdgeUnrivaled(inner) => {
                    <EdgeUnrivaled as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::EmptyArray(inner) => {
                    <EmptyArray as alloy_sol_types::SolError>::abi_encode_raw(inner, out)
                }
                Self::EmptyAssertionChain(inner) => {
                    <EmptyAssertionChain as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::EmptyChallengePeriod(inner) => {
                    <EmptyChallengePeriod as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::EmptyClaimId(inner) => {
                    <EmptyClaimId as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::EmptyEdgeSpecificProof(inner) => {
                    <EmptyEdgeSpecificProof as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::EmptyEndMachineStatus(inner) => {
                    <EmptyEndMachineStatus as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::EmptyEndRoot(inner) => {
                    <EmptyEndRoot as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::EmptyFirstRival(inner) => {
                    <EmptyFirstRival as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::EmptyOneStepProofEntry(inner) => {
                    <EmptyOneStepProofEntry as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::EmptyOriginId(inner) => {
                    <EmptyOriginId as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::EmptyPrefixProof(inner) => {
                    <EmptyPrefixProof as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::EmptyStakeReceiver(inner) => {
                    <EmptyStakeReceiver as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::EmptyStaker(inner) => {
                    <EmptyStaker as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::EmptyStartMachineStatus(inner) => {
                    <EmptyStartMachineStatus as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::EmptyStartRoot(inner) => {
                    <EmptyStartRoot as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::EndHistoryRootMismatch(inner) => {
                    <EndHistoryRootMismatch as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::HeightDiffLtTwo(inner) => {
                    <HeightDiffLtTwo as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::InsufficientConfirmationBlocks(inner) => {
                    <InsufficientConfirmationBlocks as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::InvalidEdgeType(inner) => {
                    <InvalidEdgeType as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::InvalidEndHeight(inner) => {
                    <InvalidEndHeight as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::InvalidHeights(inner) => {
                    <InvalidHeights as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::LevelTooHigh(inner) => {
                    <LevelTooHigh as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::MerkleProofTooLong(inner) => {
                    <MerkleProofTooLong as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::NotPowerOfTwo(inner) => {
                    <NotPowerOfTwo as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::NotValidator(inner) => {
                    <NotValidator as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::OriginIdMutualIdMismatch(inner) => {
                    <OriginIdMutualIdMismatch as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::RivalEdgeConfirmed(inner) => {
                    <RivalEdgeConfirmed as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::StakeAmountsMismatch(inner) => {
                    <StakeAmountsMismatch as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::ZeroBigStepLevels(inner) => {
                    <ZeroBigStepLevels as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
            }
        }
    }
    ///Container for all the [`EdgeChallengeManager`](self) events.
    pub enum EdgeChallengeManagerEvents {
        #[allow(missing_docs)]
        EdgeAdded(EdgeAdded),
        #[allow(missing_docs)]
        EdgeBisected(EdgeBisected),
        #[allow(missing_docs)]
        EdgeConfirmedByOneStepProof(EdgeConfirmedByOneStepProof),
        #[allow(missing_docs)]
        EdgeConfirmedByTime(EdgeConfirmedByTime),
        #[allow(missing_docs)]
        EdgeRefunded(EdgeRefunded),
        #[allow(missing_docs)]
        Initialized(Initialized),
        #[allow(missing_docs)]
        TimerCacheUpdated(TimerCacheUpdated),
    }
    #[automatically_derived]
    impl EdgeChallengeManagerEvents {
        /// All the selectors of this enum.
        ///
        /// Note that the selectors might not be in the same order as the variants.
        /// No guarantees are made about the order of the selectors.
        ///
        /// Prefer using `SolInterface` methods instead.
        pub const SELECTORS: &'static [[u8; 32usize]] = &[
            [
                46u8,
                8u8,
                8u8,
                131u8,
                10u8,
                34u8,
                32u8,
                76u8,
                179u8,
                251u8,
                143u8,
                141u8,
                120u8,
                75u8,
                40u8,
                188u8,
                151u8,
                233u8,
                206u8,
                46u8,
                57u8,
                210u8,
                249u8,
                205u8,
                226u8,
                134u8,
                13u8,
                224u8,
                149u8,
                125u8,
                104u8,
                235u8,
            ],
            [
                115u8,
                64u8,
                81u8,
                13u8,
                36u8,
                183u8,
                236u8,
                155u8,
                92u8,
                16u8,
                15u8,
                85u8,
                0u8,
                217u8,
                52u8,
                41u8,
                216u8,
                13u8,
                0u8,
                212u8,
                111u8,
                13u8,
                24u8,
                228u8,
                232u8,
                93u8,
                12u8,
                76u8,
                194u8,
                43u8,
                153u8,
                36u8,
            ],
            [
                127u8,
                38u8,
                184u8,
                63u8,
                249u8,
                110u8,
                31u8,
                43u8,
                106u8,
                104u8,
                47u8,
                19u8,
                56u8,
                82u8,
                246u8,
                121u8,
                138u8,
                9u8,
                196u8,
                101u8,
                218u8,
                149u8,
                146u8,
                20u8,
                96u8,
                206u8,
                251u8,
                56u8,
                71u8,
                64u8,
                36u8,
                152u8,
            ],
            [
                166u8,
                53u8,
                57u8,
                137u8,
                89u8,
                221u8,
                181u8,
                206u8,
                59u8,
                20u8,
                83u8,
                126u8,
                223u8,
                194u8,
                91u8,
                46u8,
                103u8,
                18u8,
                116u8,
                201u8,
                184u8,
                202u8,
                208u8,
                244u8,
                189u8,
                99u8,
                71u8,
                82u8,
                230u8,
                144u8,
                7u8,
                182u8,
            ],
            [
                170u8,
                75u8,
                102u8,
                177u8,
                206u8,
                147u8,
                140u8,
                6u8,
                226u8,
                163u8,
                248u8,
                70u8,
                107u8,
                174u8,
                16u8,
                239u8,
                98u8,
                231u8,
                71u8,
                99u8,
                14u8,
                56u8,
                89u8,
                136u8,
                159u8,
                71u8,
                25u8,
                252u8,
                100u8,
                39u8,
                181u8,
                164u8,
            ],
            [
                190u8,
                23u8,
                117u8,
                93u8,
                141u8,
                131u8,
                106u8,
                214u8,
                123u8,
                250u8,
                248u8,
                229u8,
                179u8,
                134u8,
                154u8,
                237u8,
                180u8,
                203u8,
                160u8,
                63u8,
                41u8,
                90u8,
                22u8,
                124u8,
                85u8,
                71u8,
                254u8,
                221u8,
                217u8,
                239u8,
                80u8,
                173u8,
            ],
            [
                225u8,
                29u8,
                180u8,
                178u8,
                123u8,
                200u8,
                198u8,
                234u8,
                89u8,
                67u8,
                236u8,
                187u8,
                32u8,
                90u8,
                225u8,
                202u8,
                141u8,
                86u8,
                196u8,
                44u8,
                113u8,
                151u8,
                23u8,
                170u8,
                248u8,
                165u8,
                61u8,
                67u8,
                208u8,
                206u8,
                231u8,
                194u8,
            ],
        ];
    }
    #[automatically_derived]
    impl alloy_sol_types::SolEventInterface for EdgeChallengeManagerEvents {
        const NAME: &'static str = "EdgeChallengeManagerEvents";
        const COUNT: usize = 7usize;
        fn decode_raw_log(
            topics: &[alloy_sol_types::Word],
            data: &[u8],
            validate: bool,
        ) -> alloy_sol_types::Result<Self> {
            match topics.first().copied() {
                Some(<EdgeAdded as alloy_sol_types::SolEvent>::SIGNATURE_HASH) => {
                    <EdgeAdded as alloy_sol_types::SolEvent>::decode_raw_log(
                            topics,
                            data,
                            validate,
                        )
                        .map(Self::EdgeAdded)
                }
                Some(<EdgeBisected as alloy_sol_types::SolEvent>::SIGNATURE_HASH) => {
                    <EdgeBisected as alloy_sol_types::SolEvent>::decode_raw_log(
                            topics,
                            data,
                            validate,
                        )
                        .map(Self::EdgeBisected)
                }
                Some(
                    <EdgeConfirmedByOneStepProof as alloy_sol_types::SolEvent>::SIGNATURE_HASH,
                ) => {
                    <EdgeConfirmedByOneStepProof as alloy_sol_types::SolEvent>::decode_raw_log(
                            topics,
                            data,
                            validate,
                        )
                        .map(Self::EdgeConfirmedByOneStepProof)
                }
                Some(
                    <EdgeConfirmedByTime as alloy_sol_types::SolEvent>::SIGNATURE_HASH,
                ) => {
                    <EdgeConfirmedByTime as alloy_sol_types::SolEvent>::decode_raw_log(
                            topics,
                            data,
                            validate,
                        )
                        .map(Self::EdgeConfirmedByTime)
                }
                Some(<EdgeRefunded as alloy_sol_types::SolEvent>::SIGNATURE_HASH) => {
                    <EdgeRefunded as alloy_sol_types::SolEvent>::decode_raw_log(
                            topics,
                            data,
                            validate,
                        )
                        .map(Self::EdgeRefunded)
                }
                Some(<Initialized as alloy_sol_types::SolEvent>::SIGNATURE_HASH) => {
                    <Initialized as alloy_sol_types::SolEvent>::decode_raw_log(
                            topics,
                            data,
                            validate,
                        )
                        .map(Self::Initialized)
                }
                Some(
                    <TimerCacheUpdated as alloy_sol_types::SolEvent>::SIGNATURE_HASH,
                ) => {
                    <TimerCacheUpdated as alloy_sol_types::SolEvent>::decode_raw_log(
                            topics,
                            data,
                            validate,
                        )
                        .map(Self::TimerCacheUpdated)
                }
                _ => {
                    alloy_sol_types::private::Err(alloy_sol_types::Error::InvalidLog {
                        name: <Self as alloy_sol_types::SolEventInterface>::NAME,
                        log: alloy_sol_types::private::Box::new(
                            alloy_sol_types::private::LogData::new_unchecked(
                                topics.to_vec(),
                                data.to_vec().into(),
                            ),
                        ),
                    })
                }
            }
        }
    }
    #[automatically_derived]
    impl alloy_sol_types::private::IntoLogData for EdgeChallengeManagerEvents {
        fn to_log_data(&self) -> alloy_sol_types::private::LogData {
            match self {
                Self::EdgeAdded(inner) => {
                    alloy_sol_types::private::IntoLogData::to_log_data(inner)
                }
                Self::EdgeBisected(inner) => {
                    alloy_sol_types::private::IntoLogData::to_log_data(inner)
                }
                Self::EdgeConfirmedByOneStepProof(inner) => {
                    alloy_sol_types::private::IntoLogData::to_log_data(inner)
                }
                Self::EdgeConfirmedByTime(inner) => {
                    alloy_sol_types::private::IntoLogData::to_log_data(inner)
                }
                Self::EdgeRefunded(inner) => {
                    alloy_sol_types::private::IntoLogData::to_log_data(inner)
                }
                Self::Initialized(inner) => {
                    alloy_sol_types::private::IntoLogData::to_log_data(inner)
                }
                Self::TimerCacheUpdated(inner) => {
                    alloy_sol_types::private::IntoLogData::to_log_data(inner)
                }
            }
        }
        fn into_log_data(self) -> alloy_sol_types::private::LogData {
            match self {
                Self::EdgeAdded(inner) => {
                    alloy_sol_types::private::IntoLogData::into_log_data(inner)
                }
                Self::EdgeBisected(inner) => {
                    alloy_sol_types::private::IntoLogData::into_log_data(inner)
                }
                Self::EdgeConfirmedByOneStepProof(inner) => {
                    alloy_sol_types::private::IntoLogData::into_log_data(inner)
                }
                Self::EdgeConfirmedByTime(inner) => {
                    alloy_sol_types::private::IntoLogData::into_log_data(inner)
                }
                Self::EdgeRefunded(inner) => {
                    alloy_sol_types::private::IntoLogData::into_log_data(inner)
                }
                Self::Initialized(inner) => {
                    alloy_sol_types::private::IntoLogData::into_log_data(inner)
                }
                Self::TimerCacheUpdated(inner) => {
                    alloy_sol_types::private::IntoLogData::into_log_data(inner)
                }
            }
        }
    }
    use alloy::contract as alloy_contract;
    /**Creates a new wrapper around an on-chain [`EdgeChallengeManager`](self) contract instance.

See the [wrapper's documentation](`EdgeChallengeManagerInstance`) for more details.*/
    #[inline]
    pub const fn new<
        T: alloy_contract::private::Transport + ::core::clone::Clone,
        P: alloy_contract::private::Provider<T, N>,
        N: alloy_contract::private::Network,
    >(
        address: alloy_sol_types::private::Address,
        provider: P,
    ) -> EdgeChallengeManagerInstance<T, P, N> {
        EdgeChallengeManagerInstance::<T, P, N>::new(address, provider)
    }
    /**Deploys this contract using the given `provider` and constructor arguments, if any.

Returns a new instance of the contract, if the deployment was successful.

For more fine-grained control over the deployment process, use [`deploy_builder`] instead.*/
    #[inline]
    pub fn deploy<
        T: alloy_contract::private::Transport + ::core::clone::Clone,
        P: alloy_contract::private::Provider<T, N>,
        N: alloy_contract::private::Network,
    >(
        provider: P,
    ) -> impl ::core::future::Future<
        Output = alloy_contract::Result<EdgeChallengeManagerInstance<T, P, N>>,
    > {
        EdgeChallengeManagerInstance::<T, P, N>::deploy(provider)
    }
    /**Creates a `RawCallBuilder` for deploying this contract using the given `provider`
and constructor arguments, if any.

This is a simple wrapper around creating a `RawCallBuilder` with the data set to
the bytecode concatenated with the constructor's ABI-encoded arguments.*/
    #[inline]
    pub fn deploy_builder<
        T: alloy_contract::private::Transport + ::core::clone::Clone,
        P: alloy_contract::private::Provider<T, N>,
        N: alloy_contract::private::Network,
    >(provider: P) -> alloy_contract::RawCallBuilder<T, P, N> {
        EdgeChallengeManagerInstance::<T, P, N>::deploy_builder(provider)
    }
    /**A [`EdgeChallengeManager`](self) instance.

Contains type-safe methods for interacting with an on-chain instance of the
[`EdgeChallengeManager`](self) contract located at a given `address`, using a given
provider `P`.

If the contract bytecode is available (see the [`sol!`](alloy_sol_types::sol!)
documentation on how to provide it), the `deploy` and `deploy_builder` methods can
be used to deploy a new instance of the contract.

See the [module-level documentation](self) for all the available methods.*/
    #[derive(Clone)]
    pub struct EdgeChallengeManagerInstance<
        T,
        P,
        N = alloy_contract::private::Ethereum,
    > {
        address: alloy_sol_types::private::Address,
        provider: P,
        _network_transport: ::core::marker::PhantomData<(N, T)>,
    }
    #[automatically_derived]
    impl<T, P, N> ::core::fmt::Debug for EdgeChallengeManagerInstance<T, P, N> {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
            f.debug_tuple("EdgeChallengeManagerInstance").field(&self.address).finish()
        }
    }
    /// Instantiation and getters/setters.
    #[automatically_derived]
    impl<
        T: alloy_contract::private::Transport + ::core::clone::Clone,
        P: alloy_contract::private::Provider<T, N>,
        N: alloy_contract::private::Network,
    > EdgeChallengeManagerInstance<T, P, N> {
        /**Creates a new wrapper around an on-chain [`EdgeChallengeManager`](self) contract instance.

See the [wrapper's documentation](`EdgeChallengeManagerInstance`) for more details.*/
        #[inline]
        pub const fn new(
            address: alloy_sol_types::private::Address,
            provider: P,
        ) -> Self {
            Self {
                address,
                provider,
                _network_transport: ::core::marker::PhantomData,
            }
        }
        /**Deploys this contract using the given `provider` and constructor arguments, if any.

Returns a new instance of the contract, if the deployment was successful.

For more fine-grained control over the deployment process, use [`deploy_builder`] instead.*/
        #[inline]
        pub async fn deploy(
            provider: P,
        ) -> alloy_contract::Result<EdgeChallengeManagerInstance<T, P, N>> {
            let call_builder = Self::deploy_builder(provider);
            let contract_address = call_builder.deploy().await?;
            Ok(Self::new(contract_address, call_builder.provider))
        }
        /**Creates a `RawCallBuilder` for deploying this contract using the given `provider`
and constructor arguments, if any.

This is a simple wrapper around creating a `RawCallBuilder` with the data set to
the bytecode concatenated with the constructor's ABI-encoded arguments.*/
        #[inline]
        pub fn deploy_builder(provider: P) -> alloy_contract::RawCallBuilder<T, P, N> {
            alloy_contract::RawCallBuilder::new_raw_deploy(
                provider,
                ::core::clone::Clone::clone(&BYTECODE),
            )
        }
        /// Returns a reference to the address.
        #[inline]
        pub const fn address(&self) -> &alloy_sol_types::private::Address {
            &self.address
        }
        /// Sets the address.
        #[inline]
        pub fn set_address(&mut self, address: alloy_sol_types::private::Address) {
            self.address = address;
        }
        /// Sets the address and returns `self`.
        pub fn at(mut self, address: alloy_sol_types::private::Address) -> Self {
            self.set_address(address);
            self
        }
        /// Returns a reference to the provider.
        #[inline]
        pub const fn provider(&self) -> &P {
            &self.provider
        }
    }
    impl<T, P: ::core::clone::Clone, N> EdgeChallengeManagerInstance<T, &P, N> {
        /// Clones the provider and returns a new instance with the cloned provider.
        #[inline]
        pub fn with_cloned_provider(self) -> EdgeChallengeManagerInstance<T, P, N> {
            EdgeChallengeManagerInstance {
                address: self.address,
                provider: ::core::clone::Clone::clone(&self.provider),
                _network_transport: ::core::marker::PhantomData,
            }
        }
    }
    /// Function calls.
    #[automatically_derived]
    impl<
        T: alloy_contract::private::Transport + ::core::clone::Clone,
        P: alloy_contract::private::Provider<T, N>,
        N: alloy_contract::private::Network,
    > EdgeChallengeManagerInstance<T, P, N> {
        /// Creates a new call builder using this contract instance's provider and address.
        ///
        /// Note that the call can be any function call, not just those defined in this
        /// contract. Prefer using the other methods for building type-safe contract calls.
        pub fn call_builder<C: alloy_sol_types::SolCall>(
            &self,
            call: &C,
        ) -> alloy_contract::SolCallBuilder<T, &P, C, N> {
            alloy_contract::SolCallBuilder::new_sol(&self.provider, &self.address, call)
        }
        ///Creates a new call builder for the [`LAYERZERO_BIGSTEPEDGE_HEIGHT`] function.
        pub fn LAYERZERO_BIGSTEPEDGE_HEIGHT(
            &self,
        ) -> alloy_contract::SolCallBuilder<T, &P, LAYERZERO_BIGSTEPEDGE_HEIGHTCall, N> {
            self.call_builder(
                &LAYERZERO_BIGSTEPEDGE_HEIGHTCall {
                },
            )
        }
        ///Creates a new call builder for the [`LAYERZERO_BLOCKEDGE_HEIGHT`] function.
        pub fn LAYERZERO_BLOCKEDGE_HEIGHT(
            &self,
        ) -> alloy_contract::SolCallBuilder<T, &P, LAYERZERO_BLOCKEDGE_HEIGHTCall, N> {
            self.call_builder(&LAYERZERO_BLOCKEDGE_HEIGHTCall {})
        }
        ///Creates a new call builder for the [`LAYERZERO_SMALLSTEPEDGE_HEIGHT`] function.
        pub fn LAYERZERO_SMALLSTEPEDGE_HEIGHT(
            &self,
        ) -> alloy_contract::SolCallBuilder<
            T,
            &P,
            LAYERZERO_SMALLSTEPEDGE_HEIGHTCall,
            N,
        > {
            self.call_builder(
                &LAYERZERO_SMALLSTEPEDGE_HEIGHTCall {
                },
            )
        }
        ///Creates a new call builder for the [`NUM_BIGSTEP_LEVEL`] function.
        pub fn NUM_BIGSTEP_LEVEL(
            &self,
        ) -> alloy_contract::SolCallBuilder<T, &P, NUM_BIGSTEP_LEVELCall, N> {
            self.call_builder(&NUM_BIGSTEP_LEVELCall {})
        }
        ///Creates a new call builder for the [`assertionChain`] function.
        pub fn assertionChain(
            &self,
        ) -> alloy_contract::SolCallBuilder<T, &P, assertionChainCall, N> {
            self.call_builder(&assertionChainCall {})
        }
        ///Creates a new call builder for the [`bisectEdge`] function.
        pub fn bisectEdge(
            &self,
            edgeId: alloy::sol_types::private::FixedBytes<32>,
            bisectionHistoryRoot: alloy::sol_types::private::FixedBytes<32>,
            prefixProof: alloy::sol_types::private::Bytes,
        ) -> alloy_contract::SolCallBuilder<T, &P, bisectEdgeCall, N> {
            self.call_builder(
                &bisectEdgeCall {
                    edgeId,
                    bisectionHistoryRoot,
                    prefixProof,
                },
            )
        }
        ///Creates a new call builder for the [`calculateEdgeId`] function.
        pub fn calculateEdgeId(
            &self,
            level: u8,
            originId: alloy::sol_types::private::FixedBytes<32>,
            startHeight: alloy::sol_types::private::primitives::aliases::U256,
            startHistoryRoot: alloy::sol_types::private::FixedBytes<32>,
            endHeight: alloy::sol_types::private::primitives::aliases::U256,
            endHistoryRoot: alloy::sol_types::private::FixedBytes<32>,
        ) -> alloy_contract::SolCallBuilder<T, &P, calculateEdgeIdCall, N> {
            self.call_builder(
                &calculateEdgeIdCall {
                    level,
                    originId,
                    startHeight,
                    startHistoryRoot,
                    endHeight,
                    endHistoryRoot,
                },
            )
        }
        ///Creates a new call builder for the [`calculateMutualId`] function.
        pub fn calculateMutualId(
            &self,
            level: u8,
            originId: alloy::sol_types::private::FixedBytes<32>,
            startHeight: alloy::sol_types::private::primitives::aliases::U256,
            startHistoryRoot: alloy::sol_types::private::FixedBytes<32>,
            endHeight: alloy::sol_types::private::primitives::aliases::U256,
        ) -> alloy_contract::SolCallBuilder<T, &P, calculateMutualIdCall, N> {
            self.call_builder(
                &calculateMutualIdCall {
                    level,
                    originId,
                    startHeight,
                    startHistoryRoot,
                    endHeight,
                },
            )
        }
        ///Creates a new call builder for the [`challengePeriodBlocks`] function.
        pub fn challengePeriodBlocks(
            &self,
        ) -> alloy_contract::SolCallBuilder<T, &P, challengePeriodBlocksCall, N> {
            self.call_builder(&challengePeriodBlocksCall {})
        }
        ///Creates a new call builder for the [`confirmEdgeByOneStepProof`] function.
        pub fn confirmEdgeByOneStepProof(
            &self,
            edgeId: alloy::sol_types::private::FixedBytes<32>,
            oneStepData: <OneStepData as alloy::sol_types::SolType>::RustType,
            prevConfig: <ConfigData as alloy::sol_types::SolType>::RustType,
            beforeHistoryInclusionProof: alloy::sol_types::private::Vec<
                alloy::sol_types::private::FixedBytes<32>,
            >,
            afterHistoryInclusionProof: alloy::sol_types::private::Vec<
                alloy::sol_types::private::FixedBytes<32>,
            >,
        ) -> alloy_contract::SolCallBuilder<T, &P, confirmEdgeByOneStepProofCall, N> {
            self.call_builder(
                &confirmEdgeByOneStepProofCall {
                    edgeId,
                    oneStepData,
                    prevConfig,
                    beforeHistoryInclusionProof,
                    afterHistoryInclusionProof,
                },
            )
        }
        ///Creates a new call builder for the [`confirmEdgeByTime`] function.
        pub fn confirmEdgeByTime(
            &self,
            edgeId: alloy::sol_types::private::FixedBytes<32>,
            claimStateData: <AssertionStateData as alloy::sol_types::SolType>::RustType,
        ) -> alloy_contract::SolCallBuilder<T, &P, confirmEdgeByTimeCall, N> {
            self.call_builder(
                &confirmEdgeByTimeCall {
                    edgeId,
                    claimStateData,
                },
            )
        }
        ///Creates a new call builder for the [`confirmedRival`] function.
        pub fn confirmedRival(
            &self,
            mutualId: alloy::sol_types::private::FixedBytes<32>,
        ) -> alloy_contract::SolCallBuilder<T, &P, confirmedRivalCall, N> {
            self.call_builder(&confirmedRivalCall { mutualId })
        }
        ///Creates a new call builder for the [`createLayerZeroEdge`] function.
        pub fn createLayerZeroEdge(
            &self,
            args: <CreateEdgeArgs as alloy::sol_types::SolType>::RustType,
        ) -> alloy_contract::SolCallBuilder<T, &P, createLayerZeroEdgeCall, N> {
            self.call_builder(&createLayerZeroEdgeCall { args })
        }
        ///Creates a new call builder for the [`edgeExists`] function.
        pub fn edgeExists(
            &self,
            edgeId: alloy::sol_types::private::FixedBytes<32>,
        ) -> alloy_contract::SolCallBuilder<T, &P, edgeExistsCall, N> {
            self.call_builder(&edgeExistsCall { edgeId })
        }
        ///Creates a new call builder for the [`edgeLength`] function.
        pub fn edgeLength(
            &self,
            edgeId: alloy::sol_types::private::FixedBytes<32>,
        ) -> alloy_contract::SolCallBuilder<T, &P, edgeLengthCall, N> {
            self.call_builder(&edgeLengthCall { edgeId })
        }
        ///Creates a new call builder for the [`excessStakeReceiver`] function.
        pub fn excessStakeReceiver(
            &self,
        ) -> alloy_contract::SolCallBuilder<T, &P, excessStakeReceiverCall, N> {
            self.call_builder(&excessStakeReceiverCall {})
        }
        ///Creates a new call builder for the [`firstRival`] function.
        pub fn firstRival(
            &self,
            mutualId: alloy::sol_types::private::FixedBytes<32>,
        ) -> alloy_contract::SolCallBuilder<T, &P, firstRivalCall, N> {
            self.call_builder(&firstRivalCall { mutualId })
        }
        ///Creates a new call builder for the [`getEdge`] function.
        pub fn getEdge(
            &self,
            edgeId: alloy::sol_types::private::FixedBytes<32>,
        ) -> alloy_contract::SolCallBuilder<T, &P, getEdgeCall, N> {
            self.call_builder(&getEdgeCall { edgeId })
        }
        ///Creates a new call builder for the [`getLayerZeroEndHeight`] function.
        pub fn getLayerZeroEndHeight(
            &self,
            eType: <EdgeType as alloy::sol_types::SolType>::RustType,
        ) -> alloy_contract::SolCallBuilder<T, &P, getLayerZeroEndHeightCall, N> {
            self.call_builder(&getLayerZeroEndHeightCall { eType })
        }
        ///Creates a new call builder for the [`getPrevAssertionHash`] function.
        pub fn getPrevAssertionHash(
            &self,
            edgeId: alloy::sol_types::private::FixedBytes<32>,
        ) -> alloy_contract::SolCallBuilder<T, &P, getPrevAssertionHashCall, N> {
            self.call_builder(&getPrevAssertionHashCall { edgeId })
        }
        ///Creates a new call builder for the [`hasLengthOneRival`] function.
        pub fn hasLengthOneRival(
            &self,
            edgeId: alloy::sol_types::private::FixedBytes<32>,
        ) -> alloy_contract::SolCallBuilder<T, &P, hasLengthOneRivalCall, N> {
            self.call_builder(&hasLengthOneRivalCall { edgeId })
        }
        ///Creates a new call builder for the [`hasMadeLayerZeroRival`] function.
        pub fn hasMadeLayerZeroRival(
            &self,
            account: alloy::sol_types::private::Address,
            mutualId: alloy::sol_types::private::FixedBytes<32>,
        ) -> alloy_contract::SolCallBuilder<T, &P, hasMadeLayerZeroRivalCall, N> {
            self.call_builder(
                &hasMadeLayerZeroRivalCall {
                    account,
                    mutualId,
                },
            )
        }
        ///Creates a new call builder for the [`hasRival`] function.
        pub fn hasRival(
            &self,
            edgeId: alloy::sol_types::private::FixedBytes<32>,
        ) -> alloy_contract::SolCallBuilder<T, &P, hasRivalCall, N> {
            self.call_builder(&hasRivalCall { edgeId })
        }
        ///Creates a new call builder for the [`initialize`] function.
        pub fn initialize(
            &self,
            _assertionChain: alloy::sol_types::private::Address,
            _challengePeriodBlocks: u64,
            _oneStepProofEntry: alloy::sol_types::private::Address,
            layerZeroBlockEdgeHeight: alloy::sol_types::private::primitives::aliases::U256,
            layerZeroBigStepEdgeHeight: alloy::sol_types::private::primitives::aliases::U256,
            layerZeroSmallStepEdgeHeight: alloy::sol_types::private::primitives::aliases::U256,
            _stakeToken: alloy::sol_types::private::Address,
            _excessStakeReceiver: alloy::sol_types::private::Address,
            _numBigStepLevel: u8,
            _stakeAmounts: alloy::sol_types::private::Vec<
                alloy::sol_types::private::primitives::aliases::U256,
            >,
        ) -> alloy_contract::SolCallBuilder<T, &P, initializeCall, N> {
            self.call_builder(
                &initializeCall {
                    _assertionChain,
                    _challengePeriodBlocks,
                    _oneStepProofEntry,
                    layerZeroBlockEdgeHeight,
                    layerZeroBigStepEdgeHeight,
                    layerZeroSmallStepEdgeHeight,
                    _stakeToken,
                    _excessStakeReceiver,
                    _numBigStepLevel,
                    _stakeAmounts,
                },
            )
        }
        ///Creates a new call builder for the [`multiUpdateTimeCacheByChildren`] function.
        pub fn multiUpdateTimeCacheByChildren(
            &self,
            edgeIds: alloy::sol_types::private::Vec<
                alloy::sol_types::private::FixedBytes<32>,
            >,
            maximumCachedTime: alloy::sol_types::private::primitives::aliases::U256,
        ) -> alloy_contract::SolCallBuilder<
            T,
            &P,
            multiUpdateTimeCacheByChildrenCall,
            N,
        > {
            self.call_builder(
                &multiUpdateTimeCacheByChildrenCall {
                    edgeIds,
                    maximumCachedTime,
                },
            )
        }
        ///Creates a new call builder for the [`oneStepProofEntry`] function.
        pub fn oneStepProofEntry(
            &self,
        ) -> alloy_contract::SolCallBuilder<T, &P, oneStepProofEntryCall, N> {
            self.call_builder(&oneStepProofEntryCall {})
        }
        ///Creates a new call builder for the [`refundStake`] function.
        pub fn refundStake(
            &self,
            edgeId: alloy::sol_types::private::FixedBytes<32>,
        ) -> alloy_contract::SolCallBuilder<T, &P, refundStakeCall, N> {
            self.call_builder(&refundStakeCall { edgeId })
        }
        ///Creates a new call builder for the [`stakeAmounts`] function.
        pub fn stakeAmounts(
            &self,
            _0: alloy::sol_types::private::primitives::aliases::U256,
        ) -> alloy_contract::SolCallBuilder<T, &P, stakeAmountsCall, N> {
            self.call_builder(&stakeAmountsCall { _0 })
        }
        ///Creates a new call builder for the [`stakeToken`] function.
        pub fn stakeToken(
            &self,
        ) -> alloy_contract::SolCallBuilder<T, &P, stakeTokenCall, N> {
            self.call_builder(&stakeTokenCall {})
        }
        ///Creates a new call builder for the [`timeUnrivaled`] function.
        pub fn timeUnrivaled(
            &self,
            edgeId: alloy::sol_types::private::FixedBytes<32>,
        ) -> alloy_contract::SolCallBuilder<T, &P, timeUnrivaledCall, N> {
            self.call_builder(&timeUnrivaledCall { edgeId })
        }
        ///Creates a new call builder for the [`updateTimerCacheByChildren`] function.
        pub fn updateTimerCacheByChildren(
            &self,
            edgeId: alloy::sol_types::private::FixedBytes<32>,
            maximumCachedTime: alloy::sol_types::private::primitives::aliases::U256,
        ) -> alloy_contract::SolCallBuilder<T, &P, updateTimerCacheByChildrenCall, N> {
            self.call_builder(
                &updateTimerCacheByChildrenCall {
                    edgeId,
                    maximumCachedTime,
                },
            )
        }
        ///Creates a new call builder for the [`updateTimerCacheByClaim`] function.
        pub fn updateTimerCacheByClaim(
            &self,
            edgeId: alloy::sol_types::private::FixedBytes<32>,
            claimingEdgeId: alloy::sol_types::private::FixedBytes<32>,
            maximumCachedTime: alloy::sol_types::private::primitives::aliases::U256,
        ) -> alloy_contract::SolCallBuilder<T, &P, updateTimerCacheByClaimCall, N> {
            self.call_builder(
                &updateTimerCacheByClaimCall {
                    edgeId,
                    claimingEdgeId,
                    maximumCachedTime,
                },
            )
        }
    }
    /// Event filters.
    #[automatically_derived]
    impl<
        T: alloy_contract::private::Transport + ::core::clone::Clone,
        P: alloy_contract::private::Provider<T, N>,
        N: alloy_contract::private::Network,
    > EdgeChallengeManagerInstance<T, P, N> {
        /// Creates a new event filter using this contract instance's provider and address.
        ///
        /// Note that the type can be any event, not just those defined in this contract.
        /// Prefer using the other methods for building type-safe event filters.
        pub fn event_filter<E: alloy_sol_types::SolEvent>(
            &self,
        ) -> alloy_contract::Event<T, &P, E, N> {
            alloy_contract::Event::new_sol(&self.provider, &self.address)
        }
        ///Creates a new event filter for the [`EdgeAdded`] event.
        pub fn EdgeAdded_filter(&self) -> alloy_contract::Event<T, &P, EdgeAdded, N> {
            self.event_filter::<EdgeAdded>()
        }
        ///Creates a new event filter for the [`EdgeBisected`] event.
        pub fn EdgeBisected_filter(
            &self,
        ) -> alloy_contract::Event<T, &P, EdgeBisected, N> {
            self.event_filter::<EdgeBisected>()
        }
        ///Creates a new event filter for the [`EdgeConfirmedByOneStepProof`] event.
        pub fn EdgeConfirmedByOneStepProof_filter(
            &self,
        ) -> alloy_contract::Event<T, &P, EdgeConfirmedByOneStepProof, N> {
            self.event_filter::<EdgeConfirmedByOneStepProof>()
        }
        ///Creates a new event filter for the [`EdgeConfirmedByTime`] event.
        pub fn EdgeConfirmedByTime_filter(
            &self,
        ) -> alloy_contract::Event<T, &P, EdgeConfirmedByTime, N> {
            self.event_filter::<EdgeConfirmedByTime>()
        }
        ///Creates a new event filter for the [`EdgeRefunded`] event.
        pub fn EdgeRefunded_filter(
            &self,
        ) -> alloy_contract::Event<T, &P, EdgeRefunded, N> {
            self.event_filter::<EdgeRefunded>()
        }
        ///Creates a new event filter for the [`Initialized`] event.
        pub fn Initialized_filter(
            &self,
        ) -> alloy_contract::Event<T, &P, Initialized, N> {
            self.event_filter::<Initialized>()
        }
        ///Creates a new event filter for the [`TimerCacheUpdated`] event.
        pub fn TimerCacheUpdated_filter(
            &self,
        ) -> alloy_contract::Event<T, &P, TimerCacheUpdated, N> {
            self.event_filter::<TimerCacheUpdated>()
        }
    }
}
