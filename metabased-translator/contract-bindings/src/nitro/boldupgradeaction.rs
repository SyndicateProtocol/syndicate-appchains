/**

Generated by the following Solidity interface...
```solidity
interface BOLDUpgradeAction {
    struct BufferConfig {
        uint64 threshold;
        uint64 max;
        uint64 replenishRateInBasis;
    }
    struct Contracts {
        address excessStakeReceiver;
        address rollup;
        address bridge;
        address sequencerInbox;
        address rollupEventInbox;
        address outbox;
        address inbox;
        address osp;
    }
    struct Implementations {
        address bridge;
        address seqInbox;
        address inbox;
        address rei;
        address outbox;
        address newRollupUser;
        address newRollupAdmin;
        address challengeManager;
    }
    struct ProxyAdmins {
        address outbox;
        address bridge;
        address rei;
        address seqInbox;
        address inbox;
    }
    struct Settings {
        uint64 confirmPeriodBlocks;
        uint64 challengePeriodBlocks;
        address stakeToken;
        uint256 stakeAmt;
        uint256[] miniStakeAmounts;
        uint256 chainId;
        uint256 minimumAssertionPeriod;
        uint64 validatorAfkBlocks;
        bool disableValidatorWhitelist;
        uint256 blockLeafSize;
        uint256 bigStepLeafSize;
        uint256 smallStepLeafSize;
        uint8 numBigStepLevel;
        uint64 challengeGracePeriodBlocks;
        bool isDelayBufferable;
        BufferConfig bufferConfig;
    }

    event RollupMigrated(address rollup, address challengeManager);

    constructor(Contracts contracts, ProxyAdmins proxyAdmins, Implementations implementations, Settings settings);

    function BIGSTEP_LEAF_SIZE() external view returns (uint256);
    function BLOCK_LEAF_SIZE() external view returns (uint256);
    function BRIDGE() external view returns (address);
    function CHAIN_ID() external view returns (uint256);
    function CHALLENGE_GRACE_PERIOD_BLOCKS() external view returns (uint64);
    function CHALLENGE_PERIOD_BLOCKS() external view returns (uint64);
    function CONFIRM_PERIOD_BLOCKS() external view returns (uint64);
    function DISABLE_VALIDATOR_WHITELIST() external view returns (bool);
    function EXCESS_STAKE_RECEIVER() external view returns (address);
    function IMPL_BRIDGE() external view returns (address);
    function IMPL_CHALLENGE_MANAGER() external view returns (address);
    function IMPL_INBOX() external view returns (address);
    function IMPL_NEW_ROLLUP_ADMIN() external view returns (address);
    function IMPL_NEW_ROLLUP_USER() external view returns (address);
    function IMPL_OUTBOX() external view returns (address);
    function IMPL_REI() external view returns (address);
    function IMPL_SEQUENCER_INBOX() external view returns (address);
    function INBOX() external view returns (address);
    function IS_DELAY_BUFFERABLE() external view returns (bool);
    function MAX() external view returns (uint64);
    function MINIMUM_ASSERTION_PERIOD() external view returns (uint256);
    function MINI_STAKE_AMOUNTS_STORAGE() external view returns (address);
    function NUM_BIGSTEP_LEVEL() external view returns (uint8);
    function OLD_ROLLUP() external view returns (address);
    function OSP() external view returns (address);
    function OUTBOX() external view returns (address);
    function PREIMAGE_LOOKUP() external view returns (address);
    function PROXY_ADMIN_BRIDGE() external view returns (address);
    function PROXY_ADMIN_INBOX() external view returns (address);
    function PROXY_ADMIN_OUTBOX() external view returns (address);
    function PROXY_ADMIN_REI() external view returns (address);
    function PROXY_ADMIN_SEQUENCER_INBOX() external view returns (address);
    function REI() external view returns (address);
    function REPLENISH_RATE_IN_BASIS() external view returns (uint64);
    function SECONDS_PER_SLOT() external view returns (uint256);
    function SEQ_INBOX() external view returns (address);
    function SMALLSTEP_LEAF_SIZE() external view returns (uint256);
    function STAKE_AMOUNT() external view returns (uint256);
    function STAKE_TOKEN() external view returns (address);
    function THRESHOLD() external view returns (uint64);
    function VALIDATOR_AFK_BLOCKS() external view returns (uint64);
    function expectedRollupAddress(address deployer, uint256 chainId) external pure returns (address);
    function perform(address[] memory validators) external;
    function validateRollupDeployedAtAddress(address rollupAddress, address deployer, uint256 chainId) external view;
}
```

...which was generated by the following JSON ABI:
```json
[
  {
    "type": "constructor",
    "inputs": [
      {
        "name": "contracts",
        "type": "tuple",
        "internalType": "struct BOLDUpgradeAction.Contracts",
        "components": [
          {
            "name": "excessStakeReceiver",
            "type": "address",
            "internalType": "address"
          },
          {
            "name": "rollup",
            "type": "address",
            "internalType": "contract IOldRollup"
          },
          {
            "name": "bridge",
            "type": "address",
            "internalType": "address"
          },
          {
            "name": "sequencerInbox",
            "type": "address",
            "internalType": "address"
          },
          {
            "name": "rollupEventInbox",
            "type": "address",
            "internalType": "address"
          },
          {
            "name": "outbox",
            "type": "address",
            "internalType": "address"
          },
          {
            "name": "inbox",
            "type": "address",
            "internalType": "address"
          },
          {
            "name": "osp",
            "type": "address",
            "internalType": "contract IOneStepProofEntry"
          }
        ]
      },
      {
        "name": "proxyAdmins",
        "type": "tuple",
        "internalType": "struct BOLDUpgradeAction.ProxyAdmins",
        "components": [
          {
            "name": "outbox",
            "type": "address",
            "internalType": "address"
          },
          {
            "name": "bridge",
            "type": "address",
            "internalType": "address"
          },
          {
            "name": "rei",
            "type": "address",
            "internalType": "address"
          },
          {
            "name": "seqInbox",
            "type": "address",
            "internalType": "address"
          },
          {
            "name": "inbox",
            "type": "address",
            "internalType": "address"
          }
        ]
      },
      {
        "name": "implementations",
        "type": "tuple",
        "internalType": "struct BOLDUpgradeAction.Implementations",
        "components": [
          {
            "name": "bridge",
            "type": "address",
            "internalType": "address"
          },
          {
            "name": "seqInbox",
            "type": "address",
            "internalType": "address"
          },
          {
            "name": "inbox",
            "type": "address",
            "internalType": "address"
          },
          {
            "name": "rei",
            "type": "address",
            "internalType": "address"
          },
          {
            "name": "outbox",
            "type": "address",
            "internalType": "address"
          },
          {
            "name": "newRollupUser",
            "type": "address",
            "internalType": "address"
          },
          {
            "name": "newRollupAdmin",
            "type": "address",
            "internalType": "address"
          },
          {
            "name": "challengeManager",
            "type": "address",
            "internalType": "address"
          }
        ]
      },
      {
        "name": "settings",
        "type": "tuple",
        "internalType": "struct BOLDUpgradeAction.Settings",
        "components": [
          {
            "name": "confirmPeriodBlocks",
            "type": "uint64",
            "internalType": "uint64"
          },
          {
            "name": "challengePeriodBlocks",
            "type": "uint64",
            "internalType": "uint64"
          },
          {
            "name": "stakeToken",
            "type": "address",
            "internalType": "address"
          },
          {
            "name": "stakeAmt",
            "type": "uint256",
            "internalType": "uint256"
          },
          {
            "name": "miniStakeAmounts",
            "type": "uint256[]",
            "internalType": "uint256[]"
          },
          {
            "name": "chainId",
            "type": "uint256",
            "internalType": "uint256"
          },
          {
            "name": "minimumAssertionPeriod",
            "type": "uint256",
            "internalType": "uint256"
          },
          {
            "name": "validatorAfkBlocks",
            "type": "uint64",
            "internalType": "uint64"
          },
          {
            "name": "disableValidatorWhitelist",
            "type": "bool",
            "internalType": "bool"
          },
          {
            "name": "blockLeafSize",
            "type": "uint256",
            "internalType": "uint256"
          },
          {
            "name": "bigStepLeafSize",
            "type": "uint256",
            "internalType": "uint256"
          },
          {
            "name": "smallStepLeafSize",
            "type": "uint256",
            "internalType": "uint256"
          },
          {
            "name": "numBigStepLevel",
            "type": "uint8",
            "internalType": "uint8"
          },
          {
            "name": "challengeGracePeriodBlocks",
            "type": "uint64",
            "internalType": "uint64"
          },
          {
            "name": "isDelayBufferable",
            "type": "bool",
            "internalType": "bool"
          },
          {
            "name": "bufferConfig",
            "type": "tuple",
            "internalType": "struct BufferConfig",
            "components": [
              {
                "name": "threshold",
                "type": "uint64",
                "internalType": "uint64"
              },
              {
                "name": "max",
                "type": "uint64",
                "internalType": "uint64"
              },
              {
                "name": "replenishRateInBasis",
                "type": "uint64",
                "internalType": "uint64"
              }
            ]
          }
        ]
      }
    ],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "BIGSTEP_LEAF_SIZE",
    "inputs": [],
    "outputs": [
      {
        "name": "",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "BLOCK_LEAF_SIZE",
    "inputs": [],
    "outputs": [
      {
        "name": "",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "BRIDGE",
    "inputs": [],
    "outputs": [
      {
        "name": "",
        "type": "address",
        "internalType": "address"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "CHAIN_ID",
    "inputs": [],
    "outputs": [
      {
        "name": "",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "CHALLENGE_GRACE_PERIOD_BLOCKS",
    "inputs": [],
    "outputs": [
      {
        "name": "",
        "type": "uint64",
        "internalType": "uint64"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "CHALLENGE_PERIOD_BLOCKS",
    "inputs": [],
    "outputs": [
      {
        "name": "",
        "type": "uint64",
        "internalType": "uint64"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "CONFIRM_PERIOD_BLOCKS",
    "inputs": [],
    "outputs": [
      {
        "name": "",
        "type": "uint64",
        "internalType": "uint64"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "DISABLE_VALIDATOR_WHITELIST",
    "inputs": [],
    "outputs": [
      {
        "name": "",
        "type": "bool",
        "internalType": "bool"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "EXCESS_STAKE_RECEIVER",
    "inputs": [],
    "outputs": [
      {
        "name": "",
        "type": "address",
        "internalType": "address"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "IMPL_BRIDGE",
    "inputs": [],
    "outputs": [
      {
        "name": "",
        "type": "address",
        "internalType": "address"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "IMPL_CHALLENGE_MANAGER",
    "inputs": [],
    "outputs": [
      {
        "name": "",
        "type": "address",
        "internalType": "address"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "IMPL_INBOX",
    "inputs": [],
    "outputs": [
      {
        "name": "",
        "type": "address",
        "internalType": "address"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "IMPL_NEW_ROLLUP_ADMIN",
    "inputs": [],
    "outputs": [
      {
        "name": "",
        "type": "address",
        "internalType": "address"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "IMPL_NEW_ROLLUP_USER",
    "inputs": [],
    "outputs": [
      {
        "name": "",
        "type": "address",
        "internalType": "address"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "IMPL_OUTBOX",
    "inputs": [],
    "outputs": [
      {
        "name": "",
        "type": "address",
        "internalType": "address"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "IMPL_REI",
    "inputs": [],
    "outputs": [
      {
        "name": "",
        "type": "address",
        "internalType": "address"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "IMPL_SEQUENCER_INBOX",
    "inputs": [],
    "outputs": [
      {
        "name": "",
        "type": "address",
        "internalType": "address"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "INBOX",
    "inputs": [],
    "outputs": [
      {
        "name": "",
        "type": "address",
        "internalType": "address"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "IS_DELAY_BUFFERABLE",
    "inputs": [],
    "outputs": [
      {
        "name": "",
        "type": "bool",
        "internalType": "bool"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "MAX",
    "inputs": [],
    "outputs": [
      {
        "name": "",
        "type": "uint64",
        "internalType": "uint64"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "MINIMUM_ASSERTION_PERIOD",
    "inputs": [],
    "outputs": [
      {
        "name": "",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "MINI_STAKE_AMOUNTS_STORAGE",
    "inputs": [],
    "outputs": [
      {
        "name": "",
        "type": "address",
        "internalType": "address"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "NUM_BIGSTEP_LEVEL",
    "inputs": [],
    "outputs": [
      {
        "name": "",
        "type": "uint8",
        "internalType": "uint8"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "OLD_ROLLUP",
    "inputs": [],
    "outputs": [
      {
        "name": "",
        "type": "address",
        "internalType": "contract IOldRollup"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "OSP",
    "inputs": [],
    "outputs": [
      {
        "name": "",
        "type": "address",
        "internalType": "contract IOneStepProofEntry"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "OUTBOX",
    "inputs": [],
    "outputs": [
      {
        "name": "",
        "type": "address",
        "internalType": "address"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "PREIMAGE_LOOKUP",
    "inputs": [],
    "outputs": [
      {
        "name": "",
        "type": "address",
        "internalType": "contract StateHashPreImageLookup"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "PROXY_ADMIN_BRIDGE",
    "inputs": [],
    "outputs": [
      {
        "name": "",
        "type": "address",
        "internalType": "contract ProxyAdmin"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "PROXY_ADMIN_INBOX",
    "inputs": [],
    "outputs": [
      {
        "name": "",
        "type": "address",
        "internalType": "contract ProxyAdmin"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "PROXY_ADMIN_OUTBOX",
    "inputs": [],
    "outputs": [
      {
        "name": "",
        "type": "address",
        "internalType": "contract ProxyAdmin"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "PROXY_ADMIN_REI",
    "inputs": [],
    "outputs": [
      {
        "name": "",
        "type": "address",
        "internalType": "contract ProxyAdmin"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "PROXY_ADMIN_SEQUENCER_INBOX",
    "inputs": [],
    "outputs": [
      {
        "name": "",
        "type": "address",
        "internalType": "contract ProxyAdmin"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "REI",
    "inputs": [],
    "outputs": [
      {
        "name": "",
        "type": "address",
        "internalType": "address"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "REPLENISH_RATE_IN_BASIS",
    "inputs": [],
    "outputs": [
      {
        "name": "",
        "type": "uint64",
        "internalType": "uint64"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "SECONDS_PER_SLOT",
    "inputs": [],
    "outputs": [
      {
        "name": "",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "SEQ_INBOX",
    "inputs": [],
    "outputs": [
      {
        "name": "",
        "type": "address",
        "internalType": "address"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "SMALLSTEP_LEAF_SIZE",
    "inputs": [],
    "outputs": [
      {
        "name": "",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "STAKE_AMOUNT",
    "inputs": [],
    "outputs": [
      {
        "name": "",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "STAKE_TOKEN",
    "inputs": [],
    "outputs": [
      {
        "name": "",
        "type": "address",
        "internalType": "address"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "THRESHOLD",
    "inputs": [],
    "outputs": [
      {
        "name": "",
        "type": "uint64",
        "internalType": "uint64"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "VALIDATOR_AFK_BLOCKS",
    "inputs": [],
    "outputs": [
      {
        "name": "",
        "type": "uint64",
        "internalType": "uint64"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "expectedRollupAddress",
    "inputs": [
      {
        "name": "deployer",
        "type": "address",
        "internalType": "address"
      },
      {
        "name": "chainId",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "address",
        "internalType": "address"
      }
    ],
    "stateMutability": "pure"
  },
  {
    "type": "function",
    "name": "perform",
    "inputs": [
      {
        "name": "validators",
        "type": "address[]",
        "internalType": "address[]"
      }
    ],
    "outputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "validateRollupDeployedAtAddress",
    "inputs": [
      {
        "name": "rollupAddress",
        "type": "address",
        "internalType": "address"
      },
      {
        "name": "deployer",
        "type": "address",
        "internalType": "address"
      },
      {
        "name": "chainId",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "outputs": [],
    "stateMutability": "view"
  },
  {
    "type": "event",
    "name": "RollupMigrated",
    "inputs": [
      {
        "name": "rollup",
        "type": "address",
        "indexed": false,
        "internalType": "address"
      },
      {
        "name": "challengeManager",
        "type": "address",
        "indexed": false,
        "internalType": "address"
      }
    ],
    "anonymous": false
  }
]
```*/
#[allow(
    non_camel_case_types,
    non_snake_case,
    clippy::pub_underscore_fields,
    clippy::style,
    clippy::empty_structs_with_brackets
)]
pub mod BOLDUpgradeAction {
    use super::*;
    use alloy::sol_types as alloy_sol_types;
    /// The creation / init bytecode of the contract.
    ///
    /// ```text
    ///0x610580604052348015610010575f80fd5b50604051616f67380380616f6783398101604081905261002f91610699565b83516001600160a01b039081166101005260208086015182166101205260408087015183166101405260608088015184166101605260808089015185166101805260a089015185166101a05260c089015185166101c05260e089015185166103a052875185166103c0529287015184166103e052868201518416610400528601518316610420529085015190911661044052516100cb90610258565b604051809103905ff0801580156100e4573d5f803e3d5ffd5b506001600160a01b0390811661046052825181166104805260208084015182166104a05260408085015183166104c05260608086015184166104e05260808087015185166105005260a08088015186166105205260c08089015187166105405260e0808a01518816610560529188015161026052870151610280528601516001600160401b039081166102a052865181166101e05293860151909316610200528482015190931661022052918301516102405282015190516101a590610265565b6101af91906107a0565b604051809103905ff0801580156101c8573d5f803e3d5ffd5b506001600160a01b03166103005261010081015115156102c05261012081015160805261014081015160a05261016081015160c05261018081015160ff1660e0526101a08101516001600160401b039081166102e0526101c08201511515610320526101e090910180516020015182166103405280515182166103605251604001511661038052506107e3915050565b6109f6806162e683390190565b61028b80616cdc83390190565b634e487b7160e01b5f52604160045260245ffd5b60405161010081016001600160401b03811182821017156102a9576102a9610272565b60405290565b60405161020081016001600160401b03811182821017156102a9576102a9610272565b6001600160a01b03811681146102e6575f80fd5b50565b80516102f4816102d2565b919050565b5f60a08284031215610309575f80fd5b60405160a081016001600160401b038111828210171561032b5761032b610272565b8060405250809150825161033e816102d2565b8152602083015161034e816102d2565b60208201526040830151610361816102d2565b60408201526060830151610374816102d2565b60608201526080830151610387816102d2565b6080919091015292915050565b5f61010082840312156103a5575f80fd5b6103ad610286565b905081516103ba816102d2565b815260208201516103ca816102d2565b60208201526103db604083016102e9565b60408201526103ec606083016102e9565b60608201526103fd608083016102e9565b608082015261040e60a083016102e9565b60a082015261041f60c083016102e9565b60c082015261043060e083016102e9565b60e082015292915050565b80516001600160401b03811681146102f4575f80fd5b5f82601f830112610460575f80fd5b815160206001600160401b038083111561047c5761047c610272565b8260051b604051601f19603f830116810181811084821117156104a1576104a1610272565b60405293845260208187018101949081019250878511156104c0575f80fd5b6020870191505b848210156104e0578151835291830191908301906104c7565b979650505050505050565b805180151581146102f4575f80fd5b805160ff811681146102f4575f80fd5b5f6060828403121561051a575f80fd5b604051606081016001600160401b038111828210171561053c5761053c610272565b60405290508061054b8361043b565b81526105596020840161043b565b602082015261056a6040840161043b565b60408201525092915050565b5f6102408284031215610587575f80fd5b61058f6102af565b905061059a8261043b565b81526105a86020830161043b565b60208201526105b9604083016102e9565b60408201526060828101519082015260808201516001600160401b038111156105e0575f80fd5b6105ec84828501610451565b60808301525060a082015160a082015260c082015160c082015261061260e0830161043b565b60e08201526101006106258184016104eb565b908201526101208281015190820152610140808301519082015261016080830151908201526101806106588184016104fa565b908201526101a061066a83820161043b565b908201526101c061067c8382016104eb565b908201526101e061068f8484830161050a565b9082015292915050565b5f805f808486036102c08112156106ae575f80fd5b610100808212156106bd575f80fd5b6106c5610286565b915086516106d2816102d2565b82526106e0602088016102e9565b60208301526106f1604088016102e9565b6040830152610702606088016102e9565b6060830152610713608088016102e9565b608083015261072460a088016102e9565b60a083015261073560c088016102e9565b60c083015261074660e088016102e9565b60e083015281955061075a888289016102f9565b9450505061076c866101a08701610394565b6102a08601519092506001600160401b03811115610788575f80fd5b61079487828801610576565b91505092959194509250565b602080825282518282018190525f9190848201906040850190845b818110156107d7578351835292840192918401916001016107bb565b50909695505050505050565b60805160a05160c05160e05161010051610120516101405161016051610180516101a0516101c0516101e05161020051610220516102405161026051610280516102a0516102c0516102e05161030051610320516103405161036051610380516103a0516103c0516103e05161040051610420516104405161046051610480516104a0516104c0516104e05161050051610520516105405161056051615793610b535f395f81816103f10152610ab101525f81816103240152610c4701525f81816104f60152610c7601525f81816107eb015261223a01525f818161079d015261210c01525f8181610619015261204c01525f81816107c4015281816123e4015261258e01525f81816108870152611ef301525f8181610812015281816119750152611a3201525f818161051d015261207501525f81816104a0015281816123b401526125b601525f81816104cf015261213601525f818161038a01528181610ad20152611f1c01525f8181610363015261226401525f81816106ca0152610dae01525f81816108d5015261247001525f81816105f2015261241001525f8181610860015261244001525f81816108ae015261238e01525f81816107280152611d3301525f818161090f0152611e7601525f81816106f10152818161116e01526111ba01525f81816105440152611d0301525f81816102ea0152611cdd01525f81816106400152611ca301525f81816109840152611bba01525f818161043f0152611b8b01525f818161068e0152610d8d01525f81816103b10152611b5b01525f818161074f01528181610bab015261202301525f818161041801528181610bda0152818161221101526122be01525f818161077601528181610c09015281816120e3015261219001525f818161083901528181610b7c0152818161236d01528181612614015281816126e8015261278101525f818161093601528181610b4d01528181611eca0152611fab01525f818161066701528181610ca501528181610fcc0152818161122401528181611469015281816114d8015281816115c7015281816116750152818161177401528181611811015281816118400152611be001525f81816105cb01528181610de60152611c7401525f818161056b0152611e4d01525f818161095d0152611e0c01525f81816104660152611de601525f81816105a40152611dc001526157935ff3fe608060405234801561000f575f80fd5b50600436106102e1575f3560e01c80638765240f11610187578063cc8089bb116100dd578063eb657a4e11610093578063ee9a31a21161006e578063ee9a31a214610931578063fa28742014610958578063faf5625f1461097f575f80fd5b8063eb657a4e146108d0578063ebe03a93146108f7578063ec4f74ce1461090a575f80fd5b8063d49d5181116100c3578063d49d51811461085b578063dae7cb8b14610882578063e8180c29146108a9575f80fd5b8063cc8089bb1461080d578063d384cb9514610834575f80fd5b8063b5e00c3f1161013d578063c21c423311610118578063c21c423314610798578063c519d151146107bf578063c897f55e146107e6575f80fd5b8063b5e00c3f14610723578063b70106971461074a578063be41b36714610771575f80fd5b8063999f20db1161016d578063999f20db146106b05780639f9854e5146106c5578063b38d57f0146106ec575f80fd5b80638765240f1461066257806391ddb28514610689575f80fd5b8063304b90711161023c5780635d9e2444116101f2578063785ffb37116101cd578063785ffb37146105ed578063817cd3121461061457806385e1f4d01461063b575f80fd5b80635d9e244414610566578063609fb5031461059f57806364f4992a146105c6575f80fd5b80634692de5d116102225780634692de5d146104f15780634b2f51ef146105185780634ceccfe51461053f575f80fd5b8063304b9071146104c25780633c2b7840146104ca575f80fd5b806310a662e21161029c5780631ccc2cd1116102775780631ccc2cd11461046157806328fb228c146104885780632cfb7ca31461049b575f80fd5b806310a662e2146103ec5780631b142ea7146104135780631c39b6721461043a575f80fd5b80630787484b116102cc5780630787484b1461035e5780630a54257d146103855780631047fc52146103ac575f80fd5b80623c78fb146102e5578062f9731e1461031f575b5f80fd5b61030c7f000000000000000000000000000000000000000000000000000000000000000081565b6040519081526020015b60405180910390f35b6103467f000000000000000000000000000000000000000000000000000000000000000081565b6040516001600160a01b039091168152602001610316565b6103467f000000000000000000000000000000000000000000000000000000000000000081565b6103467f000000000000000000000000000000000000000000000000000000000000000081565b6103d37f000000000000000000000000000000000000000000000000000000000000000081565b60405167ffffffffffffffff9091168152602001610316565b6103467f000000000000000000000000000000000000000000000000000000000000000081565b6103467f000000000000000000000000000000000000000000000000000000000000000081565b6103467f000000000000000000000000000000000000000000000000000000000000000081565b61030c7f000000000000000000000000000000000000000000000000000000000000000081565b6103466104963660046129b1565b6109a6565b6103467f000000000000000000000000000000000000000000000000000000000000000081565b61030c600c81565b6103467f000000000000000000000000000000000000000000000000000000000000000081565b6103467f000000000000000000000000000000000000000000000000000000000000000081565b6103467f000000000000000000000000000000000000000000000000000000000000000081565b6103d37f000000000000000000000000000000000000000000000000000000000000000081565b61058d7f000000000000000000000000000000000000000000000000000000000000000081565b60405160ff9091168152602001610316565b61030c7f000000000000000000000000000000000000000000000000000000000000000081565b6103467f000000000000000000000000000000000000000000000000000000000000000081565b6103d37f000000000000000000000000000000000000000000000000000000000000000081565b6103467f000000000000000000000000000000000000000000000000000000000000000081565b61030c7f000000000000000000000000000000000000000000000000000000000000000081565b6103467f000000000000000000000000000000000000000000000000000000000000000081565b6103d37f000000000000000000000000000000000000000000000000000000000000000081565b6106c36106be3660046129db565b610a12565b005b6103467f000000000000000000000000000000000000000000000000000000000000000081565b6107137f000000000000000000000000000000000000000000000000000000000000000081565b6040519015158152602001610316565b6103467f000000000000000000000000000000000000000000000000000000000000000081565b6103467f000000000000000000000000000000000000000000000000000000000000000081565b6103467f000000000000000000000000000000000000000000000000000000000000000081565b6103467f000000000000000000000000000000000000000000000000000000000000000081565b6103467f000000000000000000000000000000000000000000000000000000000000000081565b6103467f000000000000000000000000000000000000000000000000000000000000000081565b6103467f000000000000000000000000000000000000000000000000000000000000000081565b6103467f000000000000000000000000000000000000000000000000000000000000000081565b6103d37f000000000000000000000000000000000000000000000000000000000000000081565b6103467f000000000000000000000000000000000000000000000000000000000000000081565b6107137f000000000000000000000000000000000000000000000000000000000000000081565b6103d37f000000000000000000000000000000000000000000000000000000000000000081565b6106c3610905366004612ace565b610a9b565b6103d37f000000000000000000000000000000000000000000000000000000000000000081565b6103467f000000000000000000000000000000000000000000000000000000000000000081565b61030c7f000000000000000000000000000000000000000000000000000000000000000081565b61030c7f000000000000000000000000000000000000000000000000000000000000000081565b5f80826040516020016109bb91815260200190565b604051602081830303815290604052805190602001209050610a0881604051806020016109e7906127f5565b6020820181038252601f19601f8201166040525080519060200120866113df565b9150505b92915050565b5f836001600160a01b03163b118015610a455750826001600160a01b0316610a3a83836109a6565b6001600160a01b0316145b610a965760405162461bcd60e51b815260206004820152600d60248201527f414444525f4d49534d415443480000000000000000000000000000000000000060448201526064015b60405180910390fd5b505050565b610aa3611467565b5f610aac611806565b90505f7f00000000000000000000000000000000000000000000000000000000000000007f0000000000000000000000000000000000000000000000000000000000000000604051610afd90612802565b6001600160a01b039283168152911660208201526060604082018190525f90820152608001604051809103905ff080158015610b3b573d5f803e3d5ffd5b5090505f6040518061012001604052807f00000000000000000000000000000000000000000000000000000000000000006001600160a01b031681526020017f00000000000000000000000000000000000000000000000000000000000000006001600160a01b031681526020017f00000000000000000000000000000000000000000000000000000000000000006001600160a01b031681526020017f00000000000000000000000000000000000000000000000000000000000000006001600160a01b031681526020017f00000000000000000000000000000000000000000000000000000000000000006001600160a01b03168152602001836001600160a01b031681526020017f00000000000000000000000000000000000000000000000000000000000000006001600160a01b031681526020017f00000000000000000000000000000000000000000000000000000000000000006001600160a01b031681526020017f00000000000000000000000000000000000000000000000000000000000000006001600160a01b031663bc45e0ae6040518163ffffffff1660e01b8152600401602060405180830381865afa158015610cff573d5f803e3d5ffd5b505050506040513d601f19601f82011682018060405250810190610d239190612b68565b6001600160a01b031681525090505f8360c00151604051602001610d4991815260200190565b6040516020818303038152906040528051906020012090505f610d70308660c001516109a6565b9050610d7b81611eb3565b836001600160a01b0316631a72d54c827f00000000000000000000000000000000000000000000000000000000000000007f00000000000000000000000000000000000000000000000000000000000000008961018001518a6101a001518b6101c001518c602001517f00000000000000000000000000000000000000000000000000000000000000008e61024001518f61014001516040518b63ffffffff1660e01b8152600401610e369a99989796959493929190612b83565b5f604051808303815f87803b158015610e4d575f80fd5b505af1158015610e5f573d5f803e3d5ffd5b505050505f82604051610e71906127f5565b8190604051809103905ff5905080158015610e8e573d5f803e3d5ffd5b509050816001600160a01b0316816001600160a01b031614610ef25760405162461bcd60e51b815260206004820152601560248201527f554e455850435445445f524f4c4c55505f4144445200000000000000000000006044820152606401610a8d565b608086018051309091526040517fadfef6ac0000000000000000000000000000000000000000000000000000000081526001600160a01b0383169063adfef6ac90610f43908a908990600401612e1a565b5f604051808303815f87803b158015610f5a575f80fd5b505af1158015610f6c573d5f803e3d5ffd5b5050505087515f1461116c575f885167ffffffffffffffff811115610f9357610f93612a19565b604051908082528060200260200182016040528015610fbc578160200160208202803683370190505b5090505f5b89518110156110f5577f00000000000000000000000000000000000000000000000000000000000000006001600160a01b031663facd743b8b838151811061100b5761100b613031565b60200260200101516040518263ffffffff1660e01b815260040161103e91906001600160a01b0391909116815260200190565b602060405180830381865afa158015611059573d5f803e3d5ffd5b505050506040513d601f19601f8201168201806040525081019061107d9190613059565b6110c95760405162461bcd60e51b815260206004820152601860248201527f554e45585045435445445f4e45575f56414c494441544f5200000000000000006044820152606401610a8d565b60018282815181106110dd576110dd613031565b91151560209283029190910190910152600101610fc1565b506040517fa3ffb7720000000000000000000000000000000000000000000000000000000081526001600160a01b0384169063a3ffb7729061113d908c9085906004016130aa565b5f604051808303815f87803b158015611154575f80fd5b505af1158015611166573d5f803e3d5ffd5b50505050505b7f000000000000000000000000000000000000000000000000000000000000000015611222576040517fa2b4f1d80000000000000000000000000000000000000000000000000000000081527f0000000000000000000000000000000000000000000000000000000000000000151560048201526001600160a01b0383169063a2b4f1d8906024015f604051808303815f87803b15801561120b575f80fd5b505af115801561121d573d5f803e3d5ffd5b505050505b7f00000000000000000000000000000000000000000000000000000000000000006001600160a01b03166355840a586040518163ffffffff1660e01b8152600401602060405180830381865afa92505050801561129c575060408051601f3d908101601f1916820190925261129991810190612b68565b60015b15611322576001600160a01b03811615611320576040517f0d561b370000000000000000000000000000000000000000000000000000000081526001600160a01b038281166004830152841690630d561b37906024015f604051808303815f87803b158015611309575f80fd5b505af115801561131b573d5f803e3d5ffd5b505050505b505b6040517f13af40350000000000000000000000000000000000000000000000000000000081526001600160a01b0382811660048301528316906313af4035906024015f604051808303815f87803b15801561137b575f80fd5b505af115801561138d573d5f803e3d5ffd5b5050604080516001600160a01b0380881682528a1660208201527f7e5cc5c3fce046d868d5918548df8d3e8ef9f09e6fb30a68081f1f1348cd0314935001905060405180910390a15050505050505050565b604080517fff00000000000000000000000000000000000000000000000000000000000000602080830191909152606084901b7fffffffffffffffffffffffffffffffffffffffff00000000000000000000000016602183015260358201869052605580830186905283518084039091018152607590920190925280519101205b9392505050565b7f00000000000000000000000000000000000000000000000000000000000000006001600160a01b0316638456cb596040518163ffffffff1660e01b81526004015f604051808303815f87803b1580156114bf575f80fd5b505af11580156114d1573d5f803e3d5ffd5b505050505f7f00000000000000000000000000000000000000000000000000000000000000006001600160a01b031663dff697876040518163ffffffff1660e01b8152600401602060405180830381865afa158015611532573d5f803e3d5ffd5b505050506040513d601f19601f820116820180604052508101906115569190613118565b905060328167ffffffffffffffff16111561156f575060325b5f5b8167ffffffffffffffff168167ffffffffffffffff161015611802576040517f6ddd374400000000000000000000000000000000000000000000000000000000815267ffffffffffffffff821660048201525f907f00000000000000000000000000000000000000000000000000000000000000006001600160a01b031690636ddd374490602401602060405180830381865afa158015611614573d5f803e3d5ffd5b505050506040513d601f19601f820116820180604052508101906116389190612b68565b6040517fa23c44b10000000000000000000000000000000000000000000000000000000081526001600160a01b0380831660048301529192505f917f0000000000000000000000000000000000000000000000000000000000000000169063a23c44b19060240160a060405180830381865afa1580156116ba573d5f803e3d5ffd5b505050506040513d601f19601f820116820180604052508101906116de9190613131565b9050806080015180156116fd5750606081015167ffffffffffffffff16155b156117ed576040805160018082528183019092525f916020808301908036833701905050905082815f8151811061173657611736613031565b6001600160a01b0392831660209182029290920101526040517f7c75c2980000000000000000000000000000000000000000000000000000000081527f000000000000000000000000000000000000000000000000000000000000000090911690637c75c298906117ab9084906004016131b6565b5f604051808303815f87803b1580156117c2575f80fd5b505af11580156117d4573d5f803e3d5ffd5b505050506001856117e591906131dc565b9450506117fb565b826117f781613204565b9350505b5050611571565b5050565b61180e61280f565b5f7f00000000000000000000000000000000000000000000000000000000000000006001600160a01b03166392c8134c7f00000000000000000000000000000000000000000000000000000000000000006001600160a01b03166365f7f80d6040518163ffffffff1660e01b8152600401602060405180830381865afa15801561189a573d5f803e3d5ffd5b505050506040513d601f19601f820116820180604052508101906118be9190613118565b6040517fffffffff0000000000000000000000000000000000000000000000000000000060e084901b16815267ffffffffffffffff909116600482015260240161018060405180830381865afa15801561191a573d5f803e3d5ffd5b505050506040513d601f19601f8201168201806040525081019061193e919061322a565b516040517f8eaa6ac0000000000000000000000000000000000000000000000000000000008152600481018290529091505f9081907f00000000000000000000000000000000000000000000000000000000000000006001600160a01b031690638eaa6ac09060240160c060405180830381865afa1580156119c2573d5f803e3d5ffd5b505050506040513d601f19601f820116820180604052508101906119e6919061335c565b915091506119f261291d565b82518152602080840151908201906002811115611a1157611a11612cf8565b90816002811115611a2457611a24612cf8565b905250836001600160a01b037f0000000000000000000000000000000000000000000000000000000000000000166331644130611a6084612331565b856040518363ffffffff1660e01b8152600401611a7e929190613416565b602060405180830381865afa158015611a99573d5f803e3d5ffd5b505050506040513d601f19601f82011682018060405250810190611abd9190613448565b14611b0a5760405162461bcd60e51b815260206004820152601d60248201527f496e76616c6964206c617465737420657865637574696f6e20686173680000006044820152606401610a8d565b611b3160405180608001604052805f81526020015f81526020015f81526020015f81525090565b604080516060810182525f8082526020820181905291810191909152604051806102a001604052807f000000000000000000000000000000000000000000000000000000000000000067ffffffffffffffff1681526020017f00000000000000000000000000000000000000000000000000000000000000006001600160a01b031681526020017f000000000000000000000000000000000000000000000000000000000000000081526020017f00000000000000000000000000000000000000000000000000000000000000006001600160a01b0316638ee1a1266040518163ffffffff1660e01b8152600401602060405180830381865afa158015611c3a573d5f803e3d5ffd5b505050506040513d601f19601f82011682018060405250810190611c5e9190613448565b8152602001306001600160a01b031681526020017f00000000000000000000000000000000000000000000000000000000000000006001600160a01b031681526020017f0000000000000000000000000000000000000000000000000000000000000000815260200160405180602001604052805f81525081526020017f000000000000000000000000000000000000000000000000000000000000000081526020017f000000000000000000000000000000000000000000000000000000000000000067ffffffffffffffff1681526020017f00000000000000000000000000000000000000000000000000000000000000006001600160a01b031663b0ec2ae16040518163ffffffff1660e01b81526004015f60405180830381865afa158015611d8c573d5f803e3d5ffd5b505050506040513d5f823e601f3d908101601f19168201604052611db3919081019061345f565b81526020018381526020017f000000000000000000000000000000000000000000000000000000000000000081526020017f000000000000000000000000000000000000000000000000000000000000000081526020017f000000000000000000000000000000000000000000000000000000000000000081526020018481526020018581526020015f6001600160a01b031681526020017f000000000000000000000000000000000000000000000000000000000000000060ff1681526020017f000000000000000000000000000000000000000000000000000000000000000067ffffffffffffffff16815260200182815250965050505050505090565b60405163266a23b160e21b81526001600160a01b037f000000000000000000000000000000000000000000000000000000000000000081811660048401527f000000000000000000000000000000000000000000000000000000000000000082166024840152917f0000000000000000000000000000000000000000000000000000000000000000909116906399a88ec4906044015f604051808303815f87803b158015611f5f575f80fd5b505af1158015611f71573d5f803e3d5ffd5b50506040517f919cc7060000000000000000000000000000000000000000000000000000000081526001600160a01b0385811660048301527f000000000000000000000000000000000000000000000000000000000000000016925063919cc70691506024015f604051808303815f87803b158015611fee575f80fd5b505af1158015612000573d5f803e3d5ffd5b5050505061200c61236b565b60405163266a23b160e21b81526001600160a01b037f000000000000000000000000000000000000000000000000000000000000000081811660048401527f000000000000000000000000000000000000000000000000000000000000000082166024840152917f0000000000000000000000000000000000000000000000000000000000000000909116906399a88ec4906044015f604051808303815f87803b1580156120b8575f80fd5b505af11580156120ca573d5f803e3d5ffd5b505060405163266a23b160e21b81526001600160a01b037f000000000000000000000000000000000000000000000000000000000000000081811660048401527f00000000000000000000000000000000000000000000000000000000000000008216602484015293507f00000000000000000000000000000000000000000000000000000000000000001691506399a88ec4906044015f604051808303815f87803b158015612178575f80fd5b505af115801561218a573d5f803e3d5ffd5b505050507f00000000000000000000000000000000000000000000000000000000000000006001600160a01b0316636ae71f126040518163ffffffff1660e01b81526004015f604051808303815f87803b1580156121e6575f80fd5b505af11580156121f8573d5f803e3d5ffd5b505060405163266a23b160e21b81526001600160a01b037f000000000000000000000000000000000000000000000000000000000000000081811660048401527f00000000000000000000000000000000000000000000000000000000000000008216602484015293507f00000000000000000000000000000000000000000000000000000000000000001691506399a88ec4906044015f604051808303815f87803b1580156122a6575f80fd5b505af11580156122b8573d5f803e3d5ffd5b505050507f00000000000000000000000000000000000000000000000000000000000000006001600160a01b0316636ae71f126040518163ffffffff1660e01b81526004015f604051808303815f87803b158015612314575f80fd5b505af1158015612326573d5f803e3d5ffd5b505050505050505050565b612339612942565b6040518060400160405280835f015181526020018360200151600281111561236357612363612cf8565b905292915050565b7f00000000000000000000000000000000000000000000000000000000000000007f00000000000000000000000000000000000000000000000000000000000000001561256f577f00000000000000000000000000000000000000000000000000000000000000006001600160a01b0316639623609d827f000000000000000000000000000000000000000000000000000000000000000060405180606001604052807f000000000000000000000000000000000000000000000000000000000000000067ffffffffffffffff1681526020017f000000000000000000000000000000000000000000000000000000000000000067ffffffffffffffff1681526020017f000000000000000000000000000000000000000000000000000000000000000067ffffffffffffffff168152506040516024016124ac91906134e0565b60408051601f198184030181529181526020820180517bffffffffffffffffffffffffffffffffffffffffffffffffffffffff167fa655d93700000000000000000000000000000000000000000000000000000000179052517fffffffff0000000000000000000000000000000000000000000000000000000060e086901b16815261253d93929190600401613511565b5f604051808303815f87803b158015612554575f80fd5b505af1158015612566573d5f803e3d5ffd5b5050505061260e565b60405163266a23b160e21b81526001600160a01b0382811660048301527f0000000000000000000000000000000000000000000000000000000000000000811660248301527f000000000000000000000000000000000000000000000000000000000000000016906399a88ec4906044015f604051808303815f87803b1580156125f7575f80fd5b505af1158015612609573d5f803e3d5ffd5b505050505b5f805f807f00000000000000000000000000000000000000000000000000000000000000006001600160a01b031663ebea461d6040518163ffffffff1660e01b8152600401608060405180830381865afa15801561266e573d5f803e3d5ffd5b505050506040513d601f19601f820116820180604052508101906126929190613545565b93509350935093505f600c836126a8919061358c565b156126c8576126b8600c8461359f565b6126c39060016135b2565b6126d3565b6126d3600c8461359f565b90508481116126e257846126e4565b805b94507f00000000000000000000000000000000000000000000000000000000000000006001600160a01b031663b31761f86040518060800160405280888152602001878152602001868152602001858152506040518263ffffffff1660e01b815260040161275291906135c5565b5f604051808303815f87803b158015612769575f80fd5b505af115801561277b573d5f803e3d5ffd5b505050507f00000000000000000000000000000000000000000000000000000000000000006001600160a01b0316636ae71f126040518163ffffffff1660e01b81526004015f604051808303815f87803b1580156127d7575f80fd5b505af11580156127e9573d5f803e3d5ffd5b50505050505050505050565b6113e4806135f183390190565b610d89806149d583390190565b604051806102a001604052805f67ffffffffffffffff1681526020015f6001600160a01b031681526020015f81526020015f80191681526020015f6001600160a01b031681526020015f6001600160a01b031681526020015f8152602001606081526020015f81526020015f67ffffffffffffffff168152602001606081526020016128b860405180608001604052805f81526020015f81526020015f81526020015f81525090565b81526020015f81526020015f81526020015f81526020016128d761291d565b81525f602080830182905260408084018390526060808501849052608085018490528151908101825283815291820183905281019190915260a09091015290565b905290565b6040518060600160405280612930612960565b81526020015f81525f60209091015290565b6040518060400160405280612955612960565b81526020015f905290565b604051806040016040528061297361297c565b81526020016129185b60405180604001604052806002906020820280368337509192915050565b6001600160a01b03811681146129ae575f80fd5b50565b5f80604083850312156129c2575f80fd5b82356129cd8161299a565b946020939093013593505050565b5f805f606084860312156129ed575f80fd5b83356129f88161299a565b92506020840135612a088161299a565b929592945050506040919091013590565b634e487b7160e01b5f52604160045260245ffd5b604051610180810167ffffffffffffffff81118282101715612a5157612a51612a19565b60405290565b6040805190810167ffffffffffffffff81118282101715612a5157612a51612a19565b604051601f8201601f1916810167ffffffffffffffff81118282101715612aa357612aa3612a19565b604052919050565b5f67ffffffffffffffff821115612ac457612ac4612a19565b5060051b60200190565b5f6020808385031215612adf575f80fd5b823567ffffffffffffffff811115612af5575f80fd5b8301601f81018513612b05575f80fd5b8035612b18612b1382612aab565b612a7a565b81815260059190911b82018301908381019087831115612b36575f80fd5b928401925b82841015612b5d578335612b4e8161299a565b82529284019290840190612b3b565b979650505050505050565b5f60208284031215612b78575f80fd5b81516114608161299a565b5f6101408083016001600160a01b03808f168552602067ffffffffffffffff8f166020870152818e1660408701528c60608701528b60808701528a60a0870152818a1660c087015281891660e087015260ff88166101008701528361012087015282935086519150818352610160860193506020870192505f5b82811015612c1957835185529381019392810192600101612bfd565b50929f9e505050505050505050505050505050565b5f81518084528060208401602086015e5f602082860101526020601f19601f83011685010191505092915050565b5f815180845260208085019450602084015f5b83811015612c8b57815187529582019590820190600101612c6f565b509495945050505050565b8051825f5b6002811015612cba578251825260209283019290910190600101612c9b565b505050602080820151604084015f5b6002811015612cf057825167ffffffffffffffff1682529183019190830190600101612cc9565b505050505050565b634e487b7160e01b5f52602160045260245ffd5b60038110612d2857634e487b7160e01b5f52602160045260245ffd5b9052565b612d37828251612c96565b6020810151612d496080840182612d0c565b506040015160a09190910152565b6001600160a01b03808251168352806020830151166020840152806040830151166040840152506060810151612d9860608401826001600160a01b03169052565b506080810151612db360808401826001600160a01b03169052565b5060a0810151612dce60a08401826001600160a01b03169052565b5060c0810151612de960c08401826001600160a01b03169052565b5060e0810151612e0460e08401826001600160a01b03169052565b50610100908101516001600160a01b0316910152565b5f610140808352612e37818401865167ffffffffffffffff169052565b60208501516001600160a01b0381166101608501525060408501516101808181860152606087015191506101a08281870152608088015192506101c0612e87818801856001600160a01b03169052565b60a089015193506101e0612ea5818901866001600160a01b03169052565b60c08a0151945061020085818a015260e08b015195506102206103e0818b0152612ed36105208b0188612c2e565b96506101008c015161024081818d01526101208e01519150610260612f03818e018467ffffffffffffffff169052565b8a8f01519a5061028092507ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffec08d8b0301838e0152612f418a8c612c5c565b9a506101608f01519950612f7a6102a08e018b805182526020810151602083015260408101516040830152606081015160608301525050565b888f01516103208e0152878f01516103408e0152868f01516103608e0152858f01519950612fac6103808e018b612d2c565b938e01516104408d0152918d01516001600160a01b03166104608c0152908c015160ff166104808b0152908b015167ffffffffffffffff9081166104a08b0152908b0151805182166104c08b0152602081015182166104e08b015260408101519091166105008a015294506130219350505050565b5090506114606020830184612d57565b634e487b7160e01b5f52603260045260245ffd5b80518015158114613054575f80fd5b919050565b5f60208284031215613069575f80fd5b61146082613045565b5f815180845260208085019450602084015f5b83811015612c8b5781516001600160a01b031687529582019590820190600101613085565b604081525f6130bc6040830185613072565b8281036020848101919091528451808352858201928201905f5b818110156130f45784511515835293830193918301916001016130d6565b5090979650505050505050565b805167ffffffffffffffff81168114613054575f80fd5b5f60208284031215613128575f80fd5b61146082613101565b5f60a08284031215613141575f80fd5b60405160a0810181811067ffffffffffffffff8211171561316457613164612a19565b6040528251815261317760208401613101565b602082015261318860408401613101565b604082015261319960608401613101565b60608201526131aa60808401613045565b60808201529392505050565b602081525f6114606020830184613072565b634e487b7160e01b5f52601160045260245ffd5b67ffffffffffffffff8281168282160390808211156131fd576131fd6131c8565b5092915050565b5f67ffffffffffffffff808316818103613220576132206131c8565b6001019392505050565b5f610180828403121561323b575f80fd5b613243612a2d565b82518152602083015160208201526040830151604082015261326760608401613101565b606082015261327860808401613101565b608082015261328960a08401613101565b60a082015261329a60c08401613101565b60c08201526132ab60e08401613101565b60e08201526101006132be818501613101565b908201526101206132d0848201613101565b908201526101406132e2848201613101565b90820152610160928301519281019290925250919050565b5f82601f830112613309575f80fd5b613311612a57565b806040840185811115613322575f80fd5b845b818110156133435761333581613101565b845260209384019301613324565b509095945050505050565b805160038110613054575f80fd5b5f8082840360c081121561336e575f80fd5b60a081121561337b575f80fd5b613383612a57565b6080821215613390575f80fd5b613398612a57565b915085601f8601126133a8575f80fd5b6133b0612a57565b8060408701888111156133c1575f80fd5b875b818110156133db5780518452602093840193016133c3565b508185526133e989826132fa565b60208601525050508181526134006080860161334e565b602082015260a094909401519395939450505050565b5f60c082019050613428828551612c96565b602084015161343a6080840182612d0c565b508260a08301529392505050565b5f60208284031215613458575f80fd5b5051919050565b5f6020808385031215613470575f80fd5b825167ffffffffffffffff811115613486575f80fd5b8301601f81018513613496575f80fd5b80516134a4612b1382612aab565b81815260059190911b820183019083810190878311156134c2575f80fd5b928401925b82841015612b5d578351825292840192908401906134c7565b60608101610a0c8284805167ffffffffffffffff908116835260208083015182169084015260409182015116910152565b5f6001600160a01b0380861683528085166020840152506060604083015261353c6060830184612c2e565b95945050505050565b5f805f8060808587031215613558575f80fd5b505082516020840151604085015160609095015191969095509092509050565b634e487b7160e01b5f52601260045260245ffd5b5f8261359a5761359a613578565b500690565b5f826135ad576135ad613578565b500490565b80820180821115610a0c57610a0c6131c8565b8151815260208083015190820152604080830151908201526060808301519082015260808101610a0c56fe6080604052348015600e575f80fd5b506113c88061001c5f395ff3fe608060405260043610610021575f3560e01c8063adfef6ac1461003857610030565b366100305761002e610057565b005b61002e610057565b348015610043575f80fd5b5061002e610052366004610d61565b610069565b6100676100626101b8565b61029a565b565b5f6100726102bd565b6001600160a01b031614801561009757505f61008c6102ef565b6001600160a01b0316145b80156100b257505f6100a7610316565b6001600160a01b0316145b156101b0576101ac8160c0015183836040516024016100d29291906110f9565b60408051601f19818403018152918152602080830180517bffffffffffffffffffffffffffffffffffffffffffffffffffffffff167f0ee5ef0c0000000000000000000000000000000000000000000000000000000017905260e08601519087015191516001600160a01b0390921660248301529060440160408051601f198184030181529190526020810180517bffffffffffffffffffffffffffffffffffffffffffffffffffffffff167fc4d66de800000000000000000000000000000000000000000000000000000000179052608087015161033d565b5050565b6101ac610057565b5f600436101561020f5760405162461bcd60e51b815260206004820152600b60248201527f4e4f5f46554e435f53494700000000000000000000000000000000000000000060448201526064015b60405180910390fd5b5f336102196102bd565b6001600160a01b0316036102345761022f6102ef565b61023c565b61023c610316565b90506001600160a01b0381163b6102955760405162461bcd60e51b815260206004820152601360248201527f5441524745545f4e4f545f434f4e5452414354000000000000000000000000006044820152606401610206565b919050565b365f80375f80365f845af43d5f803e8080156102b4573d5ff35b3d5ffd5b505050565b5f7fb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d61035b546001600160a01b0316919050565b5f7f360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc6102e0565b5f7f2b1dbce74324248c222f0ec2d5ed7bd323cfc425b336f0253c5ccfda7265546d6102e0565b61036860017fb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6104611310565b7fb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103146103965761039661132f565b6103c160017f360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbd611310565b7f360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc146103ef576103ef61132f565b61041a60017f2b1dbce74324248c222f0ec2d5ed7bd323cfc425b336f0253c5ccfda7265546e611310565b7f2b1dbce74324248c222f0ec2d5ed7bd323cfc425b336f0253c5ccfda7265546d146104485761044861132f565b6104518161046e565b61045c85855f6104c5565b61046783835f6104ef565b5050505050565b7f7e644d79422f17c01e4894b5f4f588d331ebfa28653d42ae832dc59e38c9798f6104976102bd565b604080516001600160a01b03928316815291841660208301520160405180910390a16104c2816104f8565b50565b6104ce836105d0565b5f825111806104da5750805b156102b8576104e9838361060f565b50505050565b6104ce8361063d565b6001600160a01b0381166105745760405162461bcd60e51b815260206004820152602660248201527f455243313936373a206e65772061646d696e20697320746865207a65726f206160448201527f64647265737300000000000000000000000000000000000000000000000000006064820152608401610206565b807fb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d61035b80547fffffffffffffffffffffffff0000000000000000000000000000000000000000166001600160a01b039290921691909117905550565b6105d98161067c565b6040516001600160a01b038216907fbc7cd75a20ee27fd9adebab32041f755214dbc6bffa90cc0225b39da2e5c2d3b905f90a250565b6060610634838360405180606001604052806027815260200161136c60279139610720565b90505b92915050565b61064681610812565b6040516001600160a01b038216907ff7eed2a7fabbf1bec8d55ed5e785cc76622376dde5df4ff15470551e030b8134905f90a250565b6001600160a01b0381163b6106f95760405162461bcd60e51b815260206004820152602d60248201527f455243313936373a206e657720696d706c656d656e746174696f6e206973206e60448201527f6f74206120636f6e7472616374000000000000000000000000000000000000006064820152608401610206565b807f360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc610597565b60606001600160a01b0384163b61079f5760405162461bcd60e51b815260206004820152602660248201527f416464726573733a2064656c65676174652063616c6c20746f206e6f6e2d636f60448201527f6e747261637400000000000000000000000000000000000000000000000000006064820152608401610206565b5f80856001600160a01b0316856040516107b99190611343565b5f60405180830381855af49150503d805f81146107f1576040519150601f19603f3d011682016040523d82523d5f602084013e6107f6565b606091505b50915091506108068282866108b6565b925050505b9392505050565b6001600160a01b0381163b61088f5760405162461bcd60e51b815260206004820152603760248201527f455243313936373a206e6577207365636f6e6461727920696d706c656d656e7460448201527f6174696f6e206973206e6f74206120636f6e74726163740000000000000000006064820152608401610206565b807f2b1dbce74324248c222f0ec2d5ed7bd323cfc425b336f0253c5ccfda7265546d610597565b606083156108c557508161080b565b8251156108d55782518084602001fd5b8160405162461bcd60e51b81526004016102069190611359565b634e487b7160e01b5f52604160045260245ffd5b6040516060810167ffffffffffffffff81118282101715610926576109266108ef565b60405290565b6040805190810167ffffffffffffffff81118282101715610926576109266108ef565b604051610120810167ffffffffffffffff81118282101715610926576109266108ef565b6040516102a0810167ffffffffffffffff81118282101715610926576109266108ef565b604051601f8201601f1916810167ffffffffffffffff811182821017156109c0576109c06108ef565b604052919050565b803567ffffffffffffffff81168114610295575f80fd5b80356001600160a01b0381168114610295575f80fd5b5f82601f830112610a04575f80fd5b813567ffffffffffffffff811115610a1e57610a1e6108ef565b610a316020601f19601f84011601610997565b818152846020838601011115610a45575f80fd5b816020850160208301375f918101602001919091529392505050565b5f82601f830112610a70575f80fd5b8135602067ffffffffffffffff821115610a8c57610a8c6108ef565b8160051b610a9b828201610997565b9283528481018201928281019087851115610ab4575f80fd5b83870192505b84831015610ad357823582529183019190830190610aba565b979650505050505050565b5f60808284031215610aee575f80fd5b6040516080810181811067ffffffffffffffff82111715610b1157610b116108ef565b8060405250809150823581526020830135602082015260408301356040820152606083013560608201525092915050565b5f82601f830112610b51575f80fd5b610b5961092c565b806040840185811115610b6a575f80fd5b845b81811015610b8b57610b7d816109c8565b845260209384019301610b6c565b509095945050505050565b803560038110610295575f80fd5b5f81830360c0811215610bb5575f80fd5b610bbd610903565b91506080811215610bcc575f80fd5b50610bd561092c565b83601f840112610be3575f80fd5b610beb61092c565b806040850186811115610bfc575f80fd5b855b81811015610c16578035845260209384019301610bfe565b50818452610c248782610b42565b60208501525050508152610c3a60808301610b96565b602082015260a0820135604082015292915050565b803560ff81168114610295575f80fd5b5f60608284031215610c6f575f80fd5b610c77610903565b9050610c82826109c8565b8152610c90602083016109c8565b6020820152610ca1604083016109c8565b604082015292915050565b5f6101208284031215610cbd575f80fd5b610cc561094f565b9050610cd0826109df565b8152610cde602083016109df565b6020820152610cef604083016109df565b6040820152610d00606083016109df565b6060820152610d11608083016109df565b6080820152610d2260a083016109df565b60a0820152610d3360c083016109df565b60c0820152610d4460e083016109df565b60e0820152610100610d578184016109df565b9082015292915050565b5f80610140808486031215610d74575f80fd5b833567ffffffffffffffff80821115610d8b575f80fd5b908501906103e08288031215610d9f575f80fd5b610da7610973565b610db0836109c8565b8152610dbe602084016109df565b60208201526040830135604082015260608301356060820152610de3608084016109df565b6080820152610df460a084016109df565b60a082015260c083013560c082015260e083013582811115610e14575f80fd5b610e20898286016109f5565b60e0830152506101008381013590820152610120610e3f8185016109c8565b908201528284013582811115610e53575f80fd5b610e5f89828601610a61565b85830152506101609350610e7588858501610ade565b848201526101e09350838301356101808201526102009150818301356101a0820152610220808401356101c0830152610240610eb38a828701610ba4565b8684015261030085013584840152610ece61032086016109df565b82840152610edf6103408601610c4f565b9083015250610ef161036084016109c8565b610260820152610f05886103808501610c5f565b61028082015280955050505050610f1f8460208501610cac565b90509250929050565b5f81518084528060208401602086015e5f602082860101526020601f19601f83011685010191505092915050565b5f815180845260208085019450602084015f5b83811015610f8557815187529582019590820190600101610f69565b509495945050505050565b60038110610fac57634e487b7160e01b5f52602160045260245ffd5b9052565b80518051835f5b6002811015610fd6578251825260209283019290910190600101610fb7565b50505060209081015190604084015f5b600281101561100d57835167ffffffffffffffff1682529282019290820190600101610fe6565b5050505060208101516110236080840182610f90565b506040015160a09190910152565b6001600160a01b0380825116835280602083015116602084015280604083015116604084015250606081015161107260608401826001600160a01b03169052565b50608081015161108d60808401826001600160a01b03169052565b5060a08101516110a860a08401826001600160a01b03169052565b5060c08101516110c360c08401826001600160a01b03169052565b5060e08101516110de60e08401826001600160a01b03169052565b50610100818101516001600160a01b038116848301526104e9565b5f610140808352611116818401865167ffffffffffffffff169052565b60208501516001600160a01b0381166101608501525060408501516101808181860152606087015191506101a08281870152608088015192506101c0611166818801856001600160a01b03169052565b60a089015193506101e0611184818901866001600160a01b03169052565b60c08a0151945061020085818a015260e08b015195506102206103e0818b01526111b26105208b0188610f28565b96506101008c015161024081818d01526101208e015191506102606111e2818e018467ffffffffffffffff169052565b8a8f01519a5061028092507ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffec08d8b0301838e01526112208a8c610f56565b9a506101608f015199506112596102a08e018b805182526020810151602083015260408101516040830152606081015160608301525050565b888f01516103208e0152878f01516103408e0152868f01516103608e0152858f0151995061128b6103808e018b610fb0565b938e01516104408d0152918d01516001600160a01b03166104608c0152908c015160ff166104808b0152908b015167ffffffffffffffff9081166104a08b0152908b0151805182166104c08b0152602081015182166104e08b015260408101519091166105008a015294506113009350505050565b50905061080b6020830184611031565b8181038181111561063757634e487b7160e01b5f52601160045260245ffd5b634e487b7160e01b5f52600160045260245ffd5b5f82518060208501845e5f920191825250919050565b602081525f6106346020830184610f2856fe416464726573733a206c6f772d6c6576656c2064656c65676174652063616c6c206661696c6564a2646970667358221220c3b57cc1c902d57e4e5dea720ed63f19c757cd25bcb40afbcc377b072e67131e64736f6c634300081900336080604052604051610d89380380610d89833981016040819052610022916103b7565b828161002f82825f610043565b5061003b90508261006e565b5050506104cd565b61004c836100db565b5f825111806100585750805b1561006957610067838361011a565b505b505050565b7f7e644d79422f17c01e4894b5f4f588d331ebfa28653d42ae832dc59e38c9798f6100ad5f80516020610d42833981519152546001600160a01b031690565b604080516001600160a01b03928316815291841660208301520160405180910390a16100d881610146565b50565b6100e4816101e1565b6040516001600160a01b038216907fbc7cd75a20ee27fd9adebab32041f755214dbc6bffa90cc0225b39da2e5c2d3b905f90a250565b606061013f8383604051806060016040528060278152602001610d6260279139610275565b9392505050565b6001600160a01b0381166101b05760405162461bcd60e51b815260206004820152602660248201527f455243313936373a206e65772061646d696e20697320746865207a65726f206160448201526564647265737360d01b60648201526084015b60405180910390fd5b805f80516020610d428339815191525b80546001600160a01b0319166001600160a01b039290921691909117905550565b6001600160a01b0381163b61024e5760405162461bcd60e51b815260206004820152602d60248201527f455243313936373a206e657720696d706c656d656e746174696f6e206973206e60448201526c1bdd08184818dbdb9d1c9858dd609a1b60648201526084016101a7565b807f360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc6101c0565b60606001600160a01b0384163b6102dd5760405162461bcd60e51b815260206004820152602660248201527f416464726573733a2064656c65676174652063616c6c20746f206e6f6e2d636f6044820152651b9d1c9858dd60d21b60648201526084016101a7565b5f80856001600160a01b0316856040516102f79190610482565b5f60405180830381855af49150503d805f811461032f576040519150601f19603f3d011682016040523d82523d5f602084013e610334565b606091505b50909250905061034582828661034f565b9695505050505050565b6060831561035e57508161013f565b82511561036e5782518084602001fd5b8160405162461bcd60e51b81526004016101a79190610498565b80516001600160a01b038116811461039e575f80fd5b919050565b634e487b7160e01b5f52604160045260245ffd5b5f805f606084860312156103c9575f80fd5b6103d284610388565b92506103e060208501610388565b60408501519092506001600160401b03808211156103fc575f80fd5b818601915086601f83011261040f575f80fd5b815181811115610421576104216103a3565b604051601f8201601f19908116603f01168101908382118183101715610449576104496103a3565b81604052828152896020848701011115610461575f80fd5b8260208601602083015e5f6020848301015280955050505050509250925092565b5f82518060208501845e5f920191825250919050565b602081525f82518060208401528060208501604085015e5f604082850101526040601f19601f83011684010191505092915050565b610868806104da5f395ff3fe60806040526004361061005d575f3560e01c80635c60da1b116100425780635c60da1b146100a65780638f283970146100d6578063f851a440146100f55761006c565b80633659cfe6146100745780634f1ef286146100935761006c565b3661006c5761006a610109565b005b61006a610109565b34801561007f575f80fd5b5061006a61008e36600461070d565b610123565b61006a6100a1366004610726565b61015e565b3480156100b1575f80fd5b506100ba6101c4565b6040516001600160a01b03909116815260200160405180910390f35b3480156100e1575f80fd5b5061006a6100f036600461070d565b6101f4565b348015610100575f80fd5b506100ba610214565b610111610234565b61012161011c6102e4565b6102ed565b565b61012b61030b565b6001600160a01b03163303610156576101538160405180602001604052805f8152505f61033d565b50565b610153610109565b61016661030b565b6001600160a01b031633036101bc576101b78383838080601f0160208091040260200160405190810160405280939291908181526020018383808284375f920191909152506001925061033d915050565b505050565b6101b7610109565b5f6101cd61030b565b6001600160a01b031633036101e9576101e46102e4565b905090565b6101f1610109565b90565b6101fc61030b565b6001600160a01b031633036101565761015381610367565b5f61021d61030b565b6001600160a01b031633036101e9576101e461030b565b61023c61030b565b6001600160a01b031633036101215760405162461bcd60e51b815260206004820152604260248201527f5472616e73706172656e745570677261646561626c6550726f78793a2061646d60448201527f696e2063616e6e6f742066616c6c6261636b20746f2070726f7879207461726760648201527f6574000000000000000000000000000000000000000000000000000000000000608482015260a4015b60405180910390fd5b5f6101e46103bb565b365f80375f80365f845af43d5f803e808015610307573d5ff35b3d5ffd5b5f7fb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d61035b546001600160a01b0316919050565b610346836103e2565b5f825111806103525750805b156101b7576103618383610421565b50505050565b7f7e644d79422f17c01e4894b5f4f588d331ebfa28653d42ae832dc59e38c9798f61039061030b565b604080516001600160a01b03928316815291841660208301520160405180910390a16101538161044d565b5f7f360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc61032e565b6103eb81610525565b6040516001600160a01b038216907fbc7cd75a20ee27fd9adebab32041f755214dbc6bffa90cc0225b39da2e5c2d3b905f90a250565b6060610446838360405180606001604052806027815260200161080c602791396105c9565b9392505050565b6001600160a01b0381166104c95760405162461bcd60e51b815260206004820152602660248201527f455243313936373a206e65772061646d696e20697320746865207a65726f206160448201527f646472657373000000000000000000000000000000000000000000000000000060648201526084016102db565b807fb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d61035b80547fffffffffffffffffffffffff0000000000000000000000000000000000000000166001600160a01b039290921691909117905550565b6001600160a01b0381163b6105a25760405162461bcd60e51b815260206004820152602d60248201527f455243313936373a206e657720696d706c656d656e746174696f6e206973206e60448201527f6f74206120636f6e74726163740000000000000000000000000000000000000060648201526084016102db565b807f360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc6104ec565b60606001600160a01b0384163b6106485760405162461bcd60e51b815260206004820152602660248201527f416464726573733a2064656c65676174652063616c6c20746f206e6f6e2d636f60448201527f6e7472616374000000000000000000000000000000000000000000000000000060648201526084016102db565b5f80856001600160a01b03168560405161066291906107a2565b5f60405180830381855af49150503d805f811461069a576040519150601f19603f3d011682016040523d82523d5f602084013e61069f565b606091505b50915091506106af8282866106b9565b9695505050505050565b606083156106c8575081610446565b8251156106d85782518084602001fd5b8160405162461bcd60e51b81526004016102db91906107b8565b80356001600160a01b0381168114610708575f80fd5b919050565b5f6020828403121561071d575f80fd5b610446826106f2565b5f805f60408486031215610738575f80fd5b610741846106f2565b9250602084013567ffffffffffffffff8082111561075d575f80fd5b818601915086601f830112610770575f80fd5b81358181111561077e575f80fd5b87602082850101111561078f575f80fd5b6020830194508093505050509250925092565b5f82518060208501845e5f920191825250919050565b602081525f82518060208401528060208501604085015e5f6040828501015260407fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe0601f8301168401019150509291505056fe416464726573733a206c6f772d6c6576656c2064656c65676174652063616c6c206661696c6564a26469706673582212205147d38957e9df6e1da1b98751987c55e32bdc4cb009ea7a145ab634aee1897364736f6c63430008190033b53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103416464726573733a206c6f772d6c6576656c2064656c65676174652063616c6c206661696c6564a2646970667358221220dc6f6699c6fbde234a387f805d698aedaf1e55062dd4ac5e874c1513c6bee1af64736f6c634300081900336080604052348015600e575f80fd5b506109da8061001c5f395ff3fe608060405234801561000f575f80fd5b506004361061003f575f3560e01c806331644130146100435780638eaa6ac014610069578063945c94941461008a575b5f80fd5b610056610051366004610411565b61009f565b6040519081526020015b60405180910390f35b61007c61007736600461043a565b61018f565b604051610060929190610471565b61009d6100983660046104f8565b6102b7565b005b5f61014e6100b236859003850185610580565b8051805160209182015192820151805190830151604080517f476c6f62616c2073746174653a0000000000000000000000000000000000000081870152602d810194909452604d8401959095527fffffffffffffffff00000000000000000000000000000000000000000000000060c092831b8116606d850152911b1660758201528251808203605d018152607d909101909252815191012090565b8261015f60a0860160808701610648565b6040516020016101719392919061066a565b60405160208183030381529060405280519060200120905092915050565b6101976103a2565b5f82815260208190526040812080546101af906106a5565b80601f01602080910402602001604051908101604052809291908181526020018280546101db906106a5565b80156102265780601f106101fd57610100808354040283529160200191610226565b820191905f5260205f20905b81548152906001019060200180831161020957829003601f168201915b505050505080602001905181019061023e919061073d565b90925090505f8190036102b2576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152601060248201527f48617368206e6f7420796574207365740000000000000000000000000000000060448201526064015b60405180910390fd5b915091565b6102c1828261009f565b8314610329576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152600c60248201527f496e76616c69642068617368000000000000000000000000000000000000000060448201526064016102a9565b818160405160200161033c92919061085c565b60408051601f198184030181529181525f8581526020819052209061036190826108c2565b507f14c0a6b8d81f5915dacfd85e41ae4798343ec29de408ac4c13360c7238ae0ad983838360405161039593929190610982565b60405180910390a1505050565b60405180604001604052806103b56103c1565b81526020015f5b905290565b60405180604001604052806103d46103dd565b81526020016103bc5b60405180604001604052806002906020820280368337509192915050565b5f60a0828403121561040b575f80fd5b50919050565b5f8060c08385031215610422575f80fd5b61042c84846103fb565b9460a0939093013593505050565b5f6020828403121561044a575f80fd5b5035919050565b6003811061046d57634e487b7160e01b5f52602160045260245ffd5b9052565b8251805160c083019190835f5b600281101561049d57825182526020928301929091019060010161047e565b50505060209081015190604084015f5b60028110156104d457835167ffffffffffffffff16825292820192908201906001016104ad565b5050505060208401516104ea6080840182610451565b508260a08301529392505050565b5f805f60e0848603121561050a575f80fd5b8335925061051b85602086016103fb565b915060c084013590509250925092565b634e487b7160e01b5f52604160045260245ffd5b6040805190810167ffffffffffffffff811182821017156105625761056261052b565b60405290565b67ffffffffffffffff8116811461057d575f80fd5b50565b5f60808284031215610590575f80fd5b61059861053f565b83601f8401126105a6575f80fd5b6105ae61053f565b8060408501868111156105bf575f80fd5b855b818110156105d95780358452602093840193016105c1565b5081845286605f8701126105eb575f80fd5b6105f361053f565b92508291506080860187811115610608575f80fd5b8082101561062d57813561061b81610568565b84526020938401939190910190610608565b50506020830152509392505050565b6003811061057d575f80fd5b5f60208284031215610658575f80fd5b81356106638161063c565b9392505050565b8381528260208201525f6003831061069057634e487b7160e01b5f52602160045260245ffd5b5060f89190911b604082015260410192915050565b600181811c908216806106b957607f821691505b60208210810361040b57634e487b7160e01b5f52602260045260245ffd5b5f82601f8301126106e6575f80fd5b6106ee61053f565b8060408401858111156106ff575f80fd5b845b8181101561072257805161071481610568565b845260209384019301610701565b509095945050505050565b80516107388161063c565b919050565b5f8082840360c081121561074f575f80fd5b60a081121561075c575f80fd5b61076461053f565b6080821215610771575f80fd5b61077961053f565b915085601f860112610789575f80fd5b61079161053f565b8060408701888111156107a2575f80fd5b875b818110156107bc5780518452602093840193016107a4565b508185526107ca89826106d7565b60208601525050508181526107e16080860161072d565b602082015260a094909401519395939450505050565b604081833760408201604082015f5b600281101561083957813561081a81610568565b67ffffffffffffffff1683526020928301929190910190600101610806565b505050608081013561084a8161063c565b6108576080840182610451565b505050565b60c0810161086a82856107f7565b8260a08301529392505050565b601f82111561085757805f5260205f20601f840160051c8101602085101561089c5750805b601f840160051c820191505b818110156108bb575f81556001016108a8565b5050505050565b815167ffffffffffffffff8111156108dc576108dc61052b565b6108f0816108ea84546106a5565b84610877565b602080601f831160018114610923575f841561090c5750858301515b5f19600386901b1c1916600185901b17855561097a565b5f85815260208120601f198616915b8281101561095157888601518255948401946001909101908401610932565b508582101561096e57878501515f19600388901b60f8161c191681555b505060018460011b0185555b505050505050565b83815260e0810161099660208301856107f7565b8260c083015294935050505056fea2646970667358221220fd953c6df4907248ae24c8c866354a80cd368fc849c73ffa4e66d136ed36391d64736f6c63430008190033608060405234801561000f575f80fd5b5060405161028b38038061028b83398101604081905261002e916100b8565b8051610040905f906020840190610047565b5050610170565b828054828255905f5260205f20908101928215610080579160200282015b82811115610080578251825591602001919060010190610065565b5061008c929150610090565b5090565b5b8082111561008c575f8155600101610091565b634e487b7160e01b5f52604160045260245ffd5b5f60208083850312156100c9575f80fd5b82516001600160401b03808211156100df575f80fd5b818501915085601f8301126100f2575f80fd5b815181811115610104576101046100a4565b8060051b604051601f19603f83011681018181108582111715610129576101296100a4565b604052918252848201925083810185019188831115610146575f80fd5b938501935b828510156101645784518452938501939285019261014b565b98975050505050505050565b61010e8061017d5f395ff3fe6080604052348015600e575f80fd5b50600436106026575f3560e01c8063b0ec2ae114602a575b5f80fd5b60306044565b604051603b91906097565b60405180910390f35b60605f805480602002602001604051908101604052809291908181526020018280548015608d57602002820191905f5260205f20905b815481526020019060010190808311607a575b5050505050905090565b602080825282518282018190525f9190848201906040850190845b8181101560cc5783518352928401929184019160010160b2565b5090969550505050505056fea2646970667358221220c09622ecb210d34fce04203be6d969299036860315d6c3c6e678834e77157bff64736f6c63430008190033
    /// ```
    #[rustfmt::skip]
    #[allow(clippy::all)]
    pub static BYTECODE: alloy_sol_types::private::Bytes = alloy_sol_types::private::Bytes::from_static(
        b"a\x05\x80`@R4\x80\x15a\0\x10W_\x80\xFD[P`@Qaog8\x03\x80aog\x839\x81\x01`@\x81\x90Ra\0/\x91a\x06\x99V[\x83Q`\x01`\x01`\xA0\x1B\x03\x90\x81\x16a\x01\0R` \x80\x86\x01Q\x82\x16a\x01 R`@\x80\x87\x01Q\x83\x16a\x01@R``\x80\x88\x01Q\x84\x16a\x01`R`\x80\x80\x89\x01Q\x85\x16a\x01\x80R`\xA0\x89\x01Q\x85\x16a\x01\xA0R`\xC0\x89\x01Q\x85\x16a\x01\xC0R`\xE0\x89\x01Q\x85\x16a\x03\xA0R\x87Q\x85\x16a\x03\xC0R\x92\x87\x01Q\x84\x16a\x03\xE0R\x86\x82\x01Q\x84\x16a\x04\0R\x86\x01Q\x83\x16a\x04 R\x90\x85\x01Q\x90\x91\x16a\x04@RQa\0\xCB\x90a\x02XV[`@Q\x80\x91\x03\x90_\xF0\x80\x15\x80\x15a\0\xE4W=_\x80>=_\xFD[P`\x01`\x01`\xA0\x1B\x03\x90\x81\x16a\x04`R\x82Q\x81\x16a\x04\x80R` \x80\x84\x01Q\x82\x16a\x04\xA0R`@\x80\x85\x01Q\x83\x16a\x04\xC0R``\x80\x86\x01Q\x84\x16a\x04\xE0R`\x80\x80\x87\x01Q\x85\x16a\x05\0R`\xA0\x80\x88\x01Q\x86\x16a\x05 R`\xC0\x80\x89\x01Q\x87\x16a\x05@R`\xE0\x80\x8A\x01Q\x88\x16a\x05`R\x91\x88\x01Qa\x02`R\x87\x01Qa\x02\x80R\x86\x01Q`\x01`\x01`@\x1B\x03\x90\x81\x16a\x02\xA0R\x86Q\x81\x16a\x01\xE0R\x93\x86\x01Q\x90\x93\x16a\x02\0R\x84\x82\x01Q\x90\x93\x16a\x02 R\x91\x83\x01Qa\x02@R\x82\x01Q\x90Qa\x01\xA5\x90a\x02eV[a\x01\xAF\x91\x90a\x07\xA0V[`@Q\x80\x91\x03\x90_\xF0\x80\x15\x80\x15a\x01\xC8W=_\x80>=_\xFD[P`\x01`\x01`\xA0\x1B\x03\x16a\x03\0Ra\x01\0\x81\x01Q\x15\x15a\x02\xC0Ra\x01 \x81\x01Q`\x80Ra\x01@\x81\x01Q`\xA0Ra\x01`\x81\x01Q`\xC0Ra\x01\x80\x81\x01Q`\xFF\x16`\xE0Ra\x01\xA0\x81\x01Q`\x01`\x01`@\x1B\x03\x90\x81\x16a\x02\xE0Ra\x01\xC0\x82\x01Q\x15\x15a\x03 Ra\x01\xE0\x90\x91\x01\x80Q` \x01Q\x82\x16a\x03@R\x80QQ\x82\x16a\x03`RQ`@\x01Q\x16a\x03\x80RPa\x07\xE3\x91PPV[a\t\xF6\x80ab\xE6\x839\x01\x90V[a\x02\x8B\x80al\xDC\x839\x01\x90V[cNH{q`\xE0\x1B_R`A`\x04R`$_\xFD[`@Qa\x01\0\x81\x01`\x01`\x01`@\x1B\x03\x81\x11\x82\x82\x10\x17\x15a\x02\xA9Wa\x02\xA9a\x02rV[`@R\x90V[`@Qa\x02\0\x81\x01`\x01`\x01`@\x1B\x03\x81\x11\x82\x82\x10\x17\x15a\x02\xA9Wa\x02\xA9a\x02rV[`\x01`\x01`\xA0\x1B\x03\x81\x16\x81\x14a\x02\xE6W_\x80\xFD[PV[\x80Qa\x02\xF4\x81a\x02\xD2V[\x91\x90PV[_`\xA0\x82\x84\x03\x12\x15a\x03\tW_\x80\xFD[`@Q`\xA0\x81\x01`\x01`\x01`@\x1B\x03\x81\x11\x82\x82\x10\x17\x15a\x03+Wa\x03+a\x02rV[\x80`@RP\x80\x91P\x82Qa\x03>\x81a\x02\xD2V[\x81R` \x83\x01Qa\x03N\x81a\x02\xD2V[` \x82\x01R`@\x83\x01Qa\x03a\x81a\x02\xD2V[`@\x82\x01R``\x83\x01Qa\x03t\x81a\x02\xD2V[``\x82\x01R`\x80\x83\x01Qa\x03\x87\x81a\x02\xD2V[`\x80\x91\x90\x91\x01R\x92\x91PPV[_a\x01\0\x82\x84\x03\x12\x15a\x03\xA5W_\x80\xFD[a\x03\xADa\x02\x86V[\x90P\x81Qa\x03\xBA\x81a\x02\xD2V[\x81R` \x82\x01Qa\x03\xCA\x81a\x02\xD2V[` \x82\x01Ra\x03\xDB`@\x83\x01a\x02\xE9V[`@\x82\x01Ra\x03\xEC``\x83\x01a\x02\xE9V[``\x82\x01Ra\x03\xFD`\x80\x83\x01a\x02\xE9V[`\x80\x82\x01Ra\x04\x0E`\xA0\x83\x01a\x02\xE9V[`\xA0\x82\x01Ra\x04\x1F`\xC0\x83\x01a\x02\xE9V[`\xC0\x82\x01Ra\x040`\xE0\x83\x01a\x02\xE9V[`\xE0\x82\x01R\x92\x91PPV[\x80Q`\x01`\x01`@\x1B\x03\x81\x16\x81\x14a\x02\xF4W_\x80\xFD[_\x82`\x1F\x83\x01\x12a\x04`W_\x80\xFD[\x81Q` `\x01`\x01`@\x1B\x03\x80\x83\x11\x15a\x04|Wa\x04|a\x02rV[\x82`\x05\x1B`@Q`\x1F\x19`?\x83\x01\x16\x81\x01\x81\x81\x10\x84\x82\x11\x17\x15a\x04\xA1Wa\x04\xA1a\x02rV[`@R\x93\x84R` \x81\x87\x01\x81\x01\x94\x90\x81\x01\x92P\x87\x85\x11\x15a\x04\xC0W_\x80\xFD[` \x87\x01\x91P[\x84\x82\x10\x15a\x04\xE0W\x81Q\x83R\x91\x83\x01\x91\x90\x83\x01\x90a\x04\xC7V[\x97\x96PPPPPPPV[\x80Q\x80\x15\x15\x81\x14a\x02\xF4W_\x80\xFD[\x80Q`\xFF\x81\x16\x81\x14a\x02\xF4W_\x80\xFD[_``\x82\x84\x03\x12\x15a\x05\x1AW_\x80\xFD[`@Q``\x81\x01`\x01`\x01`@\x1B\x03\x81\x11\x82\x82\x10\x17\x15a\x05<Wa\x05<a\x02rV[`@R\x90P\x80a\x05K\x83a\x04;V[\x81Ra\x05Y` \x84\x01a\x04;V[` \x82\x01Ra\x05j`@\x84\x01a\x04;V[`@\x82\x01RP\x92\x91PPV[_a\x02@\x82\x84\x03\x12\x15a\x05\x87W_\x80\xFD[a\x05\x8Fa\x02\xAFV[\x90Pa\x05\x9A\x82a\x04;V[\x81Ra\x05\xA8` \x83\x01a\x04;V[` \x82\x01Ra\x05\xB9`@\x83\x01a\x02\xE9V[`@\x82\x01R``\x82\x81\x01Q\x90\x82\x01R`\x80\x82\x01Q`\x01`\x01`@\x1B\x03\x81\x11\x15a\x05\xE0W_\x80\xFD[a\x05\xEC\x84\x82\x85\x01a\x04QV[`\x80\x83\x01RP`\xA0\x82\x01Q`\xA0\x82\x01R`\xC0\x82\x01Q`\xC0\x82\x01Ra\x06\x12`\xE0\x83\x01a\x04;V[`\xE0\x82\x01Ra\x01\0a\x06%\x81\x84\x01a\x04\xEBV[\x90\x82\x01Ra\x01 \x82\x81\x01Q\x90\x82\x01Ra\x01@\x80\x83\x01Q\x90\x82\x01Ra\x01`\x80\x83\x01Q\x90\x82\x01Ra\x01\x80a\x06X\x81\x84\x01a\x04\xFAV[\x90\x82\x01Ra\x01\xA0a\x06j\x83\x82\x01a\x04;V[\x90\x82\x01Ra\x01\xC0a\x06|\x83\x82\x01a\x04\xEBV[\x90\x82\x01Ra\x01\xE0a\x06\x8F\x84\x84\x83\x01a\x05\nV[\x90\x82\x01R\x92\x91PPV[_\x80_\x80\x84\x86\x03a\x02\xC0\x81\x12\x15a\x06\xAEW_\x80\xFD[a\x01\0\x80\x82\x12\x15a\x06\xBDW_\x80\xFD[a\x06\xC5a\x02\x86V[\x91P\x86Qa\x06\xD2\x81a\x02\xD2V[\x82Ra\x06\xE0` \x88\x01a\x02\xE9V[` \x83\x01Ra\x06\xF1`@\x88\x01a\x02\xE9V[`@\x83\x01Ra\x07\x02``\x88\x01a\x02\xE9V[``\x83\x01Ra\x07\x13`\x80\x88\x01a\x02\xE9V[`\x80\x83\x01Ra\x07$`\xA0\x88\x01a\x02\xE9V[`\xA0\x83\x01Ra\x075`\xC0\x88\x01a\x02\xE9V[`\xC0\x83\x01Ra\x07F`\xE0\x88\x01a\x02\xE9V[`\xE0\x83\x01R\x81\x95Pa\x07Z\x88\x82\x89\x01a\x02\xF9V[\x94PPPa\x07l\x86a\x01\xA0\x87\x01a\x03\x94V[a\x02\xA0\x86\x01Q\x90\x92P`\x01`\x01`@\x1B\x03\x81\x11\x15a\x07\x88W_\x80\xFD[a\x07\x94\x87\x82\x88\x01a\x05vV[\x91PP\x92\x95\x91\x94P\x92PV[` \x80\x82R\x82Q\x82\x82\x01\x81\x90R_\x91\x90\x84\x82\x01\x90`@\x85\x01\x90\x84[\x81\x81\x10\x15a\x07\xD7W\x83Q\x83R\x92\x84\x01\x92\x91\x84\x01\x91`\x01\x01a\x07\xBBV[P\x90\x96\x95PPPPPPV[`\x80Q`\xA0Q`\xC0Q`\xE0Qa\x01\0Qa\x01 Qa\x01@Qa\x01`Qa\x01\x80Qa\x01\xA0Qa\x01\xC0Qa\x01\xE0Qa\x02\0Qa\x02 Qa\x02@Qa\x02`Qa\x02\x80Qa\x02\xA0Qa\x02\xC0Qa\x02\xE0Qa\x03\0Qa\x03 Qa\x03@Qa\x03`Qa\x03\x80Qa\x03\xA0Qa\x03\xC0Qa\x03\xE0Qa\x04\0Qa\x04 Qa\x04@Qa\x04`Qa\x04\x80Qa\x04\xA0Qa\x04\xC0Qa\x04\xE0Qa\x05\0Qa\x05 Qa\x05@Qa\x05`QaW\x93a\x0BS_9_\x81\x81a\x03\xF1\x01Ra\n\xB1\x01R_\x81\x81a\x03$\x01Ra\x0CG\x01R_\x81\x81a\x04\xF6\x01Ra\x0Cv\x01R_\x81\x81a\x07\xEB\x01Ra\":\x01R_\x81\x81a\x07\x9D\x01Ra!\x0C\x01R_\x81\x81a\x06\x19\x01Ra L\x01R_\x81\x81a\x07\xC4\x01R\x81\x81a#\xE4\x01Ra%\x8E\x01R_\x81\x81a\x08\x87\x01Ra\x1E\xF3\x01R_\x81\x81a\x08\x12\x01R\x81\x81a\x19u\x01Ra\x1A2\x01R_\x81\x81a\x05\x1D\x01Ra u\x01R_\x81\x81a\x04\xA0\x01R\x81\x81a#\xB4\x01Ra%\xB6\x01R_\x81\x81a\x04\xCF\x01Ra!6\x01R_\x81\x81a\x03\x8A\x01R\x81\x81a\n\xD2\x01Ra\x1F\x1C\x01R_\x81\x81a\x03c\x01Ra\"d\x01R_\x81\x81a\x06\xCA\x01Ra\r\xAE\x01R_\x81\x81a\x08\xD5\x01Ra$p\x01R_\x81\x81a\x05\xF2\x01Ra$\x10\x01R_\x81\x81a\x08`\x01Ra$@\x01R_\x81\x81a\x08\xAE\x01Ra#\x8E\x01R_\x81\x81a\x07(\x01Ra\x1D3\x01R_\x81\x81a\t\x0F\x01Ra\x1Ev\x01R_\x81\x81a\x06\xF1\x01R\x81\x81a\x11n\x01Ra\x11\xBA\x01R_\x81\x81a\x05D\x01Ra\x1D\x03\x01R_\x81\x81a\x02\xEA\x01Ra\x1C\xDD\x01R_\x81\x81a\x06@\x01Ra\x1C\xA3\x01R_\x81\x81a\t\x84\x01Ra\x1B\xBA\x01R_\x81\x81a\x04?\x01Ra\x1B\x8B\x01R_\x81\x81a\x06\x8E\x01Ra\r\x8D\x01R_\x81\x81a\x03\xB1\x01Ra\x1B[\x01R_\x81\x81a\x07O\x01R\x81\x81a\x0B\xAB\x01Ra #\x01R_\x81\x81a\x04\x18\x01R\x81\x81a\x0B\xDA\x01R\x81\x81a\"\x11\x01Ra\"\xBE\x01R_\x81\x81a\x07v\x01R\x81\x81a\x0C\t\x01R\x81\x81a \xE3\x01Ra!\x90\x01R_\x81\x81a\x089\x01R\x81\x81a\x0B|\x01R\x81\x81a#m\x01R\x81\x81a&\x14\x01R\x81\x81a&\xE8\x01Ra'\x81\x01R_\x81\x81a\t6\x01R\x81\x81a\x0BM\x01R\x81\x81a\x1E\xCA\x01Ra\x1F\xAB\x01R_\x81\x81a\x06g\x01R\x81\x81a\x0C\xA5\x01R\x81\x81a\x0F\xCC\x01R\x81\x81a\x12$\x01R\x81\x81a\x14i\x01R\x81\x81a\x14\xD8\x01R\x81\x81a\x15\xC7\x01R\x81\x81a\x16u\x01R\x81\x81a\x17t\x01R\x81\x81a\x18\x11\x01R\x81\x81a\x18@\x01Ra\x1B\xE0\x01R_\x81\x81a\x05\xCB\x01R\x81\x81a\r\xE6\x01Ra\x1Ct\x01R_\x81\x81a\x05k\x01Ra\x1EM\x01R_\x81\x81a\t]\x01Ra\x1E\x0C\x01R_\x81\x81a\x04f\x01Ra\x1D\xE6\x01R_\x81\x81a\x05\xA4\x01Ra\x1D\xC0\x01RaW\x93_\xF3\xFE`\x80`@R4\x80\x15a\0\x0FW_\x80\xFD[P`\x046\x10a\x02\xE1W_5`\xE0\x1C\x80c\x87e$\x0F\x11a\x01\x87W\x80c\xCC\x80\x89\xBB\x11a\0\xDDW\x80c\xEBezN\x11a\0\x93W\x80c\xEE\x9A1\xA2\x11a\0nW\x80c\xEE\x9A1\xA2\x14a\t1W\x80c\xFA(t \x14a\tXW\x80c\xFA\xF5b_\x14a\t\x7FW_\x80\xFD[\x80c\xEBezN\x14a\x08\xD0W\x80c\xEB\xE0:\x93\x14a\x08\xF7W\x80c\xECOt\xCE\x14a\t\nW_\x80\xFD[\x80c\xD4\x9DQ\x81\x11a\0\xC3W\x80c\xD4\x9DQ\x81\x14a\x08[W\x80c\xDA\xE7\xCB\x8B\x14a\x08\x82W\x80c\xE8\x18\x0C)\x14a\x08\xA9W_\x80\xFD[\x80c\xCC\x80\x89\xBB\x14a\x08\rW\x80c\xD3\x84\xCB\x95\x14a\x084W_\x80\xFD[\x80c\xB5\xE0\x0C?\x11a\x01=W\x80c\xC2\x1CB3\x11a\x01\x18W\x80c\xC2\x1CB3\x14a\x07\x98W\x80c\xC5\x19\xD1Q\x14a\x07\xBFW\x80c\xC8\x97\xF5^\x14a\x07\xE6W_\x80\xFD[\x80c\xB5\xE0\x0C?\x14a\x07#W\x80c\xB7\x01\x06\x97\x14a\x07JW\x80c\xBEA\xB3g\x14a\x07qW_\x80\xFD[\x80c\x99\x9F \xDB\x11a\x01mW\x80c\x99\x9F \xDB\x14a\x06\xB0W\x80c\x9F\x98T\xE5\x14a\x06\xC5W\x80c\xB3\x8DW\xF0\x14a\x06\xECW_\x80\xFD[\x80c\x87e$\x0F\x14a\x06bW\x80c\x91\xDD\xB2\x85\x14a\x06\x89W_\x80\xFD[\x80c0K\x90q\x11a\x02<W\x80c]\x9E$D\x11a\x01\xF2W\x80cx_\xFB7\x11a\x01\xCDW\x80cx_\xFB7\x14a\x05\xEDW\x80c\x81|\xD3\x12\x14a\x06\x14W\x80c\x85\xE1\xF4\xD0\x14a\x06;W_\x80\xFD[\x80c]\x9E$D\x14a\x05fW\x80c`\x9F\xB5\x03\x14a\x05\x9FW\x80cd\xF4\x99*\x14a\x05\xC6W_\x80\xFD[\x80cF\x92\xDE]\x11a\x02\"W\x80cF\x92\xDE]\x14a\x04\xF1W\x80cK/Q\xEF\x14a\x05\x18W\x80cL\xEC\xCF\xE5\x14a\x05?W_\x80\xFD[\x80c0K\x90q\x14a\x04\xC2W\x80c<+x@\x14a\x04\xCAW_\x80\xFD[\x80c\x10\xA6b\xE2\x11a\x02\x9CW\x80c\x1C\xCC,\xD1\x11a\x02wW\x80c\x1C\xCC,\xD1\x14a\x04aW\x80c(\xFB\"\x8C\x14a\x04\x88W\x80c,\xFB|\xA3\x14a\x04\x9BW_\x80\xFD[\x80c\x10\xA6b\xE2\x14a\x03\xECW\x80c\x1B\x14.\xA7\x14a\x04\x13W\x80c\x1C9\xB6r\x14a\x04:W_\x80\xFD[\x80c\x07\x87HK\x11a\x02\xCCW\x80c\x07\x87HK\x14a\x03^W\x80c\nT%}\x14a\x03\x85W\x80c\x10G\xFCR\x14a\x03\xACW_\x80\xFD[\x80b<x\xFB\x14a\x02\xE5W\x80b\xF9s\x1E\x14a\x03\x1FW[_\x80\xFD[a\x03\x0C\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81V[`@Q\x90\x81R` \x01[`@Q\x80\x91\x03\x90\xF3[a\x03F\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81V[`@Q`\x01`\x01`\xA0\x1B\x03\x90\x91\x16\x81R` \x01a\x03\x16V[a\x03F\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81V[a\x03F\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81V[a\x03\xD3\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81V[`@Qg\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x90\x91\x16\x81R` \x01a\x03\x16V[a\x03F\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81V[a\x03F\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81V[a\x03F\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81V[a\x03\x0C\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81V[a\x03Fa\x04\x966`\x04a)\xB1V[a\t\xA6V[a\x03F\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81V[a\x03\x0C`\x0C\x81V[a\x03F\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81V[a\x03F\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81V[a\x03F\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81V[a\x03\xD3\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81V[a\x05\x8D\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81V[`@Q`\xFF\x90\x91\x16\x81R` \x01a\x03\x16V[a\x03\x0C\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81V[a\x03F\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81V[a\x03\xD3\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81V[a\x03F\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81V[a\x03\x0C\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81V[a\x03F\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81V[a\x03\xD3\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81V[a\x06\xC3a\x06\xBE6`\x04a)\xDBV[a\n\x12V[\0[a\x03F\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81V[a\x07\x13\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81V[`@Q\x90\x15\x15\x81R` \x01a\x03\x16V[a\x03F\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81V[a\x03F\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81V[a\x03F\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81V[a\x03F\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81V[a\x03F\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81V[a\x03F\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81V[a\x03F\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81V[a\x03F\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81V[a\x03\xD3\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81V[a\x03F\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81V[a\x07\x13\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81V[a\x03\xD3\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81V[a\x06\xC3a\t\x056`\x04a*\xCEV[a\n\x9BV[a\x03\xD3\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81V[a\x03F\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81V[a\x03\x0C\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81V[a\x03\x0C\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81V[_\x80\x82`@Q` \x01a\t\xBB\x91\x81R` \x01\x90V[`@Q` \x81\x83\x03\x03\x81R\x90`@R\x80Q\x90` \x01 \x90Pa\n\x08\x81`@Q\x80` \x01a\t\xE7\x90a'\xF5V[` \x82\x01\x81\x03\x82R`\x1F\x19`\x1F\x82\x01\x16`@RP\x80Q\x90` \x01 \x86a\x13\xDFV[\x91PP[\x92\x91PPV[_\x83`\x01`\x01`\xA0\x1B\x03\x16;\x11\x80\x15a\nEWP\x82`\x01`\x01`\xA0\x1B\x03\x16a\n:\x83\x83a\t\xA6V[`\x01`\x01`\xA0\x1B\x03\x16\x14[a\n\x96W`@QbF\x1B\xCD`\xE5\x1B\x81R` `\x04\x82\x01R`\r`$\x82\x01R\x7FADDR_MISMATCH\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0`D\x82\x01R`d\x01[`@Q\x80\x91\x03\x90\xFD[PPPV[a\n\xA3a\x14gV[_a\n\xACa\x18\x06V[\x90P_\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0`@Qa\n\xFD\x90a(\x02V[`\x01`\x01`\xA0\x1B\x03\x92\x83\x16\x81R\x91\x16` \x82\x01R```@\x82\x01\x81\x90R_\x90\x82\x01R`\x80\x01`@Q\x80\x91\x03\x90_\xF0\x80\x15\x80\x15a\x0B;W=_\x80>=_\xFD[P\x90P_`@Q\x80a\x01 \x01`@R\x80\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0`\x01`\x01`\xA0\x1B\x03\x16\x81R` \x01\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0`\x01`\x01`\xA0\x1B\x03\x16\x81R` \x01\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0`\x01`\x01`\xA0\x1B\x03\x16\x81R` \x01\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0`\x01`\x01`\xA0\x1B\x03\x16\x81R` \x01\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0`\x01`\x01`\xA0\x1B\x03\x16\x81R` \x01\x83`\x01`\x01`\xA0\x1B\x03\x16\x81R` \x01\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0`\x01`\x01`\xA0\x1B\x03\x16\x81R` \x01\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0`\x01`\x01`\xA0\x1B\x03\x16\x81R` \x01\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0`\x01`\x01`\xA0\x1B\x03\x16c\xBCE\xE0\xAE`@Q\x81c\xFF\xFF\xFF\xFF\x16`\xE0\x1B\x81R`\x04\x01` `@Q\x80\x83\x03\x81\x86Z\xFA\x15\x80\x15a\x0C\xFFW=_\x80>=_\xFD[PPPP`@Q=`\x1F\x19`\x1F\x82\x01\x16\x82\x01\x80`@RP\x81\x01\x90a\r#\x91\x90a+hV[`\x01`\x01`\xA0\x1B\x03\x16\x81RP\x90P_\x83`\xC0\x01Q`@Q` \x01a\rI\x91\x81R` \x01\x90V[`@Q` \x81\x83\x03\x03\x81R\x90`@R\x80Q\x90` \x01 \x90P_a\rp0\x86`\xC0\x01Qa\t\xA6V[\x90Pa\r{\x81a\x1E\xB3V[\x83`\x01`\x01`\xA0\x1B\x03\x16c\x1Ar\xD5L\x82\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x89a\x01\x80\x01Q\x8Aa\x01\xA0\x01Q\x8Ba\x01\xC0\x01Q\x8C` \x01Q\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x8Ea\x02@\x01Q\x8Fa\x01@\x01Q`@Q\x8Bc\xFF\xFF\xFF\xFF\x16`\xE0\x1B\x81R`\x04\x01a\x0E6\x9A\x99\x98\x97\x96\x95\x94\x93\x92\x91\x90a+\x83V[_`@Q\x80\x83\x03\x81_\x87\x80;\x15\x80\x15a\x0EMW_\x80\xFD[PZ\xF1\x15\x80\x15a\x0E_W=_\x80>=_\xFD[PPPP_\x82`@Qa\x0Eq\x90a'\xF5V[\x81\x90`@Q\x80\x91\x03\x90_\xF5\x90P\x80\x15\x80\x15a\x0E\x8EW=_\x80>=_\xFD[P\x90P\x81`\x01`\x01`\xA0\x1B\x03\x16\x81`\x01`\x01`\xA0\x1B\x03\x16\x14a\x0E\xF2W`@QbF\x1B\xCD`\xE5\x1B\x81R` `\x04\x82\x01R`\x15`$\x82\x01R\x7FUNEXPCTED_ROLLUP_ADDR\0\0\0\0\0\0\0\0\0\0\0`D\x82\x01R`d\x01a\n\x8DV[`\x80\x86\x01\x80Q0\x90\x91R`@Q\x7F\xAD\xFE\xF6\xAC\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x01`\x01`\xA0\x1B\x03\x83\x16\x90c\xAD\xFE\xF6\xAC\x90a\x0FC\x90\x8A\x90\x89\x90`\x04\x01a.\x1AV[_`@Q\x80\x83\x03\x81_\x87\x80;\x15\x80\x15a\x0FZW_\x80\xFD[PZ\xF1\x15\x80\x15a\x0FlW=_\x80>=_\xFD[PPPP\x87Q_\x14a\x11lW_\x88Qg\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x11\x15a\x0F\x93Wa\x0F\x93a*\x19V[`@Q\x90\x80\x82R\x80` \x02` \x01\x82\x01`@R\x80\x15a\x0F\xBCW\x81` \x01` \x82\x02\x806\x837\x01\x90P[P\x90P_[\x89Q\x81\x10\x15a\x10\xF5W\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0`\x01`\x01`\xA0\x1B\x03\x16c\xFA\xCDt;\x8B\x83\x81Q\x81\x10a\x10\x0BWa\x10\x0Ba01V[` \x02` \x01\x01Q`@Q\x82c\xFF\xFF\xFF\xFF\x16`\xE0\x1B\x81R`\x04\x01a\x10>\x91\x90`\x01`\x01`\xA0\x1B\x03\x91\x90\x91\x16\x81R` \x01\x90V[` `@Q\x80\x83\x03\x81\x86Z\xFA\x15\x80\x15a\x10YW=_\x80>=_\xFD[PPPP`@Q=`\x1F\x19`\x1F\x82\x01\x16\x82\x01\x80`@RP\x81\x01\x90a\x10}\x91\x90a0YV[a\x10\xC9W`@QbF\x1B\xCD`\xE5\x1B\x81R` `\x04\x82\x01R`\x18`$\x82\x01R\x7FUNEXPECTED_NEW_VALIDATOR\0\0\0\0\0\0\0\0`D\x82\x01R`d\x01a\n\x8DV[`\x01\x82\x82\x81Q\x81\x10a\x10\xDDWa\x10\xDDa01V[\x91\x15\x15` \x92\x83\x02\x91\x90\x91\x01\x90\x91\x01R`\x01\x01a\x0F\xC1V[P`@Q\x7F\xA3\xFF\xB7r\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x01`\x01`\xA0\x1B\x03\x84\x16\x90c\xA3\xFF\xB7r\x90a\x11=\x90\x8C\x90\x85\x90`\x04\x01a0\xAAV[_`@Q\x80\x83\x03\x81_\x87\x80;\x15\x80\x15a\x11TW_\x80\xFD[PZ\xF1\x15\x80\x15a\x11fW=_\x80>=_\xFD[PPPPP[\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x15a\x12\"W`@Q\x7F\xA2\xB4\xF1\xD8\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x15\x15`\x04\x82\x01R`\x01`\x01`\xA0\x1B\x03\x83\x16\x90c\xA2\xB4\xF1\xD8\x90`$\x01_`@Q\x80\x83\x03\x81_\x87\x80;\x15\x80\x15a\x12\x0BW_\x80\xFD[PZ\xF1\x15\x80\x15a\x12\x1DW=_\x80>=_\xFD[PPPP[\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0`\x01`\x01`\xA0\x1B\x03\x16cU\x84\nX`@Q\x81c\xFF\xFF\xFF\xFF\x16`\xE0\x1B\x81R`\x04\x01` `@Q\x80\x83\x03\x81\x86Z\xFA\x92PPP\x80\x15a\x12\x9CWP`@\x80Q`\x1F=\x90\x81\x01`\x1F\x19\x16\x82\x01\x90\x92Ra\x12\x99\x91\x81\x01\x90a+hV[`\x01[\x15a\x13\"W`\x01`\x01`\xA0\x1B\x03\x81\x16\x15a\x13 W`@Q\x7F\rV\x1B7\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x01`\x01`\xA0\x1B\x03\x82\x81\x16`\x04\x83\x01R\x84\x16\x90c\rV\x1B7\x90`$\x01_`@Q\x80\x83\x03\x81_\x87\x80;\x15\x80\x15a\x13\tW_\x80\xFD[PZ\xF1\x15\x80\x15a\x13\x1BW=_\x80>=_\xFD[PPPP[P[`@Q\x7F\x13\xAF@5\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x01`\x01`\xA0\x1B\x03\x82\x81\x16`\x04\x83\x01R\x83\x16\x90c\x13\xAF@5\x90`$\x01_`@Q\x80\x83\x03\x81_\x87\x80;\x15\x80\x15a\x13{W_\x80\xFD[PZ\xF1\x15\x80\x15a\x13\x8DW=_\x80>=_\xFD[PP`@\x80Q`\x01`\x01`\xA0\x1B\x03\x80\x88\x16\x82R\x8A\x16` \x82\x01R\x7F~\\\xC5\xC3\xFC\xE0F\xD8h\xD5\x91\x85H\xDF\x8D>\x8E\xF9\xF0\x9Eo\xB3\nh\x08\x1F\x1F\x13H\xCD\x03\x14\x93P\x01\x90P`@Q\x80\x91\x03\x90\xA1PPPPPPPPV[`@\x80Q\x7F\xFF\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0` \x80\x83\x01\x91\x90\x91R``\x84\x90\x1B\x7F\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\0\0\0\0\0\0\0\0\0\0\0\0\x16`!\x83\x01R`5\x82\x01\x86\x90R`U\x80\x83\x01\x86\x90R\x83Q\x80\x84\x03\x90\x91\x01\x81R`u\x90\x92\x01\x90\x92R\x80Q\x91\x01 [\x93\x92PPPV[\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0`\x01`\x01`\xA0\x1B\x03\x16c\x84V\xCBY`@Q\x81c\xFF\xFF\xFF\xFF\x16`\xE0\x1B\x81R`\x04\x01_`@Q\x80\x83\x03\x81_\x87\x80;\x15\x80\x15a\x14\xBFW_\x80\xFD[PZ\xF1\x15\x80\x15a\x14\xD1W=_\x80>=_\xFD[PPPP_\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0`\x01`\x01`\xA0\x1B\x03\x16c\xDF\xF6\x97\x87`@Q\x81c\xFF\xFF\xFF\xFF\x16`\xE0\x1B\x81R`\x04\x01` `@Q\x80\x83\x03\x81\x86Z\xFA\x15\x80\x15a\x152W=_\x80>=_\xFD[PPPP`@Q=`\x1F\x19`\x1F\x82\x01\x16\x82\x01\x80`@RP\x81\x01\x90a\x15V\x91\x90a1\x18V[\x90P`2\x81g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x11\x15a\x15oWP`2[_[\x81g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x81g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x10\x15a\x18\x02W`@Q\x7Fm\xDD7D\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81Rg\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x82\x16`\x04\x82\x01R_\x90\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0`\x01`\x01`\xA0\x1B\x03\x16\x90cm\xDD7D\x90`$\x01` `@Q\x80\x83\x03\x81\x86Z\xFA\x15\x80\x15a\x16\x14W=_\x80>=_\xFD[PPPP`@Q=`\x1F\x19`\x1F\x82\x01\x16\x82\x01\x80`@RP\x81\x01\x90a\x168\x91\x90a+hV[`@Q\x7F\xA2<D\xB1\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x01`\x01`\xA0\x1B\x03\x80\x83\x16`\x04\x83\x01R\x91\x92P_\x91\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x16\x90c\xA2<D\xB1\x90`$\x01`\xA0`@Q\x80\x83\x03\x81\x86Z\xFA\x15\x80\x15a\x16\xBAW=_\x80>=_\xFD[PPPP`@Q=`\x1F\x19`\x1F\x82\x01\x16\x82\x01\x80`@RP\x81\x01\x90a\x16\xDE\x91\x90a11V[\x90P\x80`\x80\x01Q\x80\x15a\x16\xFDWP``\x81\x01Qg\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x15[\x15a\x17\xEDW`@\x80Q`\x01\x80\x82R\x81\x83\x01\x90\x92R_\x91` \x80\x83\x01\x90\x806\x837\x01\x90PP\x90P\x82\x81_\x81Q\x81\x10a\x176Wa\x176a01V[`\x01`\x01`\xA0\x1B\x03\x92\x83\x16` \x91\x82\x02\x92\x90\x92\x01\x01R`@Q\x7F|u\xC2\x98\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x90\x91\x16\x90c|u\xC2\x98\x90a\x17\xAB\x90\x84\x90`\x04\x01a1\xB6V[_`@Q\x80\x83\x03\x81_\x87\x80;\x15\x80\x15a\x17\xC2W_\x80\xFD[PZ\xF1\x15\x80\x15a\x17\xD4W=_\x80>=_\xFD[PPPP`\x01\x85a\x17\xE5\x91\x90a1\xDCV[\x94PPa\x17\xFBV[\x82a\x17\xF7\x81a2\x04V[\x93PP[PPa\x15qV[PPV[a\x18\x0Ea(\x0FV[_\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0`\x01`\x01`\xA0\x1B\x03\x16c\x92\xC8\x13L\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0`\x01`\x01`\xA0\x1B\x03\x16ce\xF7\xF8\r`@Q\x81c\xFF\xFF\xFF\xFF\x16`\xE0\x1B\x81R`\x04\x01` `@Q\x80\x83\x03\x81\x86Z\xFA\x15\x80\x15a\x18\x9AW=_\x80>=_\xFD[PPPP`@Q=`\x1F\x19`\x1F\x82\x01\x16\x82\x01\x80`@RP\x81\x01\x90a\x18\xBE\x91\x90a1\x18V[`@Q\x7F\xFF\xFF\xFF\xFF\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0`\xE0\x84\x90\x1B\x16\x81Rg\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x90\x91\x16`\x04\x82\x01R`$\x01a\x01\x80`@Q\x80\x83\x03\x81\x86Z\xFA\x15\x80\x15a\x19\x1AW=_\x80>=_\xFD[PPPP`@Q=`\x1F\x19`\x1F\x82\x01\x16\x82\x01\x80`@RP\x81\x01\x90a\x19>\x91\x90a2*V[Q`@Q\x7F\x8E\xAAj\xC0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x81\x01\x82\x90R\x90\x91P_\x90\x81\x90\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0`\x01`\x01`\xA0\x1B\x03\x16\x90c\x8E\xAAj\xC0\x90`$\x01`\xC0`@Q\x80\x83\x03\x81\x86Z\xFA\x15\x80\x15a\x19\xC2W=_\x80>=_\xFD[PPPP`@Q=`\x1F\x19`\x1F\x82\x01\x16\x82\x01\x80`@RP\x81\x01\x90a\x19\xE6\x91\x90a3\\V[\x91P\x91Pa\x19\xF2a)\x1DV[\x82Q\x81R` \x80\x84\x01Q\x90\x82\x01\x90`\x02\x81\x11\x15a\x1A\x11Wa\x1A\x11a,\xF8V[\x90\x81`\x02\x81\x11\x15a\x1A$Wa\x1A$a,\xF8V[\x90RP\x83`\x01`\x01`\xA0\x1B\x03\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x16c1dA0a\x1A`\x84a#1V[\x85`@Q\x83c\xFF\xFF\xFF\xFF\x16`\xE0\x1B\x81R`\x04\x01a\x1A~\x92\x91\x90a4\x16V[` `@Q\x80\x83\x03\x81\x86Z\xFA\x15\x80\x15a\x1A\x99W=_\x80>=_\xFD[PPPP`@Q=`\x1F\x19`\x1F\x82\x01\x16\x82\x01\x80`@RP\x81\x01\x90a\x1A\xBD\x91\x90a4HV[\x14a\x1B\nW`@QbF\x1B\xCD`\xE5\x1B\x81R` `\x04\x82\x01R`\x1D`$\x82\x01R\x7FInvalid latest execution hash\0\0\0`D\x82\x01R`d\x01a\n\x8DV[a\x1B1`@Q\x80`\x80\x01`@R\x80_\x81R` \x01_\x81R` \x01_\x81R` \x01_\x81RP\x90V[`@\x80Q``\x81\x01\x82R_\x80\x82R` \x82\x01\x81\x90R\x91\x81\x01\x91\x90\x91R`@Q\x80a\x02\xA0\x01`@R\x80\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x81R` \x01\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0`\x01`\x01`\xA0\x1B\x03\x16\x81R` \x01\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R` \x01\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0`\x01`\x01`\xA0\x1B\x03\x16c\x8E\xE1\xA1&`@Q\x81c\xFF\xFF\xFF\xFF\x16`\xE0\x1B\x81R`\x04\x01` `@Q\x80\x83\x03\x81\x86Z\xFA\x15\x80\x15a\x1C:W=_\x80>=_\xFD[PPPP`@Q=`\x1F\x19`\x1F\x82\x01\x16\x82\x01\x80`@RP\x81\x01\x90a\x1C^\x91\x90a4HV[\x81R` \x010`\x01`\x01`\xA0\x1B\x03\x16\x81R` \x01\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0`\x01`\x01`\xA0\x1B\x03\x16\x81R` \x01\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R` \x01`@Q\x80` \x01`@R\x80_\x81RP\x81R` \x01\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R` \x01\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x81R` \x01\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0`\x01`\x01`\xA0\x1B\x03\x16c\xB0\xEC*\xE1`@Q\x81c\xFF\xFF\xFF\xFF\x16`\xE0\x1B\x81R`\x04\x01_`@Q\x80\x83\x03\x81\x86Z\xFA\x15\x80\x15a\x1D\x8CW=_\x80>=_\xFD[PPPP`@Q=_\x82>`\x1F=\x90\x81\x01`\x1F\x19\x16\x82\x01`@Ra\x1D\xB3\x91\x90\x81\x01\x90a4_V[\x81R` \x01\x83\x81R` \x01\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R` \x01\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R` \x01\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R` \x01\x84\x81R` \x01\x85\x81R` \x01_`\x01`\x01`\xA0\x1B\x03\x16\x81R` \x01\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0`\xFF\x16\x81R` \x01\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x81R` \x01\x82\x81RP\x96PPPPPPP\x90V[`@Qc&j#\xB1`\xE2\x1B\x81R`\x01`\x01`\xA0\x1B\x03\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81\x81\x16`\x04\x84\x01R\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x82\x16`$\x84\x01R\x91\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x90\x91\x16\x90c\x99\xA8\x8E\xC4\x90`D\x01_`@Q\x80\x83\x03\x81_\x87\x80;\x15\x80\x15a\x1F_W_\x80\xFD[PZ\xF1\x15\x80\x15a\x1FqW=_\x80>=_\xFD[PP`@Q\x7F\x91\x9C\xC7\x06\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x01`\x01`\xA0\x1B\x03\x85\x81\x16`\x04\x83\x01R\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x16\x92Pc\x91\x9C\xC7\x06\x91P`$\x01_`@Q\x80\x83\x03\x81_\x87\x80;\x15\x80\x15a\x1F\xEEW_\x80\xFD[PZ\xF1\x15\x80\x15a \0W=_\x80>=_\xFD[PPPPa \x0Ca#kV[`@Qc&j#\xB1`\xE2\x1B\x81R`\x01`\x01`\xA0\x1B\x03\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81\x81\x16`\x04\x84\x01R\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x82\x16`$\x84\x01R\x91\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x90\x91\x16\x90c\x99\xA8\x8E\xC4\x90`D\x01_`@Q\x80\x83\x03\x81_\x87\x80;\x15\x80\x15a \xB8W_\x80\xFD[PZ\xF1\x15\x80\x15a \xCAW=_\x80>=_\xFD[PP`@Qc&j#\xB1`\xE2\x1B\x81R`\x01`\x01`\xA0\x1B\x03\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81\x81\x16`\x04\x84\x01R\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x82\x16`$\x84\x01R\x93P\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x16\x91Pc\x99\xA8\x8E\xC4\x90`D\x01_`@Q\x80\x83\x03\x81_\x87\x80;\x15\x80\x15a!xW_\x80\xFD[PZ\xF1\x15\x80\x15a!\x8AW=_\x80>=_\xFD[PPPP\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0`\x01`\x01`\xA0\x1B\x03\x16cj\xE7\x1F\x12`@Q\x81c\xFF\xFF\xFF\xFF\x16`\xE0\x1B\x81R`\x04\x01_`@Q\x80\x83\x03\x81_\x87\x80;\x15\x80\x15a!\xE6W_\x80\xFD[PZ\xF1\x15\x80\x15a!\xF8W=_\x80>=_\xFD[PP`@Qc&j#\xB1`\xE2\x1B\x81R`\x01`\x01`\xA0\x1B\x03\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81\x81\x16`\x04\x84\x01R\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x82\x16`$\x84\x01R\x93P\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x16\x91Pc\x99\xA8\x8E\xC4\x90`D\x01_`@Q\x80\x83\x03\x81_\x87\x80;\x15\x80\x15a\"\xA6W_\x80\xFD[PZ\xF1\x15\x80\x15a\"\xB8W=_\x80>=_\xFD[PPPP\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0`\x01`\x01`\xA0\x1B\x03\x16cj\xE7\x1F\x12`@Q\x81c\xFF\xFF\xFF\xFF\x16`\xE0\x1B\x81R`\x04\x01_`@Q\x80\x83\x03\x81_\x87\x80;\x15\x80\x15a#\x14W_\x80\xFD[PZ\xF1\x15\x80\x15a#&W=_\x80>=_\xFD[PPPPPPPPPV[a#9a)BV[`@Q\x80`@\x01`@R\x80\x83_\x01Q\x81R` \x01\x83` \x01Q`\x02\x81\x11\x15a#cWa#ca,\xF8V[\x90R\x92\x91PPV[\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x15a%oW\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0`\x01`\x01`\xA0\x1B\x03\x16c\x96#`\x9D\x82\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0`@Q\x80``\x01`@R\x80\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x81R` \x01\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x81R` \x01\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x81RP`@Q`$\x01a$\xAC\x91\x90a4\xE0V[`@\x80Q`\x1F\x19\x81\x84\x03\x01\x81R\x91\x81R` \x82\x01\x80Q{\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x7F\xA6U\xD97\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x17\x90RQ\x7F\xFF\xFF\xFF\xFF\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0`\xE0\x86\x90\x1B\x16\x81Ra%=\x93\x92\x91\x90`\x04\x01a5\x11V[_`@Q\x80\x83\x03\x81_\x87\x80;\x15\x80\x15a%TW_\x80\xFD[PZ\xF1\x15\x80\x15a%fW=_\x80>=_\xFD[PPPPa&\x0EV[`@Qc&j#\xB1`\xE2\x1B\x81R`\x01`\x01`\xA0\x1B\x03\x82\x81\x16`\x04\x83\x01R\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81\x16`$\x83\x01R\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x16\x90c\x99\xA8\x8E\xC4\x90`D\x01_`@Q\x80\x83\x03\x81_\x87\x80;\x15\x80\x15a%\xF7W_\x80\xFD[PZ\xF1\x15\x80\x15a&\tW=_\x80>=_\xFD[PPPP[_\x80_\x80\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0`\x01`\x01`\xA0\x1B\x03\x16c\xEB\xEAF\x1D`@Q\x81c\xFF\xFF\xFF\xFF\x16`\xE0\x1B\x81R`\x04\x01`\x80`@Q\x80\x83\x03\x81\x86Z\xFA\x15\x80\x15a&nW=_\x80>=_\xFD[PPPP`@Q=`\x1F\x19`\x1F\x82\x01\x16\x82\x01\x80`@RP\x81\x01\x90a&\x92\x91\x90a5EV[\x93P\x93P\x93P\x93P_`\x0C\x83a&\xA8\x91\x90a5\x8CV[\x15a&\xC8Wa&\xB8`\x0C\x84a5\x9FV[a&\xC3\x90`\x01a5\xB2V[a&\xD3V[a&\xD3`\x0C\x84a5\x9FV[\x90P\x84\x81\x11a&\xE2W\x84a&\xE4V[\x80[\x94P\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0`\x01`\x01`\xA0\x1B\x03\x16c\xB3\x17a\xF8`@Q\x80`\x80\x01`@R\x80\x88\x81R` \x01\x87\x81R` \x01\x86\x81R` \x01\x85\x81RP`@Q\x82c\xFF\xFF\xFF\xFF\x16`\xE0\x1B\x81R`\x04\x01a'R\x91\x90a5\xC5V[_`@Q\x80\x83\x03\x81_\x87\x80;\x15\x80\x15a'iW_\x80\xFD[PZ\xF1\x15\x80\x15a'{W=_\x80>=_\xFD[PPPP\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0`\x01`\x01`\xA0\x1B\x03\x16cj\xE7\x1F\x12`@Q\x81c\xFF\xFF\xFF\xFF\x16`\xE0\x1B\x81R`\x04\x01_`@Q\x80\x83\x03\x81_\x87\x80;\x15\x80\x15a'\xD7W_\x80\xFD[PZ\xF1\x15\x80\x15a'\xE9W=_\x80>=_\xFD[PPPPPPPPPPV[a\x13\xE4\x80a5\xF1\x839\x01\x90V[a\r\x89\x80aI\xD5\x839\x01\x90V[`@Q\x80a\x02\xA0\x01`@R\x80_g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x81R` \x01_`\x01`\x01`\xA0\x1B\x03\x16\x81R` \x01_\x81R` \x01_\x80\x19\x16\x81R` \x01_`\x01`\x01`\xA0\x1B\x03\x16\x81R` \x01_`\x01`\x01`\xA0\x1B\x03\x16\x81R` \x01_\x81R` \x01``\x81R` \x01_\x81R` \x01_g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x81R` \x01``\x81R` \x01a(\xB8`@Q\x80`\x80\x01`@R\x80_\x81R` \x01_\x81R` \x01_\x81R` \x01_\x81RP\x90V[\x81R` \x01_\x81R` \x01_\x81R` \x01_\x81R` \x01a(\xD7a)\x1DV[\x81R_` \x80\x83\x01\x82\x90R`@\x80\x84\x01\x83\x90R``\x80\x85\x01\x84\x90R`\x80\x85\x01\x84\x90R\x81Q\x90\x81\x01\x82R\x83\x81R\x91\x82\x01\x83\x90R\x81\x01\x91\x90\x91R`\xA0\x90\x91\x01R\x90V[\x90R\x90V[`@Q\x80``\x01`@R\x80a)0a)`V[\x81R` \x01_\x81R_` \x90\x91\x01R\x90V[`@Q\x80`@\x01`@R\x80a)Ua)`V[\x81R` \x01_\x90R\x90V[`@Q\x80`@\x01`@R\x80a)sa)|V[\x81R` \x01a)\x18[`@Q\x80`@\x01`@R\x80`\x02\x90` \x82\x02\x806\x837P\x91\x92\x91PPV[`\x01`\x01`\xA0\x1B\x03\x81\x16\x81\x14a)\xAEW_\x80\xFD[PV[_\x80`@\x83\x85\x03\x12\x15a)\xC2W_\x80\xFD[\x825a)\xCD\x81a)\x9AV[\x94` \x93\x90\x93\x015\x93PPPV[_\x80_``\x84\x86\x03\x12\x15a)\xEDW_\x80\xFD[\x835a)\xF8\x81a)\x9AV[\x92P` \x84\x015a*\x08\x81a)\x9AV[\x92\x95\x92\x94PPP`@\x91\x90\x91\x015\x90V[cNH{q`\xE0\x1B_R`A`\x04R`$_\xFD[`@Qa\x01\x80\x81\x01g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x11\x82\x82\x10\x17\x15a*QWa*Qa*\x19V[`@R\x90V[`@\x80Q\x90\x81\x01g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x11\x82\x82\x10\x17\x15a*QWa*Qa*\x19V[`@Q`\x1F\x82\x01`\x1F\x19\x16\x81\x01g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x11\x82\x82\x10\x17\x15a*\xA3Wa*\xA3a*\x19V[`@R\x91\x90PV[_g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x82\x11\x15a*\xC4Wa*\xC4a*\x19V[P`\x05\x1B` \x01\x90V[_` \x80\x83\x85\x03\x12\x15a*\xDFW_\x80\xFD[\x825g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x11\x15a*\xF5W_\x80\xFD[\x83\x01`\x1F\x81\x01\x85\x13a+\x05W_\x80\xFD[\x805a+\x18a+\x13\x82a*\xABV[a*zV[\x81\x81R`\x05\x91\x90\x91\x1B\x82\x01\x83\x01\x90\x83\x81\x01\x90\x87\x83\x11\x15a+6W_\x80\xFD[\x92\x84\x01\x92[\x82\x84\x10\x15a+]W\x835a+N\x81a)\x9AV[\x82R\x92\x84\x01\x92\x90\x84\x01\x90a+;V[\x97\x96PPPPPPPV[_` \x82\x84\x03\x12\x15a+xW_\x80\xFD[\x81Qa\x14`\x81a)\x9AV[_a\x01@\x80\x83\x01`\x01`\x01`\xA0\x1B\x03\x80\x8F\x16\x85R` g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x8F\x16` \x87\x01R\x81\x8E\x16`@\x87\x01R\x8C``\x87\x01R\x8B`\x80\x87\x01R\x8A`\xA0\x87\x01R\x81\x8A\x16`\xC0\x87\x01R\x81\x89\x16`\xE0\x87\x01R`\xFF\x88\x16a\x01\0\x87\x01R\x83a\x01 \x87\x01R\x82\x93P\x86Q\x91P\x81\x83Ra\x01`\x86\x01\x93P` \x87\x01\x92P_[\x82\x81\x10\x15a,\x19W\x83Q\x85R\x93\x81\x01\x93\x92\x81\x01\x92`\x01\x01a+\xFDV[P\x92\x9F\x9EPPPPPPPPPPPPPPPV[_\x81Q\x80\x84R\x80` \x84\x01` \x86\x01^_` \x82\x86\x01\x01R` `\x1F\x19`\x1F\x83\x01\x16\x85\x01\x01\x91PP\x92\x91PPV[_\x81Q\x80\x84R` \x80\x85\x01\x94P` \x84\x01_[\x83\x81\x10\x15a,\x8BW\x81Q\x87R\x95\x82\x01\x95\x90\x82\x01\x90`\x01\x01a,oV[P\x94\x95\x94PPPPPV[\x80Q\x82_[`\x02\x81\x10\x15a,\xBAW\x82Q\x82R` \x92\x83\x01\x92\x90\x91\x01\x90`\x01\x01a,\x9BV[PPP` \x80\x82\x01Q`@\x84\x01_[`\x02\x81\x10\x15a,\xF0W\x82Qg\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x82R\x91\x83\x01\x91\x90\x83\x01\x90`\x01\x01a,\xC9V[PPPPPPV[cNH{q`\xE0\x1B_R`!`\x04R`$_\xFD[`\x03\x81\x10a-(WcNH{q`\xE0\x1B_R`!`\x04R`$_\xFD[\x90RV[a-7\x82\x82Qa,\x96V[` \x81\x01Qa-I`\x80\x84\x01\x82a-\x0CV[P`@\x01Q`\xA0\x91\x90\x91\x01RV[`\x01`\x01`\xA0\x1B\x03\x80\x82Q\x16\x83R\x80` \x83\x01Q\x16` \x84\x01R\x80`@\x83\x01Q\x16`@\x84\x01RP``\x81\x01Qa-\x98``\x84\x01\x82`\x01`\x01`\xA0\x1B\x03\x16\x90RV[P`\x80\x81\x01Qa-\xB3`\x80\x84\x01\x82`\x01`\x01`\xA0\x1B\x03\x16\x90RV[P`\xA0\x81\x01Qa-\xCE`\xA0\x84\x01\x82`\x01`\x01`\xA0\x1B\x03\x16\x90RV[P`\xC0\x81\x01Qa-\xE9`\xC0\x84\x01\x82`\x01`\x01`\xA0\x1B\x03\x16\x90RV[P`\xE0\x81\x01Qa.\x04`\xE0\x84\x01\x82`\x01`\x01`\xA0\x1B\x03\x16\x90RV[Pa\x01\0\x90\x81\x01Q`\x01`\x01`\xA0\x1B\x03\x16\x91\x01RV[_a\x01@\x80\x83Ra.7\x81\x84\x01\x86Qg\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x90RV[` \x85\x01Q`\x01`\x01`\xA0\x1B\x03\x81\x16a\x01`\x85\x01RP`@\x85\x01Qa\x01\x80\x81\x81\x86\x01R``\x87\x01Q\x91Pa\x01\xA0\x82\x81\x87\x01R`\x80\x88\x01Q\x92Pa\x01\xC0a.\x87\x81\x88\x01\x85`\x01`\x01`\xA0\x1B\x03\x16\x90RV[`\xA0\x89\x01Q\x93Pa\x01\xE0a.\xA5\x81\x89\x01\x86`\x01`\x01`\xA0\x1B\x03\x16\x90RV[`\xC0\x8A\x01Q\x94Pa\x02\0\x85\x81\x8A\x01R`\xE0\x8B\x01Q\x95Pa\x02 a\x03\xE0\x81\x8B\x01Ra.\xD3a\x05 \x8B\x01\x88a,.V[\x96Pa\x01\0\x8C\x01Qa\x02@\x81\x81\x8D\x01Ra\x01 \x8E\x01Q\x91Pa\x02`a/\x03\x81\x8E\x01\x84g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x90RV[\x8A\x8F\x01Q\x9APa\x02\x80\x92P\x7F\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFE\xC0\x8D\x8B\x03\x01\x83\x8E\x01Ra/A\x8A\x8Ca,\\V[\x9APa\x01`\x8F\x01Q\x99Pa/za\x02\xA0\x8E\x01\x8B\x80Q\x82R` \x81\x01Q` \x83\x01R`@\x81\x01Q`@\x83\x01R``\x81\x01Q``\x83\x01RPPV[\x88\x8F\x01Qa\x03 \x8E\x01R\x87\x8F\x01Qa\x03@\x8E\x01R\x86\x8F\x01Qa\x03`\x8E\x01R\x85\x8F\x01Q\x99Pa/\xACa\x03\x80\x8E\x01\x8Ba-,V[\x93\x8E\x01Qa\x04@\x8D\x01R\x91\x8D\x01Q`\x01`\x01`\xA0\x1B\x03\x16a\x04`\x8C\x01R\x90\x8C\x01Q`\xFF\x16a\x04\x80\x8B\x01R\x90\x8B\x01Qg\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x90\x81\x16a\x04\xA0\x8B\x01R\x90\x8B\x01Q\x80Q\x82\x16a\x04\xC0\x8B\x01R` \x81\x01Q\x82\x16a\x04\xE0\x8B\x01R`@\x81\x01Q\x90\x91\x16a\x05\0\x8A\x01R\x94Pa0!\x93PPPPV[P\x90Pa\x14`` \x83\x01\x84a-WV[cNH{q`\xE0\x1B_R`2`\x04R`$_\xFD[\x80Q\x80\x15\x15\x81\x14a0TW_\x80\xFD[\x91\x90PV[_` \x82\x84\x03\x12\x15a0iW_\x80\xFD[a\x14`\x82a0EV[_\x81Q\x80\x84R` \x80\x85\x01\x94P` \x84\x01_[\x83\x81\x10\x15a,\x8BW\x81Q`\x01`\x01`\xA0\x1B\x03\x16\x87R\x95\x82\x01\x95\x90\x82\x01\x90`\x01\x01a0\x85V[`@\x81R_a0\xBC`@\x83\x01\x85a0rV[\x82\x81\x03` \x84\x81\x01\x91\x90\x91R\x84Q\x80\x83R\x85\x82\x01\x92\x82\x01\x90_[\x81\x81\x10\x15a0\xF4W\x84Q\x15\x15\x83R\x93\x83\x01\x93\x91\x83\x01\x91`\x01\x01a0\xD6V[P\x90\x97\x96PPPPPPPV[\x80Qg\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x16\x81\x14a0TW_\x80\xFD[_` \x82\x84\x03\x12\x15a1(W_\x80\xFD[a\x14`\x82a1\x01V[_`\xA0\x82\x84\x03\x12\x15a1AW_\x80\xFD[`@Q`\xA0\x81\x01\x81\x81\x10g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x82\x11\x17\x15a1dWa1da*\x19V[`@R\x82Q\x81Ra1w` \x84\x01a1\x01V[` \x82\x01Ra1\x88`@\x84\x01a1\x01V[`@\x82\x01Ra1\x99``\x84\x01a1\x01V[``\x82\x01Ra1\xAA`\x80\x84\x01a0EV[`\x80\x82\x01R\x93\x92PPPV[` \x81R_a\x14`` \x83\x01\x84a0rV[cNH{q`\xE0\x1B_R`\x11`\x04R`$_\xFD[g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x82\x81\x16\x82\x82\x16\x03\x90\x80\x82\x11\x15a1\xFDWa1\xFDa1\xC8V[P\x92\x91PPV[_g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x80\x83\x16\x81\x81\x03a2 Wa2 a1\xC8V[`\x01\x01\x93\x92PPPV[_a\x01\x80\x82\x84\x03\x12\x15a2;W_\x80\xFD[a2Ca*-V[\x82Q\x81R` \x83\x01Q` \x82\x01R`@\x83\x01Q`@\x82\x01Ra2g``\x84\x01a1\x01V[``\x82\x01Ra2x`\x80\x84\x01a1\x01V[`\x80\x82\x01Ra2\x89`\xA0\x84\x01a1\x01V[`\xA0\x82\x01Ra2\x9A`\xC0\x84\x01a1\x01V[`\xC0\x82\x01Ra2\xAB`\xE0\x84\x01a1\x01V[`\xE0\x82\x01Ra\x01\0a2\xBE\x81\x85\x01a1\x01V[\x90\x82\x01Ra\x01 a2\xD0\x84\x82\x01a1\x01V[\x90\x82\x01Ra\x01@a2\xE2\x84\x82\x01a1\x01V[\x90\x82\x01Ra\x01`\x92\x83\x01Q\x92\x81\x01\x92\x90\x92RP\x91\x90PV[_\x82`\x1F\x83\x01\x12a3\tW_\x80\xFD[a3\x11a*WV[\x80`@\x84\x01\x85\x81\x11\x15a3\"W_\x80\xFD[\x84[\x81\x81\x10\x15a3CWa35\x81a1\x01V[\x84R` \x93\x84\x01\x93\x01a3$V[P\x90\x95\x94PPPPPV[\x80Q`\x03\x81\x10a0TW_\x80\xFD[_\x80\x82\x84\x03`\xC0\x81\x12\x15a3nW_\x80\xFD[`\xA0\x81\x12\x15a3{W_\x80\xFD[a3\x83a*WV[`\x80\x82\x12\x15a3\x90W_\x80\xFD[a3\x98a*WV[\x91P\x85`\x1F\x86\x01\x12a3\xA8W_\x80\xFD[a3\xB0a*WV[\x80`@\x87\x01\x88\x81\x11\x15a3\xC1W_\x80\xFD[\x87[\x81\x81\x10\x15a3\xDBW\x80Q\x84R` \x93\x84\x01\x93\x01a3\xC3V[P\x81\x85Ra3\xE9\x89\x82a2\xFAV[` \x86\x01RPPP\x81\x81Ra4\0`\x80\x86\x01a3NV[` \x82\x01R`\xA0\x94\x90\x94\x01Q\x93\x95\x93\x94PPPPV[_`\xC0\x82\x01\x90Pa4(\x82\x85Qa,\x96V[` \x84\x01Qa4:`\x80\x84\x01\x82a-\x0CV[P\x82`\xA0\x83\x01R\x93\x92PPPV[_` \x82\x84\x03\x12\x15a4XW_\x80\xFD[PQ\x91\x90PV[_` \x80\x83\x85\x03\x12\x15a4pW_\x80\xFD[\x82Qg\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x11\x15a4\x86W_\x80\xFD[\x83\x01`\x1F\x81\x01\x85\x13a4\x96W_\x80\xFD[\x80Qa4\xA4a+\x13\x82a*\xABV[\x81\x81R`\x05\x91\x90\x91\x1B\x82\x01\x83\x01\x90\x83\x81\x01\x90\x87\x83\x11\x15a4\xC2W_\x80\xFD[\x92\x84\x01\x92[\x82\x84\x10\x15a+]W\x83Q\x82R\x92\x84\x01\x92\x90\x84\x01\x90a4\xC7V[``\x81\x01a\n\x0C\x82\x84\x80Qg\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x90\x81\x16\x83R` \x80\x83\x01Q\x82\x16\x90\x84\x01R`@\x91\x82\x01Q\x16\x91\x01RV[_`\x01`\x01`\xA0\x1B\x03\x80\x86\x16\x83R\x80\x85\x16` \x84\x01RP```@\x83\x01Ra5<``\x83\x01\x84a,.V[\x95\x94PPPPPV[_\x80_\x80`\x80\x85\x87\x03\x12\x15a5XW_\x80\xFD[PP\x82Q` \x84\x01Q`@\x85\x01Q``\x90\x95\x01Q\x91\x96\x90\x95P\x90\x92P\x90PV[cNH{q`\xE0\x1B_R`\x12`\x04R`$_\xFD[_\x82a5\x9AWa5\x9Aa5xV[P\x06\x90V[_\x82a5\xADWa5\xADa5xV[P\x04\x90V[\x80\x82\x01\x80\x82\x11\x15a\n\x0CWa\n\x0Ca1\xC8V[\x81Q\x81R` \x80\x83\x01Q\x90\x82\x01R`@\x80\x83\x01Q\x90\x82\x01R``\x80\x83\x01Q\x90\x82\x01R`\x80\x81\x01a\n\x0CV\xFE`\x80`@R4\x80\x15`\x0EW_\x80\xFD[Pa\x13\xC8\x80a\0\x1C_9_\xF3\xFE`\x80`@R`\x046\x10a\0!W_5`\xE0\x1C\x80c\xAD\xFE\xF6\xAC\x14a\08Wa\x000V[6a\x000Wa\0.a\0WV[\0[a\0.a\0WV[4\x80\x15a\0CW_\x80\xFD[Pa\0.a\0R6`\x04a\raV[a\0iV[a\0ga\0ba\x01\xB8V[a\x02\x9AV[V[_a\0ra\x02\xBDV[`\x01`\x01`\xA0\x1B\x03\x16\x14\x80\x15a\0\x97WP_a\0\x8Ca\x02\xEFV[`\x01`\x01`\xA0\x1B\x03\x16\x14[\x80\x15a\0\xB2WP_a\0\xA7a\x03\x16V[`\x01`\x01`\xA0\x1B\x03\x16\x14[\x15a\x01\xB0Wa\x01\xAC\x81`\xC0\x01Q\x83\x83`@Q`$\x01a\0\xD2\x92\x91\x90a\x10\xF9V[`@\x80Q`\x1F\x19\x81\x84\x03\x01\x81R\x91\x81R` \x80\x83\x01\x80Q{\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x7F\x0E\xE5\xEF\x0C\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x17\x90R`\xE0\x86\x01Q\x90\x87\x01Q\x91Q`\x01`\x01`\xA0\x1B\x03\x90\x92\x16`$\x83\x01R\x90`D\x01`@\x80Q`\x1F\x19\x81\x84\x03\x01\x81R\x91\x90R` \x81\x01\x80Q{\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x7F\xC4\xD6m\xE8\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x17\x90R`\x80\x87\x01Qa\x03=V[PPV[a\x01\xACa\0WV[_`\x046\x10\x15a\x02\x0FW`@QbF\x1B\xCD`\xE5\x1B\x81R` `\x04\x82\x01R`\x0B`$\x82\x01R\x7FNO_FUNC_SIG\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0`D\x82\x01R`d\x01[`@Q\x80\x91\x03\x90\xFD[_3a\x02\x19a\x02\xBDV[`\x01`\x01`\xA0\x1B\x03\x16\x03a\x024Wa\x02/a\x02\xEFV[a\x02<V[a\x02<a\x03\x16V[\x90P`\x01`\x01`\xA0\x1B\x03\x81\x16;a\x02\x95W`@QbF\x1B\xCD`\xE5\x1B\x81R` `\x04\x82\x01R`\x13`$\x82\x01R\x7FTARGET_NOT_CONTRACT\0\0\0\0\0\0\0\0\0\0\0\0\0`D\x82\x01R`d\x01a\x02\x06V[\x91\x90PV[6_\x807_\x806_\x84Z\xF4=_\x80>\x80\x80\x15a\x02\xB4W=_\xF3[=_\xFD[PPPV[_\x7F\xB51'hJV\x8B1s\xAE\x13\xB9\xF8\xA6\x01n$>c\xB6\xE8\xEE\x11x\xD6\xA7\x17\x85\x0B]a\x03[T`\x01`\x01`\xA0\x1B\x03\x16\x91\x90PV[_\x7F6\x08\x94\xA1;\xA1\xA3!\x06g\xC8(I-\xB9\x8D\xCA> v\xCC75\xA9 \xA3\xCAP]8+\xBCa\x02\xE0V[_\x7F+\x1D\xBC\xE7C$$\x8C\"/\x0E\xC2\xD5\xED{\xD3#\xCF\xC4%\xB36\xF0%<\\\xCF\xDAreTma\x02\xE0V[a\x03h`\x01\x7F\xB51'hJV\x8B1s\xAE\x13\xB9\xF8\xA6\x01n$>c\xB6\xE8\xEE\x11x\xD6\xA7\x17\x85\x0B]a\x04a\x13\x10V[\x7F\xB51'hJV\x8B1s\xAE\x13\xB9\xF8\xA6\x01n$>c\xB6\xE8\xEE\x11x\xD6\xA7\x17\x85\x0B]a\x03\x14a\x03\x96Wa\x03\x96a\x13/V[a\x03\xC1`\x01\x7F6\x08\x94\xA1;\xA1\xA3!\x06g\xC8(I-\xB9\x8D\xCA> v\xCC75\xA9 \xA3\xCAP]8+\xBDa\x13\x10V[\x7F6\x08\x94\xA1;\xA1\xA3!\x06g\xC8(I-\xB9\x8D\xCA> v\xCC75\xA9 \xA3\xCAP]8+\xBC\x14a\x03\xEFWa\x03\xEFa\x13/V[a\x04\x1A`\x01\x7F+\x1D\xBC\xE7C$$\x8C\"/\x0E\xC2\xD5\xED{\xD3#\xCF\xC4%\xB36\xF0%<\\\xCF\xDAreTna\x13\x10V[\x7F+\x1D\xBC\xE7C$$\x8C\"/\x0E\xC2\xD5\xED{\xD3#\xCF\xC4%\xB36\xF0%<\\\xCF\xDAreTm\x14a\x04HWa\x04Ha\x13/V[a\x04Q\x81a\x04nV[a\x04\\\x85\x85_a\x04\xC5V[a\x04g\x83\x83_a\x04\xEFV[PPPPPV[\x7F~dMyB/\x17\xC0\x1EH\x94\xB5\xF4\xF5\x88\xD31\xEB\xFA(e=B\xAE\x83-\xC5\x9E8\xC9y\x8Fa\x04\x97a\x02\xBDV[`@\x80Q`\x01`\x01`\xA0\x1B\x03\x92\x83\x16\x81R\x91\x84\x16` \x83\x01R\x01`@Q\x80\x91\x03\x90\xA1a\x04\xC2\x81a\x04\xF8V[PV[a\x04\xCE\x83a\x05\xD0V[_\x82Q\x11\x80a\x04\xDAWP\x80[\x15a\x02\xB8Wa\x04\xE9\x83\x83a\x06\x0FV[PPPPV[a\x04\xCE\x83a\x06=V[`\x01`\x01`\xA0\x1B\x03\x81\x16a\x05tW`@QbF\x1B\xCD`\xE5\x1B\x81R` `\x04\x82\x01R`&`$\x82\x01R\x7FERC1967: new admin is the zero a`D\x82\x01R\x7Fddress\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0`d\x82\x01R`\x84\x01a\x02\x06V[\x80\x7F\xB51'hJV\x8B1s\xAE\x13\xB9\xF8\xA6\x01n$>c\xB6\xE8\xEE\x11x\xD6\xA7\x17\x85\x0B]a\x03[\x80T\x7F\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x16`\x01`\x01`\xA0\x1B\x03\x92\x90\x92\x16\x91\x90\x91\x17\x90UPV[a\x05\xD9\x81a\x06|V[`@Q`\x01`\x01`\xA0\x1B\x03\x82\x16\x90\x7F\xBC|\xD7Z \xEE'\xFD\x9A\xDE\xBA\xB3 A\xF7U!M\xBCk\xFF\xA9\x0C\xC0\"[9\xDA.\\-;\x90_\x90\xA2PV[``a\x064\x83\x83`@Q\x80``\x01`@R\x80`'\x81R` \x01a\x13l`'\x919a\x07 V[\x90P[\x92\x91PPV[a\x06F\x81a\x08\x12V[`@Q`\x01`\x01`\xA0\x1B\x03\x82\x16\x90\x7F\xF7\xEE\xD2\xA7\xFA\xBB\xF1\xBE\xC8\xD5^\xD5\xE7\x85\xCCvb#v\xDD\xE5\xDFO\xF1TpU\x1E\x03\x0B\x814\x90_\x90\xA2PV[`\x01`\x01`\xA0\x1B\x03\x81\x16;a\x06\xF9W`@QbF\x1B\xCD`\xE5\x1B\x81R` `\x04\x82\x01R`-`$\x82\x01R\x7FERC1967: new implementation is n`D\x82\x01R\x7Fot a contract\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0`d\x82\x01R`\x84\x01a\x02\x06V[\x80\x7F6\x08\x94\xA1;\xA1\xA3!\x06g\xC8(I-\xB9\x8D\xCA> v\xCC75\xA9 \xA3\xCAP]8+\xBCa\x05\x97V[```\x01`\x01`\xA0\x1B\x03\x84\x16;a\x07\x9FW`@QbF\x1B\xCD`\xE5\x1B\x81R` `\x04\x82\x01R`&`$\x82\x01R\x7FAddress: delegate call to non-co`D\x82\x01R\x7Fntract\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0`d\x82\x01R`\x84\x01a\x02\x06V[_\x80\x85`\x01`\x01`\xA0\x1B\x03\x16\x85`@Qa\x07\xB9\x91\x90a\x13CV[_`@Q\x80\x83\x03\x81\x85Z\xF4\x91PP=\x80_\x81\x14a\x07\xF1W`@Q\x91P`\x1F\x19`?=\x01\x16\x82\x01`@R=\x82R=_` \x84\x01>a\x07\xF6V[``\x91P[P\x91P\x91Pa\x08\x06\x82\x82\x86a\x08\xB6V[\x92PPP[\x93\x92PPPV[`\x01`\x01`\xA0\x1B\x03\x81\x16;a\x08\x8FW`@QbF\x1B\xCD`\xE5\x1B\x81R` `\x04\x82\x01R`7`$\x82\x01R\x7FERC1967: new secondary implement`D\x82\x01R\x7Fation is not a contract\0\0\0\0\0\0\0\0\0`d\x82\x01R`\x84\x01a\x02\x06V[\x80\x7F+\x1D\xBC\xE7C$$\x8C\"/\x0E\xC2\xD5\xED{\xD3#\xCF\xC4%\xB36\xF0%<\\\xCF\xDAreTma\x05\x97V[``\x83\x15a\x08\xC5WP\x81a\x08\x0BV[\x82Q\x15a\x08\xD5W\x82Q\x80\x84` \x01\xFD[\x81`@QbF\x1B\xCD`\xE5\x1B\x81R`\x04\x01a\x02\x06\x91\x90a\x13YV[cNH{q`\xE0\x1B_R`A`\x04R`$_\xFD[`@Q``\x81\x01g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x11\x82\x82\x10\x17\x15a\t&Wa\t&a\x08\xEFV[`@R\x90V[`@\x80Q\x90\x81\x01g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x11\x82\x82\x10\x17\x15a\t&Wa\t&a\x08\xEFV[`@Qa\x01 \x81\x01g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x11\x82\x82\x10\x17\x15a\t&Wa\t&a\x08\xEFV[`@Qa\x02\xA0\x81\x01g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x11\x82\x82\x10\x17\x15a\t&Wa\t&a\x08\xEFV[`@Q`\x1F\x82\x01`\x1F\x19\x16\x81\x01g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x11\x82\x82\x10\x17\x15a\t\xC0Wa\t\xC0a\x08\xEFV[`@R\x91\x90PV[\x805g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x16\x81\x14a\x02\x95W_\x80\xFD[\x805`\x01`\x01`\xA0\x1B\x03\x81\x16\x81\x14a\x02\x95W_\x80\xFD[_\x82`\x1F\x83\x01\x12a\n\x04W_\x80\xFD[\x815g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x11\x15a\n\x1EWa\n\x1Ea\x08\xEFV[a\n1` `\x1F\x19`\x1F\x84\x01\x16\x01a\t\x97V[\x81\x81R\x84` \x83\x86\x01\x01\x11\x15a\nEW_\x80\xFD[\x81` \x85\x01` \x83\x017_\x91\x81\x01` \x01\x91\x90\x91R\x93\x92PPPV[_\x82`\x1F\x83\x01\x12a\npW_\x80\xFD[\x815` g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x82\x11\x15a\n\x8CWa\n\x8Ca\x08\xEFV[\x81`\x05\x1Ba\n\x9B\x82\x82\x01a\t\x97V[\x92\x83R\x84\x81\x01\x82\x01\x92\x82\x81\x01\x90\x87\x85\x11\x15a\n\xB4W_\x80\xFD[\x83\x87\x01\x92P[\x84\x83\x10\x15a\n\xD3W\x825\x82R\x91\x83\x01\x91\x90\x83\x01\x90a\n\xBAV[\x97\x96PPPPPPPV[_`\x80\x82\x84\x03\x12\x15a\n\xEEW_\x80\xFD[`@Q`\x80\x81\x01\x81\x81\x10g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x82\x11\x17\x15a\x0B\x11Wa\x0B\x11a\x08\xEFV[\x80`@RP\x80\x91P\x825\x81R` \x83\x015` \x82\x01R`@\x83\x015`@\x82\x01R``\x83\x015``\x82\x01RP\x92\x91PPV[_\x82`\x1F\x83\x01\x12a\x0BQW_\x80\xFD[a\x0BYa\t,V[\x80`@\x84\x01\x85\x81\x11\x15a\x0BjW_\x80\xFD[\x84[\x81\x81\x10\x15a\x0B\x8BWa\x0B}\x81a\t\xC8V[\x84R` \x93\x84\x01\x93\x01a\x0BlV[P\x90\x95\x94PPPPPV[\x805`\x03\x81\x10a\x02\x95W_\x80\xFD[_\x81\x83\x03`\xC0\x81\x12\x15a\x0B\xB5W_\x80\xFD[a\x0B\xBDa\t\x03V[\x91P`\x80\x81\x12\x15a\x0B\xCCW_\x80\xFD[Pa\x0B\xD5a\t,V[\x83`\x1F\x84\x01\x12a\x0B\xE3W_\x80\xFD[a\x0B\xEBa\t,V[\x80`@\x85\x01\x86\x81\x11\x15a\x0B\xFCW_\x80\xFD[\x85[\x81\x81\x10\x15a\x0C\x16W\x805\x84R` \x93\x84\x01\x93\x01a\x0B\xFEV[P\x81\x84Ra\x0C$\x87\x82a\x0BBV[` \x85\x01RPPP\x81Ra\x0C:`\x80\x83\x01a\x0B\x96V[` \x82\x01R`\xA0\x82\x015`@\x82\x01R\x92\x91PPV[\x805`\xFF\x81\x16\x81\x14a\x02\x95W_\x80\xFD[_``\x82\x84\x03\x12\x15a\x0CoW_\x80\xFD[a\x0Cwa\t\x03V[\x90Pa\x0C\x82\x82a\t\xC8V[\x81Ra\x0C\x90` \x83\x01a\t\xC8V[` \x82\x01Ra\x0C\xA1`@\x83\x01a\t\xC8V[`@\x82\x01R\x92\x91PPV[_a\x01 \x82\x84\x03\x12\x15a\x0C\xBDW_\x80\xFD[a\x0C\xC5a\tOV[\x90Pa\x0C\xD0\x82a\t\xDFV[\x81Ra\x0C\xDE` \x83\x01a\t\xDFV[` \x82\x01Ra\x0C\xEF`@\x83\x01a\t\xDFV[`@\x82\x01Ra\r\0``\x83\x01a\t\xDFV[``\x82\x01Ra\r\x11`\x80\x83\x01a\t\xDFV[`\x80\x82\x01Ra\r\"`\xA0\x83\x01a\t\xDFV[`\xA0\x82\x01Ra\r3`\xC0\x83\x01a\t\xDFV[`\xC0\x82\x01Ra\rD`\xE0\x83\x01a\t\xDFV[`\xE0\x82\x01Ra\x01\0a\rW\x81\x84\x01a\t\xDFV[\x90\x82\x01R\x92\x91PPV[_\x80a\x01@\x80\x84\x86\x03\x12\x15a\rtW_\x80\xFD[\x835g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x80\x82\x11\x15a\r\x8BW_\x80\xFD[\x90\x85\x01\x90a\x03\xE0\x82\x88\x03\x12\x15a\r\x9FW_\x80\xFD[a\r\xA7a\tsV[a\r\xB0\x83a\t\xC8V[\x81Ra\r\xBE` \x84\x01a\t\xDFV[` \x82\x01R`@\x83\x015`@\x82\x01R``\x83\x015``\x82\x01Ra\r\xE3`\x80\x84\x01a\t\xDFV[`\x80\x82\x01Ra\r\xF4`\xA0\x84\x01a\t\xDFV[`\xA0\x82\x01R`\xC0\x83\x015`\xC0\x82\x01R`\xE0\x83\x015\x82\x81\x11\x15a\x0E\x14W_\x80\xFD[a\x0E \x89\x82\x86\x01a\t\xF5V[`\xE0\x83\x01RPa\x01\0\x83\x81\x015\x90\x82\x01Ra\x01 a\x0E?\x81\x85\x01a\t\xC8V[\x90\x82\x01R\x82\x84\x015\x82\x81\x11\x15a\x0ESW_\x80\xFD[a\x0E_\x89\x82\x86\x01a\naV[\x85\x83\x01RPa\x01`\x93Pa\x0Eu\x88\x85\x85\x01a\n\xDEV[\x84\x82\x01Ra\x01\xE0\x93P\x83\x83\x015a\x01\x80\x82\x01Ra\x02\0\x91P\x81\x83\x015a\x01\xA0\x82\x01Ra\x02 \x80\x84\x015a\x01\xC0\x83\x01Ra\x02@a\x0E\xB3\x8A\x82\x87\x01a\x0B\xA4V[\x86\x84\x01Ra\x03\0\x85\x015\x84\x84\x01Ra\x0E\xCEa\x03 \x86\x01a\t\xDFV[\x82\x84\x01Ra\x0E\xDFa\x03@\x86\x01a\x0COV[\x90\x83\x01RPa\x0E\xF1a\x03`\x84\x01a\t\xC8V[a\x02`\x82\x01Ra\x0F\x05\x88a\x03\x80\x85\x01a\x0C_V[a\x02\x80\x82\x01R\x80\x95PPPPPa\x0F\x1F\x84` \x85\x01a\x0C\xACV[\x90P\x92P\x92\x90PV[_\x81Q\x80\x84R\x80` \x84\x01` \x86\x01^_` \x82\x86\x01\x01R` `\x1F\x19`\x1F\x83\x01\x16\x85\x01\x01\x91PP\x92\x91PPV[_\x81Q\x80\x84R` \x80\x85\x01\x94P` \x84\x01_[\x83\x81\x10\x15a\x0F\x85W\x81Q\x87R\x95\x82\x01\x95\x90\x82\x01\x90`\x01\x01a\x0FiV[P\x94\x95\x94PPPPPV[`\x03\x81\x10a\x0F\xACWcNH{q`\xE0\x1B_R`!`\x04R`$_\xFD[\x90RV[\x80Q\x80Q\x83_[`\x02\x81\x10\x15a\x0F\xD6W\x82Q\x82R` \x92\x83\x01\x92\x90\x91\x01\x90`\x01\x01a\x0F\xB7V[PPP` \x90\x81\x01Q\x90`@\x84\x01_[`\x02\x81\x10\x15a\x10\rW\x83Qg\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x82R\x92\x82\x01\x92\x90\x82\x01\x90`\x01\x01a\x0F\xE6V[PPPP` \x81\x01Qa\x10#`\x80\x84\x01\x82a\x0F\x90V[P`@\x01Q`\xA0\x91\x90\x91\x01RV[`\x01`\x01`\xA0\x1B\x03\x80\x82Q\x16\x83R\x80` \x83\x01Q\x16` \x84\x01R\x80`@\x83\x01Q\x16`@\x84\x01RP``\x81\x01Qa\x10r``\x84\x01\x82`\x01`\x01`\xA0\x1B\x03\x16\x90RV[P`\x80\x81\x01Qa\x10\x8D`\x80\x84\x01\x82`\x01`\x01`\xA0\x1B\x03\x16\x90RV[P`\xA0\x81\x01Qa\x10\xA8`\xA0\x84\x01\x82`\x01`\x01`\xA0\x1B\x03\x16\x90RV[P`\xC0\x81\x01Qa\x10\xC3`\xC0\x84\x01\x82`\x01`\x01`\xA0\x1B\x03\x16\x90RV[P`\xE0\x81\x01Qa\x10\xDE`\xE0\x84\x01\x82`\x01`\x01`\xA0\x1B\x03\x16\x90RV[Pa\x01\0\x81\x81\x01Q`\x01`\x01`\xA0\x1B\x03\x81\x16\x84\x83\x01Ra\x04\xE9V[_a\x01@\x80\x83Ra\x11\x16\x81\x84\x01\x86Qg\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x90RV[` \x85\x01Q`\x01`\x01`\xA0\x1B\x03\x81\x16a\x01`\x85\x01RP`@\x85\x01Qa\x01\x80\x81\x81\x86\x01R``\x87\x01Q\x91Pa\x01\xA0\x82\x81\x87\x01R`\x80\x88\x01Q\x92Pa\x01\xC0a\x11f\x81\x88\x01\x85`\x01`\x01`\xA0\x1B\x03\x16\x90RV[`\xA0\x89\x01Q\x93Pa\x01\xE0a\x11\x84\x81\x89\x01\x86`\x01`\x01`\xA0\x1B\x03\x16\x90RV[`\xC0\x8A\x01Q\x94Pa\x02\0\x85\x81\x8A\x01R`\xE0\x8B\x01Q\x95Pa\x02 a\x03\xE0\x81\x8B\x01Ra\x11\xB2a\x05 \x8B\x01\x88a\x0F(V[\x96Pa\x01\0\x8C\x01Qa\x02@\x81\x81\x8D\x01Ra\x01 \x8E\x01Q\x91Pa\x02`a\x11\xE2\x81\x8E\x01\x84g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x90RV[\x8A\x8F\x01Q\x9APa\x02\x80\x92P\x7F\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFE\xC0\x8D\x8B\x03\x01\x83\x8E\x01Ra\x12 \x8A\x8Ca\x0FVV[\x9APa\x01`\x8F\x01Q\x99Pa\x12Ya\x02\xA0\x8E\x01\x8B\x80Q\x82R` \x81\x01Q` \x83\x01R`@\x81\x01Q`@\x83\x01R``\x81\x01Q``\x83\x01RPPV[\x88\x8F\x01Qa\x03 \x8E\x01R\x87\x8F\x01Qa\x03@\x8E\x01R\x86\x8F\x01Qa\x03`\x8E\x01R\x85\x8F\x01Q\x99Pa\x12\x8Ba\x03\x80\x8E\x01\x8Ba\x0F\xB0V[\x93\x8E\x01Qa\x04@\x8D\x01R\x91\x8D\x01Q`\x01`\x01`\xA0\x1B\x03\x16a\x04`\x8C\x01R\x90\x8C\x01Q`\xFF\x16a\x04\x80\x8B\x01R\x90\x8B\x01Qg\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x90\x81\x16a\x04\xA0\x8B\x01R\x90\x8B\x01Q\x80Q\x82\x16a\x04\xC0\x8B\x01R` \x81\x01Q\x82\x16a\x04\xE0\x8B\x01R`@\x81\x01Q\x90\x91\x16a\x05\0\x8A\x01R\x94Pa\x13\0\x93PPPPV[P\x90Pa\x08\x0B` \x83\x01\x84a\x101V[\x81\x81\x03\x81\x81\x11\x15a\x067WcNH{q`\xE0\x1B_R`\x11`\x04R`$_\xFD[cNH{q`\xE0\x1B_R`\x01`\x04R`$_\xFD[_\x82Q\x80` \x85\x01\x84^_\x92\x01\x91\x82RP\x91\x90PV[` \x81R_a\x064` \x83\x01\x84a\x0F(V\xFEAddress: low-level delegate call failed\xA2dipfsX\"\x12 \xC3\xB5|\xC1\xC9\x02\xD5~N]\xEAr\x0E\xD6?\x19\xC7W\xCD%\xBC\xB4\n\xFB\xCC7{\x07.g\x13\x1EdsolcC\0\x08\x19\x003`\x80`@R`@Qa\r\x898\x03\x80a\r\x89\x839\x81\x01`@\x81\x90Ra\0\"\x91a\x03\xB7V[\x82\x81a\0/\x82\x82_a\0CV[Pa\0;\x90P\x82a\0nV[PPPa\x04\xCDV[a\0L\x83a\0\xDBV[_\x82Q\x11\x80a\0XWP\x80[\x15a\0iWa\0g\x83\x83a\x01\x1AV[P[PPPV[\x7F~dMyB/\x17\xC0\x1EH\x94\xB5\xF4\xF5\x88\xD31\xEB\xFA(e=B\xAE\x83-\xC5\x9E8\xC9y\x8Fa\0\xAD_\x80Q` a\rB\x839\x81Q\x91RT`\x01`\x01`\xA0\x1B\x03\x16\x90V[`@\x80Q`\x01`\x01`\xA0\x1B\x03\x92\x83\x16\x81R\x91\x84\x16` \x83\x01R\x01`@Q\x80\x91\x03\x90\xA1a\0\xD8\x81a\x01FV[PV[a\0\xE4\x81a\x01\xE1V[`@Q`\x01`\x01`\xA0\x1B\x03\x82\x16\x90\x7F\xBC|\xD7Z \xEE'\xFD\x9A\xDE\xBA\xB3 A\xF7U!M\xBCk\xFF\xA9\x0C\xC0\"[9\xDA.\\-;\x90_\x90\xA2PV[``a\x01?\x83\x83`@Q\x80``\x01`@R\x80`'\x81R` \x01a\rb`'\x919a\x02uV[\x93\x92PPPV[`\x01`\x01`\xA0\x1B\x03\x81\x16a\x01\xB0W`@QbF\x1B\xCD`\xE5\x1B\x81R` `\x04\x82\x01R`&`$\x82\x01R\x7FERC1967: new admin is the zero a`D\x82\x01Reddress`\xD0\x1B`d\x82\x01R`\x84\x01[`@Q\x80\x91\x03\x90\xFD[\x80_\x80Q` a\rB\x839\x81Q\x91R[\x80T`\x01`\x01`\xA0\x1B\x03\x19\x16`\x01`\x01`\xA0\x1B\x03\x92\x90\x92\x16\x91\x90\x91\x17\x90UPV[`\x01`\x01`\xA0\x1B\x03\x81\x16;a\x02NW`@QbF\x1B\xCD`\xE5\x1B\x81R` `\x04\x82\x01R`-`$\x82\x01R\x7FERC1967: new implementation is n`D\x82\x01Rl\x1B\xDD\x08\x18H\x18\xDB\xDB\x9D\x1C\x98X\xDD`\x9A\x1B`d\x82\x01R`\x84\x01a\x01\xA7V[\x80\x7F6\x08\x94\xA1;\xA1\xA3!\x06g\xC8(I-\xB9\x8D\xCA> v\xCC75\xA9 \xA3\xCAP]8+\xBCa\x01\xC0V[```\x01`\x01`\xA0\x1B\x03\x84\x16;a\x02\xDDW`@QbF\x1B\xCD`\xE5\x1B\x81R` `\x04\x82\x01R`&`$\x82\x01R\x7FAddress: delegate call to non-co`D\x82\x01Re\x1B\x9D\x1C\x98X\xDD`\xD2\x1B`d\x82\x01R`\x84\x01a\x01\xA7V[_\x80\x85`\x01`\x01`\xA0\x1B\x03\x16\x85`@Qa\x02\xF7\x91\x90a\x04\x82V[_`@Q\x80\x83\x03\x81\x85Z\xF4\x91PP=\x80_\x81\x14a\x03/W`@Q\x91P`\x1F\x19`?=\x01\x16\x82\x01`@R=\x82R=_` \x84\x01>a\x034V[``\x91P[P\x90\x92P\x90Pa\x03E\x82\x82\x86a\x03OV[\x96\x95PPPPPPV[``\x83\x15a\x03^WP\x81a\x01?V[\x82Q\x15a\x03nW\x82Q\x80\x84` \x01\xFD[\x81`@QbF\x1B\xCD`\xE5\x1B\x81R`\x04\x01a\x01\xA7\x91\x90a\x04\x98V[\x80Q`\x01`\x01`\xA0\x1B\x03\x81\x16\x81\x14a\x03\x9EW_\x80\xFD[\x91\x90PV[cNH{q`\xE0\x1B_R`A`\x04R`$_\xFD[_\x80_``\x84\x86\x03\x12\x15a\x03\xC9W_\x80\xFD[a\x03\xD2\x84a\x03\x88V[\x92Pa\x03\xE0` \x85\x01a\x03\x88V[`@\x85\x01Q\x90\x92P`\x01`\x01`@\x1B\x03\x80\x82\x11\x15a\x03\xFCW_\x80\xFD[\x81\x86\x01\x91P\x86`\x1F\x83\x01\x12a\x04\x0FW_\x80\xFD[\x81Q\x81\x81\x11\x15a\x04!Wa\x04!a\x03\xA3V[`@Q`\x1F\x82\x01`\x1F\x19\x90\x81\x16`?\x01\x16\x81\x01\x90\x83\x82\x11\x81\x83\x10\x17\x15a\x04IWa\x04Ia\x03\xA3V[\x81`@R\x82\x81R\x89` \x84\x87\x01\x01\x11\x15a\x04aW_\x80\xFD[\x82` \x86\x01` \x83\x01^_` \x84\x83\x01\x01R\x80\x95PPPPPP\x92P\x92P\x92V[_\x82Q\x80` \x85\x01\x84^_\x92\x01\x91\x82RP\x91\x90PV[` \x81R_\x82Q\x80` \x84\x01R\x80` \x85\x01`@\x85\x01^_`@\x82\x85\x01\x01R`@`\x1F\x19`\x1F\x83\x01\x16\x84\x01\x01\x91PP\x92\x91PPV[a\x08h\x80a\x04\xDA_9_\xF3\xFE`\x80`@R`\x046\x10a\0]W_5`\xE0\x1C\x80c\\`\xDA\x1B\x11a\0BW\x80c\\`\xDA\x1B\x14a\0\xA6W\x80c\x8F(9p\x14a\0\xD6W\x80c\xF8Q\xA4@\x14a\0\xF5Wa\0lV[\x80c6Y\xCF\xE6\x14a\0tW\x80cO\x1E\xF2\x86\x14a\0\x93Wa\0lV[6a\0lWa\0ja\x01\tV[\0[a\0ja\x01\tV[4\x80\x15a\0\x7FW_\x80\xFD[Pa\0ja\0\x8E6`\x04a\x07\rV[a\x01#V[a\0ja\0\xA16`\x04a\x07&V[a\x01^V[4\x80\x15a\0\xB1W_\x80\xFD[Pa\0\xBAa\x01\xC4V[`@Q`\x01`\x01`\xA0\x1B\x03\x90\x91\x16\x81R` \x01`@Q\x80\x91\x03\x90\xF3[4\x80\x15a\0\xE1W_\x80\xFD[Pa\0ja\0\xF06`\x04a\x07\rV[a\x01\xF4V[4\x80\x15a\x01\0W_\x80\xFD[Pa\0\xBAa\x02\x14V[a\x01\x11a\x024V[a\x01!a\x01\x1Ca\x02\xE4V[a\x02\xEDV[V[a\x01+a\x03\x0BV[`\x01`\x01`\xA0\x1B\x03\x163\x03a\x01VWa\x01S\x81`@Q\x80` \x01`@R\x80_\x81RP_a\x03=V[PV[a\x01Sa\x01\tV[a\x01fa\x03\x0BV[`\x01`\x01`\xA0\x1B\x03\x163\x03a\x01\xBCWa\x01\xB7\x83\x83\x83\x80\x80`\x1F\x01` \x80\x91\x04\x02` \x01`@Q\x90\x81\x01`@R\x80\x93\x92\x91\x90\x81\x81R` \x01\x83\x83\x80\x82\x847_\x92\x01\x91\x90\x91RP`\x01\x92Pa\x03=\x91PPV[PPPV[a\x01\xB7a\x01\tV[_a\x01\xCDa\x03\x0BV[`\x01`\x01`\xA0\x1B\x03\x163\x03a\x01\xE9Wa\x01\xE4a\x02\xE4V[\x90P\x90V[a\x01\xF1a\x01\tV[\x90V[a\x01\xFCa\x03\x0BV[`\x01`\x01`\xA0\x1B\x03\x163\x03a\x01VWa\x01S\x81a\x03gV[_a\x02\x1Da\x03\x0BV[`\x01`\x01`\xA0\x1B\x03\x163\x03a\x01\xE9Wa\x01\xE4a\x03\x0BV[a\x02<a\x03\x0BV[`\x01`\x01`\xA0\x1B\x03\x163\x03a\x01!W`@QbF\x1B\xCD`\xE5\x1B\x81R` `\x04\x82\x01R`B`$\x82\x01R\x7FTransparentUpgradeableProxy: adm`D\x82\x01R\x7Fin cannot fallback to proxy targ`d\x82\x01R\x7Fet\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0`\x84\x82\x01R`\xA4\x01[`@Q\x80\x91\x03\x90\xFD[_a\x01\xE4a\x03\xBBV[6_\x807_\x806_\x84Z\xF4=_\x80>\x80\x80\x15a\x03\x07W=_\xF3[=_\xFD[_\x7F\xB51'hJV\x8B1s\xAE\x13\xB9\xF8\xA6\x01n$>c\xB6\xE8\xEE\x11x\xD6\xA7\x17\x85\x0B]a\x03[T`\x01`\x01`\xA0\x1B\x03\x16\x91\x90PV[a\x03F\x83a\x03\xE2V[_\x82Q\x11\x80a\x03RWP\x80[\x15a\x01\xB7Wa\x03a\x83\x83a\x04!V[PPPPV[\x7F~dMyB/\x17\xC0\x1EH\x94\xB5\xF4\xF5\x88\xD31\xEB\xFA(e=B\xAE\x83-\xC5\x9E8\xC9y\x8Fa\x03\x90a\x03\x0BV[`@\x80Q`\x01`\x01`\xA0\x1B\x03\x92\x83\x16\x81R\x91\x84\x16` \x83\x01R\x01`@Q\x80\x91\x03\x90\xA1a\x01S\x81a\x04MV[_\x7F6\x08\x94\xA1;\xA1\xA3!\x06g\xC8(I-\xB9\x8D\xCA> v\xCC75\xA9 \xA3\xCAP]8+\xBCa\x03.V[a\x03\xEB\x81a\x05%V[`@Q`\x01`\x01`\xA0\x1B\x03\x82\x16\x90\x7F\xBC|\xD7Z \xEE'\xFD\x9A\xDE\xBA\xB3 A\xF7U!M\xBCk\xFF\xA9\x0C\xC0\"[9\xDA.\\-;\x90_\x90\xA2PV[``a\x04F\x83\x83`@Q\x80``\x01`@R\x80`'\x81R` \x01a\x08\x0C`'\x919a\x05\xC9V[\x93\x92PPPV[`\x01`\x01`\xA0\x1B\x03\x81\x16a\x04\xC9W`@QbF\x1B\xCD`\xE5\x1B\x81R` `\x04\x82\x01R`&`$\x82\x01R\x7FERC1967: new admin is the zero a`D\x82\x01R\x7Fddress\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0`d\x82\x01R`\x84\x01a\x02\xDBV[\x80\x7F\xB51'hJV\x8B1s\xAE\x13\xB9\xF8\xA6\x01n$>c\xB6\xE8\xEE\x11x\xD6\xA7\x17\x85\x0B]a\x03[\x80T\x7F\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x16`\x01`\x01`\xA0\x1B\x03\x92\x90\x92\x16\x91\x90\x91\x17\x90UPV[`\x01`\x01`\xA0\x1B\x03\x81\x16;a\x05\xA2W`@QbF\x1B\xCD`\xE5\x1B\x81R` `\x04\x82\x01R`-`$\x82\x01R\x7FERC1967: new implementation is n`D\x82\x01R\x7Fot a contract\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0`d\x82\x01R`\x84\x01a\x02\xDBV[\x80\x7F6\x08\x94\xA1;\xA1\xA3!\x06g\xC8(I-\xB9\x8D\xCA> v\xCC75\xA9 \xA3\xCAP]8+\xBCa\x04\xECV[```\x01`\x01`\xA0\x1B\x03\x84\x16;a\x06HW`@QbF\x1B\xCD`\xE5\x1B\x81R` `\x04\x82\x01R`&`$\x82\x01R\x7FAddress: delegate call to non-co`D\x82\x01R\x7Fntract\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0`d\x82\x01R`\x84\x01a\x02\xDBV[_\x80\x85`\x01`\x01`\xA0\x1B\x03\x16\x85`@Qa\x06b\x91\x90a\x07\xA2V[_`@Q\x80\x83\x03\x81\x85Z\xF4\x91PP=\x80_\x81\x14a\x06\x9AW`@Q\x91P`\x1F\x19`?=\x01\x16\x82\x01`@R=\x82R=_` \x84\x01>a\x06\x9FV[``\x91P[P\x91P\x91Pa\x06\xAF\x82\x82\x86a\x06\xB9V[\x96\x95PPPPPPV[``\x83\x15a\x06\xC8WP\x81a\x04FV[\x82Q\x15a\x06\xD8W\x82Q\x80\x84` \x01\xFD[\x81`@QbF\x1B\xCD`\xE5\x1B\x81R`\x04\x01a\x02\xDB\x91\x90a\x07\xB8V[\x805`\x01`\x01`\xA0\x1B\x03\x81\x16\x81\x14a\x07\x08W_\x80\xFD[\x91\x90PV[_` \x82\x84\x03\x12\x15a\x07\x1DW_\x80\xFD[a\x04F\x82a\x06\xF2V[_\x80_`@\x84\x86\x03\x12\x15a\x078W_\x80\xFD[a\x07A\x84a\x06\xF2V[\x92P` \x84\x015g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x80\x82\x11\x15a\x07]W_\x80\xFD[\x81\x86\x01\x91P\x86`\x1F\x83\x01\x12a\x07pW_\x80\xFD[\x815\x81\x81\x11\x15a\x07~W_\x80\xFD[\x87` \x82\x85\x01\x01\x11\x15a\x07\x8FW_\x80\xFD[` \x83\x01\x94P\x80\x93PPPP\x92P\x92P\x92V[_\x82Q\x80` \x85\x01\x84^_\x92\x01\x91\x82RP\x91\x90PV[` \x81R_\x82Q\x80` \x84\x01R\x80` \x85\x01`@\x85\x01^_`@\x82\x85\x01\x01R`@\x7F\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xE0`\x1F\x83\x01\x16\x84\x01\x01\x91PP\x92\x91PPV\xFEAddress: low-level delegate call failed\xA2dipfsX\"\x12 QG\xD3\x89W\xE9\xDFn\x1D\xA1\xB9\x87Q\x98|U\xE3+\xDCL\xB0\t\xEAz\x14Z\xB64\xAE\xE1\x89sdsolcC\0\x08\x19\x003\xB51'hJV\x8B1s\xAE\x13\xB9\xF8\xA6\x01n$>c\xB6\xE8\xEE\x11x\xD6\xA7\x17\x85\x0B]a\x03Address: low-level delegate call failed\xA2dipfsX\"\x12 \xDCof\x99\xC6\xFB\xDE#J8\x7F\x80]i\x8A\xED\xAF\x1EU\x06-\xD4\xAC^\x87L\x15\x13\xC6\xBE\xE1\xAFdsolcC\0\x08\x19\x003`\x80`@R4\x80\x15`\x0EW_\x80\xFD[Pa\t\xDA\x80a\0\x1C_9_\xF3\xFE`\x80`@R4\x80\x15a\0\x0FW_\x80\xFD[P`\x046\x10a\0?W_5`\xE0\x1C\x80c1dA0\x14a\0CW\x80c\x8E\xAAj\xC0\x14a\0iW\x80c\x94\\\x94\x94\x14a\0\x8AW[_\x80\xFD[a\0Va\0Q6`\x04a\x04\x11V[a\0\x9FV[`@Q\x90\x81R` \x01[`@Q\x80\x91\x03\x90\xF3[a\0|a\0w6`\x04a\x04:V[a\x01\x8FV[`@Qa\0`\x92\x91\x90a\x04qV[a\0\x9Da\0\x986`\x04a\x04\xF8V[a\x02\xB7V[\0[_a\x01Na\0\xB26\x85\x90\x03\x85\x01\x85a\x05\x80V[\x80Q\x80Q` \x91\x82\x01Q\x92\x82\x01Q\x80Q\x90\x83\x01Q`@\x80Q\x7FGlobal state:\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81\x87\x01R`-\x81\x01\x94\x90\x94R`M\x84\x01\x95\x90\x95R\x7F\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0`\xC0\x92\x83\x1B\x81\x16`m\x85\x01R\x91\x1B\x16`u\x82\x01R\x82Q\x80\x82\x03`]\x01\x81R`}\x90\x91\x01\x90\x92R\x81Q\x91\x01 \x90V[\x82a\x01_`\xA0\x86\x01`\x80\x87\x01a\x06HV[`@Q` \x01a\x01q\x93\x92\x91\x90a\x06jV[`@Q` \x81\x83\x03\x03\x81R\x90`@R\x80Q\x90` \x01 \x90P\x92\x91PPV[a\x01\x97a\x03\xA2V[_\x82\x81R` \x81\x90R`@\x81 \x80Ta\x01\xAF\x90a\x06\xA5V[\x80`\x1F\x01` \x80\x91\x04\x02` \x01`@Q\x90\x81\x01`@R\x80\x92\x91\x90\x81\x81R` \x01\x82\x80Ta\x01\xDB\x90a\x06\xA5V[\x80\x15a\x02&W\x80`\x1F\x10a\x01\xFDWa\x01\0\x80\x83T\x04\x02\x83R\x91` \x01\x91a\x02&V[\x82\x01\x91\x90_R` _ \x90[\x81T\x81R\x90`\x01\x01\x90` \x01\x80\x83\x11a\x02\tW\x82\x90\x03`\x1F\x16\x82\x01\x91[PPPPP\x80` \x01\x90Q\x81\x01\x90a\x02>\x91\x90a\x07=V[\x90\x92P\x90P_\x81\x90\x03a\x02\xB2W`@Q\x7F\x08\xC3y\xA0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R` `\x04\x82\x01R`\x10`$\x82\x01R\x7FHash not yet set\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0`D\x82\x01R`d\x01[`@Q\x80\x91\x03\x90\xFD[\x91P\x91V[a\x02\xC1\x82\x82a\0\x9FV[\x83\x14a\x03)W`@Q\x7F\x08\xC3y\xA0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R` `\x04\x82\x01R`\x0C`$\x82\x01R\x7FInvalid hash\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0`D\x82\x01R`d\x01a\x02\xA9V[\x81\x81`@Q` \x01a\x03<\x92\x91\x90a\x08\\V[`@\x80Q`\x1F\x19\x81\x84\x03\x01\x81R\x91\x81R_\x85\x81R` \x81\x90R \x90a\x03a\x90\x82a\x08\xC2V[P\x7F\x14\xC0\xA6\xB8\xD8\x1FY\x15\xDA\xCF\xD8^A\xAEG\x984>\xC2\x9D\xE4\x08\xACL\x136\x0Cr8\xAE\n\xD9\x83\x83\x83`@Qa\x03\x95\x93\x92\x91\x90a\t\x82V[`@Q\x80\x91\x03\x90\xA1PPPV[`@Q\x80`@\x01`@R\x80a\x03\xB5a\x03\xC1V[\x81R` \x01_[\x90R\x90V[`@Q\x80`@\x01`@R\x80a\x03\xD4a\x03\xDDV[\x81R` \x01a\x03\xBC[`@Q\x80`@\x01`@R\x80`\x02\x90` \x82\x02\x806\x837P\x91\x92\x91PPV[_`\xA0\x82\x84\x03\x12\x15a\x04\x0BW_\x80\xFD[P\x91\x90PV[_\x80`\xC0\x83\x85\x03\x12\x15a\x04\"W_\x80\xFD[a\x04,\x84\x84a\x03\xFBV[\x94`\xA0\x93\x90\x93\x015\x93PPPV[_` \x82\x84\x03\x12\x15a\x04JW_\x80\xFD[P5\x91\x90PV[`\x03\x81\x10a\x04mWcNH{q`\xE0\x1B_R`!`\x04R`$_\xFD[\x90RV[\x82Q\x80Q`\xC0\x83\x01\x91\x90\x83_[`\x02\x81\x10\x15a\x04\x9DW\x82Q\x82R` \x92\x83\x01\x92\x90\x91\x01\x90`\x01\x01a\x04~V[PPP` \x90\x81\x01Q\x90`@\x84\x01_[`\x02\x81\x10\x15a\x04\xD4W\x83Qg\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x82R\x92\x82\x01\x92\x90\x82\x01\x90`\x01\x01a\x04\xADV[PPPP` \x84\x01Qa\x04\xEA`\x80\x84\x01\x82a\x04QV[P\x82`\xA0\x83\x01R\x93\x92PPPV[_\x80_`\xE0\x84\x86\x03\x12\x15a\x05\nW_\x80\xFD[\x835\x92Pa\x05\x1B\x85` \x86\x01a\x03\xFBV[\x91P`\xC0\x84\x015\x90P\x92P\x92P\x92V[cNH{q`\xE0\x1B_R`A`\x04R`$_\xFD[`@\x80Q\x90\x81\x01g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x11\x82\x82\x10\x17\x15a\x05bWa\x05ba\x05+V[`@R\x90V[g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x16\x81\x14a\x05}W_\x80\xFD[PV[_`\x80\x82\x84\x03\x12\x15a\x05\x90W_\x80\xFD[a\x05\x98a\x05?V[\x83`\x1F\x84\x01\x12a\x05\xA6W_\x80\xFD[a\x05\xAEa\x05?V[\x80`@\x85\x01\x86\x81\x11\x15a\x05\xBFW_\x80\xFD[\x85[\x81\x81\x10\x15a\x05\xD9W\x805\x84R` \x93\x84\x01\x93\x01a\x05\xC1V[P\x81\x84R\x86`_\x87\x01\x12a\x05\xEBW_\x80\xFD[a\x05\xF3a\x05?V[\x92P\x82\x91P`\x80\x86\x01\x87\x81\x11\x15a\x06\x08W_\x80\xFD[\x80\x82\x10\x15a\x06-W\x815a\x06\x1B\x81a\x05hV[\x84R` \x93\x84\x01\x93\x91\x90\x91\x01\x90a\x06\x08V[PP` \x83\x01RP\x93\x92PPPV[`\x03\x81\x10a\x05}W_\x80\xFD[_` \x82\x84\x03\x12\x15a\x06XW_\x80\xFD[\x815a\x06c\x81a\x06<V[\x93\x92PPPV[\x83\x81R\x82` \x82\x01R_`\x03\x83\x10a\x06\x90WcNH{q`\xE0\x1B_R`!`\x04R`$_\xFD[P`\xF8\x91\x90\x91\x1B`@\x82\x01R`A\x01\x92\x91PPV[`\x01\x81\x81\x1C\x90\x82\x16\x80a\x06\xB9W`\x7F\x82\x16\x91P[` \x82\x10\x81\x03a\x04\x0BWcNH{q`\xE0\x1B_R`\"`\x04R`$_\xFD[_\x82`\x1F\x83\x01\x12a\x06\xE6W_\x80\xFD[a\x06\xEEa\x05?V[\x80`@\x84\x01\x85\x81\x11\x15a\x06\xFFW_\x80\xFD[\x84[\x81\x81\x10\x15a\x07\"W\x80Qa\x07\x14\x81a\x05hV[\x84R` \x93\x84\x01\x93\x01a\x07\x01V[P\x90\x95\x94PPPPPV[\x80Qa\x078\x81a\x06<V[\x91\x90PV[_\x80\x82\x84\x03`\xC0\x81\x12\x15a\x07OW_\x80\xFD[`\xA0\x81\x12\x15a\x07\\W_\x80\xFD[a\x07da\x05?V[`\x80\x82\x12\x15a\x07qW_\x80\xFD[a\x07ya\x05?V[\x91P\x85`\x1F\x86\x01\x12a\x07\x89W_\x80\xFD[a\x07\x91a\x05?V[\x80`@\x87\x01\x88\x81\x11\x15a\x07\xA2W_\x80\xFD[\x87[\x81\x81\x10\x15a\x07\xBCW\x80Q\x84R` \x93\x84\x01\x93\x01a\x07\xA4V[P\x81\x85Ra\x07\xCA\x89\x82a\x06\xD7V[` \x86\x01RPPP\x81\x81Ra\x07\xE1`\x80\x86\x01a\x07-V[` \x82\x01R`\xA0\x94\x90\x94\x01Q\x93\x95\x93\x94PPPPV[`@\x81\x837`@\x82\x01`@\x82\x01_[`\x02\x81\x10\x15a\x089W\x815a\x08\x1A\x81a\x05hV[g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x83R` \x92\x83\x01\x92\x91\x90\x91\x01\x90`\x01\x01a\x08\x06V[PPP`\x80\x81\x015a\x08J\x81a\x06<V[a\x08W`\x80\x84\x01\x82a\x04QV[PPPV[`\xC0\x81\x01a\x08j\x82\x85a\x07\xF7V[\x82`\xA0\x83\x01R\x93\x92PPPV[`\x1F\x82\x11\x15a\x08WW\x80_R` _ `\x1F\x84\x01`\x05\x1C\x81\x01` \x85\x10\x15a\x08\x9CWP\x80[`\x1F\x84\x01`\x05\x1C\x82\x01\x91P[\x81\x81\x10\x15a\x08\xBBW_\x81U`\x01\x01a\x08\xA8V[PPPPPV[\x81Qg\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x11\x15a\x08\xDCWa\x08\xDCa\x05+V[a\x08\xF0\x81a\x08\xEA\x84Ta\x06\xA5V[\x84a\x08wV[` \x80`\x1F\x83\x11`\x01\x81\x14a\t#W_\x84\x15a\t\x0CWP\x85\x83\x01Q[_\x19`\x03\x86\x90\x1B\x1C\x19\x16`\x01\x85\x90\x1B\x17\x85Ua\tzV[_\x85\x81R` \x81 `\x1F\x19\x86\x16\x91[\x82\x81\x10\x15a\tQW\x88\x86\x01Q\x82U\x94\x84\x01\x94`\x01\x90\x91\x01\x90\x84\x01a\t2V[P\x85\x82\x10\x15a\tnW\x87\x85\x01Q_\x19`\x03\x88\x90\x1B`\xF8\x16\x1C\x19\x16\x81U[PP`\x01\x84`\x01\x1B\x01\x85U[PPPPPPV[\x83\x81R`\xE0\x81\x01a\t\x96` \x83\x01\x85a\x07\xF7V[\x82`\xC0\x83\x01R\x94\x93PPPPV\xFE\xA2dipfsX\"\x12 \xFD\x95<m\xF4\x90rH\xAE$\xC8\xC8f5J\x80\xCD6\x8F\xC8I\xC7?\xFANf\xD16\xED69\x1DdsolcC\0\x08\x19\x003`\x80`@R4\x80\x15a\0\x0FW_\x80\xFD[P`@Qa\x02\x8B8\x03\x80a\x02\x8B\x839\x81\x01`@\x81\x90Ra\0.\x91a\0\xB8V[\x80Qa\0@\x90_\x90` \x84\x01\x90a\0GV[PPa\x01pV[\x82\x80T\x82\x82U\x90_R` _ \x90\x81\x01\x92\x82\x15a\0\x80W\x91` \x02\x82\x01[\x82\x81\x11\x15a\0\x80W\x82Q\x82U\x91` \x01\x91\x90`\x01\x01\x90a\0eV[Pa\0\x8C\x92\x91Pa\0\x90V[P\x90V[[\x80\x82\x11\x15a\0\x8CW_\x81U`\x01\x01a\0\x91V[cNH{q`\xE0\x1B_R`A`\x04R`$_\xFD[_` \x80\x83\x85\x03\x12\x15a\0\xC9W_\x80\xFD[\x82Q`\x01`\x01`@\x1B\x03\x80\x82\x11\x15a\0\xDFW_\x80\xFD[\x81\x85\x01\x91P\x85`\x1F\x83\x01\x12a\0\xF2W_\x80\xFD[\x81Q\x81\x81\x11\x15a\x01\x04Wa\x01\x04a\0\xA4V[\x80`\x05\x1B`@Q`\x1F\x19`?\x83\x01\x16\x81\x01\x81\x81\x10\x85\x82\x11\x17\x15a\x01)Wa\x01)a\0\xA4V[`@R\x91\x82R\x84\x82\x01\x92P\x83\x81\x01\x85\x01\x91\x88\x83\x11\x15a\x01FW_\x80\xFD[\x93\x85\x01\x93[\x82\x85\x10\x15a\x01dW\x84Q\x84R\x93\x85\x01\x93\x92\x85\x01\x92a\x01KV[\x98\x97PPPPPPPPV[a\x01\x0E\x80a\x01}_9_\xF3\xFE`\x80`@R4\x80\x15`\x0EW_\x80\xFD[P`\x046\x10`&W_5`\xE0\x1C\x80c\xB0\xEC*\xE1\x14`*W[_\x80\xFD[`0`DV[`@Q`;\x91\x90`\x97V[`@Q\x80\x91\x03\x90\xF3[``_\x80T\x80` \x02` \x01`@Q\x90\x81\x01`@R\x80\x92\x91\x90\x81\x81R` \x01\x82\x80T\x80\x15`\x8DW` \x02\x82\x01\x91\x90_R` _ \x90[\x81T\x81R` \x01\x90`\x01\x01\x90\x80\x83\x11`zW[PPPPP\x90P\x90V[` \x80\x82R\x82Q\x82\x82\x01\x81\x90R_\x91\x90\x84\x82\x01\x90`@\x85\x01\x90\x84[\x81\x81\x10\x15`\xCCW\x83Q\x83R\x92\x84\x01\x92\x91\x84\x01\x91`\x01\x01`\xB2V[P\x90\x96\x95PPPPPPV\xFE\xA2dipfsX\"\x12 \xC0\x96\"\xEC\xB2\x10\xD3O\xCE\x04 ;\xE6\xD9i)\x906\x86\x03\x15\xD6\xC3\xC6\xE6x\x83Nw\x15{\xFFdsolcC\0\x08\x19\x003",
    );
    /// The runtime bytecode of the contract, as deployed on the network.
    ///
    /// ```text
    ///0x608060405234801561000f575f80fd5b50600436106102e1575f3560e01c80638765240f11610187578063cc8089bb116100dd578063eb657a4e11610093578063ee9a31a21161006e578063ee9a31a214610931578063fa28742014610958578063faf5625f1461097f575f80fd5b8063eb657a4e146108d0578063ebe03a93146108f7578063ec4f74ce1461090a575f80fd5b8063d49d5181116100c3578063d49d51811461085b578063dae7cb8b14610882578063e8180c29146108a9575f80fd5b8063cc8089bb1461080d578063d384cb9514610834575f80fd5b8063b5e00c3f1161013d578063c21c423311610118578063c21c423314610798578063c519d151146107bf578063c897f55e146107e6575f80fd5b8063b5e00c3f14610723578063b70106971461074a578063be41b36714610771575f80fd5b8063999f20db1161016d578063999f20db146106b05780639f9854e5146106c5578063b38d57f0146106ec575f80fd5b80638765240f1461066257806391ddb28514610689575f80fd5b8063304b90711161023c5780635d9e2444116101f2578063785ffb37116101cd578063785ffb37146105ed578063817cd3121461061457806385e1f4d01461063b575f80fd5b80635d9e244414610566578063609fb5031461059f57806364f4992a146105c6575f80fd5b80634692de5d116102225780634692de5d146104f15780634b2f51ef146105185780634ceccfe51461053f575f80fd5b8063304b9071146104c25780633c2b7840146104ca575f80fd5b806310a662e21161029c5780631ccc2cd1116102775780631ccc2cd11461046157806328fb228c146104885780632cfb7ca31461049b575f80fd5b806310a662e2146103ec5780631b142ea7146104135780631c39b6721461043a575f80fd5b80630787484b116102cc5780630787484b1461035e5780630a54257d146103855780631047fc52146103ac575f80fd5b80623c78fb146102e5578062f9731e1461031f575b5f80fd5b61030c7f000000000000000000000000000000000000000000000000000000000000000081565b6040519081526020015b60405180910390f35b6103467f000000000000000000000000000000000000000000000000000000000000000081565b6040516001600160a01b039091168152602001610316565b6103467f000000000000000000000000000000000000000000000000000000000000000081565b6103467f000000000000000000000000000000000000000000000000000000000000000081565b6103d37f000000000000000000000000000000000000000000000000000000000000000081565b60405167ffffffffffffffff9091168152602001610316565b6103467f000000000000000000000000000000000000000000000000000000000000000081565b6103467f000000000000000000000000000000000000000000000000000000000000000081565b6103467f000000000000000000000000000000000000000000000000000000000000000081565b61030c7f000000000000000000000000000000000000000000000000000000000000000081565b6103466104963660046129b1565b6109a6565b6103467f000000000000000000000000000000000000000000000000000000000000000081565b61030c600c81565b6103467f000000000000000000000000000000000000000000000000000000000000000081565b6103467f000000000000000000000000000000000000000000000000000000000000000081565b6103467f000000000000000000000000000000000000000000000000000000000000000081565b6103d37f000000000000000000000000000000000000000000000000000000000000000081565b61058d7f000000000000000000000000000000000000000000000000000000000000000081565b60405160ff9091168152602001610316565b61030c7f000000000000000000000000000000000000000000000000000000000000000081565b6103467f000000000000000000000000000000000000000000000000000000000000000081565b6103d37f000000000000000000000000000000000000000000000000000000000000000081565b6103467f000000000000000000000000000000000000000000000000000000000000000081565b61030c7f000000000000000000000000000000000000000000000000000000000000000081565b6103467f000000000000000000000000000000000000000000000000000000000000000081565b6103d37f000000000000000000000000000000000000000000000000000000000000000081565b6106c36106be3660046129db565b610a12565b005b6103467f000000000000000000000000000000000000000000000000000000000000000081565b6107137f000000000000000000000000000000000000000000000000000000000000000081565b6040519015158152602001610316565b6103467f000000000000000000000000000000000000000000000000000000000000000081565b6103467f000000000000000000000000000000000000000000000000000000000000000081565b6103467f000000000000000000000000000000000000000000000000000000000000000081565b6103467f000000000000000000000000000000000000000000000000000000000000000081565b6103467f000000000000000000000000000000000000000000000000000000000000000081565b6103467f000000000000000000000000000000000000000000000000000000000000000081565b6103467f000000000000000000000000000000000000000000000000000000000000000081565b6103467f000000000000000000000000000000000000000000000000000000000000000081565b6103d37f000000000000000000000000000000000000000000000000000000000000000081565b6103467f000000000000000000000000000000000000000000000000000000000000000081565b6107137f000000000000000000000000000000000000000000000000000000000000000081565b6103d37f000000000000000000000000000000000000000000000000000000000000000081565b6106c3610905366004612ace565b610a9b565b6103d37f000000000000000000000000000000000000000000000000000000000000000081565b6103467f000000000000000000000000000000000000000000000000000000000000000081565b61030c7f000000000000000000000000000000000000000000000000000000000000000081565b61030c7f000000000000000000000000000000000000000000000000000000000000000081565b5f80826040516020016109bb91815260200190565b604051602081830303815290604052805190602001209050610a0881604051806020016109e7906127f5565b6020820181038252601f19601f8201166040525080519060200120866113df565b9150505b92915050565b5f836001600160a01b03163b118015610a455750826001600160a01b0316610a3a83836109a6565b6001600160a01b0316145b610a965760405162461bcd60e51b815260206004820152600d60248201527f414444525f4d49534d415443480000000000000000000000000000000000000060448201526064015b60405180910390fd5b505050565b610aa3611467565b5f610aac611806565b90505f7f00000000000000000000000000000000000000000000000000000000000000007f0000000000000000000000000000000000000000000000000000000000000000604051610afd90612802565b6001600160a01b039283168152911660208201526060604082018190525f90820152608001604051809103905ff080158015610b3b573d5f803e3d5ffd5b5090505f6040518061012001604052807f00000000000000000000000000000000000000000000000000000000000000006001600160a01b031681526020017f00000000000000000000000000000000000000000000000000000000000000006001600160a01b031681526020017f00000000000000000000000000000000000000000000000000000000000000006001600160a01b031681526020017f00000000000000000000000000000000000000000000000000000000000000006001600160a01b031681526020017f00000000000000000000000000000000000000000000000000000000000000006001600160a01b03168152602001836001600160a01b031681526020017f00000000000000000000000000000000000000000000000000000000000000006001600160a01b031681526020017f00000000000000000000000000000000000000000000000000000000000000006001600160a01b031681526020017f00000000000000000000000000000000000000000000000000000000000000006001600160a01b031663bc45e0ae6040518163ffffffff1660e01b8152600401602060405180830381865afa158015610cff573d5f803e3d5ffd5b505050506040513d601f19601f82011682018060405250810190610d239190612b68565b6001600160a01b031681525090505f8360c00151604051602001610d4991815260200190565b6040516020818303038152906040528051906020012090505f610d70308660c001516109a6565b9050610d7b81611eb3565b836001600160a01b0316631a72d54c827f00000000000000000000000000000000000000000000000000000000000000007f00000000000000000000000000000000000000000000000000000000000000008961018001518a6101a001518b6101c001518c602001517f00000000000000000000000000000000000000000000000000000000000000008e61024001518f61014001516040518b63ffffffff1660e01b8152600401610e369a99989796959493929190612b83565b5f604051808303815f87803b158015610e4d575f80fd5b505af1158015610e5f573d5f803e3d5ffd5b505050505f82604051610e71906127f5565b8190604051809103905ff5905080158015610e8e573d5f803e3d5ffd5b509050816001600160a01b0316816001600160a01b031614610ef25760405162461bcd60e51b815260206004820152601560248201527f554e455850435445445f524f4c4c55505f4144445200000000000000000000006044820152606401610a8d565b608086018051309091526040517fadfef6ac0000000000000000000000000000000000000000000000000000000081526001600160a01b0383169063adfef6ac90610f43908a908990600401612e1a565b5f604051808303815f87803b158015610f5a575f80fd5b505af1158015610f6c573d5f803e3d5ffd5b5050505087515f1461116c575f885167ffffffffffffffff811115610f9357610f93612a19565b604051908082528060200260200182016040528015610fbc578160200160208202803683370190505b5090505f5b89518110156110f5577f00000000000000000000000000000000000000000000000000000000000000006001600160a01b031663facd743b8b838151811061100b5761100b613031565b60200260200101516040518263ffffffff1660e01b815260040161103e91906001600160a01b0391909116815260200190565b602060405180830381865afa158015611059573d5f803e3d5ffd5b505050506040513d601f19601f8201168201806040525081019061107d9190613059565b6110c95760405162461bcd60e51b815260206004820152601860248201527f554e45585045435445445f4e45575f56414c494441544f5200000000000000006044820152606401610a8d565b60018282815181106110dd576110dd613031565b91151560209283029190910190910152600101610fc1565b506040517fa3ffb7720000000000000000000000000000000000000000000000000000000081526001600160a01b0384169063a3ffb7729061113d908c9085906004016130aa565b5f604051808303815f87803b158015611154575f80fd5b505af1158015611166573d5f803e3d5ffd5b50505050505b7f000000000000000000000000000000000000000000000000000000000000000015611222576040517fa2b4f1d80000000000000000000000000000000000000000000000000000000081527f0000000000000000000000000000000000000000000000000000000000000000151560048201526001600160a01b0383169063a2b4f1d8906024015f604051808303815f87803b15801561120b575f80fd5b505af115801561121d573d5f803e3d5ffd5b505050505b7f00000000000000000000000000000000000000000000000000000000000000006001600160a01b03166355840a586040518163ffffffff1660e01b8152600401602060405180830381865afa92505050801561129c575060408051601f3d908101601f1916820190925261129991810190612b68565b60015b15611322576001600160a01b03811615611320576040517f0d561b370000000000000000000000000000000000000000000000000000000081526001600160a01b038281166004830152841690630d561b37906024015f604051808303815f87803b158015611309575f80fd5b505af115801561131b573d5f803e3d5ffd5b505050505b505b6040517f13af40350000000000000000000000000000000000000000000000000000000081526001600160a01b0382811660048301528316906313af4035906024015f604051808303815f87803b15801561137b575f80fd5b505af115801561138d573d5f803e3d5ffd5b5050604080516001600160a01b0380881682528a1660208201527f7e5cc5c3fce046d868d5918548df8d3e8ef9f09e6fb30a68081f1f1348cd0314935001905060405180910390a15050505050505050565b604080517fff00000000000000000000000000000000000000000000000000000000000000602080830191909152606084901b7fffffffffffffffffffffffffffffffffffffffff00000000000000000000000016602183015260358201869052605580830186905283518084039091018152607590920190925280519101205b9392505050565b7f00000000000000000000000000000000000000000000000000000000000000006001600160a01b0316638456cb596040518163ffffffff1660e01b81526004015f604051808303815f87803b1580156114bf575f80fd5b505af11580156114d1573d5f803e3d5ffd5b505050505f7f00000000000000000000000000000000000000000000000000000000000000006001600160a01b031663dff697876040518163ffffffff1660e01b8152600401602060405180830381865afa158015611532573d5f803e3d5ffd5b505050506040513d601f19601f820116820180604052508101906115569190613118565b905060328167ffffffffffffffff16111561156f575060325b5f5b8167ffffffffffffffff168167ffffffffffffffff161015611802576040517f6ddd374400000000000000000000000000000000000000000000000000000000815267ffffffffffffffff821660048201525f907f00000000000000000000000000000000000000000000000000000000000000006001600160a01b031690636ddd374490602401602060405180830381865afa158015611614573d5f803e3d5ffd5b505050506040513d601f19601f820116820180604052508101906116389190612b68565b6040517fa23c44b10000000000000000000000000000000000000000000000000000000081526001600160a01b0380831660048301529192505f917f0000000000000000000000000000000000000000000000000000000000000000169063a23c44b19060240160a060405180830381865afa1580156116ba573d5f803e3d5ffd5b505050506040513d601f19601f820116820180604052508101906116de9190613131565b9050806080015180156116fd5750606081015167ffffffffffffffff16155b156117ed576040805160018082528183019092525f916020808301908036833701905050905082815f8151811061173657611736613031565b6001600160a01b0392831660209182029290920101526040517f7c75c2980000000000000000000000000000000000000000000000000000000081527f000000000000000000000000000000000000000000000000000000000000000090911690637c75c298906117ab9084906004016131b6565b5f604051808303815f87803b1580156117c2575f80fd5b505af11580156117d4573d5f803e3d5ffd5b505050506001856117e591906131dc565b9450506117fb565b826117f781613204565b9350505b5050611571565b5050565b61180e61280f565b5f7f00000000000000000000000000000000000000000000000000000000000000006001600160a01b03166392c8134c7f00000000000000000000000000000000000000000000000000000000000000006001600160a01b03166365f7f80d6040518163ffffffff1660e01b8152600401602060405180830381865afa15801561189a573d5f803e3d5ffd5b505050506040513d601f19601f820116820180604052508101906118be9190613118565b6040517fffffffff0000000000000000000000000000000000000000000000000000000060e084901b16815267ffffffffffffffff909116600482015260240161018060405180830381865afa15801561191a573d5f803e3d5ffd5b505050506040513d601f19601f8201168201806040525081019061193e919061322a565b516040517f8eaa6ac0000000000000000000000000000000000000000000000000000000008152600481018290529091505f9081907f00000000000000000000000000000000000000000000000000000000000000006001600160a01b031690638eaa6ac09060240160c060405180830381865afa1580156119c2573d5f803e3d5ffd5b505050506040513d601f19601f820116820180604052508101906119e6919061335c565b915091506119f261291d565b82518152602080840151908201906002811115611a1157611a11612cf8565b90816002811115611a2457611a24612cf8565b905250836001600160a01b037f0000000000000000000000000000000000000000000000000000000000000000166331644130611a6084612331565b856040518363ffffffff1660e01b8152600401611a7e929190613416565b602060405180830381865afa158015611a99573d5f803e3d5ffd5b505050506040513d601f19601f82011682018060405250810190611abd9190613448565b14611b0a5760405162461bcd60e51b815260206004820152601d60248201527f496e76616c6964206c617465737420657865637574696f6e20686173680000006044820152606401610a8d565b611b3160405180608001604052805f81526020015f81526020015f81526020015f81525090565b604080516060810182525f8082526020820181905291810191909152604051806102a001604052807f000000000000000000000000000000000000000000000000000000000000000067ffffffffffffffff1681526020017f00000000000000000000000000000000000000000000000000000000000000006001600160a01b031681526020017f000000000000000000000000000000000000000000000000000000000000000081526020017f00000000000000000000000000000000000000000000000000000000000000006001600160a01b0316638ee1a1266040518163ffffffff1660e01b8152600401602060405180830381865afa158015611c3a573d5f803e3d5ffd5b505050506040513d601f19601f82011682018060405250810190611c5e9190613448565b8152602001306001600160a01b031681526020017f00000000000000000000000000000000000000000000000000000000000000006001600160a01b031681526020017f0000000000000000000000000000000000000000000000000000000000000000815260200160405180602001604052805f81525081526020017f000000000000000000000000000000000000000000000000000000000000000081526020017f000000000000000000000000000000000000000000000000000000000000000067ffffffffffffffff1681526020017f00000000000000000000000000000000000000000000000000000000000000006001600160a01b031663b0ec2ae16040518163ffffffff1660e01b81526004015f60405180830381865afa158015611d8c573d5f803e3d5ffd5b505050506040513d5f823e601f3d908101601f19168201604052611db3919081019061345f565b81526020018381526020017f000000000000000000000000000000000000000000000000000000000000000081526020017f000000000000000000000000000000000000000000000000000000000000000081526020017f000000000000000000000000000000000000000000000000000000000000000081526020018481526020018581526020015f6001600160a01b031681526020017f000000000000000000000000000000000000000000000000000000000000000060ff1681526020017f000000000000000000000000000000000000000000000000000000000000000067ffffffffffffffff16815260200182815250965050505050505090565b60405163266a23b160e21b81526001600160a01b037f000000000000000000000000000000000000000000000000000000000000000081811660048401527f000000000000000000000000000000000000000000000000000000000000000082166024840152917f0000000000000000000000000000000000000000000000000000000000000000909116906399a88ec4906044015f604051808303815f87803b158015611f5f575f80fd5b505af1158015611f71573d5f803e3d5ffd5b50506040517f919cc7060000000000000000000000000000000000000000000000000000000081526001600160a01b0385811660048301527f000000000000000000000000000000000000000000000000000000000000000016925063919cc70691506024015f604051808303815f87803b158015611fee575f80fd5b505af1158015612000573d5f803e3d5ffd5b5050505061200c61236b565b60405163266a23b160e21b81526001600160a01b037f000000000000000000000000000000000000000000000000000000000000000081811660048401527f000000000000000000000000000000000000000000000000000000000000000082166024840152917f0000000000000000000000000000000000000000000000000000000000000000909116906399a88ec4906044015f604051808303815f87803b1580156120b8575f80fd5b505af11580156120ca573d5f803e3d5ffd5b505060405163266a23b160e21b81526001600160a01b037f000000000000000000000000000000000000000000000000000000000000000081811660048401527f00000000000000000000000000000000000000000000000000000000000000008216602484015293507f00000000000000000000000000000000000000000000000000000000000000001691506399a88ec4906044015f604051808303815f87803b158015612178575f80fd5b505af115801561218a573d5f803e3d5ffd5b505050507f00000000000000000000000000000000000000000000000000000000000000006001600160a01b0316636ae71f126040518163ffffffff1660e01b81526004015f604051808303815f87803b1580156121e6575f80fd5b505af11580156121f8573d5f803e3d5ffd5b505060405163266a23b160e21b81526001600160a01b037f000000000000000000000000000000000000000000000000000000000000000081811660048401527f00000000000000000000000000000000000000000000000000000000000000008216602484015293507f00000000000000000000000000000000000000000000000000000000000000001691506399a88ec4906044015f604051808303815f87803b1580156122a6575f80fd5b505af11580156122b8573d5f803e3d5ffd5b505050507f00000000000000000000000000000000000000000000000000000000000000006001600160a01b0316636ae71f126040518163ffffffff1660e01b81526004015f604051808303815f87803b158015612314575f80fd5b505af1158015612326573d5f803e3d5ffd5b505050505050505050565b612339612942565b6040518060400160405280835f015181526020018360200151600281111561236357612363612cf8565b905292915050565b7f00000000000000000000000000000000000000000000000000000000000000007f00000000000000000000000000000000000000000000000000000000000000001561256f577f00000000000000000000000000000000000000000000000000000000000000006001600160a01b0316639623609d827f000000000000000000000000000000000000000000000000000000000000000060405180606001604052807f000000000000000000000000000000000000000000000000000000000000000067ffffffffffffffff1681526020017f000000000000000000000000000000000000000000000000000000000000000067ffffffffffffffff1681526020017f000000000000000000000000000000000000000000000000000000000000000067ffffffffffffffff168152506040516024016124ac91906134e0565b60408051601f198184030181529181526020820180517bffffffffffffffffffffffffffffffffffffffffffffffffffffffff167fa655d93700000000000000000000000000000000000000000000000000000000179052517fffffffff0000000000000000000000000000000000000000000000000000000060e086901b16815261253d93929190600401613511565b5f604051808303815f87803b158015612554575f80fd5b505af1158015612566573d5f803e3d5ffd5b5050505061260e565b60405163266a23b160e21b81526001600160a01b0382811660048301527f0000000000000000000000000000000000000000000000000000000000000000811660248301527f000000000000000000000000000000000000000000000000000000000000000016906399a88ec4906044015f604051808303815f87803b1580156125f7575f80fd5b505af1158015612609573d5f803e3d5ffd5b505050505b5f805f807f00000000000000000000000000000000000000000000000000000000000000006001600160a01b031663ebea461d6040518163ffffffff1660e01b8152600401608060405180830381865afa15801561266e573d5f803e3d5ffd5b505050506040513d601f19601f820116820180604052508101906126929190613545565b93509350935093505f600c836126a8919061358c565b156126c8576126b8600c8461359f565b6126c39060016135b2565b6126d3565b6126d3600c8461359f565b90508481116126e257846126e4565b805b94507f00000000000000000000000000000000000000000000000000000000000000006001600160a01b031663b31761f86040518060800160405280888152602001878152602001868152602001858152506040518263ffffffff1660e01b815260040161275291906135c5565b5f604051808303815f87803b158015612769575f80fd5b505af115801561277b573d5f803e3d5ffd5b505050507f00000000000000000000000000000000000000000000000000000000000000006001600160a01b0316636ae71f126040518163ffffffff1660e01b81526004015f604051808303815f87803b1580156127d7575f80fd5b505af11580156127e9573d5f803e3d5ffd5b50505050505050505050565b6113e4806135f183390190565b610d89806149d583390190565b604051806102a001604052805f67ffffffffffffffff1681526020015f6001600160a01b031681526020015f81526020015f80191681526020015f6001600160a01b031681526020015f6001600160a01b031681526020015f8152602001606081526020015f81526020015f67ffffffffffffffff168152602001606081526020016128b860405180608001604052805f81526020015f81526020015f81526020015f81525090565b81526020015f81526020015f81526020015f81526020016128d761291d565b81525f602080830182905260408084018390526060808501849052608085018490528151908101825283815291820183905281019190915260a09091015290565b905290565b6040518060600160405280612930612960565b81526020015f81525f60209091015290565b6040518060400160405280612955612960565b81526020015f905290565b604051806040016040528061297361297c565b81526020016129185b60405180604001604052806002906020820280368337509192915050565b6001600160a01b03811681146129ae575f80fd5b50565b5f80604083850312156129c2575f80fd5b82356129cd8161299a565b946020939093013593505050565b5f805f606084860312156129ed575f80fd5b83356129f88161299a565b92506020840135612a088161299a565b929592945050506040919091013590565b634e487b7160e01b5f52604160045260245ffd5b604051610180810167ffffffffffffffff81118282101715612a5157612a51612a19565b60405290565b6040805190810167ffffffffffffffff81118282101715612a5157612a51612a19565b604051601f8201601f1916810167ffffffffffffffff81118282101715612aa357612aa3612a19565b604052919050565b5f67ffffffffffffffff821115612ac457612ac4612a19565b5060051b60200190565b5f6020808385031215612adf575f80fd5b823567ffffffffffffffff811115612af5575f80fd5b8301601f81018513612b05575f80fd5b8035612b18612b1382612aab565b612a7a565b81815260059190911b82018301908381019087831115612b36575f80fd5b928401925b82841015612b5d578335612b4e8161299a565b82529284019290840190612b3b565b979650505050505050565b5f60208284031215612b78575f80fd5b81516114608161299a565b5f6101408083016001600160a01b03808f168552602067ffffffffffffffff8f166020870152818e1660408701528c60608701528b60808701528a60a0870152818a1660c087015281891660e087015260ff88166101008701528361012087015282935086519150818352610160860193506020870192505f5b82811015612c1957835185529381019392810192600101612bfd565b50929f9e505050505050505050505050505050565b5f81518084528060208401602086015e5f602082860101526020601f19601f83011685010191505092915050565b5f815180845260208085019450602084015f5b83811015612c8b57815187529582019590820190600101612c6f565b509495945050505050565b8051825f5b6002811015612cba578251825260209283019290910190600101612c9b565b505050602080820151604084015f5b6002811015612cf057825167ffffffffffffffff1682529183019190830190600101612cc9565b505050505050565b634e487b7160e01b5f52602160045260245ffd5b60038110612d2857634e487b7160e01b5f52602160045260245ffd5b9052565b612d37828251612c96565b6020810151612d496080840182612d0c565b506040015160a09190910152565b6001600160a01b03808251168352806020830151166020840152806040830151166040840152506060810151612d9860608401826001600160a01b03169052565b506080810151612db360808401826001600160a01b03169052565b5060a0810151612dce60a08401826001600160a01b03169052565b5060c0810151612de960c08401826001600160a01b03169052565b5060e0810151612e0460e08401826001600160a01b03169052565b50610100908101516001600160a01b0316910152565b5f610140808352612e37818401865167ffffffffffffffff169052565b60208501516001600160a01b0381166101608501525060408501516101808181860152606087015191506101a08281870152608088015192506101c0612e87818801856001600160a01b03169052565b60a089015193506101e0612ea5818901866001600160a01b03169052565b60c08a0151945061020085818a015260e08b015195506102206103e0818b0152612ed36105208b0188612c2e565b96506101008c015161024081818d01526101208e01519150610260612f03818e018467ffffffffffffffff169052565b8a8f01519a5061028092507ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffec08d8b0301838e0152612f418a8c612c5c565b9a506101608f01519950612f7a6102a08e018b805182526020810151602083015260408101516040830152606081015160608301525050565b888f01516103208e0152878f01516103408e0152868f01516103608e0152858f01519950612fac6103808e018b612d2c565b938e01516104408d0152918d01516001600160a01b03166104608c0152908c015160ff166104808b0152908b015167ffffffffffffffff9081166104a08b0152908b0151805182166104c08b0152602081015182166104e08b015260408101519091166105008a015294506130219350505050565b5090506114606020830184612d57565b634e487b7160e01b5f52603260045260245ffd5b80518015158114613054575f80fd5b919050565b5f60208284031215613069575f80fd5b61146082613045565b5f815180845260208085019450602084015f5b83811015612c8b5781516001600160a01b031687529582019590820190600101613085565b604081525f6130bc6040830185613072565b8281036020848101919091528451808352858201928201905f5b818110156130f45784511515835293830193918301916001016130d6565b5090979650505050505050565b805167ffffffffffffffff81168114613054575f80fd5b5f60208284031215613128575f80fd5b61146082613101565b5f60a08284031215613141575f80fd5b60405160a0810181811067ffffffffffffffff8211171561316457613164612a19565b6040528251815261317760208401613101565b602082015261318860408401613101565b604082015261319960608401613101565b60608201526131aa60808401613045565b60808201529392505050565b602081525f6114606020830184613072565b634e487b7160e01b5f52601160045260245ffd5b67ffffffffffffffff8281168282160390808211156131fd576131fd6131c8565b5092915050565b5f67ffffffffffffffff808316818103613220576132206131c8565b6001019392505050565b5f610180828403121561323b575f80fd5b613243612a2d565b82518152602083015160208201526040830151604082015261326760608401613101565b606082015261327860808401613101565b608082015261328960a08401613101565b60a082015261329a60c08401613101565b60c08201526132ab60e08401613101565b60e08201526101006132be818501613101565b908201526101206132d0848201613101565b908201526101406132e2848201613101565b90820152610160928301519281019290925250919050565b5f82601f830112613309575f80fd5b613311612a57565b806040840185811115613322575f80fd5b845b818110156133435761333581613101565b845260209384019301613324565b509095945050505050565b805160038110613054575f80fd5b5f8082840360c081121561336e575f80fd5b60a081121561337b575f80fd5b613383612a57565b6080821215613390575f80fd5b613398612a57565b915085601f8601126133a8575f80fd5b6133b0612a57565b8060408701888111156133c1575f80fd5b875b818110156133db5780518452602093840193016133c3565b508185526133e989826132fa565b60208601525050508181526134006080860161334e565b602082015260a094909401519395939450505050565b5f60c082019050613428828551612c96565b602084015161343a6080840182612d0c565b508260a08301529392505050565b5f60208284031215613458575f80fd5b5051919050565b5f6020808385031215613470575f80fd5b825167ffffffffffffffff811115613486575f80fd5b8301601f81018513613496575f80fd5b80516134a4612b1382612aab565b81815260059190911b820183019083810190878311156134c2575f80fd5b928401925b82841015612b5d578351825292840192908401906134c7565b60608101610a0c8284805167ffffffffffffffff908116835260208083015182169084015260409182015116910152565b5f6001600160a01b0380861683528085166020840152506060604083015261353c6060830184612c2e565b95945050505050565b5f805f8060808587031215613558575f80fd5b505082516020840151604085015160609095015191969095509092509050565b634e487b7160e01b5f52601260045260245ffd5b5f8261359a5761359a613578565b500690565b5f826135ad576135ad613578565b500490565b80820180821115610a0c57610a0c6131c8565b8151815260208083015190820152604080830151908201526060808301519082015260808101610a0c56fe6080604052348015600e575f80fd5b506113c88061001c5f395ff3fe608060405260043610610021575f3560e01c8063adfef6ac1461003857610030565b366100305761002e610057565b005b61002e610057565b348015610043575f80fd5b5061002e610052366004610d61565b610069565b6100676100626101b8565b61029a565b565b5f6100726102bd565b6001600160a01b031614801561009757505f61008c6102ef565b6001600160a01b0316145b80156100b257505f6100a7610316565b6001600160a01b0316145b156101b0576101ac8160c0015183836040516024016100d29291906110f9565b60408051601f19818403018152918152602080830180517bffffffffffffffffffffffffffffffffffffffffffffffffffffffff167f0ee5ef0c0000000000000000000000000000000000000000000000000000000017905260e08601519087015191516001600160a01b0390921660248301529060440160408051601f198184030181529190526020810180517bffffffffffffffffffffffffffffffffffffffffffffffffffffffff167fc4d66de800000000000000000000000000000000000000000000000000000000179052608087015161033d565b5050565b6101ac610057565b5f600436101561020f5760405162461bcd60e51b815260206004820152600b60248201527f4e4f5f46554e435f53494700000000000000000000000000000000000000000060448201526064015b60405180910390fd5b5f336102196102bd565b6001600160a01b0316036102345761022f6102ef565b61023c565b61023c610316565b90506001600160a01b0381163b6102955760405162461bcd60e51b815260206004820152601360248201527f5441524745545f4e4f545f434f4e5452414354000000000000000000000000006044820152606401610206565b919050565b365f80375f80365f845af43d5f803e8080156102b4573d5ff35b3d5ffd5b505050565b5f7fb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d61035b546001600160a01b0316919050565b5f7f360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc6102e0565b5f7f2b1dbce74324248c222f0ec2d5ed7bd323cfc425b336f0253c5ccfda7265546d6102e0565b61036860017fb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6104611310565b7fb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103146103965761039661132f565b6103c160017f360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbd611310565b7f360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc146103ef576103ef61132f565b61041a60017f2b1dbce74324248c222f0ec2d5ed7bd323cfc425b336f0253c5ccfda7265546e611310565b7f2b1dbce74324248c222f0ec2d5ed7bd323cfc425b336f0253c5ccfda7265546d146104485761044861132f565b6104518161046e565b61045c85855f6104c5565b61046783835f6104ef565b5050505050565b7f7e644d79422f17c01e4894b5f4f588d331ebfa28653d42ae832dc59e38c9798f6104976102bd565b604080516001600160a01b03928316815291841660208301520160405180910390a16104c2816104f8565b50565b6104ce836105d0565b5f825111806104da5750805b156102b8576104e9838361060f565b50505050565b6104ce8361063d565b6001600160a01b0381166105745760405162461bcd60e51b815260206004820152602660248201527f455243313936373a206e65772061646d696e20697320746865207a65726f206160448201527f64647265737300000000000000000000000000000000000000000000000000006064820152608401610206565b807fb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d61035b80547fffffffffffffffffffffffff0000000000000000000000000000000000000000166001600160a01b039290921691909117905550565b6105d98161067c565b6040516001600160a01b038216907fbc7cd75a20ee27fd9adebab32041f755214dbc6bffa90cc0225b39da2e5c2d3b905f90a250565b6060610634838360405180606001604052806027815260200161136c60279139610720565b90505b92915050565b61064681610812565b6040516001600160a01b038216907ff7eed2a7fabbf1bec8d55ed5e785cc76622376dde5df4ff15470551e030b8134905f90a250565b6001600160a01b0381163b6106f95760405162461bcd60e51b815260206004820152602d60248201527f455243313936373a206e657720696d706c656d656e746174696f6e206973206e60448201527f6f74206120636f6e7472616374000000000000000000000000000000000000006064820152608401610206565b807f360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc610597565b60606001600160a01b0384163b61079f5760405162461bcd60e51b815260206004820152602660248201527f416464726573733a2064656c65676174652063616c6c20746f206e6f6e2d636f60448201527f6e747261637400000000000000000000000000000000000000000000000000006064820152608401610206565b5f80856001600160a01b0316856040516107b99190611343565b5f60405180830381855af49150503d805f81146107f1576040519150601f19603f3d011682016040523d82523d5f602084013e6107f6565b606091505b50915091506108068282866108b6565b925050505b9392505050565b6001600160a01b0381163b61088f5760405162461bcd60e51b815260206004820152603760248201527f455243313936373a206e6577207365636f6e6461727920696d706c656d656e7460448201527f6174696f6e206973206e6f74206120636f6e74726163740000000000000000006064820152608401610206565b807f2b1dbce74324248c222f0ec2d5ed7bd323cfc425b336f0253c5ccfda7265546d610597565b606083156108c557508161080b565b8251156108d55782518084602001fd5b8160405162461bcd60e51b81526004016102069190611359565b634e487b7160e01b5f52604160045260245ffd5b6040516060810167ffffffffffffffff81118282101715610926576109266108ef565b60405290565b6040805190810167ffffffffffffffff81118282101715610926576109266108ef565b604051610120810167ffffffffffffffff81118282101715610926576109266108ef565b6040516102a0810167ffffffffffffffff81118282101715610926576109266108ef565b604051601f8201601f1916810167ffffffffffffffff811182821017156109c0576109c06108ef565b604052919050565b803567ffffffffffffffff81168114610295575f80fd5b80356001600160a01b0381168114610295575f80fd5b5f82601f830112610a04575f80fd5b813567ffffffffffffffff811115610a1e57610a1e6108ef565b610a316020601f19601f84011601610997565b818152846020838601011115610a45575f80fd5b816020850160208301375f918101602001919091529392505050565b5f82601f830112610a70575f80fd5b8135602067ffffffffffffffff821115610a8c57610a8c6108ef565b8160051b610a9b828201610997565b9283528481018201928281019087851115610ab4575f80fd5b83870192505b84831015610ad357823582529183019190830190610aba565b979650505050505050565b5f60808284031215610aee575f80fd5b6040516080810181811067ffffffffffffffff82111715610b1157610b116108ef565b8060405250809150823581526020830135602082015260408301356040820152606083013560608201525092915050565b5f82601f830112610b51575f80fd5b610b5961092c565b806040840185811115610b6a575f80fd5b845b81811015610b8b57610b7d816109c8565b845260209384019301610b6c565b509095945050505050565b803560038110610295575f80fd5b5f81830360c0811215610bb5575f80fd5b610bbd610903565b91506080811215610bcc575f80fd5b50610bd561092c565b83601f840112610be3575f80fd5b610beb61092c565b806040850186811115610bfc575f80fd5b855b81811015610c16578035845260209384019301610bfe565b50818452610c248782610b42565b60208501525050508152610c3a60808301610b96565b602082015260a0820135604082015292915050565b803560ff81168114610295575f80fd5b5f60608284031215610c6f575f80fd5b610c77610903565b9050610c82826109c8565b8152610c90602083016109c8565b6020820152610ca1604083016109c8565b604082015292915050565b5f6101208284031215610cbd575f80fd5b610cc561094f565b9050610cd0826109df565b8152610cde602083016109df565b6020820152610cef604083016109df565b6040820152610d00606083016109df565b6060820152610d11608083016109df565b6080820152610d2260a083016109df565b60a0820152610d3360c083016109df565b60c0820152610d4460e083016109df565b60e0820152610100610d578184016109df565b9082015292915050565b5f80610140808486031215610d74575f80fd5b833567ffffffffffffffff80821115610d8b575f80fd5b908501906103e08288031215610d9f575f80fd5b610da7610973565b610db0836109c8565b8152610dbe602084016109df565b60208201526040830135604082015260608301356060820152610de3608084016109df565b6080820152610df460a084016109df565b60a082015260c083013560c082015260e083013582811115610e14575f80fd5b610e20898286016109f5565b60e0830152506101008381013590820152610120610e3f8185016109c8565b908201528284013582811115610e53575f80fd5b610e5f89828601610a61565b85830152506101609350610e7588858501610ade565b848201526101e09350838301356101808201526102009150818301356101a0820152610220808401356101c0830152610240610eb38a828701610ba4565b8684015261030085013584840152610ece61032086016109df565b82840152610edf6103408601610c4f565b9083015250610ef161036084016109c8565b610260820152610f05886103808501610c5f565b61028082015280955050505050610f1f8460208501610cac565b90509250929050565b5f81518084528060208401602086015e5f602082860101526020601f19601f83011685010191505092915050565b5f815180845260208085019450602084015f5b83811015610f8557815187529582019590820190600101610f69565b509495945050505050565b60038110610fac57634e487b7160e01b5f52602160045260245ffd5b9052565b80518051835f5b6002811015610fd6578251825260209283019290910190600101610fb7565b50505060209081015190604084015f5b600281101561100d57835167ffffffffffffffff1682529282019290820190600101610fe6565b5050505060208101516110236080840182610f90565b506040015160a09190910152565b6001600160a01b0380825116835280602083015116602084015280604083015116604084015250606081015161107260608401826001600160a01b03169052565b50608081015161108d60808401826001600160a01b03169052565b5060a08101516110a860a08401826001600160a01b03169052565b5060c08101516110c360c08401826001600160a01b03169052565b5060e08101516110de60e08401826001600160a01b03169052565b50610100818101516001600160a01b038116848301526104e9565b5f610140808352611116818401865167ffffffffffffffff169052565b60208501516001600160a01b0381166101608501525060408501516101808181860152606087015191506101a08281870152608088015192506101c0611166818801856001600160a01b03169052565b60a089015193506101e0611184818901866001600160a01b03169052565b60c08a0151945061020085818a015260e08b015195506102206103e0818b01526111b26105208b0188610f28565b96506101008c015161024081818d01526101208e015191506102606111e2818e018467ffffffffffffffff169052565b8a8f01519a5061028092507ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffec08d8b0301838e01526112208a8c610f56565b9a506101608f015199506112596102a08e018b805182526020810151602083015260408101516040830152606081015160608301525050565b888f01516103208e0152878f01516103408e0152868f01516103608e0152858f0151995061128b6103808e018b610fb0565b938e01516104408d0152918d01516001600160a01b03166104608c0152908c015160ff166104808b0152908b015167ffffffffffffffff9081166104a08b0152908b0151805182166104c08b0152602081015182166104e08b015260408101519091166105008a015294506113009350505050565b50905061080b6020830184611031565b8181038181111561063757634e487b7160e01b5f52601160045260245ffd5b634e487b7160e01b5f52600160045260245ffd5b5f82518060208501845e5f920191825250919050565b602081525f6106346020830184610f2856fe416464726573733a206c6f772d6c6576656c2064656c65676174652063616c6c206661696c6564a2646970667358221220c3b57cc1c902d57e4e5dea720ed63f19c757cd25bcb40afbcc377b072e67131e64736f6c634300081900336080604052604051610d89380380610d89833981016040819052610022916103b7565b828161002f82825f610043565b5061003b90508261006e565b5050506104cd565b61004c836100db565b5f825111806100585750805b1561006957610067838361011a565b505b505050565b7f7e644d79422f17c01e4894b5f4f588d331ebfa28653d42ae832dc59e38c9798f6100ad5f80516020610d42833981519152546001600160a01b031690565b604080516001600160a01b03928316815291841660208301520160405180910390a16100d881610146565b50565b6100e4816101e1565b6040516001600160a01b038216907fbc7cd75a20ee27fd9adebab32041f755214dbc6bffa90cc0225b39da2e5c2d3b905f90a250565b606061013f8383604051806060016040528060278152602001610d6260279139610275565b9392505050565b6001600160a01b0381166101b05760405162461bcd60e51b815260206004820152602660248201527f455243313936373a206e65772061646d696e20697320746865207a65726f206160448201526564647265737360d01b60648201526084015b60405180910390fd5b805f80516020610d428339815191525b80546001600160a01b0319166001600160a01b039290921691909117905550565b6001600160a01b0381163b61024e5760405162461bcd60e51b815260206004820152602d60248201527f455243313936373a206e657720696d706c656d656e746174696f6e206973206e60448201526c1bdd08184818dbdb9d1c9858dd609a1b60648201526084016101a7565b807f360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc6101c0565b60606001600160a01b0384163b6102dd5760405162461bcd60e51b815260206004820152602660248201527f416464726573733a2064656c65676174652063616c6c20746f206e6f6e2d636f6044820152651b9d1c9858dd60d21b60648201526084016101a7565b5f80856001600160a01b0316856040516102f79190610482565b5f60405180830381855af49150503d805f811461032f576040519150601f19603f3d011682016040523d82523d5f602084013e610334565b606091505b50909250905061034582828661034f565b9695505050505050565b6060831561035e57508161013f565b82511561036e5782518084602001fd5b8160405162461bcd60e51b81526004016101a79190610498565b80516001600160a01b038116811461039e575f80fd5b919050565b634e487b7160e01b5f52604160045260245ffd5b5f805f606084860312156103c9575f80fd5b6103d284610388565b92506103e060208501610388565b60408501519092506001600160401b03808211156103fc575f80fd5b818601915086601f83011261040f575f80fd5b815181811115610421576104216103a3565b604051601f8201601f19908116603f01168101908382118183101715610449576104496103a3565b81604052828152896020848701011115610461575f80fd5b8260208601602083015e5f6020848301015280955050505050509250925092565b5f82518060208501845e5f920191825250919050565b602081525f82518060208401528060208501604085015e5f604082850101526040601f19601f83011684010191505092915050565b610868806104da5f395ff3fe60806040526004361061005d575f3560e01c80635c60da1b116100425780635c60da1b146100a65780638f283970146100d6578063f851a440146100f55761006c565b80633659cfe6146100745780634f1ef286146100935761006c565b3661006c5761006a610109565b005b61006a610109565b34801561007f575f80fd5b5061006a61008e36600461070d565b610123565b61006a6100a1366004610726565b61015e565b3480156100b1575f80fd5b506100ba6101c4565b6040516001600160a01b03909116815260200160405180910390f35b3480156100e1575f80fd5b5061006a6100f036600461070d565b6101f4565b348015610100575f80fd5b506100ba610214565b610111610234565b61012161011c6102e4565b6102ed565b565b61012b61030b565b6001600160a01b03163303610156576101538160405180602001604052805f8152505f61033d565b50565b610153610109565b61016661030b565b6001600160a01b031633036101bc576101b78383838080601f0160208091040260200160405190810160405280939291908181526020018383808284375f920191909152506001925061033d915050565b505050565b6101b7610109565b5f6101cd61030b565b6001600160a01b031633036101e9576101e46102e4565b905090565b6101f1610109565b90565b6101fc61030b565b6001600160a01b031633036101565761015381610367565b5f61021d61030b565b6001600160a01b031633036101e9576101e461030b565b61023c61030b565b6001600160a01b031633036101215760405162461bcd60e51b815260206004820152604260248201527f5472616e73706172656e745570677261646561626c6550726f78793a2061646d60448201527f696e2063616e6e6f742066616c6c6261636b20746f2070726f7879207461726760648201527f6574000000000000000000000000000000000000000000000000000000000000608482015260a4015b60405180910390fd5b5f6101e46103bb565b365f80375f80365f845af43d5f803e808015610307573d5ff35b3d5ffd5b5f7fb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d61035b546001600160a01b0316919050565b610346836103e2565b5f825111806103525750805b156101b7576103618383610421565b50505050565b7f7e644d79422f17c01e4894b5f4f588d331ebfa28653d42ae832dc59e38c9798f61039061030b565b604080516001600160a01b03928316815291841660208301520160405180910390a16101538161044d565b5f7f360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc61032e565b6103eb81610525565b6040516001600160a01b038216907fbc7cd75a20ee27fd9adebab32041f755214dbc6bffa90cc0225b39da2e5c2d3b905f90a250565b6060610446838360405180606001604052806027815260200161080c602791396105c9565b9392505050565b6001600160a01b0381166104c95760405162461bcd60e51b815260206004820152602660248201527f455243313936373a206e65772061646d696e20697320746865207a65726f206160448201527f646472657373000000000000000000000000000000000000000000000000000060648201526084016102db565b807fb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d61035b80547fffffffffffffffffffffffff0000000000000000000000000000000000000000166001600160a01b039290921691909117905550565b6001600160a01b0381163b6105a25760405162461bcd60e51b815260206004820152602d60248201527f455243313936373a206e657720696d706c656d656e746174696f6e206973206e60448201527f6f74206120636f6e74726163740000000000000000000000000000000000000060648201526084016102db565b807f360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc6104ec565b60606001600160a01b0384163b6106485760405162461bcd60e51b815260206004820152602660248201527f416464726573733a2064656c65676174652063616c6c20746f206e6f6e2d636f60448201527f6e7472616374000000000000000000000000000000000000000000000000000060648201526084016102db565b5f80856001600160a01b03168560405161066291906107a2565b5f60405180830381855af49150503d805f811461069a576040519150601f19603f3d011682016040523d82523d5f602084013e61069f565b606091505b50915091506106af8282866106b9565b9695505050505050565b606083156106c8575081610446565b8251156106d85782518084602001fd5b8160405162461bcd60e51b81526004016102db91906107b8565b80356001600160a01b0381168114610708575f80fd5b919050565b5f6020828403121561071d575f80fd5b610446826106f2565b5f805f60408486031215610738575f80fd5b610741846106f2565b9250602084013567ffffffffffffffff8082111561075d575f80fd5b818601915086601f830112610770575f80fd5b81358181111561077e575f80fd5b87602082850101111561078f575f80fd5b6020830194508093505050509250925092565b5f82518060208501845e5f920191825250919050565b602081525f82518060208401528060208501604085015e5f6040828501015260407fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe0601f8301168401019150509291505056fe416464726573733a206c6f772d6c6576656c2064656c65676174652063616c6c206661696c6564a26469706673582212205147d38957e9df6e1da1b98751987c55e32bdc4cb009ea7a145ab634aee1897364736f6c63430008190033b53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103416464726573733a206c6f772d6c6576656c2064656c65676174652063616c6c206661696c6564a2646970667358221220dc6f6699c6fbde234a387f805d698aedaf1e55062dd4ac5e874c1513c6bee1af64736f6c63430008190033
    /// ```
    #[rustfmt::skip]
    #[allow(clippy::all)]
    pub static DEPLOYED_BYTECODE: alloy_sol_types::private::Bytes = alloy_sol_types::private::Bytes::from_static(
        b"`\x80`@R4\x80\x15a\0\x0FW_\x80\xFD[P`\x046\x10a\x02\xE1W_5`\xE0\x1C\x80c\x87e$\x0F\x11a\x01\x87W\x80c\xCC\x80\x89\xBB\x11a\0\xDDW\x80c\xEBezN\x11a\0\x93W\x80c\xEE\x9A1\xA2\x11a\0nW\x80c\xEE\x9A1\xA2\x14a\t1W\x80c\xFA(t \x14a\tXW\x80c\xFA\xF5b_\x14a\t\x7FW_\x80\xFD[\x80c\xEBezN\x14a\x08\xD0W\x80c\xEB\xE0:\x93\x14a\x08\xF7W\x80c\xECOt\xCE\x14a\t\nW_\x80\xFD[\x80c\xD4\x9DQ\x81\x11a\0\xC3W\x80c\xD4\x9DQ\x81\x14a\x08[W\x80c\xDA\xE7\xCB\x8B\x14a\x08\x82W\x80c\xE8\x18\x0C)\x14a\x08\xA9W_\x80\xFD[\x80c\xCC\x80\x89\xBB\x14a\x08\rW\x80c\xD3\x84\xCB\x95\x14a\x084W_\x80\xFD[\x80c\xB5\xE0\x0C?\x11a\x01=W\x80c\xC2\x1CB3\x11a\x01\x18W\x80c\xC2\x1CB3\x14a\x07\x98W\x80c\xC5\x19\xD1Q\x14a\x07\xBFW\x80c\xC8\x97\xF5^\x14a\x07\xE6W_\x80\xFD[\x80c\xB5\xE0\x0C?\x14a\x07#W\x80c\xB7\x01\x06\x97\x14a\x07JW\x80c\xBEA\xB3g\x14a\x07qW_\x80\xFD[\x80c\x99\x9F \xDB\x11a\x01mW\x80c\x99\x9F \xDB\x14a\x06\xB0W\x80c\x9F\x98T\xE5\x14a\x06\xC5W\x80c\xB3\x8DW\xF0\x14a\x06\xECW_\x80\xFD[\x80c\x87e$\x0F\x14a\x06bW\x80c\x91\xDD\xB2\x85\x14a\x06\x89W_\x80\xFD[\x80c0K\x90q\x11a\x02<W\x80c]\x9E$D\x11a\x01\xF2W\x80cx_\xFB7\x11a\x01\xCDW\x80cx_\xFB7\x14a\x05\xEDW\x80c\x81|\xD3\x12\x14a\x06\x14W\x80c\x85\xE1\xF4\xD0\x14a\x06;W_\x80\xFD[\x80c]\x9E$D\x14a\x05fW\x80c`\x9F\xB5\x03\x14a\x05\x9FW\x80cd\xF4\x99*\x14a\x05\xC6W_\x80\xFD[\x80cF\x92\xDE]\x11a\x02\"W\x80cF\x92\xDE]\x14a\x04\xF1W\x80cK/Q\xEF\x14a\x05\x18W\x80cL\xEC\xCF\xE5\x14a\x05?W_\x80\xFD[\x80c0K\x90q\x14a\x04\xC2W\x80c<+x@\x14a\x04\xCAW_\x80\xFD[\x80c\x10\xA6b\xE2\x11a\x02\x9CW\x80c\x1C\xCC,\xD1\x11a\x02wW\x80c\x1C\xCC,\xD1\x14a\x04aW\x80c(\xFB\"\x8C\x14a\x04\x88W\x80c,\xFB|\xA3\x14a\x04\x9BW_\x80\xFD[\x80c\x10\xA6b\xE2\x14a\x03\xECW\x80c\x1B\x14.\xA7\x14a\x04\x13W\x80c\x1C9\xB6r\x14a\x04:W_\x80\xFD[\x80c\x07\x87HK\x11a\x02\xCCW\x80c\x07\x87HK\x14a\x03^W\x80c\nT%}\x14a\x03\x85W\x80c\x10G\xFCR\x14a\x03\xACW_\x80\xFD[\x80b<x\xFB\x14a\x02\xE5W\x80b\xF9s\x1E\x14a\x03\x1FW[_\x80\xFD[a\x03\x0C\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81V[`@Q\x90\x81R` \x01[`@Q\x80\x91\x03\x90\xF3[a\x03F\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81V[`@Q`\x01`\x01`\xA0\x1B\x03\x90\x91\x16\x81R` \x01a\x03\x16V[a\x03F\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81V[a\x03F\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81V[a\x03\xD3\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81V[`@Qg\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x90\x91\x16\x81R` \x01a\x03\x16V[a\x03F\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81V[a\x03F\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81V[a\x03F\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81V[a\x03\x0C\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81V[a\x03Fa\x04\x966`\x04a)\xB1V[a\t\xA6V[a\x03F\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81V[a\x03\x0C`\x0C\x81V[a\x03F\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81V[a\x03F\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81V[a\x03F\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81V[a\x03\xD3\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81V[a\x05\x8D\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81V[`@Q`\xFF\x90\x91\x16\x81R` \x01a\x03\x16V[a\x03\x0C\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81V[a\x03F\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81V[a\x03\xD3\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81V[a\x03F\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81V[a\x03\x0C\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81V[a\x03F\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81V[a\x03\xD3\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81V[a\x06\xC3a\x06\xBE6`\x04a)\xDBV[a\n\x12V[\0[a\x03F\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81V[a\x07\x13\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81V[`@Q\x90\x15\x15\x81R` \x01a\x03\x16V[a\x03F\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81V[a\x03F\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81V[a\x03F\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81V[a\x03F\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81V[a\x03F\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81V[a\x03F\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81V[a\x03F\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81V[a\x03F\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81V[a\x03\xD3\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81V[a\x03F\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81V[a\x07\x13\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81V[a\x03\xD3\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81V[a\x06\xC3a\t\x056`\x04a*\xCEV[a\n\x9BV[a\x03\xD3\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81V[a\x03F\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81V[a\x03\x0C\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81V[a\x03\x0C\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81V[_\x80\x82`@Q` \x01a\t\xBB\x91\x81R` \x01\x90V[`@Q` \x81\x83\x03\x03\x81R\x90`@R\x80Q\x90` \x01 \x90Pa\n\x08\x81`@Q\x80` \x01a\t\xE7\x90a'\xF5V[` \x82\x01\x81\x03\x82R`\x1F\x19`\x1F\x82\x01\x16`@RP\x80Q\x90` \x01 \x86a\x13\xDFV[\x91PP[\x92\x91PPV[_\x83`\x01`\x01`\xA0\x1B\x03\x16;\x11\x80\x15a\nEWP\x82`\x01`\x01`\xA0\x1B\x03\x16a\n:\x83\x83a\t\xA6V[`\x01`\x01`\xA0\x1B\x03\x16\x14[a\n\x96W`@QbF\x1B\xCD`\xE5\x1B\x81R` `\x04\x82\x01R`\r`$\x82\x01R\x7FADDR_MISMATCH\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0`D\x82\x01R`d\x01[`@Q\x80\x91\x03\x90\xFD[PPPV[a\n\xA3a\x14gV[_a\n\xACa\x18\x06V[\x90P_\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0`@Qa\n\xFD\x90a(\x02V[`\x01`\x01`\xA0\x1B\x03\x92\x83\x16\x81R\x91\x16` \x82\x01R```@\x82\x01\x81\x90R_\x90\x82\x01R`\x80\x01`@Q\x80\x91\x03\x90_\xF0\x80\x15\x80\x15a\x0B;W=_\x80>=_\xFD[P\x90P_`@Q\x80a\x01 \x01`@R\x80\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0`\x01`\x01`\xA0\x1B\x03\x16\x81R` \x01\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0`\x01`\x01`\xA0\x1B\x03\x16\x81R` \x01\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0`\x01`\x01`\xA0\x1B\x03\x16\x81R` \x01\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0`\x01`\x01`\xA0\x1B\x03\x16\x81R` \x01\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0`\x01`\x01`\xA0\x1B\x03\x16\x81R` \x01\x83`\x01`\x01`\xA0\x1B\x03\x16\x81R` \x01\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0`\x01`\x01`\xA0\x1B\x03\x16\x81R` \x01\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0`\x01`\x01`\xA0\x1B\x03\x16\x81R` \x01\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0`\x01`\x01`\xA0\x1B\x03\x16c\xBCE\xE0\xAE`@Q\x81c\xFF\xFF\xFF\xFF\x16`\xE0\x1B\x81R`\x04\x01` `@Q\x80\x83\x03\x81\x86Z\xFA\x15\x80\x15a\x0C\xFFW=_\x80>=_\xFD[PPPP`@Q=`\x1F\x19`\x1F\x82\x01\x16\x82\x01\x80`@RP\x81\x01\x90a\r#\x91\x90a+hV[`\x01`\x01`\xA0\x1B\x03\x16\x81RP\x90P_\x83`\xC0\x01Q`@Q` \x01a\rI\x91\x81R` \x01\x90V[`@Q` \x81\x83\x03\x03\x81R\x90`@R\x80Q\x90` \x01 \x90P_a\rp0\x86`\xC0\x01Qa\t\xA6V[\x90Pa\r{\x81a\x1E\xB3V[\x83`\x01`\x01`\xA0\x1B\x03\x16c\x1Ar\xD5L\x82\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x89a\x01\x80\x01Q\x8Aa\x01\xA0\x01Q\x8Ba\x01\xC0\x01Q\x8C` \x01Q\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x8Ea\x02@\x01Q\x8Fa\x01@\x01Q`@Q\x8Bc\xFF\xFF\xFF\xFF\x16`\xE0\x1B\x81R`\x04\x01a\x0E6\x9A\x99\x98\x97\x96\x95\x94\x93\x92\x91\x90a+\x83V[_`@Q\x80\x83\x03\x81_\x87\x80;\x15\x80\x15a\x0EMW_\x80\xFD[PZ\xF1\x15\x80\x15a\x0E_W=_\x80>=_\xFD[PPPP_\x82`@Qa\x0Eq\x90a'\xF5V[\x81\x90`@Q\x80\x91\x03\x90_\xF5\x90P\x80\x15\x80\x15a\x0E\x8EW=_\x80>=_\xFD[P\x90P\x81`\x01`\x01`\xA0\x1B\x03\x16\x81`\x01`\x01`\xA0\x1B\x03\x16\x14a\x0E\xF2W`@QbF\x1B\xCD`\xE5\x1B\x81R` `\x04\x82\x01R`\x15`$\x82\x01R\x7FUNEXPCTED_ROLLUP_ADDR\0\0\0\0\0\0\0\0\0\0\0`D\x82\x01R`d\x01a\n\x8DV[`\x80\x86\x01\x80Q0\x90\x91R`@Q\x7F\xAD\xFE\xF6\xAC\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x01`\x01`\xA0\x1B\x03\x83\x16\x90c\xAD\xFE\xF6\xAC\x90a\x0FC\x90\x8A\x90\x89\x90`\x04\x01a.\x1AV[_`@Q\x80\x83\x03\x81_\x87\x80;\x15\x80\x15a\x0FZW_\x80\xFD[PZ\xF1\x15\x80\x15a\x0FlW=_\x80>=_\xFD[PPPP\x87Q_\x14a\x11lW_\x88Qg\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x11\x15a\x0F\x93Wa\x0F\x93a*\x19V[`@Q\x90\x80\x82R\x80` \x02` \x01\x82\x01`@R\x80\x15a\x0F\xBCW\x81` \x01` \x82\x02\x806\x837\x01\x90P[P\x90P_[\x89Q\x81\x10\x15a\x10\xF5W\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0`\x01`\x01`\xA0\x1B\x03\x16c\xFA\xCDt;\x8B\x83\x81Q\x81\x10a\x10\x0BWa\x10\x0Ba01V[` \x02` \x01\x01Q`@Q\x82c\xFF\xFF\xFF\xFF\x16`\xE0\x1B\x81R`\x04\x01a\x10>\x91\x90`\x01`\x01`\xA0\x1B\x03\x91\x90\x91\x16\x81R` \x01\x90V[` `@Q\x80\x83\x03\x81\x86Z\xFA\x15\x80\x15a\x10YW=_\x80>=_\xFD[PPPP`@Q=`\x1F\x19`\x1F\x82\x01\x16\x82\x01\x80`@RP\x81\x01\x90a\x10}\x91\x90a0YV[a\x10\xC9W`@QbF\x1B\xCD`\xE5\x1B\x81R` `\x04\x82\x01R`\x18`$\x82\x01R\x7FUNEXPECTED_NEW_VALIDATOR\0\0\0\0\0\0\0\0`D\x82\x01R`d\x01a\n\x8DV[`\x01\x82\x82\x81Q\x81\x10a\x10\xDDWa\x10\xDDa01V[\x91\x15\x15` \x92\x83\x02\x91\x90\x91\x01\x90\x91\x01R`\x01\x01a\x0F\xC1V[P`@Q\x7F\xA3\xFF\xB7r\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x01`\x01`\xA0\x1B\x03\x84\x16\x90c\xA3\xFF\xB7r\x90a\x11=\x90\x8C\x90\x85\x90`\x04\x01a0\xAAV[_`@Q\x80\x83\x03\x81_\x87\x80;\x15\x80\x15a\x11TW_\x80\xFD[PZ\xF1\x15\x80\x15a\x11fW=_\x80>=_\xFD[PPPPP[\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x15a\x12\"W`@Q\x7F\xA2\xB4\xF1\xD8\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x15\x15`\x04\x82\x01R`\x01`\x01`\xA0\x1B\x03\x83\x16\x90c\xA2\xB4\xF1\xD8\x90`$\x01_`@Q\x80\x83\x03\x81_\x87\x80;\x15\x80\x15a\x12\x0BW_\x80\xFD[PZ\xF1\x15\x80\x15a\x12\x1DW=_\x80>=_\xFD[PPPP[\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0`\x01`\x01`\xA0\x1B\x03\x16cU\x84\nX`@Q\x81c\xFF\xFF\xFF\xFF\x16`\xE0\x1B\x81R`\x04\x01` `@Q\x80\x83\x03\x81\x86Z\xFA\x92PPP\x80\x15a\x12\x9CWP`@\x80Q`\x1F=\x90\x81\x01`\x1F\x19\x16\x82\x01\x90\x92Ra\x12\x99\x91\x81\x01\x90a+hV[`\x01[\x15a\x13\"W`\x01`\x01`\xA0\x1B\x03\x81\x16\x15a\x13 W`@Q\x7F\rV\x1B7\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x01`\x01`\xA0\x1B\x03\x82\x81\x16`\x04\x83\x01R\x84\x16\x90c\rV\x1B7\x90`$\x01_`@Q\x80\x83\x03\x81_\x87\x80;\x15\x80\x15a\x13\tW_\x80\xFD[PZ\xF1\x15\x80\x15a\x13\x1BW=_\x80>=_\xFD[PPPP[P[`@Q\x7F\x13\xAF@5\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x01`\x01`\xA0\x1B\x03\x82\x81\x16`\x04\x83\x01R\x83\x16\x90c\x13\xAF@5\x90`$\x01_`@Q\x80\x83\x03\x81_\x87\x80;\x15\x80\x15a\x13{W_\x80\xFD[PZ\xF1\x15\x80\x15a\x13\x8DW=_\x80>=_\xFD[PP`@\x80Q`\x01`\x01`\xA0\x1B\x03\x80\x88\x16\x82R\x8A\x16` \x82\x01R\x7F~\\\xC5\xC3\xFC\xE0F\xD8h\xD5\x91\x85H\xDF\x8D>\x8E\xF9\xF0\x9Eo\xB3\nh\x08\x1F\x1F\x13H\xCD\x03\x14\x93P\x01\x90P`@Q\x80\x91\x03\x90\xA1PPPPPPPPV[`@\x80Q\x7F\xFF\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0` \x80\x83\x01\x91\x90\x91R``\x84\x90\x1B\x7F\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\0\0\0\0\0\0\0\0\0\0\0\0\x16`!\x83\x01R`5\x82\x01\x86\x90R`U\x80\x83\x01\x86\x90R\x83Q\x80\x84\x03\x90\x91\x01\x81R`u\x90\x92\x01\x90\x92R\x80Q\x91\x01 [\x93\x92PPPV[\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0`\x01`\x01`\xA0\x1B\x03\x16c\x84V\xCBY`@Q\x81c\xFF\xFF\xFF\xFF\x16`\xE0\x1B\x81R`\x04\x01_`@Q\x80\x83\x03\x81_\x87\x80;\x15\x80\x15a\x14\xBFW_\x80\xFD[PZ\xF1\x15\x80\x15a\x14\xD1W=_\x80>=_\xFD[PPPP_\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0`\x01`\x01`\xA0\x1B\x03\x16c\xDF\xF6\x97\x87`@Q\x81c\xFF\xFF\xFF\xFF\x16`\xE0\x1B\x81R`\x04\x01` `@Q\x80\x83\x03\x81\x86Z\xFA\x15\x80\x15a\x152W=_\x80>=_\xFD[PPPP`@Q=`\x1F\x19`\x1F\x82\x01\x16\x82\x01\x80`@RP\x81\x01\x90a\x15V\x91\x90a1\x18V[\x90P`2\x81g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x11\x15a\x15oWP`2[_[\x81g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x81g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x10\x15a\x18\x02W`@Q\x7Fm\xDD7D\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81Rg\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x82\x16`\x04\x82\x01R_\x90\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0`\x01`\x01`\xA0\x1B\x03\x16\x90cm\xDD7D\x90`$\x01` `@Q\x80\x83\x03\x81\x86Z\xFA\x15\x80\x15a\x16\x14W=_\x80>=_\xFD[PPPP`@Q=`\x1F\x19`\x1F\x82\x01\x16\x82\x01\x80`@RP\x81\x01\x90a\x168\x91\x90a+hV[`@Q\x7F\xA2<D\xB1\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x01`\x01`\xA0\x1B\x03\x80\x83\x16`\x04\x83\x01R\x91\x92P_\x91\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x16\x90c\xA2<D\xB1\x90`$\x01`\xA0`@Q\x80\x83\x03\x81\x86Z\xFA\x15\x80\x15a\x16\xBAW=_\x80>=_\xFD[PPPP`@Q=`\x1F\x19`\x1F\x82\x01\x16\x82\x01\x80`@RP\x81\x01\x90a\x16\xDE\x91\x90a11V[\x90P\x80`\x80\x01Q\x80\x15a\x16\xFDWP``\x81\x01Qg\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x15[\x15a\x17\xEDW`@\x80Q`\x01\x80\x82R\x81\x83\x01\x90\x92R_\x91` \x80\x83\x01\x90\x806\x837\x01\x90PP\x90P\x82\x81_\x81Q\x81\x10a\x176Wa\x176a01V[`\x01`\x01`\xA0\x1B\x03\x92\x83\x16` \x91\x82\x02\x92\x90\x92\x01\x01R`@Q\x7F|u\xC2\x98\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x90\x91\x16\x90c|u\xC2\x98\x90a\x17\xAB\x90\x84\x90`\x04\x01a1\xB6V[_`@Q\x80\x83\x03\x81_\x87\x80;\x15\x80\x15a\x17\xC2W_\x80\xFD[PZ\xF1\x15\x80\x15a\x17\xD4W=_\x80>=_\xFD[PPPP`\x01\x85a\x17\xE5\x91\x90a1\xDCV[\x94PPa\x17\xFBV[\x82a\x17\xF7\x81a2\x04V[\x93PP[PPa\x15qV[PPV[a\x18\x0Ea(\x0FV[_\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0`\x01`\x01`\xA0\x1B\x03\x16c\x92\xC8\x13L\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0`\x01`\x01`\xA0\x1B\x03\x16ce\xF7\xF8\r`@Q\x81c\xFF\xFF\xFF\xFF\x16`\xE0\x1B\x81R`\x04\x01` `@Q\x80\x83\x03\x81\x86Z\xFA\x15\x80\x15a\x18\x9AW=_\x80>=_\xFD[PPPP`@Q=`\x1F\x19`\x1F\x82\x01\x16\x82\x01\x80`@RP\x81\x01\x90a\x18\xBE\x91\x90a1\x18V[`@Q\x7F\xFF\xFF\xFF\xFF\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0`\xE0\x84\x90\x1B\x16\x81Rg\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x90\x91\x16`\x04\x82\x01R`$\x01a\x01\x80`@Q\x80\x83\x03\x81\x86Z\xFA\x15\x80\x15a\x19\x1AW=_\x80>=_\xFD[PPPP`@Q=`\x1F\x19`\x1F\x82\x01\x16\x82\x01\x80`@RP\x81\x01\x90a\x19>\x91\x90a2*V[Q`@Q\x7F\x8E\xAAj\xC0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x81\x01\x82\x90R\x90\x91P_\x90\x81\x90\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0`\x01`\x01`\xA0\x1B\x03\x16\x90c\x8E\xAAj\xC0\x90`$\x01`\xC0`@Q\x80\x83\x03\x81\x86Z\xFA\x15\x80\x15a\x19\xC2W=_\x80>=_\xFD[PPPP`@Q=`\x1F\x19`\x1F\x82\x01\x16\x82\x01\x80`@RP\x81\x01\x90a\x19\xE6\x91\x90a3\\V[\x91P\x91Pa\x19\xF2a)\x1DV[\x82Q\x81R` \x80\x84\x01Q\x90\x82\x01\x90`\x02\x81\x11\x15a\x1A\x11Wa\x1A\x11a,\xF8V[\x90\x81`\x02\x81\x11\x15a\x1A$Wa\x1A$a,\xF8V[\x90RP\x83`\x01`\x01`\xA0\x1B\x03\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x16c1dA0a\x1A`\x84a#1V[\x85`@Q\x83c\xFF\xFF\xFF\xFF\x16`\xE0\x1B\x81R`\x04\x01a\x1A~\x92\x91\x90a4\x16V[` `@Q\x80\x83\x03\x81\x86Z\xFA\x15\x80\x15a\x1A\x99W=_\x80>=_\xFD[PPPP`@Q=`\x1F\x19`\x1F\x82\x01\x16\x82\x01\x80`@RP\x81\x01\x90a\x1A\xBD\x91\x90a4HV[\x14a\x1B\nW`@QbF\x1B\xCD`\xE5\x1B\x81R` `\x04\x82\x01R`\x1D`$\x82\x01R\x7FInvalid latest execution hash\0\0\0`D\x82\x01R`d\x01a\n\x8DV[a\x1B1`@Q\x80`\x80\x01`@R\x80_\x81R` \x01_\x81R` \x01_\x81R` \x01_\x81RP\x90V[`@\x80Q``\x81\x01\x82R_\x80\x82R` \x82\x01\x81\x90R\x91\x81\x01\x91\x90\x91R`@Q\x80a\x02\xA0\x01`@R\x80\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x81R` \x01\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0`\x01`\x01`\xA0\x1B\x03\x16\x81R` \x01\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R` \x01\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0`\x01`\x01`\xA0\x1B\x03\x16c\x8E\xE1\xA1&`@Q\x81c\xFF\xFF\xFF\xFF\x16`\xE0\x1B\x81R`\x04\x01` `@Q\x80\x83\x03\x81\x86Z\xFA\x15\x80\x15a\x1C:W=_\x80>=_\xFD[PPPP`@Q=`\x1F\x19`\x1F\x82\x01\x16\x82\x01\x80`@RP\x81\x01\x90a\x1C^\x91\x90a4HV[\x81R` \x010`\x01`\x01`\xA0\x1B\x03\x16\x81R` \x01\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0`\x01`\x01`\xA0\x1B\x03\x16\x81R` \x01\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R` \x01`@Q\x80` \x01`@R\x80_\x81RP\x81R` \x01\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R` \x01\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x81R` \x01\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0`\x01`\x01`\xA0\x1B\x03\x16c\xB0\xEC*\xE1`@Q\x81c\xFF\xFF\xFF\xFF\x16`\xE0\x1B\x81R`\x04\x01_`@Q\x80\x83\x03\x81\x86Z\xFA\x15\x80\x15a\x1D\x8CW=_\x80>=_\xFD[PPPP`@Q=_\x82>`\x1F=\x90\x81\x01`\x1F\x19\x16\x82\x01`@Ra\x1D\xB3\x91\x90\x81\x01\x90a4_V[\x81R` \x01\x83\x81R` \x01\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R` \x01\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R` \x01\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R` \x01\x84\x81R` \x01\x85\x81R` \x01_`\x01`\x01`\xA0\x1B\x03\x16\x81R` \x01\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0`\xFF\x16\x81R` \x01\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x81R` \x01\x82\x81RP\x96PPPPPPP\x90V[`@Qc&j#\xB1`\xE2\x1B\x81R`\x01`\x01`\xA0\x1B\x03\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81\x81\x16`\x04\x84\x01R\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x82\x16`$\x84\x01R\x91\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x90\x91\x16\x90c\x99\xA8\x8E\xC4\x90`D\x01_`@Q\x80\x83\x03\x81_\x87\x80;\x15\x80\x15a\x1F_W_\x80\xFD[PZ\xF1\x15\x80\x15a\x1FqW=_\x80>=_\xFD[PP`@Q\x7F\x91\x9C\xC7\x06\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x01`\x01`\xA0\x1B\x03\x85\x81\x16`\x04\x83\x01R\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x16\x92Pc\x91\x9C\xC7\x06\x91P`$\x01_`@Q\x80\x83\x03\x81_\x87\x80;\x15\x80\x15a\x1F\xEEW_\x80\xFD[PZ\xF1\x15\x80\x15a \0W=_\x80>=_\xFD[PPPPa \x0Ca#kV[`@Qc&j#\xB1`\xE2\x1B\x81R`\x01`\x01`\xA0\x1B\x03\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81\x81\x16`\x04\x84\x01R\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x82\x16`$\x84\x01R\x91\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x90\x91\x16\x90c\x99\xA8\x8E\xC4\x90`D\x01_`@Q\x80\x83\x03\x81_\x87\x80;\x15\x80\x15a \xB8W_\x80\xFD[PZ\xF1\x15\x80\x15a \xCAW=_\x80>=_\xFD[PP`@Qc&j#\xB1`\xE2\x1B\x81R`\x01`\x01`\xA0\x1B\x03\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81\x81\x16`\x04\x84\x01R\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x82\x16`$\x84\x01R\x93P\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x16\x91Pc\x99\xA8\x8E\xC4\x90`D\x01_`@Q\x80\x83\x03\x81_\x87\x80;\x15\x80\x15a!xW_\x80\xFD[PZ\xF1\x15\x80\x15a!\x8AW=_\x80>=_\xFD[PPPP\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0`\x01`\x01`\xA0\x1B\x03\x16cj\xE7\x1F\x12`@Q\x81c\xFF\xFF\xFF\xFF\x16`\xE0\x1B\x81R`\x04\x01_`@Q\x80\x83\x03\x81_\x87\x80;\x15\x80\x15a!\xE6W_\x80\xFD[PZ\xF1\x15\x80\x15a!\xF8W=_\x80>=_\xFD[PP`@Qc&j#\xB1`\xE2\x1B\x81R`\x01`\x01`\xA0\x1B\x03\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81\x81\x16`\x04\x84\x01R\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x82\x16`$\x84\x01R\x93P\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x16\x91Pc\x99\xA8\x8E\xC4\x90`D\x01_`@Q\x80\x83\x03\x81_\x87\x80;\x15\x80\x15a\"\xA6W_\x80\xFD[PZ\xF1\x15\x80\x15a\"\xB8W=_\x80>=_\xFD[PPPP\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0`\x01`\x01`\xA0\x1B\x03\x16cj\xE7\x1F\x12`@Q\x81c\xFF\xFF\xFF\xFF\x16`\xE0\x1B\x81R`\x04\x01_`@Q\x80\x83\x03\x81_\x87\x80;\x15\x80\x15a#\x14W_\x80\xFD[PZ\xF1\x15\x80\x15a#&W=_\x80>=_\xFD[PPPPPPPPPV[a#9a)BV[`@Q\x80`@\x01`@R\x80\x83_\x01Q\x81R` \x01\x83` \x01Q`\x02\x81\x11\x15a#cWa#ca,\xF8V[\x90R\x92\x91PPV[\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x15a%oW\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0`\x01`\x01`\xA0\x1B\x03\x16c\x96#`\x9D\x82\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0`@Q\x80``\x01`@R\x80\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x81R` \x01\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x81R` \x01\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x81RP`@Q`$\x01a$\xAC\x91\x90a4\xE0V[`@\x80Q`\x1F\x19\x81\x84\x03\x01\x81R\x91\x81R` \x82\x01\x80Q{\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x7F\xA6U\xD97\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x17\x90RQ\x7F\xFF\xFF\xFF\xFF\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0`\xE0\x86\x90\x1B\x16\x81Ra%=\x93\x92\x91\x90`\x04\x01a5\x11V[_`@Q\x80\x83\x03\x81_\x87\x80;\x15\x80\x15a%TW_\x80\xFD[PZ\xF1\x15\x80\x15a%fW=_\x80>=_\xFD[PPPPa&\x0EV[`@Qc&j#\xB1`\xE2\x1B\x81R`\x01`\x01`\xA0\x1B\x03\x82\x81\x16`\x04\x83\x01R\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81\x16`$\x83\x01R\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x16\x90c\x99\xA8\x8E\xC4\x90`D\x01_`@Q\x80\x83\x03\x81_\x87\x80;\x15\x80\x15a%\xF7W_\x80\xFD[PZ\xF1\x15\x80\x15a&\tW=_\x80>=_\xFD[PPPP[_\x80_\x80\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0`\x01`\x01`\xA0\x1B\x03\x16c\xEB\xEAF\x1D`@Q\x81c\xFF\xFF\xFF\xFF\x16`\xE0\x1B\x81R`\x04\x01`\x80`@Q\x80\x83\x03\x81\x86Z\xFA\x15\x80\x15a&nW=_\x80>=_\xFD[PPPP`@Q=`\x1F\x19`\x1F\x82\x01\x16\x82\x01\x80`@RP\x81\x01\x90a&\x92\x91\x90a5EV[\x93P\x93P\x93P\x93P_`\x0C\x83a&\xA8\x91\x90a5\x8CV[\x15a&\xC8Wa&\xB8`\x0C\x84a5\x9FV[a&\xC3\x90`\x01a5\xB2V[a&\xD3V[a&\xD3`\x0C\x84a5\x9FV[\x90P\x84\x81\x11a&\xE2W\x84a&\xE4V[\x80[\x94P\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0`\x01`\x01`\xA0\x1B\x03\x16c\xB3\x17a\xF8`@Q\x80`\x80\x01`@R\x80\x88\x81R` \x01\x87\x81R` \x01\x86\x81R` \x01\x85\x81RP`@Q\x82c\xFF\xFF\xFF\xFF\x16`\xE0\x1B\x81R`\x04\x01a'R\x91\x90a5\xC5V[_`@Q\x80\x83\x03\x81_\x87\x80;\x15\x80\x15a'iW_\x80\xFD[PZ\xF1\x15\x80\x15a'{W=_\x80>=_\xFD[PPPP\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0`\x01`\x01`\xA0\x1B\x03\x16cj\xE7\x1F\x12`@Q\x81c\xFF\xFF\xFF\xFF\x16`\xE0\x1B\x81R`\x04\x01_`@Q\x80\x83\x03\x81_\x87\x80;\x15\x80\x15a'\xD7W_\x80\xFD[PZ\xF1\x15\x80\x15a'\xE9W=_\x80>=_\xFD[PPPPPPPPPPV[a\x13\xE4\x80a5\xF1\x839\x01\x90V[a\r\x89\x80aI\xD5\x839\x01\x90V[`@Q\x80a\x02\xA0\x01`@R\x80_g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x81R` \x01_`\x01`\x01`\xA0\x1B\x03\x16\x81R` \x01_\x81R` \x01_\x80\x19\x16\x81R` \x01_`\x01`\x01`\xA0\x1B\x03\x16\x81R` \x01_`\x01`\x01`\xA0\x1B\x03\x16\x81R` \x01_\x81R` \x01``\x81R` \x01_\x81R` \x01_g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x81R` \x01``\x81R` \x01a(\xB8`@Q\x80`\x80\x01`@R\x80_\x81R` \x01_\x81R` \x01_\x81R` \x01_\x81RP\x90V[\x81R` \x01_\x81R` \x01_\x81R` \x01_\x81R` \x01a(\xD7a)\x1DV[\x81R_` \x80\x83\x01\x82\x90R`@\x80\x84\x01\x83\x90R``\x80\x85\x01\x84\x90R`\x80\x85\x01\x84\x90R\x81Q\x90\x81\x01\x82R\x83\x81R\x91\x82\x01\x83\x90R\x81\x01\x91\x90\x91R`\xA0\x90\x91\x01R\x90V[\x90R\x90V[`@Q\x80``\x01`@R\x80a)0a)`V[\x81R` \x01_\x81R_` \x90\x91\x01R\x90V[`@Q\x80`@\x01`@R\x80a)Ua)`V[\x81R` \x01_\x90R\x90V[`@Q\x80`@\x01`@R\x80a)sa)|V[\x81R` \x01a)\x18[`@Q\x80`@\x01`@R\x80`\x02\x90` \x82\x02\x806\x837P\x91\x92\x91PPV[`\x01`\x01`\xA0\x1B\x03\x81\x16\x81\x14a)\xAEW_\x80\xFD[PV[_\x80`@\x83\x85\x03\x12\x15a)\xC2W_\x80\xFD[\x825a)\xCD\x81a)\x9AV[\x94` \x93\x90\x93\x015\x93PPPV[_\x80_``\x84\x86\x03\x12\x15a)\xEDW_\x80\xFD[\x835a)\xF8\x81a)\x9AV[\x92P` \x84\x015a*\x08\x81a)\x9AV[\x92\x95\x92\x94PPP`@\x91\x90\x91\x015\x90V[cNH{q`\xE0\x1B_R`A`\x04R`$_\xFD[`@Qa\x01\x80\x81\x01g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x11\x82\x82\x10\x17\x15a*QWa*Qa*\x19V[`@R\x90V[`@\x80Q\x90\x81\x01g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x11\x82\x82\x10\x17\x15a*QWa*Qa*\x19V[`@Q`\x1F\x82\x01`\x1F\x19\x16\x81\x01g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x11\x82\x82\x10\x17\x15a*\xA3Wa*\xA3a*\x19V[`@R\x91\x90PV[_g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x82\x11\x15a*\xC4Wa*\xC4a*\x19V[P`\x05\x1B` \x01\x90V[_` \x80\x83\x85\x03\x12\x15a*\xDFW_\x80\xFD[\x825g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x11\x15a*\xF5W_\x80\xFD[\x83\x01`\x1F\x81\x01\x85\x13a+\x05W_\x80\xFD[\x805a+\x18a+\x13\x82a*\xABV[a*zV[\x81\x81R`\x05\x91\x90\x91\x1B\x82\x01\x83\x01\x90\x83\x81\x01\x90\x87\x83\x11\x15a+6W_\x80\xFD[\x92\x84\x01\x92[\x82\x84\x10\x15a+]W\x835a+N\x81a)\x9AV[\x82R\x92\x84\x01\x92\x90\x84\x01\x90a+;V[\x97\x96PPPPPPPV[_` \x82\x84\x03\x12\x15a+xW_\x80\xFD[\x81Qa\x14`\x81a)\x9AV[_a\x01@\x80\x83\x01`\x01`\x01`\xA0\x1B\x03\x80\x8F\x16\x85R` g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x8F\x16` \x87\x01R\x81\x8E\x16`@\x87\x01R\x8C``\x87\x01R\x8B`\x80\x87\x01R\x8A`\xA0\x87\x01R\x81\x8A\x16`\xC0\x87\x01R\x81\x89\x16`\xE0\x87\x01R`\xFF\x88\x16a\x01\0\x87\x01R\x83a\x01 \x87\x01R\x82\x93P\x86Q\x91P\x81\x83Ra\x01`\x86\x01\x93P` \x87\x01\x92P_[\x82\x81\x10\x15a,\x19W\x83Q\x85R\x93\x81\x01\x93\x92\x81\x01\x92`\x01\x01a+\xFDV[P\x92\x9F\x9EPPPPPPPPPPPPPPPV[_\x81Q\x80\x84R\x80` \x84\x01` \x86\x01^_` \x82\x86\x01\x01R` `\x1F\x19`\x1F\x83\x01\x16\x85\x01\x01\x91PP\x92\x91PPV[_\x81Q\x80\x84R` \x80\x85\x01\x94P` \x84\x01_[\x83\x81\x10\x15a,\x8BW\x81Q\x87R\x95\x82\x01\x95\x90\x82\x01\x90`\x01\x01a,oV[P\x94\x95\x94PPPPPV[\x80Q\x82_[`\x02\x81\x10\x15a,\xBAW\x82Q\x82R` \x92\x83\x01\x92\x90\x91\x01\x90`\x01\x01a,\x9BV[PPP` \x80\x82\x01Q`@\x84\x01_[`\x02\x81\x10\x15a,\xF0W\x82Qg\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x82R\x91\x83\x01\x91\x90\x83\x01\x90`\x01\x01a,\xC9V[PPPPPPV[cNH{q`\xE0\x1B_R`!`\x04R`$_\xFD[`\x03\x81\x10a-(WcNH{q`\xE0\x1B_R`!`\x04R`$_\xFD[\x90RV[a-7\x82\x82Qa,\x96V[` \x81\x01Qa-I`\x80\x84\x01\x82a-\x0CV[P`@\x01Q`\xA0\x91\x90\x91\x01RV[`\x01`\x01`\xA0\x1B\x03\x80\x82Q\x16\x83R\x80` \x83\x01Q\x16` \x84\x01R\x80`@\x83\x01Q\x16`@\x84\x01RP``\x81\x01Qa-\x98``\x84\x01\x82`\x01`\x01`\xA0\x1B\x03\x16\x90RV[P`\x80\x81\x01Qa-\xB3`\x80\x84\x01\x82`\x01`\x01`\xA0\x1B\x03\x16\x90RV[P`\xA0\x81\x01Qa-\xCE`\xA0\x84\x01\x82`\x01`\x01`\xA0\x1B\x03\x16\x90RV[P`\xC0\x81\x01Qa-\xE9`\xC0\x84\x01\x82`\x01`\x01`\xA0\x1B\x03\x16\x90RV[P`\xE0\x81\x01Qa.\x04`\xE0\x84\x01\x82`\x01`\x01`\xA0\x1B\x03\x16\x90RV[Pa\x01\0\x90\x81\x01Q`\x01`\x01`\xA0\x1B\x03\x16\x91\x01RV[_a\x01@\x80\x83Ra.7\x81\x84\x01\x86Qg\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x90RV[` \x85\x01Q`\x01`\x01`\xA0\x1B\x03\x81\x16a\x01`\x85\x01RP`@\x85\x01Qa\x01\x80\x81\x81\x86\x01R``\x87\x01Q\x91Pa\x01\xA0\x82\x81\x87\x01R`\x80\x88\x01Q\x92Pa\x01\xC0a.\x87\x81\x88\x01\x85`\x01`\x01`\xA0\x1B\x03\x16\x90RV[`\xA0\x89\x01Q\x93Pa\x01\xE0a.\xA5\x81\x89\x01\x86`\x01`\x01`\xA0\x1B\x03\x16\x90RV[`\xC0\x8A\x01Q\x94Pa\x02\0\x85\x81\x8A\x01R`\xE0\x8B\x01Q\x95Pa\x02 a\x03\xE0\x81\x8B\x01Ra.\xD3a\x05 \x8B\x01\x88a,.V[\x96Pa\x01\0\x8C\x01Qa\x02@\x81\x81\x8D\x01Ra\x01 \x8E\x01Q\x91Pa\x02`a/\x03\x81\x8E\x01\x84g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x90RV[\x8A\x8F\x01Q\x9APa\x02\x80\x92P\x7F\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFE\xC0\x8D\x8B\x03\x01\x83\x8E\x01Ra/A\x8A\x8Ca,\\V[\x9APa\x01`\x8F\x01Q\x99Pa/za\x02\xA0\x8E\x01\x8B\x80Q\x82R` \x81\x01Q` \x83\x01R`@\x81\x01Q`@\x83\x01R``\x81\x01Q``\x83\x01RPPV[\x88\x8F\x01Qa\x03 \x8E\x01R\x87\x8F\x01Qa\x03@\x8E\x01R\x86\x8F\x01Qa\x03`\x8E\x01R\x85\x8F\x01Q\x99Pa/\xACa\x03\x80\x8E\x01\x8Ba-,V[\x93\x8E\x01Qa\x04@\x8D\x01R\x91\x8D\x01Q`\x01`\x01`\xA0\x1B\x03\x16a\x04`\x8C\x01R\x90\x8C\x01Q`\xFF\x16a\x04\x80\x8B\x01R\x90\x8B\x01Qg\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x90\x81\x16a\x04\xA0\x8B\x01R\x90\x8B\x01Q\x80Q\x82\x16a\x04\xC0\x8B\x01R` \x81\x01Q\x82\x16a\x04\xE0\x8B\x01R`@\x81\x01Q\x90\x91\x16a\x05\0\x8A\x01R\x94Pa0!\x93PPPPV[P\x90Pa\x14`` \x83\x01\x84a-WV[cNH{q`\xE0\x1B_R`2`\x04R`$_\xFD[\x80Q\x80\x15\x15\x81\x14a0TW_\x80\xFD[\x91\x90PV[_` \x82\x84\x03\x12\x15a0iW_\x80\xFD[a\x14`\x82a0EV[_\x81Q\x80\x84R` \x80\x85\x01\x94P` \x84\x01_[\x83\x81\x10\x15a,\x8BW\x81Q`\x01`\x01`\xA0\x1B\x03\x16\x87R\x95\x82\x01\x95\x90\x82\x01\x90`\x01\x01a0\x85V[`@\x81R_a0\xBC`@\x83\x01\x85a0rV[\x82\x81\x03` \x84\x81\x01\x91\x90\x91R\x84Q\x80\x83R\x85\x82\x01\x92\x82\x01\x90_[\x81\x81\x10\x15a0\xF4W\x84Q\x15\x15\x83R\x93\x83\x01\x93\x91\x83\x01\x91`\x01\x01a0\xD6V[P\x90\x97\x96PPPPPPPV[\x80Qg\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x16\x81\x14a0TW_\x80\xFD[_` \x82\x84\x03\x12\x15a1(W_\x80\xFD[a\x14`\x82a1\x01V[_`\xA0\x82\x84\x03\x12\x15a1AW_\x80\xFD[`@Q`\xA0\x81\x01\x81\x81\x10g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x82\x11\x17\x15a1dWa1da*\x19V[`@R\x82Q\x81Ra1w` \x84\x01a1\x01V[` \x82\x01Ra1\x88`@\x84\x01a1\x01V[`@\x82\x01Ra1\x99``\x84\x01a1\x01V[``\x82\x01Ra1\xAA`\x80\x84\x01a0EV[`\x80\x82\x01R\x93\x92PPPV[` \x81R_a\x14`` \x83\x01\x84a0rV[cNH{q`\xE0\x1B_R`\x11`\x04R`$_\xFD[g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x82\x81\x16\x82\x82\x16\x03\x90\x80\x82\x11\x15a1\xFDWa1\xFDa1\xC8V[P\x92\x91PPV[_g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x80\x83\x16\x81\x81\x03a2 Wa2 a1\xC8V[`\x01\x01\x93\x92PPPV[_a\x01\x80\x82\x84\x03\x12\x15a2;W_\x80\xFD[a2Ca*-V[\x82Q\x81R` \x83\x01Q` \x82\x01R`@\x83\x01Q`@\x82\x01Ra2g``\x84\x01a1\x01V[``\x82\x01Ra2x`\x80\x84\x01a1\x01V[`\x80\x82\x01Ra2\x89`\xA0\x84\x01a1\x01V[`\xA0\x82\x01Ra2\x9A`\xC0\x84\x01a1\x01V[`\xC0\x82\x01Ra2\xAB`\xE0\x84\x01a1\x01V[`\xE0\x82\x01Ra\x01\0a2\xBE\x81\x85\x01a1\x01V[\x90\x82\x01Ra\x01 a2\xD0\x84\x82\x01a1\x01V[\x90\x82\x01Ra\x01@a2\xE2\x84\x82\x01a1\x01V[\x90\x82\x01Ra\x01`\x92\x83\x01Q\x92\x81\x01\x92\x90\x92RP\x91\x90PV[_\x82`\x1F\x83\x01\x12a3\tW_\x80\xFD[a3\x11a*WV[\x80`@\x84\x01\x85\x81\x11\x15a3\"W_\x80\xFD[\x84[\x81\x81\x10\x15a3CWa35\x81a1\x01V[\x84R` \x93\x84\x01\x93\x01a3$V[P\x90\x95\x94PPPPPV[\x80Q`\x03\x81\x10a0TW_\x80\xFD[_\x80\x82\x84\x03`\xC0\x81\x12\x15a3nW_\x80\xFD[`\xA0\x81\x12\x15a3{W_\x80\xFD[a3\x83a*WV[`\x80\x82\x12\x15a3\x90W_\x80\xFD[a3\x98a*WV[\x91P\x85`\x1F\x86\x01\x12a3\xA8W_\x80\xFD[a3\xB0a*WV[\x80`@\x87\x01\x88\x81\x11\x15a3\xC1W_\x80\xFD[\x87[\x81\x81\x10\x15a3\xDBW\x80Q\x84R` \x93\x84\x01\x93\x01a3\xC3V[P\x81\x85Ra3\xE9\x89\x82a2\xFAV[` \x86\x01RPPP\x81\x81Ra4\0`\x80\x86\x01a3NV[` \x82\x01R`\xA0\x94\x90\x94\x01Q\x93\x95\x93\x94PPPPV[_`\xC0\x82\x01\x90Pa4(\x82\x85Qa,\x96V[` \x84\x01Qa4:`\x80\x84\x01\x82a-\x0CV[P\x82`\xA0\x83\x01R\x93\x92PPPV[_` \x82\x84\x03\x12\x15a4XW_\x80\xFD[PQ\x91\x90PV[_` \x80\x83\x85\x03\x12\x15a4pW_\x80\xFD[\x82Qg\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x11\x15a4\x86W_\x80\xFD[\x83\x01`\x1F\x81\x01\x85\x13a4\x96W_\x80\xFD[\x80Qa4\xA4a+\x13\x82a*\xABV[\x81\x81R`\x05\x91\x90\x91\x1B\x82\x01\x83\x01\x90\x83\x81\x01\x90\x87\x83\x11\x15a4\xC2W_\x80\xFD[\x92\x84\x01\x92[\x82\x84\x10\x15a+]W\x83Q\x82R\x92\x84\x01\x92\x90\x84\x01\x90a4\xC7V[``\x81\x01a\n\x0C\x82\x84\x80Qg\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x90\x81\x16\x83R` \x80\x83\x01Q\x82\x16\x90\x84\x01R`@\x91\x82\x01Q\x16\x91\x01RV[_`\x01`\x01`\xA0\x1B\x03\x80\x86\x16\x83R\x80\x85\x16` \x84\x01RP```@\x83\x01Ra5<``\x83\x01\x84a,.V[\x95\x94PPPPPV[_\x80_\x80`\x80\x85\x87\x03\x12\x15a5XW_\x80\xFD[PP\x82Q` \x84\x01Q`@\x85\x01Q``\x90\x95\x01Q\x91\x96\x90\x95P\x90\x92P\x90PV[cNH{q`\xE0\x1B_R`\x12`\x04R`$_\xFD[_\x82a5\x9AWa5\x9Aa5xV[P\x06\x90V[_\x82a5\xADWa5\xADa5xV[P\x04\x90V[\x80\x82\x01\x80\x82\x11\x15a\n\x0CWa\n\x0Ca1\xC8V[\x81Q\x81R` \x80\x83\x01Q\x90\x82\x01R`@\x80\x83\x01Q\x90\x82\x01R``\x80\x83\x01Q\x90\x82\x01R`\x80\x81\x01a\n\x0CV\xFE`\x80`@R4\x80\x15`\x0EW_\x80\xFD[Pa\x13\xC8\x80a\0\x1C_9_\xF3\xFE`\x80`@R`\x046\x10a\0!W_5`\xE0\x1C\x80c\xAD\xFE\xF6\xAC\x14a\08Wa\x000V[6a\x000Wa\0.a\0WV[\0[a\0.a\0WV[4\x80\x15a\0CW_\x80\xFD[Pa\0.a\0R6`\x04a\raV[a\0iV[a\0ga\0ba\x01\xB8V[a\x02\x9AV[V[_a\0ra\x02\xBDV[`\x01`\x01`\xA0\x1B\x03\x16\x14\x80\x15a\0\x97WP_a\0\x8Ca\x02\xEFV[`\x01`\x01`\xA0\x1B\x03\x16\x14[\x80\x15a\0\xB2WP_a\0\xA7a\x03\x16V[`\x01`\x01`\xA0\x1B\x03\x16\x14[\x15a\x01\xB0Wa\x01\xAC\x81`\xC0\x01Q\x83\x83`@Q`$\x01a\0\xD2\x92\x91\x90a\x10\xF9V[`@\x80Q`\x1F\x19\x81\x84\x03\x01\x81R\x91\x81R` \x80\x83\x01\x80Q{\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x7F\x0E\xE5\xEF\x0C\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x17\x90R`\xE0\x86\x01Q\x90\x87\x01Q\x91Q`\x01`\x01`\xA0\x1B\x03\x90\x92\x16`$\x83\x01R\x90`D\x01`@\x80Q`\x1F\x19\x81\x84\x03\x01\x81R\x91\x90R` \x81\x01\x80Q{\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x7F\xC4\xD6m\xE8\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x17\x90R`\x80\x87\x01Qa\x03=V[PPV[a\x01\xACa\0WV[_`\x046\x10\x15a\x02\x0FW`@QbF\x1B\xCD`\xE5\x1B\x81R` `\x04\x82\x01R`\x0B`$\x82\x01R\x7FNO_FUNC_SIG\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0`D\x82\x01R`d\x01[`@Q\x80\x91\x03\x90\xFD[_3a\x02\x19a\x02\xBDV[`\x01`\x01`\xA0\x1B\x03\x16\x03a\x024Wa\x02/a\x02\xEFV[a\x02<V[a\x02<a\x03\x16V[\x90P`\x01`\x01`\xA0\x1B\x03\x81\x16;a\x02\x95W`@QbF\x1B\xCD`\xE5\x1B\x81R` `\x04\x82\x01R`\x13`$\x82\x01R\x7FTARGET_NOT_CONTRACT\0\0\0\0\0\0\0\0\0\0\0\0\0`D\x82\x01R`d\x01a\x02\x06V[\x91\x90PV[6_\x807_\x806_\x84Z\xF4=_\x80>\x80\x80\x15a\x02\xB4W=_\xF3[=_\xFD[PPPV[_\x7F\xB51'hJV\x8B1s\xAE\x13\xB9\xF8\xA6\x01n$>c\xB6\xE8\xEE\x11x\xD6\xA7\x17\x85\x0B]a\x03[T`\x01`\x01`\xA0\x1B\x03\x16\x91\x90PV[_\x7F6\x08\x94\xA1;\xA1\xA3!\x06g\xC8(I-\xB9\x8D\xCA> v\xCC75\xA9 \xA3\xCAP]8+\xBCa\x02\xE0V[_\x7F+\x1D\xBC\xE7C$$\x8C\"/\x0E\xC2\xD5\xED{\xD3#\xCF\xC4%\xB36\xF0%<\\\xCF\xDAreTma\x02\xE0V[a\x03h`\x01\x7F\xB51'hJV\x8B1s\xAE\x13\xB9\xF8\xA6\x01n$>c\xB6\xE8\xEE\x11x\xD6\xA7\x17\x85\x0B]a\x04a\x13\x10V[\x7F\xB51'hJV\x8B1s\xAE\x13\xB9\xF8\xA6\x01n$>c\xB6\xE8\xEE\x11x\xD6\xA7\x17\x85\x0B]a\x03\x14a\x03\x96Wa\x03\x96a\x13/V[a\x03\xC1`\x01\x7F6\x08\x94\xA1;\xA1\xA3!\x06g\xC8(I-\xB9\x8D\xCA> v\xCC75\xA9 \xA3\xCAP]8+\xBDa\x13\x10V[\x7F6\x08\x94\xA1;\xA1\xA3!\x06g\xC8(I-\xB9\x8D\xCA> v\xCC75\xA9 \xA3\xCAP]8+\xBC\x14a\x03\xEFWa\x03\xEFa\x13/V[a\x04\x1A`\x01\x7F+\x1D\xBC\xE7C$$\x8C\"/\x0E\xC2\xD5\xED{\xD3#\xCF\xC4%\xB36\xF0%<\\\xCF\xDAreTna\x13\x10V[\x7F+\x1D\xBC\xE7C$$\x8C\"/\x0E\xC2\xD5\xED{\xD3#\xCF\xC4%\xB36\xF0%<\\\xCF\xDAreTm\x14a\x04HWa\x04Ha\x13/V[a\x04Q\x81a\x04nV[a\x04\\\x85\x85_a\x04\xC5V[a\x04g\x83\x83_a\x04\xEFV[PPPPPV[\x7F~dMyB/\x17\xC0\x1EH\x94\xB5\xF4\xF5\x88\xD31\xEB\xFA(e=B\xAE\x83-\xC5\x9E8\xC9y\x8Fa\x04\x97a\x02\xBDV[`@\x80Q`\x01`\x01`\xA0\x1B\x03\x92\x83\x16\x81R\x91\x84\x16` \x83\x01R\x01`@Q\x80\x91\x03\x90\xA1a\x04\xC2\x81a\x04\xF8V[PV[a\x04\xCE\x83a\x05\xD0V[_\x82Q\x11\x80a\x04\xDAWP\x80[\x15a\x02\xB8Wa\x04\xE9\x83\x83a\x06\x0FV[PPPPV[a\x04\xCE\x83a\x06=V[`\x01`\x01`\xA0\x1B\x03\x81\x16a\x05tW`@QbF\x1B\xCD`\xE5\x1B\x81R` `\x04\x82\x01R`&`$\x82\x01R\x7FERC1967: new admin is the zero a`D\x82\x01R\x7Fddress\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0`d\x82\x01R`\x84\x01a\x02\x06V[\x80\x7F\xB51'hJV\x8B1s\xAE\x13\xB9\xF8\xA6\x01n$>c\xB6\xE8\xEE\x11x\xD6\xA7\x17\x85\x0B]a\x03[\x80T\x7F\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x16`\x01`\x01`\xA0\x1B\x03\x92\x90\x92\x16\x91\x90\x91\x17\x90UPV[a\x05\xD9\x81a\x06|V[`@Q`\x01`\x01`\xA0\x1B\x03\x82\x16\x90\x7F\xBC|\xD7Z \xEE'\xFD\x9A\xDE\xBA\xB3 A\xF7U!M\xBCk\xFF\xA9\x0C\xC0\"[9\xDA.\\-;\x90_\x90\xA2PV[``a\x064\x83\x83`@Q\x80``\x01`@R\x80`'\x81R` \x01a\x13l`'\x919a\x07 V[\x90P[\x92\x91PPV[a\x06F\x81a\x08\x12V[`@Q`\x01`\x01`\xA0\x1B\x03\x82\x16\x90\x7F\xF7\xEE\xD2\xA7\xFA\xBB\xF1\xBE\xC8\xD5^\xD5\xE7\x85\xCCvb#v\xDD\xE5\xDFO\xF1TpU\x1E\x03\x0B\x814\x90_\x90\xA2PV[`\x01`\x01`\xA0\x1B\x03\x81\x16;a\x06\xF9W`@QbF\x1B\xCD`\xE5\x1B\x81R` `\x04\x82\x01R`-`$\x82\x01R\x7FERC1967: new implementation is n`D\x82\x01R\x7Fot a contract\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0`d\x82\x01R`\x84\x01a\x02\x06V[\x80\x7F6\x08\x94\xA1;\xA1\xA3!\x06g\xC8(I-\xB9\x8D\xCA> v\xCC75\xA9 \xA3\xCAP]8+\xBCa\x05\x97V[```\x01`\x01`\xA0\x1B\x03\x84\x16;a\x07\x9FW`@QbF\x1B\xCD`\xE5\x1B\x81R` `\x04\x82\x01R`&`$\x82\x01R\x7FAddress: delegate call to non-co`D\x82\x01R\x7Fntract\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0`d\x82\x01R`\x84\x01a\x02\x06V[_\x80\x85`\x01`\x01`\xA0\x1B\x03\x16\x85`@Qa\x07\xB9\x91\x90a\x13CV[_`@Q\x80\x83\x03\x81\x85Z\xF4\x91PP=\x80_\x81\x14a\x07\xF1W`@Q\x91P`\x1F\x19`?=\x01\x16\x82\x01`@R=\x82R=_` \x84\x01>a\x07\xF6V[``\x91P[P\x91P\x91Pa\x08\x06\x82\x82\x86a\x08\xB6V[\x92PPP[\x93\x92PPPV[`\x01`\x01`\xA0\x1B\x03\x81\x16;a\x08\x8FW`@QbF\x1B\xCD`\xE5\x1B\x81R` `\x04\x82\x01R`7`$\x82\x01R\x7FERC1967: new secondary implement`D\x82\x01R\x7Fation is not a contract\0\0\0\0\0\0\0\0\0`d\x82\x01R`\x84\x01a\x02\x06V[\x80\x7F+\x1D\xBC\xE7C$$\x8C\"/\x0E\xC2\xD5\xED{\xD3#\xCF\xC4%\xB36\xF0%<\\\xCF\xDAreTma\x05\x97V[``\x83\x15a\x08\xC5WP\x81a\x08\x0BV[\x82Q\x15a\x08\xD5W\x82Q\x80\x84` \x01\xFD[\x81`@QbF\x1B\xCD`\xE5\x1B\x81R`\x04\x01a\x02\x06\x91\x90a\x13YV[cNH{q`\xE0\x1B_R`A`\x04R`$_\xFD[`@Q``\x81\x01g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x11\x82\x82\x10\x17\x15a\t&Wa\t&a\x08\xEFV[`@R\x90V[`@\x80Q\x90\x81\x01g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x11\x82\x82\x10\x17\x15a\t&Wa\t&a\x08\xEFV[`@Qa\x01 \x81\x01g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x11\x82\x82\x10\x17\x15a\t&Wa\t&a\x08\xEFV[`@Qa\x02\xA0\x81\x01g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x11\x82\x82\x10\x17\x15a\t&Wa\t&a\x08\xEFV[`@Q`\x1F\x82\x01`\x1F\x19\x16\x81\x01g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x11\x82\x82\x10\x17\x15a\t\xC0Wa\t\xC0a\x08\xEFV[`@R\x91\x90PV[\x805g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x16\x81\x14a\x02\x95W_\x80\xFD[\x805`\x01`\x01`\xA0\x1B\x03\x81\x16\x81\x14a\x02\x95W_\x80\xFD[_\x82`\x1F\x83\x01\x12a\n\x04W_\x80\xFD[\x815g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x11\x15a\n\x1EWa\n\x1Ea\x08\xEFV[a\n1` `\x1F\x19`\x1F\x84\x01\x16\x01a\t\x97V[\x81\x81R\x84` \x83\x86\x01\x01\x11\x15a\nEW_\x80\xFD[\x81` \x85\x01` \x83\x017_\x91\x81\x01` \x01\x91\x90\x91R\x93\x92PPPV[_\x82`\x1F\x83\x01\x12a\npW_\x80\xFD[\x815` g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x82\x11\x15a\n\x8CWa\n\x8Ca\x08\xEFV[\x81`\x05\x1Ba\n\x9B\x82\x82\x01a\t\x97V[\x92\x83R\x84\x81\x01\x82\x01\x92\x82\x81\x01\x90\x87\x85\x11\x15a\n\xB4W_\x80\xFD[\x83\x87\x01\x92P[\x84\x83\x10\x15a\n\xD3W\x825\x82R\x91\x83\x01\x91\x90\x83\x01\x90a\n\xBAV[\x97\x96PPPPPPPV[_`\x80\x82\x84\x03\x12\x15a\n\xEEW_\x80\xFD[`@Q`\x80\x81\x01\x81\x81\x10g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x82\x11\x17\x15a\x0B\x11Wa\x0B\x11a\x08\xEFV[\x80`@RP\x80\x91P\x825\x81R` \x83\x015` \x82\x01R`@\x83\x015`@\x82\x01R``\x83\x015``\x82\x01RP\x92\x91PPV[_\x82`\x1F\x83\x01\x12a\x0BQW_\x80\xFD[a\x0BYa\t,V[\x80`@\x84\x01\x85\x81\x11\x15a\x0BjW_\x80\xFD[\x84[\x81\x81\x10\x15a\x0B\x8BWa\x0B}\x81a\t\xC8V[\x84R` \x93\x84\x01\x93\x01a\x0BlV[P\x90\x95\x94PPPPPV[\x805`\x03\x81\x10a\x02\x95W_\x80\xFD[_\x81\x83\x03`\xC0\x81\x12\x15a\x0B\xB5W_\x80\xFD[a\x0B\xBDa\t\x03V[\x91P`\x80\x81\x12\x15a\x0B\xCCW_\x80\xFD[Pa\x0B\xD5a\t,V[\x83`\x1F\x84\x01\x12a\x0B\xE3W_\x80\xFD[a\x0B\xEBa\t,V[\x80`@\x85\x01\x86\x81\x11\x15a\x0B\xFCW_\x80\xFD[\x85[\x81\x81\x10\x15a\x0C\x16W\x805\x84R` \x93\x84\x01\x93\x01a\x0B\xFEV[P\x81\x84Ra\x0C$\x87\x82a\x0BBV[` \x85\x01RPPP\x81Ra\x0C:`\x80\x83\x01a\x0B\x96V[` \x82\x01R`\xA0\x82\x015`@\x82\x01R\x92\x91PPV[\x805`\xFF\x81\x16\x81\x14a\x02\x95W_\x80\xFD[_``\x82\x84\x03\x12\x15a\x0CoW_\x80\xFD[a\x0Cwa\t\x03V[\x90Pa\x0C\x82\x82a\t\xC8V[\x81Ra\x0C\x90` \x83\x01a\t\xC8V[` \x82\x01Ra\x0C\xA1`@\x83\x01a\t\xC8V[`@\x82\x01R\x92\x91PPV[_a\x01 \x82\x84\x03\x12\x15a\x0C\xBDW_\x80\xFD[a\x0C\xC5a\tOV[\x90Pa\x0C\xD0\x82a\t\xDFV[\x81Ra\x0C\xDE` \x83\x01a\t\xDFV[` \x82\x01Ra\x0C\xEF`@\x83\x01a\t\xDFV[`@\x82\x01Ra\r\0``\x83\x01a\t\xDFV[``\x82\x01Ra\r\x11`\x80\x83\x01a\t\xDFV[`\x80\x82\x01Ra\r\"`\xA0\x83\x01a\t\xDFV[`\xA0\x82\x01Ra\r3`\xC0\x83\x01a\t\xDFV[`\xC0\x82\x01Ra\rD`\xE0\x83\x01a\t\xDFV[`\xE0\x82\x01Ra\x01\0a\rW\x81\x84\x01a\t\xDFV[\x90\x82\x01R\x92\x91PPV[_\x80a\x01@\x80\x84\x86\x03\x12\x15a\rtW_\x80\xFD[\x835g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x80\x82\x11\x15a\r\x8BW_\x80\xFD[\x90\x85\x01\x90a\x03\xE0\x82\x88\x03\x12\x15a\r\x9FW_\x80\xFD[a\r\xA7a\tsV[a\r\xB0\x83a\t\xC8V[\x81Ra\r\xBE` \x84\x01a\t\xDFV[` \x82\x01R`@\x83\x015`@\x82\x01R``\x83\x015``\x82\x01Ra\r\xE3`\x80\x84\x01a\t\xDFV[`\x80\x82\x01Ra\r\xF4`\xA0\x84\x01a\t\xDFV[`\xA0\x82\x01R`\xC0\x83\x015`\xC0\x82\x01R`\xE0\x83\x015\x82\x81\x11\x15a\x0E\x14W_\x80\xFD[a\x0E \x89\x82\x86\x01a\t\xF5V[`\xE0\x83\x01RPa\x01\0\x83\x81\x015\x90\x82\x01Ra\x01 a\x0E?\x81\x85\x01a\t\xC8V[\x90\x82\x01R\x82\x84\x015\x82\x81\x11\x15a\x0ESW_\x80\xFD[a\x0E_\x89\x82\x86\x01a\naV[\x85\x83\x01RPa\x01`\x93Pa\x0Eu\x88\x85\x85\x01a\n\xDEV[\x84\x82\x01Ra\x01\xE0\x93P\x83\x83\x015a\x01\x80\x82\x01Ra\x02\0\x91P\x81\x83\x015a\x01\xA0\x82\x01Ra\x02 \x80\x84\x015a\x01\xC0\x83\x01Ra\x02@a\x0E\xB3\x8A\x82\x87\x01a\x0B\xA4V[\x86\x84\x01Ra\x03\0\x85\x015\x84\x84\x01Ra\x0E\xCEa\x03 \x86\x01a\t\xDFV[\x82\x84\x01Ra\x0E\xDFa\x03@\x86\x01a\x0COV[\x90\x83\x01RPa\x0E\xF1a\x03`\x84\x01a\t\xC8V[a\x02`\x82\x01Ra\x0F\x05\x88a\x03\x80\x85\x01a\x0C_V[a\x02\x80\x82\x01R\x80\x95PPPPPa\x0F\x1F\x84` \x85\x01a\x0C\xACV[\x90P\x92P\x92\x90PV[_\x81Q\x80\x84R\x80` \x84\x01` \x86\x01^_` \x82\x86\x01\x01R` `\x1F\x19`\x1F\x83\x01\x16\x85\x01\x01\x91PP\x92\x91PPV[_\x81Q\x80\x84R` \x80\x85\x01\x94P` \x84\x01_[\x83\x81\x10\x15a\x0F\x85W\x81Q\x87R\x95\x82\x01\x95\x90\x82\x01\x90`\x01\x01a\x0FiV[P\x94\x95\x94PPPPPV[`\x03\x81\x10a\x0F\xACWcNH{q`\xE0\x1B_R`!`\x04R`$_\xFD[\x90RV[\x80Q\x80Q\x83_[`\x02\x81\x10\x15a\x0F\xD6W\x82Q\x82R` \x92\x83\x01\x92\x90\x91\x01\x90`\x01\x01a\x0F\xB7V[PPP` \x90\x81\x01Q\x90`@\x84\x01_[`\x02\x81\x10\x15a\x10\rW\x83Qg\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x82R\x92\x82\x01\x92\x90\x82\x01\x90`\x01\x01a\x0F\xE6V[PPPP` \x81\x01Qa\x10#`\x80\x84\x01\x82a\x0F\x90V[P`@\x01Q`\xA0\x91\x90\x91\x01RV[`\x01`\x01`\xA0\x1B\x03\x80\x82Q\x16\x83R\x80` \x83\x01Q\x16` \x84\x01R\x80`@\x83\x01Q\x16`@\x84\x01RP``\x81\x01Qa\x10r``\x84\x01\x82`\x01`\x01`\xA0\x1B\x03\x16\x90RV[P`\x80\x81\x01Qa\x10\x8D`\x80\x84\x01\x82`\x01`\x01`\xA0\x1B\x03\x16\x90RV[P`\xA0\x81\x01Qa\x10\xA8`\xA0\x84\x01\x82`\x01`\x01`\xA0\x1B\x03\x16\x90RV[P`\xC0\x81\x01Qa\x10\xC3`\xC0\x84\x01\x82`\x01`\x01`\xA0\x1B\x03\x16\x90RV[P`\xE0\x81\x01Qa\x10\xDE`\xE0\x84\x01\x82`\x01`\x01`\xA0\x1B\x03\x16\x90RV[Pa\x01\0\x81\x81\x01Q`\x01`\x01`\xA0\x1B\x03\x81\x16\x84\x83\x01Ra\x04\xE9V[_a\x01@\x80\x83Ra\x11\x16\x81\x84\x01\x86Qg\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x90RV[` \x85\x01Q`\x01`\x01`\xA0\x1B\x03\x81\x16a\x01`\x85\x01RP`@\x85\x01Qa\x01\x80\x81\x81\x86\x01R``\x87\x01Q\x91Pa\x01\xA0\x82\x81\x87\x01R`\x80\x88\x01Q\x92Pa\x01\xC0a\x11f\x81\x88\x01\x85`\x01`\x01`\xA0\x1B\x03\x16\x90RV[`\xA0\x89\x01Q\x93Pa\x01\xE0a\x11\x84\x81\x89\x01\x86`\x01`\x01`\xA0\x1B\x03\x16\x90RV[`\xC0\x8A\x01Q\x94Pa\x02\0\x85\x81\x8A\x01R`\xE0\x8B\x01Q\x95Pa\x02 a\x03\xE0\x81\x8B\x01Ra\x11\xB2a\x05 \x8B\x01\x88a\x0F(V[\x96Pa\x01\0\x8C\x01Qa\x02@\x81\x81\x8D\x01Ra\x01 \x8E\x01Q\x91Pa\x02`a\x11\xE2\x81\x8E\x01\x84g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x90RV[\x8A\x8F\x01Q\x9APa\x02\x80\x92P\x7F\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFE\xC0\x8D\x8B\x03\x01\x83\x8E\x01Ra\x12 \x8A\x8Ca\x0FVV[\x9APa\x01`\x8F\x01Q\x99Pa\x12Ya\x02\xA0\x8E\x01\x8B\x80Q\x82R` \x81\x01Q` \x83\x01R`@\x81\x01Q`@\x83\x01R``\x81\x01Q``\x83\x01RPPV[\x88\x8F\x01Qa\x03 \x8E\x01R\x87\x8F\x01Qa\x03@\x8E\x01R\x86\x8F\x01Qa\x03`\x8E\x01R\x85\x8F\x01Q\x99Pa\x12\x8Ba\x03\x80\x8E\x01\x8Ba\x0F\xB0V[\x93\x8E\x01Qa\x04@\x8D\x01R\x91\x8D\x01Q`\x01`\x01`\xA0\x1B\x03\x16a\x04`\x8C\x01R\x90\x8C\x01Q`\xFF\x16a\x04\x80\x8B\x01R\x90\x8B\x01Qg\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x90\x81\x16a\x04\xA0\x8B\x01R\x90\x8B\x01Q\x80Q\x82\x16a\x04\xC0\x8B\x01R` \x81\x01Q\x82\x16a\x04\xE0\x8B\x01R`@\x81\x01Q\x90\x91\x16a\x05\0\x8A\x01R\x94Pa\x13\0\x93PPPPV[P\x90Pa\x08\x0B` \x83\x01\x84a\x101V[\x81\x81\x03\x81\x81\x11\x15a\x067WcNH{q`\xE0\x1B_R`\x11`\x04R`$_\xFD[cNH{q`\xE0\x1B_R`\x01`\x04R`$_\xFD[_\x82Q\x80` \x85\x01\x84^_\x92\x01\x91\x82RP\x91\x90PV[` \x81R_a\x064` \x83\x01\x84a\x0F(V\xFEAddress: low-level delegate call failed\xA2dipfsX\"\x12 \xC3\xB5|\xC1\xC9\x02\xD5~N]\xEAr\x0E\xD6?\x19\xC7W\xCD%\xBC\xB4\n\xFB\xCC7{\x07.g\x13\x1EdsolcC\0\x08\x19\x003`\x80`@R`@Qa\r\x898\x03\x80a\r\x89\x839\x81\x01`@\x81\x90Ra\0\"\x91a\x03\xB7V[\x82\x81a\0/\x82\x82_a\0CV[Pa\0;\x90P\x82a\0nV[PPPa\x04\xCDV[a\0L\x83a\0\xDBV[_\x82Q\x11\x80a\0XWP\x80[\x15a\0iWa\0g\x83\x83a\x01\x1AV[P[PPPV[\x7F~dMyB/\x17\xC0\x1EH\x94\xB5\xF4\xF5\x88\xD31\xEB\xFA(e=B\xAE\x83-\xC5\x9E8\xC9y\x8Fa\0\xAD_\x80Q` a\rB\x839\x81Q\x91RT`\x01`\x01`\xA0\x1B\x03\x16\x90V[`@\x80Q`\x01`\x01`\xA0\x1B\x03\x92\x83\x16\x81R\x91\x84\x16` \x83\x01R\x01`@Q\x80\x91\x03\x90\xA1a\0\xD8\x81a\x01FV[PV[a\0\xE4\x81a\x01\xE1V[`@Q`\x01`\x01`\xA0\x1B\x03\x82\x16\x90\x7F\xBC|\xD7Z \xEE'\xFD\x9A\xDE\xBA\xB3 A\xF7U!M\xBCk\xFF\xA9\x0C\xC0\"[9\xDA.\\-;\x90_\x90\xA2PV[``a\x01?\x83\x83`@Q\x80``\x01`@R\x80`'\x81R` \x01a\rb`'\x919a\x02uV[\x93\x92PPPV[`\x01`\x01`\xA0\x1B\x03\x81\x16a\x01\xB0W`@QbF\x1B\xCD`\xE5\x1B\x81R` `\x04\x82\x01R`&`$\x82\x01R\x7FERC1967: new admin is the zero a`D\x82\x01Reddress`\xD0\x1B`d\x82\x01R`\x84\x01[`@Q\x80\x91\x03\x90\xFD[\x80_\x80Q` a\rB\x839\x81Q\x91R[\x80T`\x01`\x01`\xA0\x1B\x03\x19\x16`\x01`\x01`\xA0\x1B\x03\x92\x90\x92\x16\x91\x90\x91\x17\x90UPV[`\x01`\x01`\xA0\x1B\x03\x81\x16;a\x02NW`@QbF\x1B\xCD`\xE5\x1B\x81R` `\x04\x82\x01R`-`$\x82\x01R\x7FERC1967: new implementation is n`D\x82\x01Rl\x1B\xDD\x08\x18H\x18\xDB\xDB\x9D\x1C\x98X\xDD`\x9A\x1B`d\x82\x01R`\x84\x01a\x01\xA7V[\x80\x7F6\x08\x94\xA1;\xA1\xA3!\x06g\xC8(I-\xB9\x8D\xCA> v\xCC75\xA9 \xA3\xCAP]8+\xBCa\x01\xC0V[```\x01`\x01`\xA0\x1B\x03\x84\x16;a\x02\xDDW`@QbF\x1B\xCD`\xE5\x1B\x81R` `\x04\x82\x01R`&`$\x82\x01R\x7FAddress: delegate call to non-co`D\x82\x01Re\x1B\x9D\x1C\x98X\xDD`\xD2\x1B`d\x82\x01R`\x84\x01a\x01\xA7V[_\x80\x85`\x01`\x01`\xA0\x1B\x03\x16\x85`@Qa\x02\xF7\x91\x90a\x04\x82V[_`@Q\x80\x83\x03\x81\x85Z\xF4\x91PP=\x80_\x81\x14a\x03/W`@Q\x91P`\x1F\x19`?=\x01\x16\x82\x01`@R=\x82R=_` \x84\x01>a\x034V[``\x91P[P\x90\x92P\x90Pa\x03E\x82\x82\x86a\x03OV[\x96\x95PPPPPPV[``\x83\x15a\x03^WP\x81a\x01?V[\x82Q\x15a\x03nW\x82Q\x80\x84` \x01\xFD[\x81`@QbF\x1B\xCD`\xE5\x1B\x81R`\x04\x01a\x01\xA7\x91\x90a\x04\x98V[\x80Q`\x01`\x01`\xA0\x1B\x03\x81\x16\x81\x14a\x03\x9EW_\x80\xFD[\x91\x90PV[cNH{q`\xE0\x1B_R`A`\x04R`$_\xFD[_\x80_``\x84\x86\x03\x12\x15a\x03\xC9W_\x80\xFD[a\x03\xD2\x84a\x03\x88V[\x92Pa\x03\xE0` \x85\x01a\x03\x88V[`@\x85\x01Q\x90\x92P`\x01`\x01`@\x1B\x03\x80\x82\x11\x15a\x03\xFCW_\x80\xFD[\x81\x86\x01\x91P\x86`\x1F\x83\x01\x12a\x04\x0FW_\x80\xFD[\x81Q\x81\x81\x11\x15a\x04!Wa\x04!a\x03\xA3V[`@Q`\x1F\x82\x01`\x1F\x19\x90\x81\x16`?\x01\x16\x81\x01\x90\x83\x82\x11\x81\x83\x10\x17\x15a\x04IWa\x04Ia\x03\xA3V[\x81`@R\x82\x81R\x89` \x84\x87\x01\x01\x11\x15a\x04aW_\x80\xFD[\x82` \x86\x01` \x83\x01^_` \x84\x83\x01\x01R\x80\x95PPPPPP\x92P\x92P\x92V[_\x82Q\x80` \x85\x01\x84^_\x92\x01\x91\x82RP\x91\x90PV[` \x81R_\x82Q\x80` \x84\x01R\x80` \x85\x01`@\x85\x01^_`@\x82\x85\x01\x01R`@`\x1F\x19`\x1F\x83\x01\x16\x84\x01\x01\x91PP\x92\x91PPV[a\x08h\x80a\x04\xDA_9_\xF3\xFE`\x80`@R`\x046\x10a\0]W_5`\xE0\x1C\x80c\\`\xDA\x1B\x11a\0BW\x80c\\`\xDA\x1B\x14a\0\xA6W\x80c\x8F(9p\x14a\0\xD6W\x80c\xF8Q\xA4@\x14a\0\xF5Wa\0lV[\x80c6Y\xCF\xE6\x14a\0tW\x80cO\x1E\xF2\x86\x14a\0\x93Wa\0lV[6a\0lWa\0ja\x01\tV[\0[a\0ja\x01\tV[4\x80\x15a\0\x7FW_\x80\xFD[Pa\0ja\0\x8E6`\x04a\x07\rV[a\x01#V[a\0ja\0\xA16`\x04a\x07&V[a\x01^V[4\x80\x15a\0\xB1W_\x80\xFD[Pa\0\xBAa\x01\xC4V[`@Q`\x01`\x01`\xA0\x1B\x03\x90\x91\x16\x81R` \x01`@Q\x80\x91\x03\x90\xF3[4\x80\x15a\0\xE1W_\x80\xFD[Pa\0ja\0\xF06`\x04a\x07\rV[a\x01\xF4V[4\x80\x15a\x01\0W_\x80\xFD[Pa\0\xBAa\x02\x14V[a\x01\x11a\x024V[a\x01!a\x01\x1Ca\x02\xE4V[a\x02\xEDV[V[a\x01+a\x03\x0BV[`\x01`\x01`\xA0\x1B\x03\x163\x03a\x01VWa\x01S\x81`@Q\x80` \x01`@R\x80_\x81RP_a\x03=V[PV[a\x01Sa\x01\tV[a\x01fa\x03\x0BV[`\x01`\x01`\xA0\x1B\x03\x163\x03a\x01\xBCWa\x01\xB7\x83\x83\x83\x80\x80`\x1F\x01` \x80\x91\x04\x02` \x01`@Q\x90\x81\x01`@R\x80\x93\x92\x91\x90\x81\x81R` \x01\x83\x83\x80\x82\x847_\x92\x01\x91\x90\x91RP`\x01\x92Pa\x03=\x91PPV[PPPV[a\x01\xB7a\x01\tV[_a\x01\xCDa\x03\x0BV[`\x01`\x01`\xA0\x1B\x03\x163\x03a\x01\xE9Wa\x01\xE4a\x02\xE4V[\x90P\x90V[a\x01\xF1a\x01\tV[\x90V[a\x01\xFCa\x03\x0BV[`\x01`\x01`\xA0\x1B\x03\x163\x03a\x01VWa\x01S\x81a\x03gV[_a\x02\x1Da\x03\x0BV[`\x01`\x01`\xA0\x1B\x03\x163\x03a\x01\xE9Wa\x01\xE4a\x03\x0BV[a\x02<a\x03\x0BV[`\x01`\x01`\xA0\x1B\x03\x163\x03a\x01!W`@QbF\x1B\xCD`\xE5\x1B\x81R` `\x04\x82\x01R`B`$\x82\x01R\x7FTransparentUpgradeableProxy: adm`D\x82\x01R\x7Fin cannot fallback to proxy targ`d\x82\x01R\x7Fet\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0`\x84\x82\x01R`\xA4\x01[`@Q\x80\x91\x03\x90\xFD[_a\x01\xE4a\x03\xBBV[6_\x807_\x806_\x84Z\xF4=_\x80>\x80\x80\x15a\x03\x07W=_\xF3[=_\xFD[_\x7F\xB51'hJV\x8B1s\xAE\x13\xB9\xF8\xA6\x01n$>c\xB6\xE8\xEE\x11x\xD6\xA7\x17\x85\x0B]a\x03[T`\x01`\x01`\xA0\x1B\x03\x16\x91\x90PV[a\x03F\x83a\x03\xE2V[_\x82Q\x11\x80a\x03RWP\x80[\x15a\x01\xB7Wa\x03a\x83\x83a\x04!V[PPPPV[\x7F~dMyB/\x17\xC0\x1EH\x94\xB5\xF4\xF5\x88\xD31\xEB\xFA(e=B\xAE\x83-\xC5\x9E8\xC9y\x8Fa\x03\x90a\x03\x0BV[`@\x80Q`\x01`\x01`\xA0\x1B\x03\x92\x83\x16\x81R\x91\x84\x16` \x83\x01R\x01`@Q\x80\x91\x03\x90\xA1a\x01S\x81a\x04MV[_\x7F6\x08\x94\xA1;\xA1\xA3!\x06g\xC8(I-\xB9\x8D\xCA> v\xCC75\xA9 \xA3\xCAP]8+\xBCa\x03.V[a\x03\xEB\x81a\x05%V[`@Q`\x01`\x01`\xA0\x1B\x03\x82\x16\x90\x7F\xBC|\xD7Z \xEE'\xFD\x9A\xDE\xBA\xB3 A\xF7U!M\xBCk\xFF\xA9\x0C\xC0\"[9\xDA.\\-;\x90_\x90\xA2PV[``a\x04F\x83\x83`@Q\x80``\x01`@R\x80`'\x81R` \x01a\x08\x0C`'\x919a\x05\xC9V[\x93\x92PPPV[`\x01`\x01`\xA0\x1B\x03\x81\x16a\x04\xC9W`@QbF\x1B\xCD`\xE5\x1B\x81R` `\x04\x82\x01R`&`$\x82\x01R\x7FERC1967: new admin is the zero a`D\x82\x01R\x7Fddress\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0`d\x82\x01R`\x84\x01a\x02\xDBV[\x80\x7F\xB51'hJV\x8B1s\xAE\x13\xB9\xF8\xA6\x01n$>c\xB6\xE8\xEE\x11x\xD6\xA7\x17\x85\x0B]a\x03[\x80T\x7F\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x16`\x01`\x01`\xA0\x1B\x03\x92\x90\x92\x16\x91\x90\x91\x17\x90UPV[`\x01`\x01`\xA0\x1B\x03\x81\x16;a\x05\xA2W`@QbF\x1B\xCD`\xE5\x1B\x81R` `\x04\x82\x01R`-`$\x82\x01R\x7FERC1967: new implementation is n`D\x82\x01R\x7Fot a contract\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0`d\x82\x01R`\x84\x01a\x02\xDBV[\x80\x7F6\x08\x94\xA1;\xA1\xA3!\x06g\xC8(I-\xB9\x8D\xCA> v\xCC75\xA9 \xA3\xCAP]8+\xBCa\x04\xECV[```\x01`\x01`\xA0\x1B\x03\x84\x16;a\x06HW`@QbF\x1B\xCD`\xE5\x1B\x81R` `\x04\x82\x01R`&`$\x82\x01R\x7FAddress: delegate call to non-co`D\x82\x01R\x7Fntract\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0`d\x82\x01R`\x84\x01a\x02\xDBV[_\x80\x85`\x01`\x01`\xA0\x1B\x03\x16\x85`@Qa\x06b\x91\x90a\x07\xA2V[_`@Q\x80\x83\x03\x81\x85Z\xF4\x91PP=\x80_\x81\x14a\x06\x9AW`@Q\x91P`\x1F\x19`?=\x01\x16\x82\x01`@R=\x82R=_` \x84\x01>a\x06\x9FV[``\x91P[P\x91P\x91Pa\x06\xAF\x82\x82\x86a\x06\xB9V[\x96\x95PPPPPPV[``\x83\x15a\x06\xC8WP\x81a\x04FV[\x82Q\x15a\x06\xD8W\x82Q\x80\x84` \x01\xFD[\x81`@QbF\x1B\xCD`\xE5\x1B\x81R`\x04\x01a\x02\xDB\x91\x90a\x07\xB8V[\x805`\x01`\x01`\xA0\x1B\x03\x81\x16\x81\x14a\x07\x08W_\x80\xFD[\x91\x90PV[_` \x82\x84\x03\x12\x15a\x07\x1DW_\x80\xFD[a\x04F\x82a\x06\xF2V[_\x80_`@\x84\x86\x03\x12\x15a\x078W_\x80\xFD[a\x07A\x84a\x06\xF2V[\x92P` \x84\x015g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x80\x82\x11\x15a\x07]W_\x80\xFD[\x81\x86\x01\x91P\x86`\x1F\x83\x01\x12a\x07pW_\x80\xFD[\x815\x81\x81\x11\x15a\x07~W_\x80\xFD[\x87` \x82\x85\x01\x01\x11\x15a\x07\x8FW_\x80\xFD[` \x83\x01\x94P\x80\x93PPPP\x92P\x92P\x92V[_\x82Q\x80` \x85\x01\x84^_\x92\x01\x91\x82RP\x91\x90PV[` \x81R_\x82Q\x80` \x84\x01R\x80` \x85\x01`@\x85\x01^_`@\x82\x85\x01\x01R`@\x7F\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xE0`\x1F\x83\x01\x16\x84\x01\x01\x91PP\x92\x91PPV\xFEAddress: low-level delegate call failed\xA2dipfsX\"\x12 QG\xD3\x89W\xE9\xDFn\x1D\xA1\xB9\x87Q\x98|U\xE3+\xDCL\xB0\t\xEAz\x14Z\xB64\xAE\xE1\x89sdsolcC\0\x08\x19\x003\xB51'hJV\x8B1s\xAE\x13\xB9\xF8\xA6\x01n$>c\xB6\xE8\xEE\x11x\xD6\xA7\x17\x85\x0B]a\x03Address: low-level delegate call failed\xA2dipfsX\"\x12 \xDCof\x99\xC6\xFB\xDE#J8\x7F\x80]i\x8A\xED\xAF\x1EU\x06-\xD4\xAC^\x87L\x15\x13\xC6\xBE\xE1\xAFdsolcC\0\x08\x19\x003",
    );
    /**```solidity
struct BufferConfig { uint64 threshold; uint64 max; uint64 replenishRateInBasis; }
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct BufferConfig {
        pub threshold: u64,
        pub max: u64,
        pub replenishRateInBasis: u64,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = (
            alloy::sol_types::sol_data::Uint<64>,
            alloy::sol_types::sol_data::Uint<64>,
            alloy::sol_types::sol_data::Uint<64>,
        );
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = (u64, u64, u64);
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<BufferConfig> for UnderlyingRustTuple<'_> {
            fn from(value: BufferConfig) -> Self {
                (value.threshold, value.max, value.replenishRateInBasis)
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for BufferConfig {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self {
                    threshold: tuple.0,
                    max: tuple.1,
                    replenishRateInBasis: tuple.2,
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolValue for BufferConfig {
            type SolType = Self;
        }
        #[automatically_derived]
        impl alloy_sol_types::private::SolTypeValue<Self> for BufferConfig {
            #[inline]
            fn stv_to_tokens(&self) -> <Self as alloy_sol_types::SolType>::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        64,
                    > as alloy_sol_types::SolType>::tokenize(&self.threshold),
                    <alloy::sol_types::sol_data::Uint<
                        64,
                    > as alloy_sol_types::SolType>::tokenize(&self.max),
                    <alloy::sol_types::sol_data::Uint<
                        64,
                    > as alloy_sol_types::SolType>::tokenize(&self.replenishRateInBasis),
                )
            }
            #[inline]
            fn stv_abi_encoded_size(&self) -> usize {
                if let Some(size) = <Self as alloy_sol_types::SolType>::ENCODED_SIZE {
                    return size;
                }
                let tuple = <UnderlyingRustTuple<
                    '_,
                > as ::core::convert::From<Self>>::from(self.clone());
                <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_encoded_size(&tuple)
            }
            #[inline]
            fn stv_eip712_data_word(&self) -> alloy_sol_types::Word {
                <Self as alloy_sol_types::SolStruct>::eip712_hash_struct(self)
            }
            #[inline]
            fn stv_abi_encode_packed_to(
                &self,
                out: &mut alloy_sol_types::private::Vec<u8>,
            ) {
                let tuple = <UnderlyingRustTuple<
                    '_,
                > as ::core::convert::From<Self>>::from(self.clone());
                <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_encode_packed_to(&tuple, out)
            }
            #[inline]
            fn stv_abi_packed_encoded_size(&self) -> usize {
                if let Some(size) = <Self as alloy_sol_types::SolType>::PACKED_ENCODED_SIZE {
                    return size;
                }
                let tuple = <UnderlyingRustTuple<
                    '_,
                > as ::core::convert::From<Self>>::from(self.clone());
                <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_packed_encoded_size(&tuple)
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolType for BufferConfig {
            type RustType = Self;
            type Token<'a> = <UnderlyingSolTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SOL_NAME: &'static str = <Self as alloy_sol_types::SolStruct>::NAME;
            const ENCODED_SIZE: Option<usize> = <UnderlyingSolTuple<
                '_,
            > as alloy_sol_types::SolType>::ENCODED_SIZE;
            const PACKED_ENCODED_SIZE: Option<usize> = <UnderlyingSolTuple<
                '_,
            > as alloy_sol_types::SolType>::PACKED_ENCODED_SIZE;
            #[inline]
            fn valid_token(token: &Self::Token<'_>) -> bool {
                <UnderlyingSolTuple<'_> as alloy_sol_types::SolType>::valid_token(token)
            }
            #[inline]
            fn detokenize(token: Self::Token<'_>) -> Self::RustType {
                let tuple = <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::detokenize(token);
                <Self as ::core::convert::From<UnderlyingRustTuple<'_>>>::from(tuple)
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolStruct for BufferConfig {
            const NAME: &'static str = "BufferConfig";
            #[inline]
            fn eip712_root_type() -> alloy_sol_types::private::Cow<'static, str> {
                alloy_sol_types::private::Cow::Borrowed(
                    "BufferConfig(uint64 threshold,uint64 max,uint64 replenishRateInBasis)",
                )
            }
            #[inline]
            fn eip712_components() -> alloy_sol_types::private::Vec<
                alloy_sol_types::private::Cow<'static, str>,
            > {
                alloy_sol_types::private::Vec::new()
            }
            #[inline]
            fn eip712_encode_type() -> alloy_sol_types::private::Cow<'static, str> {
                <Self as alloy_sol_types::SolStruct>::eip712_root_type()
            }
            #[inline]
            fn eip712_encode_data(&self) -> alloy_sol_types::private::Vec<u8> {
                [
                    <alloy::sol_types::sol_data::Uint<
                        64,
                    > as alloy_sol_types::SolType>::eip712_data_word(&self.threshold)
                        .0,
                    <alloy::sol_types::sol_data::Uint<
                        64,
                    > as alloy_sol_types::SolType>::eip712_data_word(&self.max)
                        .0,
                    <alloy::sol_types::sol_data::Uint<
                        64,
                    > as alloy_sol_types::SolType>::eip712_data_word(
                            &self.replenishRateInBasis,
                        )
                        .0,
                ]
                    .concat()
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::EventTopic for BufferConfig {
            #[inline]
            fn topic_preimage_length(rust: &Self::RustType) -> usize {
                0usize
                    + <alloy::sol_types::sol_data::Uint<
                        64,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.threshold,
                    )
                    + <alloy::sol_types::sol_data::Uint<
                        64,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(&rust.max)
                    + <alloy::sol_types::sol_data::Uint<
                        64,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.replenishRateInBasis,
                    )
            }
            #[inline]
            fn encode_topic_preimage(
                rust: &Self::RustType,
                out: &mut alloy_sol_types::private::Vec<u8>,
            ) {
                out.reserve(
                    <Self as alloy_sol_types::EventTopic>::topic_preimage_length(rust),
                );
                <alloy::sol_types::sol_data::Uint<
                    64,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.threshold,
                    out,
                );
                <alloy::sol_types::sol_data::Uint<
                    64,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(&rust.max, out);
                <alloy::sol_types::sol_data::Uint<
                    64,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.replenishRateInBasis,
                    out,
                );
            }
            #[inline]
            fn encode_topic(
                rust: &Self::RustType,
            ) -> alloy_sol_types::abi::token::WordToken {
                let mut out = alloy_sol_types::private::Vec::new();
                <Self as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    rust,
                    &mut out,
                );
                alloy_sol_types::abi::token::WordToken(
                    alloy_sol_types::private::keccak256(out),
                )
            }
        }
    };
    /**```solidity
struct Contracts { address excessStakeReceiver; address rollup; address bridge; address sequencerInbox; address rollupEventInbox; address outbox; address inbox; address osp; }
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct Contracts {
        pub excessStakeReceiver: alloy::sol_types::private::Address,
        pub rollup: alloy::sol_types::private::Address,
        pub bridge: alloy::sol_types::private::Address,
        pub sequencerInbox: alloy::sol_types::private::Address,
        pub rollupEventInbox: alloy::sol_types::private::Address,
        pub outbox: alloy::sol_types::private::Address,
        pub inbox: alloy::sol_types::private::Address,
        pub osp: alloy::sol_types::private::Address,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = (
            alloy::sol_types::sol_data::Address,
            alloy::sol_types::sol_data::Address,
            alloy::sol_types::sol_data::Address,
            alloy::sol_types::sol_data::Address,
            alloy::sol_types::sol_data::Address,
            alloy::sol_types::sol_data::Address,
            alloy::sol_types::sol_data::Address,
            alloy::sol_types::sol_data::Address,
        );
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = (
            alloy::sol_types::private::Address,
            alloy::sol_types::private::Address,
            alloy::sol_types::private::Address,
            alloy::sol_types::private::Address,
            alloy::sol_types::private::Address,
            alloy::sol_types::private::Address,
            alloy::sol_types::private::Address,
            alloy::sol_types::private::Address,
        );
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<Contracts> for UnderlyingRustTuple<'_> {
            fn from(value: Contracts) -> Self {
                (
                    value.excessStakeReceiver,
                    value.rollup,
                    value.bridge,
                    value.sequencerInbox,
                    value.rollupEventInbox,
                    value.outbox,
                    value.inbox,
                    value.osp,
                )
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for Contracts {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self {
                    excessStakeReceiver: tuple.0,
                    rollup: tuple.1,
                    bridge: tuple.2,
                    sequencerInbox: tuple.3,
                    rollupEventInbox: tuple.4,
                    outbox: tuple.5,
                    inbox: tuple.6,
                    osp: tuple.7,
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolValue for Contracts {
            type SolType = Self;
        }
        #[automatically_derived]
        impl alloy_sol_types::private::SolTypeValue<Self> for Contracts {
            #[inline]
            fn stv_to_tokens(&self) -> <Self as alloy_sol_types::SolType>::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.excessStakeReceiver,
                    ),
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.rollup,
                    ),
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.bridge,
                    ),
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.sequencerInbox,
                    ),
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.rollupEventInbox,
                    ),
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.outbox,
                    ),
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.inbox,
                    ),
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.osp,
                    ),
                )
            }
            #[inline]
            fn stv_abi_encoded_size(&self) -> usize {
                if let Some(size) = <Self as alloy_sol_types::SolType>::ENCODED_SIZE {
                    return size;
                }
                let tuple = <UnderlyingRustTuple<
                    '_,
                > as ::core::convert::From<Self>>::from(self.clone());
                <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_encoded_size(&tuple)
            }
            #[inline]
            fn stv_eip712_data_word(&self) -> alloy_sol_types::Word {
                <Self as alloy_sol_types::SolStruct>::eip712_hash_struct(self)
            }
            #[inline]
            fn stv_abi_encode_packed_to(
                &self,
                out: &mut alloy_sol_types::private::Vec<u8>,
            ) {
                let tuple = <UnderlyingRustTuple<
                    '_,
                > as ::core::convert::From<Self>>::from(self.clone());
                <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_encode_packed_to(&tuple, out)
            }
            #[inline]
            fn stv_abi_packed_encoded_size(&self) -> usize {
                if let Some(size) = <Self as alloy_sol_types::SolType>::PACKED_ENCODED_SIZE {
                    return size;
                }
                let tuple = <UnderlyingRustTuple<
                    '_,
                > as ::core::convert::From<Self>>::from(self.clone());
                <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_packed_encoded_size(&tuple)
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolType for Contracts {
            type RustType = Self;
            type Token<'a> = <UnderlyingSolTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SOL_NAME: &'static str = <Self as alloy_sol_types::SolStruct>::NAME;
            const ENCODED_SIZE: Option<usize> = <UnderlyingSolTuple<
                '_,
            > as alloy_sol_types::SolType>::ENCODED_SIZE;
            const PACKED_ENCODED_SIZE: Option<usize> = <UnderlyingSolTuple<
                '_,
            > as alloy_sol_types::SolType>::PACKED_ENCODED_SIZE;
            #[inline]
            fn valid_token(token: &Self::Token<'_>) -> bool {
                <UnderlyingSolTuple<'_> as alloy_sol_types::SolType>::valid_token(token)
            }
            #[inline]
            fn detokenize(token: Self::Token<'_>) -> Self::RustType {
                let tuple = <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::detokenize(token);
                <Self as ::core::convert::From<UnderlyingRustTuple<'_>>>::from(tuple)
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolStruct for Contracts {
            const NAME: &'static str = "Contracts";
            #[inline]
            fn eip712_root_type() -> alloy_sol_types::private::Cow<'static, str> {
                alloy_sol_types::private::Cow::Borrowed(
                    "Contracts(address excessStakeReceiver,address rollup,address bridge,address sequencerInbox,address rollupEventInbox,address outbox,address inbox,address osp)",
                )
            }
            #[inline]
            fn eip712_components() -> alloy_sol_types::private::Vec<
                alloy_sol_types::private::Cow<'static, str>,
            > {
                alloy_sol_types::private::Vec::new()
            }
            #[inline]
            fn eip712_encode_type() -> alloy_sol_types::private::Cow<'static, str> {
                <Self as alloy_sol_types::SolStruct>::eip712_root_type()
            }
            #[inline]
            fn eip712_encode_data(&self) -> alloy_sol_types::private::Vec<u8> {
                [
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::eip712_data_word(
                            &self.excessStakeReceiver,
                        )
                        .0,
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::eip712_data_word(
                            &self.rollup,
                        )
                        .0,
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::eip712_data_word(
                            &self.bridge,
                        )
                        .0,
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::eip712_data_word(
                            &self.sequencerInbox,
                        )
                        .0,
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::eip712_data_word(
                            &self.rollupEventInbox,
                        )
                        .0,
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::eip712_data_word(
                            &self.outbox,
                        )
                        .0,
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::eip712_data_word(
                            &self.inbox,
                        )
                        .0,
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::eip712_data_word(
                            &self.osp,
                        )
                        .0,
                ]
                    .concat()
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::EventTopic for Contracts {
            #[inline]
            fn topic_preimage_length(rust: &Self::RustType) -> usize {
                0usize
                    + <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.excessStakeReceiver,
                    )
                    + <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.rollup,
                    )
                    + <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.bridge,
                    )
                    + <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.sequencerInbox,
                    )
                    + <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.rollupEventInbox,
                    )
                    + <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.outbox,
                    )
                    + <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.inbox,
                    )
                    + <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.osp,
                    )
            }
            #[inline]
            fn encode_topic_preimage(
                rust: &Self::RustType,
                out: &mut alloy_sol_types::private::Vec<u8>,
            ) {
                out.reserve(
                    <Self as alloy_sol_types::EventTopic>::topic_preimage_length(rust),
                );
                <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.excessStakeReceiver,
                    out,
                );
                <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.rollup,
                    out,
                );
                <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.bridge,
                    out,
                );
                <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.sequencerInbox,
                    out,
                );
                <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.rollupEventInbox,
                    out,
                );
                <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.outbox,
                    out,
                );
                <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.inbox,
                    out,
                );
                <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.osp,
                    out,
                );
            }
            #[inline]
            fn encode_topic(
                rust: &Self::RustType,
            ) -> alloy_sol_types::abi::token::WordToken {
                let mut out = alloy_sol_types::private::Vec::new();
                <Self as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    rust,
                    &mut out,
                );
                alloy_sol_types::abi::token::WordToken(
                    alloy_sol_types::private::keccak256(out),
                )
            }
        }
    };
    /**```solidity
struct Implementations { address bridge; address seqInbox; address inbox; address rei; address outbox; address newRollupUser; address newRollupAdmin; address challengeManager; }
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct Implementations {
        pub bridge: alloy::sol_types::private::Address,
        pub seqInbox: alloy::sol_types::private::Address,
        pub inbox: alloy::sol_types::private::Address,
        pub rei: alloy::sol_types::private::Address,
        pub outbox: alloy::sol_types::private::Address,
        pub newRollupUser: alloy::sol_types::private::Address,
        pub newRollupAdmin: alloy::sol_types::private::Address,
        pub challengeManager: alloy::sol_types::private::Address,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = (
            alloy::sol_types::sol_data::Address,
            alloy::sol_types::sol_data::Address,
            alloy::sol_types::sol_data::Address,
            alloy::sol_types::sol_data::Address,
            alloy::sol_types::sol_data::Address,
            alloy::sol_types::sol_data::Address,
            alloy::sol_types::sol_data::Address,
            alloy::sol_types::sol_data::Address,
        );
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = (
            alloy::sol_types::private::Address,
            alloy::sol_types::private::Address,
            alloy::sol_types::private::Address,
            alloy::sol_types::private::Address,
            alloy::sol_types::private::Address,
            alloy::sol_types::private::Address,
            alloy::sol_types::private::Address,
            alloy::sol_types::private::Address,
        );
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<Implementations> for UnderlyingRustTuple<'_> {
            fn from(value: Implementations) -> Self {
                (
                    value.bridge,
                    value.seqInbox,
                    value.inbox,
                    value.rei,
                    value.outbox,
                    value.newRollupUser,
                    value.newRollupAdmin,
                    value.challengeManager,
                )
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for Implementations {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self {
                    bridge: tuple.0,
                    seqInbox: tuple.1,
                    inbox: tuple.2,
                    rei: tuple.3,
                    outbox: tuple.4,
                    newRollupUser: tuple.5,
                    newRollupAdmin: tuple.6,
                    challengeManager: tuple.7,
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolValue for Implementations {
            type SolType = Self;
        }
        #[automatically_derived]
        impl alloy_sol_types::private::SolTypeValue<Self> for Implementations {
            #[inline]
            fn stv_to_tokens(&self) -> <Self as alloy_sol_types::SolType>::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.bridge,
                    ),
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.seqInbox,
                    ),
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.inbox,
                    ),
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.rei,
                    ),
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.outbox,
                    ),
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.newRollupUser,
                    ),
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.newRollupAdmin,
                    ),
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.challengeManager,
                    ),
                )
            }
            #[inline]
            fn stv_abi_encoded_size(&self) -> usize {
                if let Some(size) = <Self as alloy_sol_types::SolType>::ENCODED_SIZE {
                    return size;
                }
                let tuple = <UnderlyingRustTuple<
                    '_,
                > as ::core::convert::From<Self>>::from(self.clone());
                <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_encoded_size(&tuple)
            }
            #[inline]
            fn stv_eip712_data_word(&self) -> alloy_sol_types::Word {
                <Self as alloy_sol_types::SolStruct>::eip712_hash_struct(self)
            }
            #[inline]
            fn stv_abi_encode_packed_to(
                &self,
                out: &mut alloy_sol_types::private::Vec<u8>,
            ) {
                let tuple = <UnderlyingRustTuple<
                    '_,
                > as ::core::convert::From<Self>>::from(self.clone());
                <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_encode_packed_to(&tuple, out)
            }
            #[inline]
            fn stv_abi_packed_encoded_size(&self) -> usize {
                if let Some(size) = <Self as alloy_sol_types::SolType>::PACKED_ENCODED_SIZE {
                    return size;
                }
                let tuple = <UnderlyingRustTuple<
                    '_,
                > as ::core::convert::From<Self>>::from(self.clone());
                <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_packed_encoded_size(&tuple)
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolType for Implementations {
            type RustType = Self;
            type Token<'a> = <UnderlyingSolTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SOL_NAME: &'static str = <Self as alloy_sol_types::SolStruct>::NAME;
            const ENCODED_SIZE: Option<usize> = <UnderlyingSolTuple<
                '_,
            > as alloy_sol_types::SolType>::ENCODED_SIZE;
            const PACKED_ENCODED_SIZE: Option<usize> = <UnderlyingSolTuple<
                '_,
            > as alloy_sol_types::SolType>::PACKED_ENCODED_SIZE;
            #[inline]
            fn valid_token(token: &Self::Token<'_>) -> bool {
                <UnderlyingSolTuple<'_> as alloy_sol_types::SolType>::valid_token(token)
            }
            #[inline]
            fn detokenize(token: Self::Token<'_>) -> Self::RustType {
                let tuple = <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::detokenize(token);
                <Self as ::core::convert::From<UnderlyingRustTuple<'_>>>::from(tuple)
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolStruct for Implementations {
            const NAME: &'static str = "Implementations";
            #[inline]
            fn eip712_root_type() -> alloy_sol_types::private::Cow<'static, str> {
                alloy_sol_types::private::Cow::Borrowed(
                    "Implementations(address bridge,address seqInbox,address inbox,address rei,address outbox,address newRollupUser,address newRollupAdmin,address challengeManager)",
                )
            }
            #[inline]
            fn eip712_components() -> alloy_sol_types::private::Vec<
                alloy_sol_types::private::Cow<'static, str>,
            > {
                alloy_sol_types::private::Vec::new()
            }
            #[inline]
            fn eip712_encode_type() -> alloy_sol_types::private::Cow<'static, str> {
                <Self as alloy_sol_types::SolStruct>::eip712_root_type()
            }
            #[inline]
            fn eip712_encode_data(&self) -> alloy_sol_types::private::Vec<u8> {
                [
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::eip712_data_word(
                            &self.bridge,
                        )
                        .0,
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::eip712_data_word(
                            &self.seqInbox,
                        )
                        .0,
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::eip712_data_word(
                            &self.inbox,
                        )
                        .0,
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::eip712_data_word(
                            &self.rei,
                        )
                        .0,
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::eip712_data_word(
                            &self.outbox,
                        )
                        .0,
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::eip712_data_word(
                            &self.newRollupUser,
                        )
                        .0,
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::eip712_data_word(
                            &self.newRollupAdmin,
                        )
                        .0,
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::eip712_data_word(
                            &self.challengeManager,
                        )
                        .0,
                ]
                    .concat()
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::EventTopic for Implementations {
            #[inline]
            fn topic_preimage_length(rust: &Self::RustType) -> usize {
                0usize
                    + <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.bridge,
                    )
                    + <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.seqInbox,
                    )
                    + <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.inbox,
                    )
                    + <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.rei,
                    )
                    + <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.outbox,
                    )
                    + <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.newRollupUser,
                    )
                    + <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.newRollupAdmin,
                    )
                    + <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.challengeManager,
                    )
            }
            #[inline]
            fn encode_topic_preimage(
                rust: &Self::RustType,
                out: &mut alloy_sol_types::private::Vec<u8>,
            ) {
                out.reserve(
                    <Self as alloy_sol_types::EventTopic>::topic_preimage_length(rust),
                );
                <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.bridge,
                    out,
                );
                <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.seqInbox,
                    out,
                );
                <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.inbox,
                    out,
                );
                <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.rei,
                    out,
                );
                <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.outbox,
                    out,
                );
                <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.newRollupUser,
                    out,
                );
                <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.newRollupAdmin,
                    out,
                );
                <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.challengeManager,
                    out,
                );
            }
            #[inline]
            fn encode_topic(
                rust: &Self::RustType,
            ) -> alloy_sol_types::abi::token::WordToken {
                let mut out = alloy_sol_types::private::Vec::new();
                <Self as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    rust,
                    &mut out,
                );
                alloy_sol_types::abi::token::WordToken(
                    alloy_sol_types::private::keccak256(out),
                )
            }
        }
    };
    /**```solidity
struct ProxyAdmins { address outbox; address bridge; address rei; address seqInbox; address inbox; }
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct ProxyAdmins {
        pub outbox: alloy::sol_types::private::Address,
        pub bridge: alloy::sol_types::private::Address,
        pub rei: alloy::sol_types::private::Address,
        pub seqInbox: alloy::sol_types::private::Address,
        pub inbox: alloy::sol_types::private::Address,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = (
            alloy::sol_types::sol_data::Address,
            alloy::sol_types::sol_data::Address,
            alloy::sol_types::sol_data::Address,
            alloy::sol_types::sol_data::Address,
            alloy::sol_types::sol_data::Address,
        );
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = (
            alloy::sol_types::private::Address,
            alloy::sol_types::private::Address,
            alloy::sol_types::private::Address,
            alloy::sol_types::private::Address,
            alloy::sol_types::private::Address,
        );
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<ProxyAdmins> for UnderlyingRustTuple<'_> {
            fn from(value: ProxyAdmins) -> Self {
                (value.outbox, value.bridge, value.rei, value.seqInbox, value.inbox)
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for ProxyAdmins {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self {
                    outbox: tuple.0,
                    bridge: tuple.1,
                    rei: tuple.2,
                    seqInbox: tuple.3,
                    inbox: tuple.4,
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolValue for ProxyAdmins {
            type SolType = Self;
        }
        #[automatically_derived]
        impl alloy_sol_types::private::SolTypeValue<Self> for ProxyAdmins {
            #[inline]
            fn stv_to_tokens(&self) -> <Self as alloy_sol_types::SolType>::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.outbox,
                    ),
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.bridge,
                    ),
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.rei,
                    ),
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.seqInbox,
                    ),
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.inbox,
                    ),
                )
            }
            #[inline]
            fn stv_abi_encoded_size(&self) -> usize {
                if let Some(size) = <Self as alloy_sol_types::SolType>::ENCODED_SIZE {
                    return size;
                }
                let tuple = <UnderlyingRustTuple<
                    '_,
                > as ::core::convert::From<Self>>::from(self.clone());
                <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_encoded_size(&tuple)
            }
            #[inline]
            fn stv_eip712_data_word(&self) -> alloy_sol_types::Word {
                <Self as alloy_sol_types::SolStruct>::eip712_hash_struct(self)
            }
            #[inline]
            fn stv_abi_encode_packed_to(
                &self,
                out: &mut alloy_sol_types::private::Vec<u8>,
            ) {
                let tuple = <UnderlyingRustTuple<
                    '_,
                > as ::core::convert::From<Self>>::from(self.clone());
                <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_encode_packed_to(&tuple, out)
            }
            #[inline]
            fn stv_abi_packed_encoded_size(&self) -> usize {
                if let Some(size) = <Self as alloy_sol_types::SolType>::PACKED_ENCODED_SIZE {
                    return size;
                }
                let tuple = <UnderlyingRustTuple<
                    '_,
                > as ::core::convert::From<Self>>::from(self.clone());
                <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_packed_encoded_size(&tuple)
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolType for ProxyAdmins {
            type RustType = Self;
            type Token<'a> = <UnderlyingSolTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SOL_NAME: &'static str = <Self as alloy_sol_types::SolStruct>::NAME;
            const ENCODED_SIZE: Option<usize> = <UnderlyingSolTuple<
                '_,
            > as alloy_sol_types::SolType>::ENCODED_SIZE;
            const PACKED_ENCODED_SIZE: Option<usize> = <UnderlyingSolTuple<
                '_,
            > as alloy_sol_types::SolType>::PACKED_ENCODED_SIZE;
            #[inline]
            fn valid_token(token: &Self::Token<'_>) -> bool {
                <UnderlyingSolTuple<'_> as alloy_sol_types::SolType>::valid_token(token)
            }
            #[inline]
            fn detokenize(token: Self::Token<'_>) -> Self::RustType {
                let tuple = <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::detokenize(token);
                <Self as ::core::convert::From<UnderlyingRustTuple<'_>>>::from(tuple)
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolStruct for ProxyAdmins {
            const NAME: &'static str = "ProxyAdmins";
            #[inline]
            fn eip712_root_type() -> alloy_sol_types::private::Cow<'static, str> {
                alloy_sol_types::private::Cow::Borrowed(
                    "ProxyAdmins(address outbox,address bridge,address rei,address seqInbox,address inbox)",
                )
            }
            #[inline]
            fn eip712_components() -> alloy_sol_types::private::Vec<
                alloy_sol_types::private::Cow<'static, str>,
            > {
                alloy_sol_types::private::Vec::new()
            }
            #[inline]
            fn eip712_encode_type() -> alloy_sol_types::private::Cow<'static, str> {
                <Self as alloy_sol_types::SolStruct>::eip712_root_type()
            }
            #[inline]
            fn eip712_encode_data(&self) -> alloy_sol_types::private::Vec<u8> {
                [
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::eip712_data_word(
                            &self.outbox,
                        )
                        .0,
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::eip712_data_word(
                            &self.bridge,
                        )
                        .0,
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::eip712_data_word(
                            &self.rei,
                        )
                        .0,
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::eip712_data_word(
                            &self.seqInbox,
                        )
                        .0,
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::eip712_data_word(
                            &self.inbox,
                        )
                        .0,
                ]
                    .concat()
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::EventTopic for ProxyAdmins {
            #[inline]
            fn topic_preimage_length(rust: &Self::RustType) -> usize {
                0usize
                    + <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.outbox,
                    )
                    + <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.bridge,
                    )
                    + <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.rei,
                    )
                    + <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.seqInbox,
                    )
                    + <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.inbox,
                    )
            }
            #[inline]
            fn encode_topic_preimage(
                rust: &Self::RustType,
                out: &mut alloy_sol_types::private::Vec<u8>,
            ) {
                out.reserve(
                    <Self as alloy_sol_types::EventTopic>::topic_preimage_length(rust),
                );
                <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.outbox,
                    out,
                );
                <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.bridge,
                    out,
                );
                <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.rei,
                    out,
                );
                <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.seqInbox,
                    out,
                );
                <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.inbox,
                    out,
                );
            }
            #[inline]
            fn encode_topic(
                rust: &Self::RustType,
            ) -> alloy_sol_types::abi::token::WordToken {
                let mut out = alloy_sol_types::private::Vec::new();
                <Self as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    rust,
                    &mut out,
                );
                alloy_sol_types::abi::token::WordToken(
                    alloy_sol_types::private::keccak256(out),
                )
            }
        }
    };
    /**```solidity
struct Settings { uint64 confirmPeriodBlocks; uint64 challengePeriodBlocks; address stakeToken; uint256 stakeAmt; uint256[] miniStakeAmounts; uint256 chainId; uint256 minimumAssertionPeriod; uint64 validatorAfkBlocks; bool disableValidatorWhitelist; uint256 blockLeafSize; uint256 bigStepLeafSize; uint256 smallStepLeafSize; uint8 numBigStepLevel; uint64 challengeGracePeriodBlocks; bool isDelayBufferable; BufferConfig bufferConfig; }
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct Settings {
        pub confirmPeriodBlocks: u64,
        pub challengePeriodBlocks: u64,
        pub stakeToken: alloy::sol_types::private::Address,
        pub stakeAmt: alloy::sol_types::private::primitives::aliases::U256,
        pub miniStakeAmounts: alloy::sol_types::private::Vec<
            alloy::sol_types::private::primitives::aliases::U256,
        >,
        pub chainId: alloy::sol_types::private::primitives::aliases::U256,
        pub minimumAssertionPeriod: alloy::sol_types::private::primitives::aliases::U256,
        pub validatorAfkBlocks: u64,
        pub disableValidatorWhitelist: bool,
        pub blockLeafSize: alloy::sol_types::private::primitives::aliases::U256,
        pub bigStepLeafSize: alloy::sol_types::private::primitives::aliases::U256,
        pub smallStepLeafSize: alloy::sol_types::private::primitives::aliases::U256,
        pub numBigStepLevel: u8,
        pub challengeGracePeriodBlocks: u64,
        pub isDelayBufferable: bool,
        pub bufferConfig: <BufferConfig as alloy::sol_types::SolType>::RustType,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = (
            alloy::sol_types::sol_data::Uint<64>,
            alloy::sol_types::sol_data::Uint<64>,
            alloy::sol_types::sol_data::Address,
            alloy::sol_types::sol_data::Uint<256>,
            alloy::sol_types::sol_data::Array<alloy::sol_types::sol_data::Uint<256>>,
            alloy::sol_types::sol_data::Uint<256>,
            alloy::sol_types::sol_data::Uint<256>,
            alloy::sol_types::sol_data::Uint<64>,
            alloy::sol_types::sol_data::Bool,
            alloy::sol_types::sol_data::Uint<256>,
            alloy::sol_types::sol_data::Uint<256>,
            alloy::sol_types::sol_data::Uint<256>,
            alloy::sol_types::sol_data::Uint<8>,
            alloy::sol_types::sol_data::Uint<64>,
            alloy::sol_types::sol_data::Bool,
            BufferConfig,
        );
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = (
            u64,
            u64,
            alloy::sol_types::private::Address,
            alloy::sol_types::private::primitives::aliases::U256,
            alloy::sol_types::private::Vec<
                alloy::sol_types::private::primitives::aliases::U256,
            >,
            alloy::sol_types::private::primitives::aliases::U256,
            alloy::sol_types::private::primitives::aliases::U256,
            u64,
            bool,
            alloy::sol_types::private::primitives::aliases::U256,
            alloy::sol_types::private::primitives::aliases::U256,
            alloy::sol_types::private::primitives::aliases::U256,
            u8,
            u64,
            bool,
            <BufferConfig as alloy::sol_types::SolType>::RustType,
        );
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<Settings> for UnderlyingRustTuple<'_> {
            fn from(value: Settings) -> Self {
                (
                    value.confirmPeriodBlocks,
                    value.challengePeriodBlocks,
                    value.stakeToken,
                    value.stakeAmt,
                    value.miniStakeAmounts,
                    value.chainId,
                    value.minimumAssertionPeriod,
                    value.validatorAfkBlocks,
                    value.disableValidatorWhitelist,
                    value.blockLeafSize,
                    value.bigStepLeafSize,
                    value.smallStepLeafSize,
                    value.numBigStepLevel,
                    value.challengeGracePeriodBlocks,
                    value.isDelayBufferable,
                    value.bufferConfig,
                )
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for Settings {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self {
                    confirmPeriodBlocks: tuple.0,
                    challengePeriodBlocks: tuple.1,
                    stakeToken: tuple.2,
                    stakeAmt: tuple.3,
                    miniStakeAmounts: tuple.4,
                    chainId: tuple.5,
                    minimumAssertionPeriod: tuple.6,
                    validatorAfkBlocks: tuple.7,
                    disableValidatorWhitelist: tuple.8,
                    blockLeafSize: tuple.9,
                    bigStepLeafSize: tuple.10,
                    smallStepLeafSize: tuple.11,
                    numBigStepLevel: tuple.12,
                    challengeGracePeriodBlocks: tuple.13,
                    isDelayBufferable: tuple.14,
                    bufferConfig: tuple.15,
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolValue for Settings {
            type SolType = Self;
        }
        #[automatically_derived]
        impl alloy_sol_types::private::SolTypeValue<Self> for Settings {
            #[inline]
            fn stv_to_tokens(&self) -> <Self as alloy_sol_types::SolType>::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        64,
                    > as alloy_sol_types::SolType>::tokenize(&self.confirmPeriodBlocks),
                    <alloy::sol_types::sol_data::Uint<
                        64,
                    > as alloy_sol_types::SolType>::tokenize(
                        &self.challengePeriodBlocks,
                    ),
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.stakeToken,
                    ),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.stakeAmt),
                    <alloy::sol_types::sol_data::Array<
                        alloy::sol_types::sol_data::Uint<256>,
                    > as alloy_sol_types::SolType>::tokenize(&self.miniStakeAmounts),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.chainId),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(
                        &self.minimumAssertionPeriod,
                    ),
                    <alloy::sol_types::sol_data::Uint<
                        64,
                    > as alloy_sol_types::SolType>::tokenize(&self.validatorAfkBlocks),
                    <alloy::sol_types::sol_data::Bool as alloy_sol_types::SolType>::tokenize(
                        &self.disableValidatorWhitelist,
                    ),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.blockLeafSize),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.bigStepLeafSize),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.smallStepLeafSize),
                    <alloy::sol_types::sol_data::Uint<
                        8,
                    > as alloy_sol_types::SolType>::tokenize(&self.numBigStepLevel),
                    <alloy::sol_types::sol_data::Uint<
                        64,
                    > as alloy_sol_types::SolType>::tokenize(
                        &self.challengeGracePeriodBlocks,
                    ),
                    <alloy::sol_types::sol_data::Bool as alloy_sol_types::SolType>::tokenize(
                        &self.isDelayBufferable,
                    ),
                    <BufferConfig as alloy_sol_types::SolType>::tokenize(
                        &self.bufferConfig,
                    ),
                )
            }
            #[inline]
            fn stv_abi_encoded_size(&self) -> usize {
                if let Some(size) = <Self as alloy_sol_types::SolType>::ENCODED_SIZE {
                    return size;
                }
                let tuple = <UnderlyingRustTuple<
                    '_,
                > as ::core::convert::From<Self>>::from(self.clone());
                <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_encoded_size(&tuple)
            }
            #[inline]
            fn stv_eip712_data_word(&self) -> alloy_sol_types::Word {
                <Self as alloy_sol_types::SolStruct>::eip712_hash_struct(self)
            }
            #[inline]
            fn stv_abi_encode_packed_to(
                &self,
                out: &mut alloy_sol_types::private::Vec<u8>,
            ) {
                let tuple = <UnderlyingRustTuple<
                    '_,
                > as ::core::convert::From<Self>>::from(self.clone());
                <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_encode_packed_to(&tuple, out)
            }
            #[inline]
            fn stv_abi_packed_encoded_size(&self) -> usize {
                if let Some(size) = <Self as alloy_sol_types::SolType>::PACKED_ENCODED_SIZE {
                    return size;
                }
                let tuple = <UnderlyingRustTuple<
                    '_,
                > as ::core::convert::From<Self>>::from(self.clone());
                <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_packed_encoded_size(&tuple)
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolType for Settings {
            type RustType = Self;
            type Token<'a> = <UnderlyingSolTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SOL_NAME: &'static str = <Self as alloy_sol_types::SolStruct>::NAME;
            const ENCODED_SIZE: Option<usize> = <UnderlyingSolTuple<
                '_,
            > as alloy_sol_types::SolType>::ENCODED_SIZE;
            const PACKED_ENCODED_SIZE: Option<usize> = <UnderlyingSolTuple<
                '_,
            > as alloy_sol_types::SolType>::PACKED_ENCODED_SIZE;
            #[inline]
            fn valid_token(token: &Self::Token<'_>) -> bool {
                <UnderlyingSolTuple<'_> as alloy_sol_types::SolType>::valid_token(token)
            }
            #[inline]
            fn detokenize(token: Self::Token<'_>) -> Self::RustType {
                let tuple = <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::detokenize(token);
                <Self as ::core::convert::From<UnderlyingRustTuple<'_>>>::from(tuple)
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolStruct for Settings {
            const NAME: &'static str = "Settings";
            #[inline]
            fn eip712_root_type() -> alloy_sol_types::private::Cow<'static, str> {
                alloy_sol_types::private::Cow::Borrowed(
                    "Settings(uint64 confirmPeriodBlocks,uint64 challengePeriodBlocks,address stakeToken,uint256 stakeAmt,uint256[] miniStakeAmounts,uint256 chainId,uint256 minimumAssertionPeriod,uint64 validatorAfkBlocks,bool disableValidatorWhitelist,uint256 blockLeafSize,uint256 bigStepLeafSize,uint256 smallStepLeafSize,uint8 numBigStepLevel,uint64 challengeGracePeriodBlocks,bool isDelayBufferable,BufferConfig bufferConfig)",
                )
            }
            #[inline]
            fn eip712_components() -> alloy_sol_types::private::Vec<
                alloy_sol_types::private::Cow<'static, str>,
            > {
                let mut components = alloy_sol_types::private::Vec::with_capacity(1);
                components
                    .push(
                        <BufferConfig as alloy_sol_types::SolStruct>::eip712_root_type(),
                    );
                components
                    .extend(
                        <BufferConfig as alloy_sol_types::SolStruct>::eip712_components(),
                    );
                components
            }
            #[inline]
            fn eip712_encode_data(&self) -> alloy_sol_types::private::Vec<u8> {
                [
                    <alloy::sol_types::sol_data::Uint<
                        64,
                    > as alloy_sol_types::SolType>::eip712_data_word(
                            &self.confirmPeriodBlocks,
                        )
                        .0,
                    <alloy::sol_types::sol_data::Uint<
                        64,
                    > as alloy_sol_types::SolType>::eip712_data_word(
                            &self.challengePeriodBlocks,
                        )
                        .0,
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::eip712_data_word(
                            &self.stakeToken,
                        )
                        .0,
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::eip712_data_word(&self.stakeAmt)
                        .0,
                    <alloy::sol_types::sol_data::Array<
                        alloy::sol_types::sol_data::Uint<256>,
                    > as alloy_sol_types::SolType>::eip712_data_word(
                            &self.miniStakeAmounts,
                        )
                        .0,
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::eip712_data_word(&self.chainId)
                        .0,
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::eip712_data_word(
                            &self.minimumAssertionPeriod,
                        )
                        .0,
                    <alloy::sol_types::sol_data::Uint<
                        64,
                    > as alloy_sol_types::SolType>::eip712_data_word(
                            &self.validatorAfkBlocks,
                        )
                        .0,
                    <alloy::sol_types::sol_data::Bool as alloy_sol_types::SolType>::eip712_data_word(
                            &self.disableValidatorWhitelist,
                        )
                        .0,
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::eip712_data_word(&self.blockLeafSize)
                        .0,
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::eip712_data_word(
                            &self.bigStepLeafSize,
                        )
                        .0,
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::eip712_data_word(
                            &self.smallStepLeafSize,
                        )
                        .0,
                    <alloy::sol_types::sol_data::Uint<
                        8,
                    > as alloy_sol_types::SolType>::eip712_data_word(
                            &self.numBigStepLevel,
                        )
                        .0,
                    <alloy::sol_types::sol_data::Uint<
                        64,
                    > as alloy_sol_types::SolType>::eip712_data_word(
                            &self.challengeGracePeriodBlocks,
                        )
                        .0,
                    <alloy::sol_types::sol_data::Bool as alloy_sol_types::SolType>::eip712_data_word(
                            &self.isDelayBufferable,
                        )
                        .0,
                    <BufferConfig as alloy_sol_types::SolType>::eip712_data_word(
                            &self.bufferConfig,
                        )
                        .0,
                ]
                    .concat()
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::EventTopic for Settings {
            #[inline]
            fn topic_preimage_length(rust: &Self::RustType) -> usize {
                0usize
                    + <alloy::sol_types::sol_data::Uint<
                        64,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.confirmPeriodBlocks,
                    )
                    + <alloy::sol_types::sol_data::Uint<
                        64,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.challengePeriodBlocks,
                    )
                    + <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.stakeToken,
                    )
                    + <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.stakeAmt,
                    )
                    + <alloy::sol_types::sol_data::Array<
                        alloy::sol_types::sol_data::Uint<256>,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.miniStakeAmounts,
                    )
                    + <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.chainId,
                    )
                    + <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.minimumAssertionPeriod,
                    )
                    + <alloy::sol_types::sol_data::Uint<
                        64,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.validatorAfkBlocks,
                    )
                    + <alloy::sol_types::sol_data::Bool as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.disableValidatorWhitelist,
                    )
                    + <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.blockLeafSize,
                    )
                    + <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.bigStepLeafSize,
                    )
                    + <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.smallStepLeafSize,
                    )
                    + <alloy::sol_types::sol_data::Uint<
                        8,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.numBigStepLevel,
                    )
                    + <alloy::sol_types::sol_data::Uint<
                        64,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.challengeGracePeriodBlocks,
                    )
                    + <alloy::sol_types::sol_data::Bool as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.isDelayBufferable,
                    )
                    + <BufferConfig as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.bufferConfig,
                    )
            }
            #[inline]
            fn encode_topic_preimage(
                rust: &Self::RustType,
                out: &mut alloy_sol_types::private::Vec<u8>,
            ) {
                out.reserve(
                    <Self as alloy_sol_types::EventTopic>::topic_preimage_length(rust),
                );
                <alloy::sol_types::sol_data::Uint<
                    64,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.confirmPeriodBlocks,
                    out,
                );
                <alloy::sol_types::sol_data::Uint<
                    64,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.challengePeriodBlocks,
                    out,
                );
                <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.stakeToken,
                    out,
                );
                <alloy::sol_types::sol_data::Uint<
                    256,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.stakeAmt,
                    out,
                );
                <alloy::sol_types::sol_data::Array<
                    alloy::sol_types::sol_data::Uint<256>,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.miniStakeAmounts,
                    out,
                );
                <alloy::sol_types::sol_data::Uint<
                    256,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.chainId,
                    out,
                );
                <alloy::sol_types::sol_data::Uint<
                    256,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.minimumAssertionPeriod,
                    out,
                );
                <alloy::sol_types::sol_data::Uint<
                    64,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.validatorAfkBlocks,
                    out,
                );
                <alloy::sol_types::sol_data::Bool as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.disableValidatorWhitelist,
                    out,
                );
                <alloy::sol_types::sol_data::Uint<
                    256,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.blockLeafSize,
                    out,
                );
                <alloy::sol_types::sol_data::Uint<
                    256,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.bigStepLeafSize,
                    out,
                );
                <alloy::sol_types::sol_data::Uint<
                    256,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.smallStepLeafSize,
                    out,
                );
                <alloy::sol_types::sol_data::Uint<
                    8,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.numBigStepLevel,
                    out,
                );
                <alloy::sol_types::sol_data::Uint<
                    64,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.challengeGracePeriodBlocks,
                    out,
                );
                <alloy::sol_types::sol_data::Bool as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.isDelayBufferable,
                    out,
                );
                <BufferConfig as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.bufferConfig,
                    out,
                );
            }
            #[inline]
            fn encode_topic(
                rust: &Self::RustType,
            ) -> alloy_sol_types::abi::token::WordToken {
                let mut out = alloy_sol_types::private::Vec::new();
                <Self as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    rust,
                    &mut out,
                );
                alloy_sol_types::abi::token::WordToken(
                    alloy_sol_types::private::keccak256(out),
                )
            }
        }
    };
    /**Event with signature `RollupMigrated(address,address)` and selector `0x7e5cc5c3fce046d868d5918548df8d3e8ef9f09e6fb30a68081f1f1348cd0314`.
```solidity
event RollupMigrated(address rollup, address challengeManager);
```*/
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    #[derive(Clone)]
    pub struct RollupMigrated {
        #[allow(missing_docs)]
        pub rollup: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub challengeManager: alloy::sol_types::private::Address,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[automatically_derived]
        impl alloy_sol_types::SolEvent for RollupMigrated {
            type DataTuple<'a> = (
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Address,
            );
            type DataToken<'a> = <Self::DataTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type TopicList = (alloy_sol_types::sol_data::FixedBytes<32>,);
            const SIGNATURE: &'static str = "RollupMigrated(address,address)";
            const SIGNATURE_HASH: alloy_sol_types::private::B256 = alloy_sol_types::private::B256::new([
                126u8,
                92u8,
                197u8,
                195u8,
                252u8,
                224u8,
                70u8,
                216u8,
                104u8,
                213u8,
                145u8,
                133u8,
                72u8,
                223u8,
                141u8,
                62u8,
                142u8,
                249u8,
                240u8,
                158u8,
                111u8,
                179u8,
                10u8,
                104u8,
                8u8,
                31u8,
                31u8,
                19u8,
                72u8,
                205u8,
                3u8,
                20u8,
            ]);
            const ANONYMOUS: bool = false;
            #[allow(unused_variables)]
            #[inline]
            fn new(
                topics: <Self::TopicList as alloy_sol_types::SolType>::RustType,
                data: <Self::DataTuple<'_> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                Self {
                    rollup: data.0,
                    challengeManager: data.1,
                }
            }
            #[inline]
            fn check_signature(
                topics: &<Self::TopicList as alloy_sol_types::SolType>::RustType,
            ) -> alloy_sol_types::Result<()> {
                if topics.0 != Self::SIGNATURE_HASH {
                    return Err(
                        alloy_sol_types::Error::invalid_event_signature_hash(
                            Self::SIGNATURE,
                            topics.0,
                            Self::SIGNATURE_HASH,
                        ),
                    );
                }
                Ok(())
            }
            #[inline]
            fn tokenize_body(&self) -> Self::DataToken<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.rollup,
                    ),
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.challengeManager,
                    ),
                )
            }
            #[inline]
            fn topics(&self) -> <Self::TopicList as alloy_sol_types::SolType>::RustType {
                (Self::SIGNATURE_HASH.into(),)
            }
            #[inline]
            fn encode_topics_raw(
                &self,
                out: &mut [alloy_sol_types::abi::token::WordToken],
            ) -> alloy_sol_types::Result<()> {
                if out.len() < <Self::TopicList as alloy_sol_types::TopicList>::COUNT {
                    return Err(alloy_sol_types::Error::Overrun);
                }
                out[0usize] = alloy_sol_types::abi::token::WordToken(
                    Self::SIGNATURE_HASH,
                );
                Ok(())
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::private::IntoLogData for RollupMigrated {
            fn to_log_data(&self) -> alloy_sol_types::private::LogData {
                From::from(self)
            }
            fn into_log_data(self) -> alloy_sol_types::private::LogData {
                From::from(&self)
            }
        }
        #[automatically_derived]
        impl From<&RollupMigrated> for alloy_sol_types::private::LogData {
            #[inline]
            fn from(this: &RollupMigrated) -> alloy_sol_types::private::LogData {
                alloy_sol_types::SolEvent::encode_log_data(this)
            }
        }
    };
    /**Constructor`.
```solidity
constructor(Contracts contracts, ProxyAdmins proxyAdmins, Implementations implementations, Settings settings);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct constructorCall {
        pub contracts: <Contracts as alloy::sol_types::SolType>::RustType,
        pub proxyAdmins: <ProxyAdmins as alloy::sol_types::SolType>::RustType,
        pub implementations: <Implementations as alloy::sol_types::SolType>::RustType,
        pub settings: <Settings as alloy::sol_types::SolType>::RustType,
    }
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                Contracts,
                ProxyAdmins,
                Implementations,
                Settings,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                <Contracts as alloy::sol_types::SolType>::RustType,
                <ProxyAdmins as alloy::sol_types::SolType>::RustType,
                <Implementations as alloy::sol_types::SolType>::RustType,
                <Settings as alloy::sol_types::SolType>::RustType,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<constructorCall> for UnderlyingRustTuple<'_> {
                fn from(value: constructorCall) -> Self {
                    (
                        value.contracts,
                        value.proxyAdmins,
                        value.implementations,
                        value.settings,
                    )
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for constructorCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        contracts: tuple.0,
                        proxyAdmins: tuple.1,
                        implementations: tuple.2,
                        settings: tuple.3,
                    }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolConstructor for constructorCall {
            type Parameters<'a> = (Contracts, ProxyAdmins, Implementations, Settings);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <Contracts as alloy_sol_types::SolType>::tokenize(&self.contracts),
                    <ProxyAdmins as alloy_sol_types::SolType>::tokenize(
                        &self.proxyAdmins,
                    ),
                    <Implementations as alloy_sol_types::SolType>::tokenize(
                        &self.implementations,
                    ),
                    <Settings as alloy_sol_types::SolType>::tokenize(&self.settings),
                )
            }
        }
    };
    /**Function with signature `BIGSTEP_LEAF_SIZE()` and selector `0x1ccc2cd1`.
```solidity
function BIGSTEP_LEAF_SIZE() external view returns (uint256);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct BIGSTEP_LEAF_SIZECall {}
    ///Container type for the return parameters of the [`BIGSTEP_LEAF_SIZE()`](BIGSTEP_LEAF_SIZECall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct BIGSTEP_LEAF_SIZEReturn {
        pub _0: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<BIGSTEP_LEAF_SIZECall>
            for UnderlyingRustTuple<'_> {
                fn from(value: BIGSTEP_LEAF_SIZECall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for BIGSTEP_LEAF_SIZECall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<BIGSTEP_LEAF_SIZEReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: BIGSTEP_LEAF_SIZEReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for BIGSTEP_LEAF_SIZEReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for BIGSTEP_LEAF_SIZECall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = BIGSTEP_LEAF_SIZEReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "BIGSTEP_LEAF_SIZE()";
            const SELECTOR: [u8; 4] = [28u8, 204u8, 44u8, 209u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `BLOCK_LEAF_SIZE()` and selector `0x609fb503`.
```solidity
function BLOCK_LEAF_SIZE() external view returns (uint256);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct BLOCK_LEAF_SIZECall {}
    ///Container type for the return parameters of the [`BLOCK_LEAF_SIZE()`](BLOCK_LEAF_SIZECall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct BLOCK_LEAF_SIZEReturn {
        pub _0: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<BLOCK_LEAF_SIZECall> for UnderlyingRustTuple<'_> {
                fn from(value: BLOCK_LEAF_SIZECall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for BLOCK_LEAF_SIZECall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<BLOCK_LEAF_SIZEReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: BLOCK_LEAF_SIZEReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for BLOCK_LEAF_SIZEReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for BLOCK_LEAF_SIZECall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = BLOCK_LEAF_SIZEReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "BLOCK_LEAF_SIZE()";
            const SELECTOR: [u8; 4] = [96u8, 159u8, 181u8, 3u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `BRIDGE()` and selector `0xee9a31a2`.
```solidity
function BRIDGE() external view returns (address);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct BRIDGECall {}
    ///Container type for the return parameters of the [`BRIDGE()`](BRIDGECall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct BRIDGEReturn {
        pub _0: alloy::sol_types::private::Address,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<BRIDGECall> for UnderlyingRustTuple<'_> {
                fn from(value: BRIDGECall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for BRIDGECall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Address,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::Address,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<BRIDGEReturn> for UnderlyingRustTuple<'_> {
                fn from(value: BRIDGEReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for BRIDGEReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for BRIDGECall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = BRIDGEReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Address,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "BRIDGE()";
            const SELECTOR: [u8; 4] = [238u8, 154u8, 49u8, 162u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `CHAIN_ID()` and selector `0x85e1f4d0`.
```solidity
function CHAIN_ID() external view returns (uint256);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct CHAIN_IDCall {}
    ///Container type for the return parameters of the [`CHAIN_ID()`](CHAIN_IDCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct CHAIN_IDReturn {
        pub _0: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<CHAIN_IDCall> for UnderlyingRustTuple<'_> {
                fn from(value: CHAIN_IDCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for CHAIN_IDCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<CHAIN_IDReturn> for UnderlyingRustTuple<'_> {
                fn from(value: CHAIN_IDReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for CHAIN_IDReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for CHAIN_IDCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = CHAIN_IDReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "CHAIN_ID()";
            const SELECTOR: [u8; 4] = [133u8, 225u8, 244u8, 208u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `CHALLENGE_GRACE_PERIOD_BLOCKS()` and selector `0xec4f74ce`.
```solidity
function CHALLENGE_GRACE_PERIOD_BLOCKS() external view returns (uint64);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct CHALLENGE_GRACE_PERIOD_BLOCKSCall {}
    ///Container type for the return parameters of the [`CHALLENGE_GRACE_PERIOD_BLOCKS()`](CHALLENGE_GRACE_PERIOD_BLOCKSCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct CHALLENGE_GRACE_PERIOD_BLOCKSReturn {
        pub _0: u64,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<CHALLENGE_GRACE_PERIOD_BLOCKSCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: CHALLENGE_GRACE_PERIOD_BLOCKSCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for CHALLENGE_GRACE_PERIOD_BLOCKSCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<64>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (u64,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<CHALLENGE_GRACE_PERIOD_BLOCKSReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: CHALLENGE_GRACE_PERIOD_BLOCKSReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for CHALLENGE_GRACE_PERIOD_BLOCKSReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for CHALLENGE_GRACE_PERIOD_BLOCKSCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = CHALLENGE_GRACE_PERIOD_BLOCKSReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Uint<64>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "CHALLENGE_GRACE_PERIOD_BLOCKS()";
            const SELECTOR: [u8; 4] = [236u8, 79u8, 116u8, 206u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `CHALLENGE_PERIOD_BLOCKS()` and selector `0x91ddb285`.
```solidity
function CHALLENGE_PERIOD_BLOCKS() external view returns (uint64);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct CHALLENGE_PERIOD_BLOCKSCall {}
    ///Container type for the return parameters of the [`CHALLENGE_PERIOD_BLOCKS()`](CHALLENGE_PERIOD_BLOCKSCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct CHALLENGE_PERIOD_BLOCKSReturn {
        pub _0: u64,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<CHALLENGE_PERIOD_BLOCKSCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: CHALLENGE_PERIOD_BLOCKSCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for CHALLENGE_PERIOD_BLOCKSCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<64>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (u64,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<CHALLENGE_PERIOD_BLOCKSReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: CHALLENGE_PERIOD_BLOCKSReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for CHALLENGE_PERIOD_BLOCKSReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for CHALLENGE_PERIOD_BLOCKSCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = CHALLENGE_PERIOD_BLOCKSReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Uint<64>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "CHALLENGE_PERIOD_BLOCKS()";
            const SELECTOR: [u8; 4] = [145u8, 221u8, 178u8, 133u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `CONFIRM_PERIOD_BLOCKS()` and selector `0x1047fc52`.
```solidity
function CONFIRM_PERIOD_BLOCKS() external view returns (uint64);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct CONFIRM_PERIOD_BLOCKSCall {}
    ///Container type for the return parameters of the [`CONFIRM_PERIOD_BLOCKS()`](CONFIRM_PERIOD_BLOCKSCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct CONFIRM_PERIOD_BLOCKSReturn {
        pub _0: u64,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<CONFIRM_PERIOD_BLOCKSCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: CONFIRM_PERIOD_BLOCKSCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for CONFIRM_PERIOD_BLOCKSCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<64>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (u64,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<CONFIRM_PERIOD_BLOCKSReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: CONFIRM_PERIOD_BLOCKSReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for CONFIRM_PERIOD_BLOCKSReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for CONFIRM_PERIOD_BLOCKSCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = CONFIRM_PERIOD_BLOCKSReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Uint<64>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "CONFIRM_PERIOD_BLOCKS()";
            const SELECTOR: [u8; 4] = [16u8, 71u8, 252u8, 82u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `DISABLE_VALIDATOR_WHITELIST()` and selector `0xb38d57f0`.
```solidity
function DISABLE_VALIDATOR_WHITELIST() external view returns (bool);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct DISABLE_VALIDATOR_WHITELISTCall {}
    ///Container type for the return parameters of the [`DISABLE_VALIDATOR_WHITELIST()`](DISABLE_VALIDATOR_WHITELISTCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct DISABLE_VALIDATOR_WHITELISTReturn {
        pub _0: bool,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<DISABLE_VALIDATOR_WHITELISTCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: DISABLE_VALIDATOR_WHITELISTCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for DISABLE_VALIDATOR_WHITELISTCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Bool,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (bool,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<DISABLE_VALIDATOR_WHITELISTReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: DISABLE_VALIDATOR_WHITELISTReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for DISABLE_VALIDATOR_WHITELISTReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for DISABLE_VALIDATOR_WHITELISTCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = DISABLE_VALIDATOR_WHITELISTReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Bool,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "DISABLE_VALIDATOR_WHITELIST()";
            const SELECTOR: [u8; 4] = [179u8, 141u8, 87u8, 240u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `EXCESS_STAKE_RECEIVER()` and selector `0x64f4992a`.
```solidity
function EXCESS_STAKE_RECEIVER() external view returns (address);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct EXCESS_STAKE_RECEIVERCall {}
    ///Container type for the return parameters of the [`EXCESS_STAKE_RECEIVER()`](EXCESS_STAKE_RECEIVERCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct EXCESS_STAKE_RECEIVERReturn {
        pub _0: alloy::sol_types::private::Address,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<EXCESS_STAKE_RECEIVERCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: EXCESS_STAKE_RECEIVERCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for EXCESS_STAKE_RECEIVERCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Address,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::Address,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<EXCESS_STAKE_RECEIVERReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: EXCESS_STAKE_RECEIVERReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for EXCESS_STAKE_RECEIVERReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for EXCESS_STAKE_RECEIVERCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = EXCESS_STAKE_RECEIVERReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Address,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "EXCESS_STAKE_RECEIVER()";
            const SELECTOR: [u8; 4] = [100u8, 244u8, 153u8, 42u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `IMPL_BRIDGE()` and selector `0xdae7cb8b`.
```solidity
function IMPL_BRIDGE() external view returns (address);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct IMPL_BRIDGECall {}
    ///Container type for the return parameters of the [`IMPL_BRIDGE()`](IMPL_BRIDGECall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct IMPL_BRIDGEReturn {
        pub _0: alloy::sol_types::private::Address,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<IMPL_BRIDGECall> for UnderlyingRustTuple<'_> {
                fn from(value: IMPL_BRIDGECall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for IMPL_BRIDGECall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Address,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::Address,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<IMPL_BRIDGEReturn> for UnderlyingRustTuple<'_> {
                fn from(value: IMPL_BRIDGEReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for IMPL_BRIDGEReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for IMPL_BRIDGECall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = IMPL_BRIDGEReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Address,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "IMPL_BRIDGE()";
            const SELECTOR: [u8; 4] = [218u8, 231u8, 203u8, 139u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `IMPL_CHALLENGE_MANAGER()` and selector `0x10a662e2`.
```solidity
function IMPL_CHALLENGE_MANAGER() external view returns (address);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct IMPL_CHALLENGE_MANAGERCall {}
    ///Container type for the return parameters of the [`IMPL_CHALLENGE_MANAGER()`](IMPL_CHALLENGE_MANAGERCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct IMPL_CHALLENGE_MANAGERReturn {
        pub _0: alloy::sol_types::private::Address,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<IMPL_CHALLENGE_MANAGERCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: IMPL_CHALLENGE_MANAGERCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for IMPL_CHALLENGE_MANAGERCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Address,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::Address,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<IMPL_CHALLENGE_MANAGERReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: IMPL_CHALLENGE_MANAGERReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for IMPL_CHALLENGE_MANAGERReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for IMPL_CHALLENGE_MANAGERCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = IMPL_CHALLENGE_MANAGERReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Address,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "IMPL_CHALLENGE_MANAGER()";
            const SELECTOR: [u8; 4] = [16u8, 166u8, 98u8, 226u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `IMPL_INBOX()` and selector `0x817cd312`.
```solidity
function IMPL_INBOX() external view returns (address);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct IMPL_INBOXCall {}
    ///Container type for the return parameters of the [`IMPL_INBOX()`](IMPL_INBOXCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct IMPL_INBOXReturn {
        pub _0: alloy::sol_types::private::Address,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<IMPL_INBOXCall> for UnderlyingRustTuple<'_> {
                fn from(value: IMPL_INBOXCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for IMPL_INBOXCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Address,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::Address,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<IMPL_INBOXReturn> for UnderlyingRustTuple<'_> {
                fn from(value: IMPL_INBOXReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for IMPL_INBOXReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for IMPL_INBOXCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = IMPL_INBOXReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Address,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "IMPL_INBOX()";
            const SELECTOR: [u8; 4] = [129u8, 124u8, 211u8, 18u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `IMPL_NEW_ROLLUP_ADMIN()` and selector `0x00f9731e`.
```solidity
function IMPL_NEW_ROLLUP_ADMIN() external view returns (address);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct IMPL_NEW_ROLLUP_ADMINCall {}
    ///Container type for the return parameters of the [`IMPL_NEW_ROLLUP_ADMIN()`](IMPL_NEW_ROLLUP_ADMINCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct IMPL_NEW_ROLLUP_ADMINReturn {
        pub _0: alloy::sol_types::private::Address,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<IMPL_NEW_ROLLUP_ADMINCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: IMPL_NEW_ROLLUP_ADMINCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for IMPL_NEW_ROLLUP_ADMINCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Address,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::Address,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<IMPL_NEW_ROLLUP_ADMINReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: IMPL_NEW_ROLLUP_ADMINReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for IMPL_NEW_ROLLUP_ADMINReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for IMPL_NEW_ROLLUP_ADMINCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = IMPL_NEW_ROLLUP_ADMINReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Address,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "IMPL_NEW_ROLLUP_ADMIN()";
            const SELECTOR: [u8; 4] = [0u8, 249u8, 115u8, 30u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `IMPL_NEW_ROLLUP_USER()` and selector `0x4692de5d`.
```solidity
function IMPL_NEW_ROLLUP_USER() external view returns (address);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct IMPL_NEW_ROLLUP_USERCall {}
    ///Container type for the return parameters of the [`IMPL_NEW_ROLLUP_USER()`](IMPL_NEW_ROLLUP_USERCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct IMPL_NEW_ROLLUP_USERReturn {
        pub _0: alloy::sol_types::private::Address,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<IMPL_NEW_ROLLUP_USERCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: IMPL_NEW_ROLLUP_USERCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for IMPL_NEW_ROLLUP_USERCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Address,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::Address,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<IMPL_NEW_ROLLUP_USERReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: IMPL_NEW_ROLLUP_USERReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for IMPL_NEW_ROLLUP_USERReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for IMPL_NEW_ROLLUP_USERCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = IMPL_NEW_ROLLUP_USERReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Address,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "IMPL_NEW_ROLLUP_USER()";
            const SELECTOR: [u8; 4] = [70u8, 146u8, 222u8, 93u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `IMPL_OUTBOX()` and selector `0xc897f55e`.
```solidity
function IMPL_OUTBOX() external view returns (address);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct IMPL_OUTBOXCall {}
    ///Container type for the return parameters of the [`IMPL_OUTBOX()`](IMPL_OUTBOXCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct IMPL_OUTBOXReturn {
        pub _0: alloy::sol_types::private::Address,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<IMPL_OUTBOXCall> for UnderlyingRustTuple<'_> {
                fn from(value: IMPL_OUTBOXCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for IMPL_OUTBOXCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Address,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::Address,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<IMPL_OUTBOXReturn> for UnderlyingRustTuple<'_> {
                fn from(value: IMPL_OUTBOXReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for IMPL_OUTBOXReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for IMPL_OUTBOXCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = IMPL_OUTBOXReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Address,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "IMPL_OUTBOX()";
            const SELECTOR: [u8; 4] = [200u8, 151u8, 245u8, 94u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `IMPL_REI()` and selector `0xc21c4233`.
```solidity
function IMPL_REI() external view returns (address);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct IMPL_REICall {}
    ///Container type for the return parameters of the [`IMPL_REI()`](IMPL_REICall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct IMPL_REIReturn {
        pub _0: alloy::sol_types::private::Address,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<IMPL_REICall> for UnderlyingRustTuple<'_> {
                fn from(value: IMPL_REICall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for IMPL_REICall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Address,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::Address,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<IMPL_REIReturn> for UnderlyingRustTuple<'_> {
                fn from(value: IMPL_REIReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for IMPL_REIReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for IMPL_REICall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = IMPL_REIReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Address,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "IMPL_REI()";
            const SELECTOR: [u8; 4] = [194u8, 28u8, 66u8, 51u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `IMPL_SEQUENCER_INBOX()` and selector `0xc519d151`.
```solidity
function IMPL_SEQUENCER_INBOX() external view returns (address);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct IMPL_SEQUENCER_INBOXCall {}
    ///Container type for the return parameters of the [`IMPL_SEQUENCER_INBOX()`](IMPL_SEQUENCER_INBOXCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct IMPL_SEQUENCER_INBOXReturn {
        pub _0: alloy::sol_types::private::Address,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<IMPL_SEQUENCER_INBOXCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: IMPL_SEQUENCER_INBOXCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for IMPL_SEQUENCER_INBOXCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Address,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::Address,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<IMPL_SEQUENCER_INBOXReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: IMPL_SEQUENCER_INBOXReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for IMPL_SEQUENCER_INBOXReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for IMPL_SEQUENCER_INBOXCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = IMPL_SEQUENCER_INBOXReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Address,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "IMPL_SEQUENCER_INBOX()";
            const SELECTOR: [u8; 4] = [197u8, 25u8, 209u8, 81u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `INBOX()` and selector `0xb7010697`.
```solidity
function INBOX() external view returns (address);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct INBOXCall {}
    ///Container type for the return parameters of the [`INBOX()`](INBOXCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct INBOXReturn {
        pub _0: alloy::sol_types::private::Address,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<INBOXCall> for UnderlyingRustTuple<'_> {
                fn from(value: INBOXCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for INBOXCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Address,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::Address,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<INBOXReturn> for UnderlyingRustTuple<'_> {
                fn from(value: INBOXReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for INBOXReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for INBOXCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = INBOXReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Address,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "INBOX()";
            const SELECTOR: [u8; 4] = [183u8, 1u8, 6u8, 151u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `IS_DELAY_BUFFERABLE()` and selector `0xe8180c29`.
```solidity
function IS_DELAY_BUFFERABLE() external view returns (bool);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct IS_DELAY_BUFFERABLECall {}
    ///Container type for the return parameters of the [`IS_DELAY_BUFFERABLE()`](IS_DELAY_BUFFERABLECall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct IS_DELAY_BUFFERABLEReturn {
        pub _0: bool,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<IS_DELAY_BUFFERABLECall>
            for UnderlyingRustTuple<'_> {
                fn from(value: IS_DELAY_BUFFERABLECall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for IS_DELAY_BUFFERABLECall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Bool,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (bool,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<IS_DELAY_BUFFERABLEReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: IS_DELAY_BUFFERABLEReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for IS_DELAY_BUFFERABLEReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for IS_DELAY_BUFFERABLECall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = IS_DELAY_BUFFERABLEReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Bool,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "IS_DELAY_BUFFERABLE()";
            const SELECTOR: [u8; 4] = [232u8, 24u8, 12u8, 41u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `MAX()` and selector `0xd49d5181`.
```solidity
function MAX() external view returns (uint64);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct MAXCall {}
    ///Container type for the return parameters of the [`MAX()`](MAXCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct MAXReturn {
        pub _0: u64,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<MAXCall> for UnderlyingRustTuple<'_> {
                fn from(value: MAXCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for MAXCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<64>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (u64,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<MAXReturn> for UnderlyingRustTuple<'_> {
                fn from(value: MAXReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for MAXReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for MAXCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = MAXReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Uint<64>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "MAX()";
            const SELECTOR: [u8; 4] = [212u8, 157u8, 81u8, 129u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `MINIMUM_ASSERTION_PERIOD()` and selector `0x003c78fb`.
```solidity
function MINIMUM_ASSERTION_PERIOD() external view returns (uint256);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct MINIMUM_ASSERTION_PERIODCall {}
    ///Container type for the return parameters of the [`MINIMUM_ASSERTION_PERIOD()`](MINIMUM_ASSERTION_PERIODCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct MINIMUM_ASSERTION_PERIODReturn {
        pub _0: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<MINIMUM_ASSERTION_PERIODCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: MINIMUM_ASSERTION_PERIODCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for MINIMUM_ASSERTION_PERIODCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<MINIMUM_ASSERTION_PERIODReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: MINIMUM_ASSERTION_PERIODReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for MINIMUM_ASSERTION_PERIODReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for MINIMUM_ASSERTION_PERIODCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = MINIMUM_ASSERTION_PERIODReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "MINIMUM_ASSERTION_PERIOD()";
            const SELECTOR: [u8; 4] = [0u8, 60u8, 120u8, 251u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `MINI_STAKE_AMOUNTS_STORAGE()` and selector `0xb5e00c3f`.
```solidity
function MINI_STAKE_AMOUNTS_STORAGE() external view returns (address);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct MINI_STAKE_AMOUNTS_STORAGECall {}
    ///Container type for the return parameters of the [`MINI_STAKE_AMOUNTS_STORAGE()`](MINI_STAKE_AMOUNTS_STORAGECall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct MINI_STAKE_AMOUNTS_STORAGEReturn {
        pub _0: alloy::sol_types::private::Address,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<MINI_STAKE_AMOUNTS_STORAGECall>
            for UnderlyingRustTuple<'_> {
                fn from(value: MINI_STAKE_AMOUNTS_STORAGECall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for MINI_STAKE_AMOUNTS_STORAGECall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Address,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::Address,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<MINI_STAKE_AMOUNTS_STORAGEReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: MINI_STAKE_AMOUNTS_STORAGEReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for MINI_STAKE_AMOUNTS_STORAGEReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for MINI_STAKE_AMOUNTS_STORAGECall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = MINI_STAKE_AMOUNTS_STORAGEReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Address,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "MINI_STAKE_AMOUNTS_STORAGE()";
            const SELECTOR: [u8; 4] = [181u8, 224u8, 12u8, 63u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `NUM_BIGSTEP_LEVEL()` and selector `0x5d9e2444`.
```solidity
function NUM_BIGSTEP_LEVEL() external view returns (uint8);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct NUM_BIGSTEP_LEVELCall {}
    ///Container type for the return parameters of the [`NUM_BIGSTEP_LEVEL()`](NUM_BIGSTEP_LEVELCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct NUM_BIGSTEP_LEVELReturn {
        pub _0: u8,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<NUM_BIGSTEP_LEVELCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: NUM_BIGSTEP_LEVELCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for NUM_BIGSTEP_LEVELCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<8>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (u8,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<NUM_BIGSTEP_LEVELReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: NUM_BIGSTEP_LEVELReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for NUM_BIGSTEP_LEVELReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for NUM_BIGSTEP_LEVELCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = NUM_BIGSTEP_LEVELReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Uint<8>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "NUM_BIGSTEP_LEVEL()";
            const SELECTOR: [u8; 4] = [93u8, 158u8, 36u8, 68u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `OLD_ROLLUP()` and selector `0x8765240f`.
```solidity
function OLD_ROLLUP() external view returns (address);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct OLD_ROLLUPCall {}
    ///Container type for the return parameters of the [`OLD_ROLLUP()`](OLD_ROLLUPCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct OLD_ROLLUPReturn {
        pub _0: alloy::sol_types::private::Address,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<OLD_ROLLUPCall> for UnderlyingRustTuple<'_> {
                fn from(value: OLD_ROLLUPCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for OLD_ROLLUPCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Address,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::Address,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<OLD_ROLLUPReturn> for UnderlyingRustTuple<'_> {
                fn from(value: OLD_ROLLUPReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for OLD_ROLLUPReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for OLD_ROLLUPCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = OLD_ROLLUPReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Address,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "OLD_ROLLUP()";
            const SELECTOR: [u8; 4] = [135u8, 101u8, 36u8, 15u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `OSP()` and selector `0x9f9854e5`.
```solidity
function OSP() external view returns (address);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct OSPCall {}
    ///Container type for the return parameters of the [`OSP()`](OSPCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct OSPReturn {
        pub _0: alloy::sol_types::private::Address,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<OSPCall> for UnderlyingRustTuple<'_> {
                fn from(value: OSPCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for OSPCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Address,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::Address,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<OSPReturn> for UnderlyingRustTuple<'_> {
                fn from(value: OSPReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for OSPReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for OSPCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = OSPReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Address,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "OSP()";
            const SELECTOR: [u8; 4] = [159u8, 152u8, 84u8, 229u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `OUTBOX()` and selector `0x1b142ea7`.
```solidity
function OUTBOX() external view returns (address);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct OUTBOXCall {}
    ///Container type for the return parameters of the [`OUTBOX()`](OUTBOXCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct OUTBOXReturn {
        pub _0: alloy::sol_types::private::Address,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<OUTBOXCall> for UnderlyingRustTuple<'_> {
                fn from(value: OUTBOXCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for OUTBOXCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Address,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::Address,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<OUTBOXReturn> for UnderlyingRustTuple<'_> {
                fn from(value: OUTBOXReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for OUTBOXReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for OUTBOXCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = OUTBOXReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Address,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "OUTBOX()";
            const SELECTOR: [u8; 4] = [27u8, 20u8, 46u8, 167u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `PREIMAGE_LOOKUP()` and selector `0xcc8089bb`.
```solidity
function PREIMAGE_LOOKUP() external view returns (address);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct PREIMAGE_LOOKUPCall {}
    ///Container type for the return parameters of the [`PREIMAGE_LOOKUP()`](PREIMAGE_LOOKUPCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct PREIMAGE_LOOKUPReturn {
        pub _0: alloy::sol_types::private::Address,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<PREIMAGE_LOOKUPCall> for UnderlyingRustTuple<'_> {
                fn from(value: PREIMAGE_LOOKUPCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for PREIMAGE_LOOKUPCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Address,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::Address,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<PREIMAGE_LOOKUPReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: PREIMAGE_LOOKUPReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for PREIMAGE_LOOKUPReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for PREIMAGE_LOOKUPCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = PREIMAGE_LOOKUPReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Address,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "PREIMAGE_LOOKUP()";
            const SELECTOR: [u8; 4] = [204u8, 128u8, 137u8, 187u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `PROXY_ADMIN_BRIDGE()` and selector `0x0a54257d`.
```solidity
function PROXY_ADMIN_BRIDGE() external view returns (address);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct PROXY_ADMIN_BRIDGECall {}
    ///Container type for the return parameters of the [`PROXY_ADMIN_BRIDGE()`](PROXY_ADMIN_BRIDGECall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct PROXY_ADMIN_BRIDGEReturn {
        pub _0: alloy::sol_types::private::Address,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<PROXY_ADMIN_BRIDGECall>
            for UnderlyingRustTuple<'_> {
                fn from(value: PROXY_ADMIN_BRIDGECall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for PROXY_ADMIN_BRIDGECall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Address,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::Address,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<PROXY_ADMIN_BRIDGEReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: PROXY_ADMIN_BRIDGEReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for PROXY_ADMIN_BRIDGEReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for PROXY_ADMIN_BRIDGECall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = PROXY_ADMIN_BRIDGEReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Address,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "PROXY_ADMIN_BRIDGE()";
            const SELECTOR: [u8; 4] = [10u8, 84u8, 37u8, 125u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `PROXY_ADMIN_INBOX()` and selector `0x4b2f51ef`.
```solidity
function PROXY_ADMIN_INBOX() external view returns (address);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct PROXY_ADMIN_INBOXCall {}
    ///Container type for the return parameters of the [`PROXY_ADMIN_INBOX()`](PROXY_ADMIN_INBOXCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct PROXY_ADMIN_INBOXReturn {
        pub _0: alloy::sol_types::private::Address,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<PROXY_ADMIN_INBOXCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: PROXY_ADMIN_INBOXCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for PROXY_ADMIN_INBOXCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Address,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::Address,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<PROXY_ADMIN_INBOXReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: PROXY_ADMIN_INBOXReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for PROXY_ADMIN_INBOXReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for PROXY_ADMIN_INBOXCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = PROXY_ADMIN_INBOXReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Address,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "PROXY_ADMIN_INBOX()";
            const SELECTOR: [u8; 4] = [75u8, 47u8, 81u8, 239u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `PROXY_ADMIN_OUTBOX()` and selector `0x0787484b`.
```solidity
function PROXY_ADMIN_OUTBOX() external view returns (address);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct PROXY_ADMIN_OUTBOXCall {}
    ///Container type for the return parameters of the [`PROXY_ADMIN_OUTBOX()`](PROXY_ADMIN_OUTBOXCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct PROXY_ADMIN_OUTBOXReturn {
        pub _0: alloy::sol_types::private::Address,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<PROXY_ADMIN_OUTBOXCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: PROXY_ADMIN_OUTBOXCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for PROXY_ADMIN_OUTBOXCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Address,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::Address,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<PROXY_ADMIN_OUTBOXReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: PROXY_ADMIN_OUTBOXReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for PROXY_ADMIN_OUTBOXReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for PROXY_ADMIN_OUTBOXCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = PROXY_ADMIN_OUTBOXReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Address,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "PROXY_ADMIN_OUTBOX()";
            const SELECTOR: [u8; 4] = [7u8, 135u8, 72u8, 75u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `PROXY_ADMIN_REI()` and selector `0x3c2b7840`.
```solidity
function PROXY_ADMIN_REI() external view returns (address);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct PROXY_ADMIN_REICall {}
    ///Container type for the return parameters of the [`PROXY_ADMIN_REI()`](PROXY_ADMIN_REICall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct PROXY_ADMIN_REIReturn {
        pub _0: alloy::sol_types::private::Address,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<PROXY_ADMIN_REICall> for UnderlyingRustTuple<'_> {
                fn from(value: PROXY_ADMIN_REICall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for PROXY_ADMIN_REICall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Address,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::Address,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<PROXY_ADMIN_REIReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: PROXY_ADMIN_REIReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for PROXY_ADMIN_REIReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for PROXY_ADMIN_REICall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = PROXY_ADMIN_REIReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Address,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "PROXY_ADMIN_REI()";
            const SELECTOR: [u8; 4] = [60u8, 43u8, 120u8, 64u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `PROXY_ADMIN_SEQUENCER_INBOX()` and selector `0x2cfb7ca3`.
```solidity
function PROXY_ADMIN_SEQUENCER_INBOX() external view returns (address);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct PROXY_ADMIN_SEQUENCER_INBOXCall {}
    ///Container type for the return parameters of the [`PROXY_ADMIN_SEQUENCER_INBOX()`](PROXY_ADMIN_SEQUENCER_INBOXCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct PROXY_ADMIN_SEQUENCER_INBOXReturn {
        pub _0: alloy::sol_types::private::Address,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<PROXY_ADMIN_SEQUENCER_INBOXCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: PROXY_ADMIN_SEQUENCER_INBOXCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for PROXY_ADMIN_SEQUENCER_INBOXCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Address,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::Address,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<PROXY_ADMIN_SEQUENCER_INBOXReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: PROXY_ADMIN_SEQUENCER_INBOXReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for PROXY_ADMIN_SEQUENCER_INBOXReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for PROXY_ADMIN_SEQUENCER_INBOXCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = PROXY_ADMIN_SEQUENCER_INBOXReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Address,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "PROXY_ADMIN_SEQUENCER_INBOX()";
            const SELECTOR: [u8; 4] = [44u8, 251u8, 124u8, 163u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `REI()` and selector `0xbe41b367`.
```solidity
function REI() external view returns (address);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct REICall {}
    ///Container type for the return parameters of the [`REI()`](REICall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct REIReturn {
        pub _0: alloy::sol_types::private::Address,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<REICall> for UnderlyingRustTuple<'_> {
                fn from(value: REICall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for REICall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Address,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::Address,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<REIReturn> for UnderlyingRustTuple<'_> {
                fn from(value: REIReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for REIReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for REICall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = REIReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Address,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "REI()";
            const SELECTOR: [u8; 4] = [190u8, 65u8, 179u8, 103u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `REPLENISH_RATE_IN_BASIS()` and selector `0xeb657a4e`.
```solidity
function REPLENISH_RATE_IN_BASIS() external view returns (uint64);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct REPLENISH_RATE_IN_BASISCall {}
    ///Container type for the return parameters of the [`REPLENISH_RATE_IN_BASIS()`](REPLENISH_RATE_IN_BASISCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct REPLENISH_RATE_IN_BASISReturn {
        pub _0: u64,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<REPLENISH_RATE_IN_BASISCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: REPLENISH_RATE_IN_BASISCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for REPLENISH_RATE_IN_BASISCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<64>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (u64,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<REPLENISH_RATE_IN_BASISReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: REPLENISH_RATE_IN_BASISReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for REPLENISH_RATE_IN_BASISReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for REPLENISH_RATE_IN_BASISCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = REPLENISH_RATE_IN_BASISReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Uint<64>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "REPLENISH_RATE_IN_BASIS()";
            const SELECTOR: [u8; 4] = [235u8, 101u8, 122u8, 78u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `SECONDS_PER_SLOT()` and selector `0x304b9071`.
```solidity
function SECONDS_PER_SLOT() external view returns (uint256);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct SECONDS_PER_SLOTCall {}
    ///Container type for the return parameters of the [`SECONDS_PER_SLOT()`](SECONDS_PER_SLOTCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct SECONDS_PER_SLOTReturn {
        pub _0: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<SECONDS_PER_SLOTCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: SECONDS_PER_SLOTCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for SECONDS_PER_SLOTCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<SECONDS_PER_SLOTReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: SECONDS_PER_SLOTReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for SECONDS_PER_SLOTReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for SECONDS_PER_SLOTCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = SECONDS_PER_SLOTReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "SECONDS_PER_SLOT()";
            const SELECTOR: [u8; 4] = [48u8, 75u8, 144u8, 113u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `SEQ_INBOX()` and selector `0xd384cb95`.
```solidity
function SEQ_INBOX() external view returns (address);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct SEQ_INBOXCall {}
    ///Container type for the return parameters of the [`SEQ_INBOX()`](SEQ_INBOXCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct SEQ_INBOXReturn {
        pub _0: alloy::sol_types::private::Address,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<SEQ_INBOXCall> for UnderlyingRustTuple<'_> {
                fn from(value: SEQ_INBOXCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for SEQ_INBOXCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Address,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::Address,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<SEQ_INBOXReturn> for UnderlyingRustTuple<'_> {
                fn from(value: SEQ_INBOXReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for SEQ_INBOXReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for SEQ_INBOXCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = SEQ_INBOXReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Address,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "SEQ_INBOX()";
            const SELECTOR: [u8; 4] = [211u8, 132u8, 203u8, 149u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `SMALLSTEP_LEAF_SIZE()` and selector `0xfa287420`.
```solidity
function SMALLSTEP_LEAF_SIZE() external view returns (uint256);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct SMALLSTEP_LEAF_SIZECall {}
    ///Container type for the return parameters of the [`SMALLSTEP_LEAF_SIZE()`](SMALLSTEP_LEAF_SIZECall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct SMALLSTEP_LEAF_SIZEReturn {
        pub _0: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<SMALLSTEP_LEAF_SIZECall>
            for UnderlyingRustTuple<'_> {
                fn from(value: SMALLSTEP_LEAF_SIZECall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for SMALLSTEP_LEAF_SIZECall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<SMALLSTEP_LEAF_SIZEReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: SMALLSTEP_LEAF_SIZEReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for SMALLSTEP_LEAF_SIZEReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for SMALLSTEP_LEAF_SIZECall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = SMALLSTEP_LEAF_SIZEReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "SMALLSTEP_LEAF_SIZE()";
            const SELECTOR: [u8; 4] = [250u8, 40u8, 116u8, 32u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `STAKE_AMOUNT()` and selector `0xfaf5625f`.
```solidity
function STAKE_AMOUNT() external view returns (uint256);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct STAKE_AMOUNTCall {}
    ///Container type for the return parameters of the [`STAKE_AMOUNT()`](STAKE_AMOUNTCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct STAKE_AMOUNTReturn {
        pub _0: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<STAKE_AMOUNTCall> for UnderlyingRustTuple<'_> {
                fn from(value: STAKE_AMOUNTCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for STAKE_AMOUNTCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<STAKE_AMOUNTReturn> for UnderlyingRustTuple<'_> {
                fn from(value: STAKE_AMOUNTReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for STAKE_AMOUNTReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for STAKE_AMOUNTCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = STAKE_AMOUNTReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "STAKE_AMOUNT()";
            const SELECTOR: [u8; 4] = [250u8, 245u8, 98u8, 95u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `STAKE_TOKEN()` and selector `0x1c39b672`.
```solidity
function STAKE_TOKEN() external view returns (address);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct STAKE_TOKENCall {}
    ///Container type for the return parameters of the [`STAKE_TOKEN()`](STAKE_TOKENCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct STAKE_TOKENReturn {
        pub _0: alloy::sol_types::private::Address,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<STAKE_TOKENCall> for UnderlyingRustTuple<'_> {
                fn from(value: STAKE_TOKENCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for STAKE_TOKENCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Address,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::Address,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<STAKE_TOKENReturn> for UnderlyingRustTuple<'_> {
                fn from(value: STAKE_TOKENReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for STAKE_TOKENReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for STAKE_TOKENCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = STAKE_TOKENReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Address,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "STAKE_TOKEN()";
            const SELECTOR: [u8; 4] = [28u8, 57u8, 182u8, 114u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `THRESHOLD()` and selector `0x785ffb37`.
```solidity
function THRESHOLD() external view returns (uint64);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct THRESHOLDCall {}
    ///Container type for the return parameters of the [`THRESHOLD()`](THRESHOLDCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct THRESHOLDReturn {
        pub _0: u64,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<THRESHOLDCall> for UnderlyingRustTuple<'_> {
                fn from(value: THRESHOLDCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for THRESHOLDCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<64>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (u64,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<THRESHOLDReturn> for UnderlyingRustTuple<'_> {
                fn from(value: THRESHOLDReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for THRESHOLDReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for THRESHOLDCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = THRESHOLDReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Uint<64>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "THRESHOLD()";
            const SELECTOR: [u8; 4] = [120u8, 95u8, 251u8, 55u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `VALIDATOR_AFK_BLOCKS()` and selector `0x4ceccfe5`.
```solidity
function VALIDATOR_AFK_BLOCKS() external view returns (uint64);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct VALIDATOR_AFK_BLOCKSCall {}
    ///Container type for the return parameters of the [`VALIDATOR_AFK_BLOCKS()`](VALIDATOR_AFK_BLOCKSCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct VALIDATOR_AFK_BLOCKSReturn {
        pub _0: u64,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<VALIDATOR_AFK_BLOCKSCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: VALIDATOR_AFK_BLOCKSCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for VALIDATOR_AFK_BLOCKSCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<64>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (u64,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<VALIDATOR_AFK_BLOCKSReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: VALIDATOR_AFK_BLOCKSReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for VALIDATOR_AFK_BLOCKSReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for VALIDATOR_AFK_BLOCKSCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = VALIDATOR_AFK_BLOCKSReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Uint<64>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "VALIDATOR_AFK_BLOCKS()";
            const SELECTOR: [u8; 4] = [76u8, 236u8, 207u8, 229u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `expectedRollupAddress(address,uint256)` and selector `0x28fb228c`.
```solidity
function expectedRollupAddress(address deployer, uint256 chainId) external pure returns (address);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct expectedRollupAddressCall {
        pub deployer: alloy::sol_types::private::Address,
        pub chainId: alloy::sol_types::private::primitives::aliases::U256,
    }
    ///Container type for the return parameters of the [`expectedRollupAddress(address,uint256)`](expectedRollupAddressCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct expectedRollupAddressReturn {
        pub _0: alloy::sol_types::private::Address,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Uint<256>,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::Address,
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<expectedRollupAddressCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: expectedRollupAddressCall) -> Self {
                    (value.deployer, value.chainId)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for expectedRollupAddressCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        deployer: tuple.0,
                        chainId: tuple.1,
                    }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Address,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::Address,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<expectedRollupAddressReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: expectedRollupAddressReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for expectedRollupAddressReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for expectedRollupAddressCall {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Uint<256>,
            );
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = expectedRollupAddressReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Address,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "expectedRollupAddress(address,uint256)";
            const SELECTOR: [u8; 4] = [40u8, 251u8, 34u8, 140u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.deployer,
                    ),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.chainId),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `perform(address[])` and selector `0xebe03a93`.
```solidity
function perform(address[] memory validators) external;
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct performCall {
        pub validators: alloy::sol_types::private::Vec<
            alloy::sol_types::private::Address,
        >,
    }
    ///Container type for the return parameters of the [`perform(address[])`](performCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct performReturn {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::Array<alloy::sol_types::sol_data::Address>,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::Vec<alloy::sol_types::private::Address>,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<performCall> for UnderlyingRustTuple<'_> {
                fn from(value: performCall) -> Self {
                    (value.validators,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for performCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { validators: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<performReturn> for UnderlyingRustTuple<'_> {
                fn from(value: performReturn) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for performReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for performCall {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::Array<alloy::sol_types::sol_data::Address>,
            );
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = performReturn;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "perform(address[])";
            const SELECTOR: [u8; 4] = [235u8, 224u8, 58u8, 147u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Array<
                        alloy::sol_types::sol_data::Address,
                    > as alloy_sol_types::SolType>::tokenize(&self.validators),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `validateRollupDeployedAtAddress(address,address,uint256)` and selector `0x999f20db`.
```solidity
function validateRollupDeployedAtAddress(address rollupAddress, address deployer, uint256 chainId) external view;
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct validateRollupDeployedAtAddressCall {
        pub rollupAddress: alloy::sol_types::private::Address,
        pub deployer: alloy::sol_types::private::Address,
        pub chainId: alloy::sol_types::private::primitives::aliases::U256,
    }
    ///Container type for the return parameters of the [`validateRollupDeployedAtAddress(address,address,uint256)`](validateRollupDeployedAtAddressCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct validateRollupDeployedAtAddressReturn {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Uint<256>,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::Address,
                alloy::sol_types::private::Address,
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<validateRollupDeployedAtAddressCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: validateRollupDeployedAtAddressCall) -> Self {
                    (value.rollupAddress, value.deployer, value.chainId)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for validateRollupDeployedAtAddressCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        rollupAddress: tuple.0,
                        deployer: tuple.1,
                        chainId: tuple.2,
                    }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<validateRollupDeployedAtAddressReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: validateRollupDeployedAtAddressReturn) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for validateRollupDeployedAtAddressReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for validateRollupDeployedAtAddressCall {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Uint<256>,
            );
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = validateRollupDeployedAtAddressReturn;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "validateRollupDeployedAtAddress(address,address,uint256)";
            const SELECTOR: [u8; 4] = [153u8, 159u8, 32u8, 219u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.rollupAddress,
                    ),
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.deployer,
                    ),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.chainId),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    ///Container for all the [`BOLDUpgradeAction`](self) function calls.
    pub enum BOLDUpgradeActionCalls {
        BIGSTEP_LEAF_SIZE(BIGSTEP_LEAF_SIZECall),
        BLOCK_LEAF_SIZE(BLOCK_LEAF_SIZECall),
        BRIDGE(BRIDGECall),
        CHAIN_ID(CHAIN_IDCall),
        CHALLENGE_GRACE_PERIOD_BLOCKS(CHALLENGE_GRACE_PERIOD_BLOCKSCall),
        CHALLENGE_PERIOD_BLOCKS(CHALLENGE_PERIOD_BLOCKSCall),
        CONFIRM_PERIOD_BLOCKS(CONFIRM_PERIOD_BLOCKSCall),
        DISABLE_VALIDATOR_WHITELIST(DISABLE_VALIDATOR_WHITELISTCall),
        EXCESS_STAKE_RECEIVER(EXCESS_STAKE_RECEIVERCall),
        IMPL_BRIDGE(IMPL_BRIDGECall),
        IMPL_CHALLENGE_MANAGER(IMPL_CHALLENGE_MANAGERCall),
        IMPL_INBOX(IMPL_INBOXCall),
        IMPL_NEW_ROLLUP_ADMIN(IMPL_NEW_ROLLUP_ADMINCall),
        IMPL_NEW_ROLLUP_USER(IMPL_NEW_ROLLUP_USERCall),
        IMPL_OUTBOX(IMPL_OUTBOXCall),
        IMPL_REI(IMPL_REICall),
        IMPL_SEQUENCER_INBOX(IMPL_SEQUENCER_INBOXCall),
        INBOX(INBOXCall),
        IS_DELAY_BUFFERABLE(IS_DELAY_BUFFERABLECall),
        MAX(MAXCall),
        MINIMUM_ASSERTION_PERIOD(MINIMUM_ASSERTION_PERIODCall),
        MINI_STAKE_AMOUNTS_STORAGE(MINI_STAKE_AMOUNTS_STORAGECall),
        NUM_BIGSTEP_LEVEL(NUM_BIGSTEP_LEVELCall),
        OLD_ROLLUP(OLD_ROLLUPCall),
        OSP(OSPCall),
        OUTBOX(OUTBOXCall),
        PREIMAGE_LOOKUP(PREIMAGE_LOOKUPCall),
        PROXY_ADMIN_BRIDGE(PROXY_ADMIN_BRIDGECall),
        PROXY_ADMIN_INBOX(PROXY_ADMIN_INBOXCall),
        PROXY_ADMIN_OUTBOX(PROXY_ADMIN_OUTBOXCall),
        PROXY_ADMIN_REI(PROXY_ADMIN_REICall),
        PROXY_ADMIN_SEQUENCER_INBOX(PROXY_ADMIN_SEQUENCER_INBOXCall),
        REI(REICall),
        REPLENISH_RATE_IN_BASIS(REPLENISH_RATE_IN_BASISCall),
        SECONDS_PER_SLOT(SECONDS_PER_SLOTCall),
        SEQ_INBOX(SEQ_INBOXCall),
        SMALLSTEP_LEAF_SIZE(SMALLSTEP_LEAF_SIZECall),
        STAKE_AMOUNT(STAKE_AMOUNTCall),
        STAKE_TOKEN(STAKE_TOKENCall),
        THRESHOLD(THRESHOLDCall),
        VALIDATOR_AFK_BLOCKS(VALIDATOR_AFK_BLOCKSCall),
        expectedRollupAddress(expectedRollupAddressCall),
        perform(performCall),
        validateRollupDeployedAtAddress(validateRollupDeployedAtAddressCall),
    }
    #[automatically_derived]
    impl BOLDUpgradeActionCalls {
        /// All the selectors of this enum.
        ///
        /// Note that the selectors might not be in the same order as the variants.
        /// No guarantees are made about the order of the selectors.
        ///
        /// Prefer using `SolInterface` methods instead.
        pub const SELECTORS: &'static [[u8; 4usize]] = &[
            [0u8, 60u8, 120u8, 251u8],
            [0u8, 249u8, 115u8, 30u8],
            [7u8, 135u8, 72u8, 75u8],
            [10u8, 84u8, 37u8, 125u8],
            [16u8, 71u8, 252u8, 82u8],
            [16u8, 166u8, 98u8, 226u8],
            [27u8, 20u8, 46u8, 167u8],
            [28u8, 57u8, 182u8, 114u8],
            [28u8, 204u8, 44u8, 209u8],
            [40u8, 251u8, 34u8, 140u8],
            [44u8, 251u8, 124u8, 163u8],
            [48u8, 75u8, 144u8, 113u8],
            [60u8, 43u8, 120u8, 64u8],
            [70u8, 146u8, 222u8, 93u8],
            [75u8, 47u8, 81u8, 239u8],
            [76u8, 236u8, 207u8, 229u8],
            [93u8, 158u8, 36u8, 68u8],
            [96u8, 159u8, 181u8, 3u8],
            [100u8, 244u8, 153u8, 42u8],
            [120u8, 95u8, 251u8, 55u8],
            [129u8, 124u8, 211u8, 18u8],
            [133u8, 225u8, 244u8, 208u8],
            [135u8, 101u8, 36u8, 15u8],
            [145u8, 221u8, 178u8, 133u8],
            [153u8, 159u8, 32u8, 219u8],
            [159u8, 152u8, 84u8, 229u8],
            [179u8, 141u8, 87u8, 240u8],
            [181u8, 224u8, 12u8, 63u8],
            [183u8, 1u8, 6u8, 151u8],
            [190u8, 65u8, 179u8, 103u8],
            [194u8, 28u8, 66u8, 51u8],
            [197u8, 25u8, 209u8, 81u8],
            [200u8, 151u8, 245u8, 94u8],
            [204u8, 128u8, 137u8, 187u8],
            [211u8, 132u8, 203u8, 149u8],
            [212u8, 157u8, 81u8, 129u8],
            [218u8, 231u8, 203u8, 139u8],
            [232u8, 24u8, 12u8, 41u8],
            [235u8, 101u8, 122u8, 78u8],
            [235u8, 224u8, 58u8, 147u8],
            [236u8, 79u8, 116u8, 206u8],
            [238u8, 154u8, 49u8, 162u8],
            [250u8, 40u8, 116u8, 32u8],
            [250u8, 245u8, 98u8, 95u8],
        ];
    }
    #[automatically_derived]
    impl alloy_sol_types::SolInterface for BOLDUpgradeActionCalls {
        const NAME: &'static str = "BOLDUpgradeActionCalls";
        const MIN_DATA_LENGTH: usize = 0usize;
        const COUNT: usize = 44usize;
        #[inline]
        fn selector(&self) -> [u8; 4] {
            match self {
                Self::BIGSTEP_LEAF_SIZE(_) => {
                    <BIGSTEP_LEAF_SIZECall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::BLOCK_LEAF_SIZE(_) => {
                    <BLOCK_LEAF_SIZECall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::BRIDGE(_) => <BRIDGECall as alloy_sol_types::SolCall>::SELECTOR,
                Self::CHAIN_ID(_) => <CHAIN_IDCall as alloy_sol_types::SolCall>::SELECTOR,
                Self::CHALLENGE_GRACE_PERIOD_BLOCKS(_) => {
                    <CHALLENGE_GRACE_PERIOD_BLOCKSCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::CHALLENGE_PERIOD_BLOCKS(_) => {
                    <CHALLENGE_PERIOD_BLOCKSCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::CONFIRM_PERIOD_BLOCKS(_) => {
                    <CONFIRM_PERIOD_BLOCKSCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::DISABLE_VALIDATOR_WHITELIST(_) => {
                    <DISABLE_VALIDATOR_WHITELISTCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::EXCESS_STAKE_RECEIVER(_) => {
                    <EXCESS_STAKE_RECEIVERCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::IMPL_BRIDGE(_) => {
                    <IMPL_BRIDGECall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::IMPL_CHALLENGE_MANAGER(_) => {
                    <IMPL_CHALLENGE_MANAGERCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::IMPL_INBOX(_) => {
                    <IMPL_INBOXCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::IMPL_NEW_ROLLUP_ADMIN(_) => {
                    <IMPL_NEW_ROLLUP_ADMINCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::IMPL_NEW_ROLLUP_USER(_) => {
                    <IMPL_NEW_ROLLUP_USERCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::IMPL_OUTBOX(_) => {
                    <IMPL_OUTBOXCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::IMPL_REI(_) => <IMPL_REICall as alloy_sol_types::SolCall>::SELECTOR,
                Self::IMPL_SEQUENCER_INBOX(_) => {
                    <IMPL_SEQUENCER_INBOXCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::INBOX(_) => <INBOXCall as alloy_sol_types::SolCall>::SELECTOR,
                Self::IS_DELAY_BUFFERABLE(_) => {
                    <IS_DELAY_BUFFERABLECall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::MAX(_) => <MAXCall as alloy_sol_types::SolCall>::SELECTOR,
                Self::MINIMUM_ASSERTION_PERIOD(_) => {
                    <MINIMUM_ASSERTION_PERIODCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::MINI_STAKE_AMOUNTS_STORAGE(_) => {
                    <MINI_STAKE_AMOUNTS_STORAGECall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::NUM_BIGSTEP_LEVEL(_) => {
                    <NUM_BIGSTEP_LEVELCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::OLD_ROLLUP(_) => {
                    <OLD_ROLLUPCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::OSP(_) => <OSPCall as alloy_sol_types::SolCall>::SELECTOR,
                Self::OUTBOX(_) => <OUTBOXCall as alloy_sol_types::SolCall>::SELECTOR,
                Self::PREIMAGE_LOOKUP(_) => {
                    <PREIMAGE_LOOKUPCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::PROXY_ADMIN_BRIDGE(_) => {
                    <PROXY_ADMIN_BRIDGECall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::PROXY_ADMIN_INBOX(_) => {
                    <PROXY_ADMIN_INBOXCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::PROXY_ADMIN_OUTBOX(_) => {
                    <PROXY_ADMIN_OUTBOXCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::PROXY_ADMIN_REI(_) => {
                    <PROXY_ADMIN_REICall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::PROXY_ADMIN_SEQUENCER_INBOX(_) => {
                    <PROXY_ADMIN_SEQUENCER_INBOXCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::REI(_) => <REICall as alloy_sol_types::SolCall>::SELECTOR,
                Self::REPLENISH_RATE_IN_BASIS(_) => {
                    <REPLENISH_RATE_IN_BASISCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::SECONDS_PER_SLOT(_) => {
                    <SECONDS_PER_SLOTCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::SEQ_INBOX(_) => {
                    <SEQ_INBOXCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::SMALLSTEP_LEAF_SIZE(_) => {
                    <SMALLSTEP_LEAF_SIZECall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::STAKE_AMOUNT(_) => {
                    <STAKE_AMOUNTCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::STAKE_TOKEN(_) => {
                    <STAKE_TOKENCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::THRESHOLD(_) => {
                    <THRESHOLDCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::VALIDATOR_AFK_BLOCKS(_) => {
                    <VALIDATOR_AFK_BLOCKSCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::expectedRollupAddress(_) => {
                    <expectedRollupAddressCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::perform(_) => <performCall as alloy_sol_types::SolCall>::SELECTOR,
                Self::validateRollupDeployedAtAddress(_) => {
                    <validateRollupDeployedAtAddressCall as alloy_sol_types::SolCall>::SELECTOR
                }
            }
        }
        #[inline]
        fn selector_at(i: usize) -> ::core::option::Option<[u8; 4]> {
            Self::SELECTORS.get(i).copied()
        }
        #[inline]
        fn valid_selector(selector: [u8; 4]) -> bool {
            Self::SELECTORS.binary_search(&selector).is_ok()
        }
        #[inline]
        #[allow(non_snake_case)]
        fn abi_decode_raw(
            selector: [u8; 4],
            data: &[u8],
            validate: bool,
        ) -> alloy_sol_types::Result<Self> {
            static DECODE_SHIMS: &[fn(
                &[u8],
                bool,
            ) -> alloy_sol_types::Result<BOLDUpgradeActionCalls>] = &[
                {
                    fn MINIMUM_ASSERTION_PERIOD(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<BOLDUpgradeActionCalls> {
                        <MINIMUM_ASSERTION_PERIODCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(BOLDUpgradeActionCalls::MINIMUM_ASSERTION_PERIOD)
                    }
                    MINIMUM_ASSERTION_PERIOD
                },
                {
                    fn IMPL_NEW_ROLLUP_ADMIN(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<BOLDUpgradeActionCalls> {
                        <IMPL_NEW_ROLLUP_ADMINCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(BOLDUpgradeActionCalls::IMPL_NEW_ROLLUP_ADMIN)
                    }
                    IMPL_NEW_ROLLUP_ADMIN
                },
                {
                    fn PROXY_ADMIN_OUTBOX(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<BOLDUpgradeActionCalls> {
                        <PROXY_ADMIN_OUTBOXCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(BOLDUpgradeActionCalls::PROXY_ADMIN_OUTBOX)
                    }
                    PROXY_ADMIN_OUTBOX
                },
                {
                    fn PROXY_ADMIN_BRIDGE(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<BOLDUpgradeActionCalls> {
                        <PROXY_ADMIN_BRIDGECall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(BOLDUpgradeActionCalls::PROXY_ADMIN_BRIDGE)
                    }
                    PROXY_ADMIN_BRIDGE
                },
                {
                    fn CONFIRM_PERIOD_BLOCKS(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<BOLDUpgradeActionCalls> {
                        <CONFIRM_PERIOD_BLOCKSCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(BOLDUpgradeActionCalls::CONFIRM_PERIOD_BLOCKS)
                    }
                    CONFIRM_PERIOD_BLOCKS
                },
                {
                    fn IMPL_CHALLENGE_MANAGER(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<BOLDUpgradeActionCalls> {
                        <IMPL_CHALLENGE_MANAGERCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(BOLDUpgradeActionCalls::IMPL_CHALLENGE_MANAGER)
                    }
                    IMPL_CHALLENGE_MANAGER
                },
                {
                    fn OUTBOX(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<BOLDUpgradeActionCalls> {
                        <OUTBOXCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(BOLDUpgradeActionCalls::OUTBOX)
                    }
                    OUTBOX
                },
                {
                    fn STAKE_TOKEN(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<BOLDUpgradeActionCalls> {
                        <STAKE_TOKENCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(BOLDUpgradeActionCalls::STAKE_TOKEN)
                    }
                    STAKE_TOKEN
                },
                {
                    fn BIGSTEP_LEAF_SIZE(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<BOLDUpgradeActionCalls> {
                        <BIGSTEP_LEAF_SIZECall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(BOLDUpgradeActionCalls::BIGSTEP_LEAF_SIZE)
                    }
                    BIGSTEP_LEAF_SIZE
                },
                {
                    fn expectedRollupAddress(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<BOLDUpgradeActionCalls> {
                        <expectedRollupAddressCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(BOLDUpgradeActionCalls::expectedRollupAddress)
                    }
                    expectedRollupAddress
                },
                {
                    fn PROXY_ADMIN_SEQUENCER_INBOX(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<BOLDUpgradeActionCalls> {
                        <PROXY_ADMIN_SEQUENCER_INBOXCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(BOLDUpgradeActionCalls::PROXY_ADMIN_SEQUENCER_INBOX)
                    }
                    PROXY_ADMIN_SEQUENCER_INBOX
                },
                {
                    fn SECONDS_PER_SLOT(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<BOLDUpgradeActionCalls> {
                        <SECONDS_PER_SLOTCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(BOLDUpgradeActionCalls::SECONDS_PER_SLOT)
                    }
                    SECONDS_PER_SLOT
                },
                {
                    fn PROXY_ADMIN_REI(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<BOLDUpgradeActionCalls> {
                        <PROXY_ADMIN_REICall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(BOLDUpgradeActionCalls::PROXY_ADMIN_REI)
                    }
                    PROXY_ADMIN_REI
                },
                {
                    fn IMPL_NEW_ROLLUP_USER(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<BOLDUpgradeActionCalls> {
                        <IMPL_NEW_ROLLUP_USERCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(BOLDUpgradeActionCalls::IMPL_NEW_ROLLUP_USER)
                    }
                    IMPL_NEW_ROLLUP_USER
                },
                {
                    fn PROXY_ADMIN_INBOX(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<BOLDUpgradeActionCalls> {
                        <PROXY_ADMIN_INBOXCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(BOLDUpgradeActionCalls::PROXY_ADMIN_INBOX)
                    }
                    PROXY_ADMIN_INBOX
                },
                {
                    fn VALIDATOR_AFK_BLOCKS(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<BOLDUpgradeActionCalls> {
                        <VALIDATOR_AFK_BLOCKSCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(BOLDUpgradeActionCalls::VALIDATOR_AFK_BLOCKS)
                    }
                    VALIDATOR_AFK_BLOCKS
                },
                {
                    fn NUM_BIGSTEP_LEVEL(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<BOLDUpgradeActionCalls> {
                        <NUM_BIGSTEP_LEVELCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(BOLDUpgradeActionCalls::NUM_BIGSTEP_LEVEL)
                    }
                    NUM_BIGSTEP_LEVEL
                },
                {
                    fn BLOCK_LEAF_SIZE(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<BOLDUpgradeActionCalls> {
                        <BLOCK_LEAF_SIZECall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(BOLDUpgradeActionCalls::BLOCK_LEAF_SIZE)
                    }
                    BLOCK_LEAF_SIZE
                },
                {
                    fn EXCESS_STAKE_RECEIVER(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<BOLDUpgradeActionCalls> {
                        <EXCESS_STAKE_RECEIVERCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(BOLDUpgradeActionCalls::EXCESS_STAKE_RECEIVER)
                    }
                    EXCESS_STAKE_RECEIVER
                },
                {
                    fn THRESHOLD(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<BOLDUpgradeActionCalls> {
                        <THRESHOLDCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(BOLDUpgradeActionCalls::THRESHOLD)
                    }
                    THRESHOLD
                },
                {
                    fn IMPL_INBOX(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<BOLDUpgradeActionCalls> {
                        <IMPL_INBOXCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(BOLDUpgradeActionCalls::IMPL_INBOX)
                    }
                    IMPL_INBOX
                },
                {
                    fn CHAIN_ID(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<BOLDUpgradeActionCalls> {
                        <CHAIN_IDCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(BOLDUpgradeActionCalls::CHAIN_ID)
                    }
                    CHAIN_ID
                },
                {
                    fn OLD_ROLLUP(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<BOLDUpgradeActionCalls> {
                        <OLD_ROLLUPCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(BOLDUpgradeActionCalls::OLD_ROLLUP)
                    }
                    OLD_ROLLUP
                },
                {
                    fn CHALLENGE_PERIOD_BLOCKS(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<BOLDUpgradeActionCalls> {
                        <CHALLENGE_PERIOD_BLOCKSCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(BOLDUpgradeActionCalls::CHALLENGE_PERIOD_BLOCKS)
                    }
                    CHALLENGE_PERIOD_BLOCKS
                },
                {
                    fn validateRollupDeployedAtAddress(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<BOLDUpgradeActionCalls> {
                        <validateRollupDeployedAtAddressCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(BOLDUpgradeActionCalls::validateRollupDeployedAtAddress)
                    }
                    validateRollupDeployedAtAddress
                },
                {
                    fn OSP(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<BOLDUpgradeActionCalls> {
                        <OSPCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(BOLDUpgradeActionCalls::OSP)
                    }
                    OSP
                },
                {
                    fn DISABLE_VALIDATOR_WHITELIST(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<BOLDUpgradeActionCalls> {
                        <DISABLE_VALIDATOR_WHITELISTCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(BOLDUpgradeActionCalls::DISABLE_VALIDATOR_WHITELIST)
                    }
                    DISABLE_VALIDATOR_WHITELIST
                },
                {
                    fn MINI_STAKE_AMOUNTS_STORAGE(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<BOLDUpgradeActionCalls> {
                        <MINI_STAKE_AMOUNTS_STORAGECall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(BOLDUpgradeActionCalls::MINI_STAKE_AMOUNTS_STORAGE)
                    }
                    MINI_STAKE_AMOUNTS_STORAGE
                },
                {
                    fn INBOX(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<BOLDUpgradeActionCalls> {
                        <INBOXCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(BOLDUpgradeActionCalls::INBOX)
                    }
                    INBOX
                },
                {
                    fn REI(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<BOLDUpgradeActionCalls> {
                        <REICall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(BOLDUpgradeActionCalls::REI)
                    }
                    REI
                },
                {
                    fn IMPL_REI(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<BOLDUpgradeActionCalls> {
                        <IMPL_REICall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(BOLDUpgradeActionCalls::IMPL_REI)
                    }
                    IMPL_REI
                },
                {
                    fn IMPL_SEQUENCER_INBOX(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<BOLDUpgradeActionCalls> {
                        <IMPL_SEQUENCER_INBOXCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(BOLDUpgradeActionCalls::IMPL_SEQUENCER_INBOX)
                    }
                    IMPL_SEQUENCER_INBOX
                },
                {
                    fn IMPL_OUTBOX(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<BOLDUpgradeActionCalls> {
                        <IMPL_OUTBOXCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(BOLDUpgradeActionCalls::IMPL_OUTBOX)
                    }
                    IMPL_OUTBOX
                },
                {
                    fn PREIMAGE_LOOKUP(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<BOLDUpgradeActionCalls> {
                        <PREIMAGE_LOOKUPCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(BOLDUpgradeActionCalls::PREIMAGE_LOOKUP)
                    }
                    PREIMAGE_LOOKUP
                },
                {
                    fn SEQ_INBOX(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<BOLDUpgradeActionCalls> {
                        <SEQ_INBOXCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(BOLDUpgradeActionCalls::SEQ_INBOX)
                    }
                    SEQ_INBOX
                },
                {
                    fn MAX(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<BOLDUpgradeActionCalls> {
                        <MAXCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(BOLDUpgradeActionCalls::MAX)
                    }
                    MAX
                },
                {
                    fn IMPL_BRIDGE(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<BOLDUpgradeActionCalls> {
                        <IMPL_BRIDGECall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(BOLDUpgradeActionCalls::IMPL_BRIDGE)
                    }
                    IMPL_BRIDGE
                },
                {
                    fn IS_DELAY_BUFFERABLE(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<BOLDUpgradeActionCalls> {
                        <IS_DELAY_BUFFERABLECall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(BOLDUpgradeActionCalls::IS_DELAY_BUFFERABLE)
                    }
                    IS_DELAY_BUFFERABLE
                },
                {
                    fn REPLENISH_RATE_IN_BASIS(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<BOLDUpgradeActionCalls> {
                        <REPLENISH_RATE_IN_BASISCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(BOLDUpgradeActionCalls::REPLENISH_RATE_IN_BASIS)
                    }
                    REPLENISH_RATE_IN_BASIS
                },
                {
                    fn perform(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<BOLDUpgradeActionCalls> {
                        <performCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(BOLDUpgradeActionCalls::perform)
                    }
                    perform
                },
                {
                    fn CHALLENGE_GRACE_PERIOD_BLOCKS(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<BOLDUpgradeActionCalls> {
                        <CHALLENGE_GRACE_PERIOD_BLOCKSCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(BOLDUpgradeActionCalls::CHALLENGE_GRACE_PERIOD_BLOCKS)
                    }
                    CHALLENGE_GRACE_PERIOD_BLOCKS
                },
                {
                    fn BRIDGE(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<BOLDUpgradeActionCalls> {
                        <BRIDGECall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(BOLDUpgradeActionCalls::BRIDGE)
                    }
                    BRIDGE
                },
                {
                    fn SMALLSTEP_LEAF_SIZE(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<BOLDUpgradeActionCalls> {
                        <SMALLSTEP_LEAF_SIZECall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(BOLDUpgradeActionCalls::SMALLSTEP_LEAF_SIZE)
                    }
                    SMALLSTEP_LEAF_SIZE
                },
                {
                    fn STAKE_AMOUNT(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<BOLDUpgradeActionCalls> {
                        <STAKE_AMOUNTCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(BOLDUpgradeActionCalls::STAKE_AMOUNT)
                    }
                    STAKE_AMOUNT
                },
            ];
            let Ok(idx) = Self::SELECTORS.binary_search(&selector) else {
                return Err(
                    alloy_sol_types::Error::unknown_selector(
                        <Self as alloy_sol_types::SolInterface>::NAME,
                        selector,
                    ),
                );
            };
            DECODE_SHIMS[idx](data, validate)
        }
        #[inline]
        fn abi_encoded_size(&self) -> usize {
            match self {
                Self::BIGSTEP_LEAF_SIZE(inner) => {
                    <BIGSTEP_LEAF_SIZECall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::BLOCK_LEAF_SIZE(inner) => {
                    <BLOCK_LEAF_SIZECall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::BRIDGE(inner) => {
                    <BRIDGECall as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::CHAIN_ID(inner) => {
                    <CHAIN_IDCall as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::CHALLENGE_GRACE_PERIOD_BLOCKS(inner) => {
                    <CHALLENGE_GRACE_PERIOD_BLOCKSCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::CHALLENGE_PERIOD_BLOCKS(inner) => {
                    <CHALLENGE_PERIOD_BLOCKSCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::CONFIRM_PERIOD_BLOCKS(inner) => {
                    <CONFIRM_PERIOD_BLOCKSCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::DISABLE_VALIDATOR_WHITELIST(inner) => {
                    <DISABLE_VALIDATOR_WHITELISTCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::EXCESS_STAKE_RECEIVER(inner) => {
                    <EXCESS_STAKE_RECEIVERCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::IMPL_BRIDGE(inner) => {
                    <IMPL_BRIDGECall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::IMPL_CHALLENGE_MANAGER(inner) => {
                    <IMPL_CHALLENGE_MANAGERCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::IMPL_INBOX(inner) => {
                    <IMPL_INBOXCall as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::IMPL_NEW_ROLLUP_ADMIN(inner) => {
                    <IMPL_NEW_ROLLUP_ADMINCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::IMPL_NEW_ROLLUP_USER(inner) => {
                    <IMPL_NEW_ROLLUP_USERCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::IMPL_OUTBOX(inner) => {
                    <IMPL_OUTBOXCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::IMPL_REI(inner) => {
                    <IMPL_REICall as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::IMPL_SEQUENCER_INBOX(inner) => {
                    <IMPL_SEQUENCER_INBOXCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::INBOX(inner) => {
                    <INBOXCall as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::IS_DELAY_BUFFERABLE(inner) => {
                    <IS_DELAY_BUFFERABLECall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::MAX(inner) => {
                    <MAXCall as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::MINIMUM_ASSERTION_PERIOD(inner) => {
                    <MINIMUM_ASSERTION_PERIODCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::MINI_STAKE_AMOUNTS_STORAGE(inner) => {
                    <MINI_STAKE_AMOUNTS_STORAGECall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::NUM_BIGSTEP_LEVEL(inner) => {
                    <NUM_BIGSTEP_LEVELCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::OLD_ROLLUP(inner) => {
                    <OLD_ROLLUPCall as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::OSP(inner) => {
                    <OSPCall as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::OUTBOX(inner) => {
                    <OUTBOXCall as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::PREIMAGE_LOOKUP(inner) => {
                    <PREIMAGE_LOOKUPCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::PROXY_ADMIN_BRIDGE(inner) => {
                    <PROXY_ADMIN_BRIDGECall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::PROXY_ADMIN_INBOX(inner) => {
                    <PROXY_ADMIN_INBOXCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::PROXY_ADMIN_OUTBOX(inner) => {
                    <PROXY_ADMIN_OUTBOXCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::PROXY_ADMIN_REI(inner) => {
                    <PROXY_ADMIN_REICall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::PROXY_ADMIN_SEQUENCER_INBOX(inner) => {
                    <PROXY_ADMIN_SEQUENCER_INBOXCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::REI(inner) => {
                    <REICall as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::REPLENISH_RATE_IN_BASIS(inner) => {
                    <REPLENISH_RATE_IN_BASISCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::SECONDS_PER_SLOT(inner) => {
                    <SECONDS_PER_SLOTCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::SEQ_INBOX(inner) => {
                    <SEQ_INBOXCall as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::SMALLSTEP_LEAF_SIZE(inner) => {
                    <SMALLSTEP_LEAF_SIZECall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::STAKE_AMOUNT(inner) => {
                    <STAKE_AMOUNTCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::STAKE_TOKEN(inner) => {
                    <STAKE_TOKENCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::THRESHOLD(inner) => {
                    <THRESHOLDCall as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::VALIDATOR_AFK_BLOCKS(inner) => {
                    <VALIDATOR_AFK_BLOCKSCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::expectedRollupAddress(inner) => {
                    <expectedRollupAddressCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::perform(inner) => {
                    <performCall as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::validateRollupDeployedAtAddress(inner) => {
                    <validateRollupDeployedAtAddressCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
            }
        }
        #[inline]
        fn abi_encode_raw(&self, out: &mut alloy_sol_types::private::Vec<u8>) {
            match self {
                Self::BIGSTEP_LEAF_SIZE(inner) => {
                    <BIGSTEP_LEAF_SIZECall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::BLOCK_LEAF_SIZE(inner) => {
                    <BLOCK_LEAF_SIZECall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::BRIDGE(inner) => {
                    <BRIDGECall as alloy_sol_types::SolCall>::abi_encode_raw(inner, out)
                }
                Self::CHAIN_ID(inner) => {
                    <CHAIN_IDCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::CHALLENGE_GRACE_PERIOD_BLOCKS(inner) => {
                    <CHALLENGE_GRACE_PERIOD_BLOCKSCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::CHALLENGE_PERIOD_BLOCKS(inner) => {
                    <CHALLENGE_PERIOD_BLOCKSCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::CONFIRM_PERIOD_BLOCKS(inner) => {
                    <CONFIRM_PERIOD_BLOCKSCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::DISABLE_VALIDATOR_WHITELIST(inner) => {
                    <DISABLE_VALIDATOR_WHITELISTCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::EXCESS_STAKE_RECEIVER(inner) => {
                    <EXCESS_STAKE_RECEIVERCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::IMPL_BRIDGE(inner) => {
                    <IMPL_BRIDGECall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::IMPL_CHALLENGE_MANAGER(inner) => {
                    <IMPL_CHALLENGE_MANAGERCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::IMPL_INBOX(inner) => {
                    <IMPL_INBOXCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::IMPL_NEW_ROLLUP_ADMIN(inner) => {
                    <IMPL_NEW_ROLLUP_ADMINCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::IMPL_NEW_ROLLUP_USER(inner) => {
                    <IMPL_NEW_ROLLUP_USERCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::IMPL_OUTBOX(inner) => {
                    <IMPL_OUTBOXCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::IMPL_REI(inner) => {
                    <IMPL_REICall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::IMPL_SEQUENCER_INBOX(inner) => {
                    <IMPL_SEQUENCER_INBOXCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::INBOX(inner) => {
                    <INBOXCall as alloy_sol_types::SolCall>::abi_encode_raw(inner, out)
                }
                Self::IS_DELAY_BUFFERABLE(inner) => {
                    <IS_DELAY_BUFFERABLECall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::MAX(inner) => {
                    <MAXCall as alloy_sol_types::SolCall>::abi_encode_raw(inner, out)
                }
                Self::MINIMUM_ASSERTION_PERIOD(inner) => {
                    <MINIMUM_ASSERTION_PERIODCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::MINI_STAKE_AMOUNTS_STORAGE(inner) => {
                    <MINI_STAKE_AMOUNTS_STORAGECall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::NUM_BIGSTEP_LEVEL(inner) => {
                    <NUM_BIGSTEP_LEVELCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::OLD_ROLLUP(inner) => {
                    <OLD_ROLLUPCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::OSP(inner) => {
                    <OSPCall as alloy_sol_types::SolCall>::abi_encode_raw(inner, out)
                }
                Self::OUTBOX(inner) => {
                    <OUTBOXCall as alloy_sol_types::SolCall>::abi_encode_raw(inner, out)
                }
                Self::PREIMAGE_LOOKUP(inner) => {
                    <PREIMAGE_LOOKUPCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::PROXY_ADMIN_BRIDGE(inner) => {
                    <PROXY_ADMIN_BRIDGECall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::PROXY_ADMIN_INBOX(inner) => {
                    <PROXY_ADMIN_INBOXCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::PROXY_ADMIN_OUTBOX(inner) => {
                    <PROXY_ADMIN_OUTBOXCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::PROXY_ADMIN_REI(inner) => {
                    <PROXY_ADMIN_REICall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::PROXY_ADMIN_SEQUENCER_INBOX(inner) => {
                    <PROXY_ADMIN_SEQUENCER_INBOXCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::REI(inner) => {
                    <REICall as alloy_sol_types::SolCall>::abi_encode_raw(inner, out)
                }
                Self::REPLENISH_RATE_IN_BASIS(inner) => {
                    <REPLENISH_RATE_IN_BASISCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::SECONDS_PER_SLOT(inner) => {
                    <SECONDS_PER_SLOTCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::SEQ_INBOX(inner) => {
                    <SEQ_INBOXCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::SMALLSTEP_LEAF_SIZE(inner) => {
                    <SMALLSTEP_LEAF_SIZECall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::STAKE_AMOUNT(inner) => {
                    <STAKE_AMOUNTCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::STAKE_TOKEN(inner) => {
                    <STAKE_TOKENCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::THRESHOLD(inner) => {
                    <THRESHOLDCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::VALIDATOR_AFK_BLOCKS(inner) => {
                    <VALIDATOR_AFK_BLOCKSCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::expectedRollupAddress(inner) => {
                    <expectedRollupAddressCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::perform(inner) => {
                    <performCall as alloy_sol_types::SolCall>::abi_encode_raw(inner, out)
                }
                Self::validateRollupDeployedAtAddress(inner) => {
                    <validateRollupDeployedAtAddressCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
            }
        }
    }
    ///Container for all the [`BOLDUpgradeAction`](self) events.
    pub enum BOLDUpgradeActionEvents {
        RollupMigrated(RollupMigrated),
    }
    #[automatically_derived]
    impl BOLDUpgradeActionEvents {
        /// All the selectors of this enum.
        ///
        /// Note that the selectors might not be in the same order as the variants.
        /// No guarantees are made about the order of the selectors.
        ///
        /// Prefer using `SolInterface` methods instead.
        pub const SELECTORS: &'static [[u8; 32usize]] = &[
            [
                126u8,
                92u8,
                197u8,
                195u8,
                252u8,
                224u8,
                70u8,
                216u8,
                104u8,
                213u8,
                145u8,
                133u8,
                72u8,
                223u8,
                141u8,
                62u8,
                142u8,
                249u8,
                240u8,
                158u8,
                111u8,
                179u8,
                10u8,
                104u8,
                8u8,
                31u8,
                31u8,
                19u8,
                72u8,
                205u8,
                3u8,
                20u8,
            ],
        ];
    }
    #[automatically_derived]
    impl alloy_sol_types::SolEventInterface for BOLDUpgradeActionEvents {
        const NAME: &'static str = "BOLDUpgradeActionEvents";
        const COUNT: usize = 1usize;
        fn decode_raw_log(
            topics: &[alloy_sol_types::Word],
            data: &[u8],
            validate: bool,
        ) -> alloy_sol_types::Result<Self> {
            match topics.first().copied() {
                Some(<RollupMigrated as alloy_sol_types::SolEvent>::SIGNATURE_HASH) => {
                    <RollupMigrated as alloy_sol_types::SolEvent>::decode_raw_log(
                            topics,
                            data,
                            validate,
                        )
                        .map(Self::RollupMigrated)
                }
                _ => {
                    alloy_sol_types::private::Err(alloy_sol_types::Error::InvalidLog {
                        name: <Self as alloy_sol_types::SolEventInterface>::NAME,
                        log: alloy_sol_types::private::Box::new(
                            alloy_sol_types::private::LogData::new_unchecked(
                                topics.to_vec(),
                                data.to_vec().into(),
                            ),
                        ),
                    })
                }
            }
        }
    }
    #[automatically_derived]
    impl alloy_sol_types::private::IntoLogData for BOLDUpgradeActionEvents {
        fn to_log_data(&self) -> alloy_sol_types::private::LogData {
            match self {
                Self::RollupMigrated(inner) => {
                    alloy_sol_types::private::IntoLogData::to_log_data(inner)
                }
            }
        }
        fn into_log_data(self) -> alloy_sol_types::private::LogData {
            match self {
                Self::RollupMigrated(inner) => {
                    alloy_sol_types::private::IntoLogData::into_log_data(inner)
                }
            }
        }
    }
    use alloy::contract as alloy_contract;
    /**Creates a new wrapper around an on-chain [`BOLDUpgradeAction`](self) contract instance.

See the [wrapper's documentation](`BOLDUpgradeActionInstance`) for more details.*/
    #[inline]
    pub const fn new<
        T: alloy_contract::private::Transport + ::core::clone::Clone,
        P: alloy_contract::private::Provider<T, N>,
        N: alloy_contract::private::Network,
    >(
        address: alloy_sol_types::private::Address,
        provider: P,
    ) -> BOLDUpgradeActionInstance<T, P, N> {
        BOLDUpgradeActionInstance::<T, P, N>::new(address, provider)
    }
    /**Deploys this contract using the given `provider` and constructor arguments, if any.

Returns a new instance of the contract, if the deployment was successful.

For more fine-grained control over the deployment process, use [`deploy_builder`] instead.*/
    #[inline]
    pub fn deploy<
        T: alloy_contract::private::Transport + ::core::clone::Clone,
        P: alloy_contract::private::Provider<T, N>,
        N: alloy_contract::private::Network,
    >(
        provider: P,
        contracts: <Contracts as alloy::sol_types::SolType>::RustType,
        proxyAdmins: <ProxyAdmins as alloy::sol_types::SolType>::RustType,
        implementations: <Implementations as alloy::sol_types::SolType>::RustType,
        settings: <Settings as alloy::sol_types::SolType>::RustType,
    ) -> impl ::core::future::Future<
        Output = alloy_contract::Result<BOLDUpgradeActionInstance<T, P, N>>,
    > {
        BOLDUpgradeActionInstance::<
            T,
            P,
            N,
        >::deploy(provider, contracts, proxyAdmins, implementations, settings)
    }
    /**Creates a `RawCallBuilder` for deploying this contract using the given `provider`
and constructor arguments, if any.

This is a simple wrapper around creating a `RawCallBuilder` with the data set to
the bytecode concatenated with the constructor's ABI-encoded arguments.*/
    #[inline]
    pub fn deploy_builder<
        T: alloy_contract::private::Transport + ::core::clone::Clone,
        P: alloy_contract::private::Provider<T, N>,
        N: alloy_contract::private::Network,
    >(
        provider: P,
        contracts: <Contracts as alloy::sol_types::SolType>::RustType,
        proxyAdmins: <ProxyAdmins as alloy::sol_types::SolType>::RustType,
        implementations: <Implementations as alloy::sol_types::SolType>::RustType,
        settings: <Settings as alloy::sol_types::SolType>::RustType,
    ) -> alloy_contract::RawCallBuilder<T, P, N> {
        BOLDUpgradeActionInstance::<
            T,
            P,
            N,
        >::deploy_builder(provider, contracts, proxyAdmins, implementations, settings)
    }
    /**A [`BOLDUpgradeAction`](self) instance.

Contains type-safe methods for interacting with an on-chain instance of the
[`BOLDUpgradeAction`](self) contract located at a given `address`, using a given
provider `P`.

If the contract bytecode is available (see the [`sol!`](alloy_sol_types::sol!)
documentation on how to provide it), the `deploy` and `deploy_builder` methods can
be used to deploy a new instance of the contract.

See the [module-level documentation](self) for all the available methods.*/
    #[derive(Clone)]
    pub struct BOLDUpgradeActionInstance<T, P, N = alloy_contract::private::Ethereum> {
        address: alloy_sol_types::private::Address,
        provider: P,
        _network_transport: ::core::marker::PhantomData<(N, T)>,
    }
    #[automatically_derived]
    impl<T, P, N> ::core::fmt::Debug for BOLDUpgradeActionInstance<T, P, N> {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
            f.debug_tuple("BOLDUpgradeActionInstance").field(&self.address).finish()
        }
    }
    /// Instantiation and getters/setters.
    #[automatically_derived]
    impl<
        T: alloy_contract::private::Transport + ::core::clone::Clone,
        P: alloy_contract::private::Provider<T, N>,
        N: alloy_contract::private::Network,
    > BOLDUpgradeActionInstance<T, P, N> {
        /**Creates a new wrapper around an on-chain [`BOLDUpgradeAction`](self) contract instance.

See the [wrapper's documentation](`BOLDUpgradeActionInstance`) for more details.*/
        #[inline]
        pub const fn new(
            address: alloy_sol_types::private::Address,
            provider: P,
        ) -> Self {
            Self {
                address,
                provider,
                _network_transport: ::core::marker::PhantomData,
            }
        }
        /**Deploys this contract using the given `provider` and constructor arguments, if any.

Returns a new instance of the contract, if the deployment was successful.

For more fine-grained control over the deployment process, use [`deploy_builder`] instead.*/
        #[inline]
        pub async fn deploy(
            provider: P,
            contracts: <Contracts as alloy::sol_types::SolType>::RustType,
            proxyAdmins: <ProxyAdmins as alloy::sol_types::SolType>::RustType,
            implementations: <Implementations as alloy::sol_types::SolType>::RustType,
            settings: <Settings as alloy::sol_types::SolType>::RustType,
        ) -> alloy_contract::Result<BOLDUpgradeActionInstance<T, P, N>> {
            let call_builder = Self::deploy_builder(
                provider,
                contracts,
                proxyAdmins,
                implementations,
                settings,
            );
            let contract_address = call_builder.deploy().await?;
            Ok(Self::new(contract_address, call_builder.provider))
        }
        /**Creates a `RawCallBuilder` for deploying this contract using the given `provider`
and constructor arguments, if any.

This is a simple wrapper around creating a `RawCallBuilder` with the data set to
the bytecode concatenated with the constructor's ABI-encoded arguments.*/
        #[inline]
        pub fn deploy_builder(
            provider: P,
            contracts: <Contracts as alloy::sol_types::SolType>::RustType,
            proxyAdmins: <ProxyAdmins as alloy::sol_types::SolType>::RustType,
            implementations: <Implementations as alloy::sol_types::SolType>::RustType,
            settings: <Settings as alloy::sol_types::SolType>::RustType,
        ) -> alloy_contract::RawCallBuilder<T, P, N> {
            alloy_contract::RawCallBuilder::new_raw_deploy(
                provider,
                [
                    &BYTECODE[..],
                    &alloy_sol_types::SolConstructor::abi_encode(
                        &constructorCall {
                            contracts,
                            proxyAdmins,
                            implementations,
                            settings,
                        },
                    )[..],
                ]
                    .concat()
                    .into(),
            )
        }
        /// Returns a reference to the address.
        #[inline]
        pub const fn address(&self) -> &alloy_sol_types::private::Address {
            &self.address
        }
        /// Sets the address.
        #[inline]
        pub fn set_address(&mut self, address: alloy_sol_types::private::Address) {
            self.address = address;
        }
        /// Sets the address and returns `self`.
        pub fn at(mut self, address: alloy_sol_types::private::Address) -> Self {
            self.set_address(address);
            self
        }
        /// Returns a reference to the provider.
        #[inline]
        pub const fn provider(&self) -> &P {
            &self.provider
        }
    }
    impl<T, P: ::core::clone::Clone, N> BOLDUpgradeActionInstance<T, &P, N> {
        /// Clones the provider and returns a new instance with the cloned provider.
        #[inline]
        pub fn with_cloned_provider(self) -> BOLDUpgradeActionInstance<T, P, N> {
            BOLDUpgradeActionInstance {
                address: self.address,
                provider: ::core::clone::Clone::clone(&self.provider),
                _network_transport: ::core::marker::PhantomData,
            }
        }
    }
    /// Function calls.
    #[automatically_derived]
    impl<
        T: alloy_contract::private::Transport + ::core::clone::Clone,
        P: alloy_contract::private::Provider<T, N>,
        N: alloy_contract::private::Network,
    > BOLDUpgradeActionInstance<T, P, N> {
        /// Creates a new call builder using this contract instance's provider and address.
        ///
        /// Note that the call can be any function call, not just those defined in this
        /// contract. Prefer using the other methods for building type-safe contract calls.
        pub fn call_builder<C: alloy_sol_types::SolCall>(
            &self,
            call: &C,
        ) -> alloy_contract::SolCallBuilder<T, &P, C, N> {
            alloy_contract::SolCallBuilder::new_sol(&self.provider, &self.address, call)
        }
        ///Creates a new call builder for the [`BIGSTEP_LEAF_SIZE`] function.
        pub fn BIGSTEP_LEAF_SIZE(
            &self,
        ) -> alloy_contract::SolCallBuilder<T, &P, BIGSTEP_LEAF_SIZECall, N> {
            self.call_builder(&BIGSTEP_LEAF_SIZECall {})
        }
        ///Creates a new call builder for the [`BLOCK_LEAF_SIZE`] function.
        pub fn BLOCK_LEAF_SIZE(
            &self,
        ) -> alloy_contract::SolCallBuilder<T, &P, BLOCK_LEAF_SIZECall, N> {
            self.call_builder(&BLOCK_LEAF_SIZECall {})
        }
        ///Creates a new call builder for the [`BRIDGE`] function.
        pub fn BRIDGE(&self) -> alloy_contract::SolCallBuilder<T, &P, BRIDGECall, N> {
            self.call_builder(&BRIDGECall {})
        }
        ///Creates a new call builder for the [`CHAIN_ID`] function.
        pub fn CHAIN_ID(
            &self,
        ) -> alloy_contract::SolCallBuilder<T, &P, CHAIN_IDCall, N> {
            self.call_builder(&CHAIN_IDCall {})
        }
        ///Creates a new call builder for the [`CHALLENGE_GRACE_PERIOD_BLOCKS`] function.
        pub fn CHALLENGE_GRACE_PERIOD_BLOCKS(
            &self,
        ) -> alloy_contract::SolCallBuilder<
            T,
            &P,
            CHALLENGE_GRACE_PERIOD_BLOCKSCall,
            N,
        > {
            self.call_builder(
                &CHALLENGE_GRACE_PERIOD_BLOCKSCall {
                },
            )
        }
        ///Creates a new call builder for the [`CHALLENGE_PERIOD_BLOCKS`] function.
        pub fn CHALLENGE_PERIOD_BLOCKS(
            &self,
        ) -> alloy_contract::SolCallBuilder<T, &P, CHALLENGE_PERIOD_BLOCKSCall, N> {
            self.call_builder(&CHALLENGE_PERIOD_BLOCKSCall {})
        }
        ///Creates a new call builder for the [`CONFIRM_PERIOD_BLOCKS`] function.
        pub fn CONFIRM_PERIOD_BLOCKS(
            &self,
        ) -> alloy_contract::SolCallBuilder<T, &P, CONFIRM_PERIOD_BLOCKSCall, N> {
            self.call_builder(&CONFIRM_PERIOD_BLOCKSCall {})
        }
        ///Creates a new call builder for the [`DISABLE_VALIDATOR_WHITELIST`] function.
        pub fn DISABLE_VALIDATOR_WHITELIST(
            &self,
        ) -> alloy_contract::SolCallBuilder<T, &P, DISABLE_VALIDATOR_WHITELISTCall, N> {
            self.call_builder(&DISABLE_VALIDATOR_WHITELISTCall {})
        }
        ///Creates a new call builder for the [`EXCESS_STAKE_RECEIVER`] function.
        pub fn EXCESS_STAKE_RECEIVER(
            &self,
        ) -> alloy_contract::SolCallBuilder<T, &P, EXCESS_STAKE_RECEIVERCall, N> {
            self.call_builder(&EXCESS_STAKE_RECEIVERCall {})
        }
        ///Creates a new call builder for the [`IMPL_BRIDGE`] function.
        pub fn IMPL_BRIDGE(
            &self,
        ) -> alloy_contract::SolCallBuilder<T, &P, IMPL_BRIDGECall, N> {
            self.call_builder(&IMPL_BRIDGECall {})
        }
        ///Creates a new call builder for the [`IMPL_CHALLENGE_MANAGER`] function.
        pub fn IMPL_CHALLENGE_MANAGER(
            &self,
        ) -> alloy_contract::SolCallBuilder<T, &P, IMPL_CHALLENGE_MANAGERCall, N> {
            self.call_builder(&IMPL_CHALLENGE_MANAGERCall {})
        }
        ///Creates a new call builder for the [`IMPL_INBOX`] function.
        pub fn IMPL_INBOX(
            &self,
        ) -> alloy_contract::SolCallBuilder<T, &P, IMPL_INBOXCall, N> {
            self.call_builder(&IMPL_INBOXCall {})
        }
        ///Creates a new call builder for the [`IMPL_NEW_ROLLUP_ADMIN`] function.
        pub fn IMPL_NEW_ROLLUP_ADMIN(
            &self,
        ) -> alloy_contract::SolCallBuilder<T, &P, IMPL_NEW_ROLLUP_ADMINCall, N> {
            self.call_builder(&IMPL_NEW_ROLLUP_ADMINCall {})
        }
        ///Creates a new call builder for the [`IMPL_NEW_ROLLUP_USER`] function.
        pub fn IMPL_NEW_ROLLUP_USER(
            &self,
        ) -> alloy_contract::SolCallBuilder<T, &P, IMPL_NEW_ROLLUP_USERCall, N> {
            self.call_builder(&IMPL_NEW_ROLLUP_USERCall {})
        }
        ///Creates a new call builder for the [`IMPL_OUTBOX`] function.
        pub fn IMPL_OUTBOX(
            &self,
        ) -> alloy_contract::SolCallBuilder<T, &P, IMPL_OUTBOXCall, N> {
            self.call_builder(&IMPL_OUTBOXCall {})
        }
        ///Creates a new call builder for the [`IMPL_REI`] function.
        pub fn IMPL_REI(
            &self,
        ) -> alloy_contract::SolCallBuilder<T, &P, IMPL_REICall, N> {
            self.call_builder(&IMPL_REICall {})
        }
        ///Creates a new call builder for the [`IMPL_SEQUENCER_INBOX`] function.
        pub fn IMPL_SEQUENCER_INBOX(
            &self,
        ) -> alloy_contract::SolCallBuilder<T, &P, IMPL_SEQUENCER_INBOXCall, N> {
            self.call_builder(&IMPL_SEQUENCER_INBOXCall {})
        }
        ///Creates a new call builder for the [`INBOX`] function.
        pub fn INBOX(&self) -> alloy_contract::SolCallBuilder<T, &P, INBOXCall, N> {
            self.call_builder(&INBOXCall {})
        }
        ///Creates a new call builder for the [`IS_DELAY_BUFFERABLE`] function.
        pub fn IS_DELAY_BUFFERABLE(
            &self,
        ) -> alloy_contract::SolCallBuilder<T, &P, IS_DELAY_BUFFERABLECall, N> {
            self.call_builder(&IS_DELAY_BUFFERABLECall {})
        }
        ///Creates a new call builder for the [`MAX`] function.
        pub fn MAX(&self) -> alloy_contract::SolCallBuilder<T, &P, MAXCall, N> {
            self.call_builder(&MAXCall {})
        }
        ///Creates a new call builder for the [`MINIMUM_ASSERTION_PERIOD`] function.
        pub fn MINIMUM_ASSERTION_PERIOD(
            &self,
        ) -> alloy_contract::SolCallBuilder<T, &P, MINIMUM_ASSERTION_PERIODCall, N> {
            self.call_builder(&MINIMUM_ASSERTION_PERIODCall {})
        }
        ///Creates a new call builder for the [`MINI_STAKE_AMOUNTS_STORAGE`] function.
        pub fn MINI_STAKE_AMOUNTS_STORAGE(
            &self,
        ) -> alloy_contract::SolCallBuilder<T, &P, MINI_STAKE_AMOUNTS_STORAGECall, N> {
            self.call_builder(&MINI_STAKE_AMOUNTS_STORAGECall {})
        }
        ///Creates a new call builder for the [`NUM_BIGSTEP_LEVEL`] function.
        pub fn NUM_BIGSTEP_LEVEL(
            &self,
        ) -> alloy_contract::SolCallBuilder<T, &P, NUM_BIGSTEP_LEVELCall, N> {
            self.call_builder(&NUM_BIGSTEP_LEVELCall {})
        }
        ///Creates a new call builder for the [`OLD_ROLLUP`] function.
        pub fn OLD_ROLLUP(
            &self,
        ) -> alloy_contract::SolCallBuilder<T, &P, OLD_ROLLUPCall, N> {
            self.call_builder(&OLD_ROLLUPCall {})
        }
        ///Creates a new call builder for the [`OSP`] function.
        pub fn OSP(&self) -> alloy_contract::SolCallBuilder<T, &P, OSPCall, N> {
            self.call_builder(&OSPCall {})
        }
        ///Creates a new call builder for the [`OUTBOX`] function.
        pub fn OUTBOX(&self) -> alloy_contract::SolCallBuilder<T, &P, OUTBOXCall, N> {
            self.call_builder(&OUTBOXCall {})
        }
        ///Creates a new call builder for the [`PREIMAGE_LOOKUP`] function.
        pub fn PREIMAGE_LOOKUP(
            &self,
        ) -> alloy_contract::SolCallBuilder<T, &P, PREIMAGE_LOOKUPCall, N> {
            self.call_builder(&PREIMAGE_LOOKUPCall {})
        }
        ///Creates a new call builder for the [`PROXY_ADMIN_BRIDGE`] function.
        pub fn PROXY_ADMIN_BRIDGE(
            &self,
        ) -> alloy_contract::SolCallBuilder<T, &P, PROXY_ADMIN_BRIDGECall, N> {
            self.call_builder(&PROXY_ADMIN_BRIDGECall {})
        }
        ///Creates a new call builder for the [`PROXY_ADMIN_INBOX`] function.
        pub fn PROXY_ADMIN_INBOX(
            &self,
        ) -> alloy_contract::SolCallBuilder<T, &P, PROXY_ADMIN_INBOXCall, N> {
            self.call_builder(&PROXY_ADMIN_INBOXCall {})
        }
        ///Creates a new call builder for the [`PROXY_ADMIN_OUTBOX`] function.
        pub fn PROXY_ADMIN_OUTBOX(
            &self,
        ) -> alloy_contract::SolCallBuilder<T, &P, PROXY_ADMIN_OUTBOXCall, N> {
            self.call_builder(&PROXY_ADMIN_OUTBOXCall {})
        }
        ///Creates a new call builder for the [`PROXY_ADMIN_REI`] function.
        pub fn PROXY_ADMIN_REI(
            &self,
        ) -> alloy_contract::SolCallBuilder<T, &P, PROXY_ADMIN_REICall, N> {
            self.call_builder(&PROXY_ADMIN_REICall {})
        }
        ///Creates a new call builder for the [`PROXY_ADMIN_SEQUENCER_INBOX`] function.
        pub fn PROXY_ADMIN_SEQUENCER_INBOX(
            &self,
        ) -> alloy_contract::SolCallBuilder<T, &P, PROXY_ADMIN_SEQUENCER_INBOXCall, N> {
            self.call_builder(&PROXY_ADMIN_SEQUENCER_INBOXCall {})
        }
        ///Creates a new call builder for the [`REI`] function.
        pub fn REI(&self) -> alloy_contract::SolCallBuilder<T, &P, REICall, N> {
            self.call_builder(&REICall {})
        }
        ///Creates a new call builder for the [`REPLENISH_RATE_IN_BASIS`] function.
        pub fn REPLENISH_RATE_IN_BASIS(
            &self,
        ) -> alloy_contract::SolCallBuilder<T, &P, REPLENISH_RATE_IN_BASISCall, N> {
            self.call_builder(&REPLENISH_RATE_IN_BASISCall {})
        }
        ///Creates a new call builder for the [`SECONDS_PER_SLOT`] function.
        pub fn SECONDS_PER_SLOT(
            &self,
        ) -> alloy_contract::SolCallBuilder<T, &P, SECONDS_PER_SLOTCall, N> {
            self.call_builder(&SECONDS_PER_SLOTCall {})
        }
        ///Creates a new call builder for the [`SEQ_INBOX`] function.
        pub fn SEQ_INBOX(
            &self,
        ) -> alloy_contract::SolCallBuilder<T, &P, SEQ_INBOXCall, N> {
            self.call_builder(&SEQ_INBOXCall {})
        }
        ///Creates a new call builder for the [`SMALLSTEP_LEAF_SIZE`] function.
        pub fn SMALLSTEP_LEAF_SIZE(
            &self,
        ) -> alloy_contract::SolCallBuilder<T, &P, SMALLSTEP_LEAF_SIZECall, N> {
            self.call_builder(&SMALLSTEP_LEAF_SIZECall {})
        }
        ///Creates a new call builder for the [`STAKE_AMOUNT`] function.
        pub fn STAKE_AMOUNT(
            &self,
        ) -> alloy_contract::SolCallBuilder<T, &P, STAKE_AMOUNTCall, N> {
            self.call_builder(&STAKE_AMOUNTCall {})
        }
        ///Creates a new call builder for the [`STAKE_TOKEN`] function.
        pub fn STAKE_TOKEN(
            &self,
        ) -> alloy_contract::SolCallBuilder<T, &P, STAKE_TOKENCall, N> {
            self.call_builder(&STAKE_TOKENCall {})
        }
        ///Creates a new call builder for the [`THRESHOLD`] function.
        pub fn THRESHOLD(
            &self,
        ) -> alloy_contract::SolCallBuilder<T, &P, THRESHOLDCall, N> {
            self.call_builder(&THRESHOLDCall {})
        }
        ///Creates a new call builder for the [`VALIDATOR_AFK_BLOCKS`] function.
        pub fn VALIDATOR_AFK_BLOCKS(
            &self,
        ) -> alloy_contract::SolCallBuilder<T, &P, VALIDATOR_AFK_BLOCKSCall, N> {
            self.call_builder(&VALIDATOR_AFK_BLOCKSCall {})
        }
        ///Creates a new call builder for the [`expectedRollupAddress`] function.
        pub fn expectedRollupAddress(
            &self,
            deployer: alloy::sol_types::private::Address,
            chainId: alloy::sol_types::private::primitives::aliases::U256,
        ) -> alloy_contract::SolCallBuilder<T, &P, expectedRollupAddressCall, N> {
            self.call_builder(
                &expectedRollupAddressCall {
                    deployer,
                    chainId,
                },
            )
        }
        ///Creates a new call builder for the [`perform`] function.
        pub fn perform(
            &self,
            validators: alloy::sol_types::private::Vec<
                alloy::sol_types::private::Address,
            >,
        ) -> alloy_contract::SolCallBuilder<T, &P, performCall, N> {
            self.call_builder(&performCall { validators })
        }
        ///Creates a new call builder for the [`validateRollupDeployedAtAddress`] function.
        pub fn validateRollupDeployedAtAddress(
            &self,
            rollupAddress: alloy::sol_types::private::Address,
            deployer: alloy::sol_types::private::Address,
            chainId: alloy::sol_types::private::primitives::aliases::U256,
        ) -> alloy_contract::SolCallBuilder<
            T,
            &P,
            validateRollupDeployedAtAddressCall,
            N,
        > {
            self.call_builder(
                &validateRollupDeployedAtAddressCall {
                    rollupAddress,
                    deployer,
                    chainId,
                },
            )
        }
    }
    /// Event filters.
    #[automatically_derived]
    impl<
        T: alloy_contract::private::Transport + ::core::clone::Clone,
        P: alloy_contract::private::Provider<T, N>,
        N: alloy_contract::private::Network,
    > BOLDUpgradeActionInstance<T, P, N> {
        /// Creates a new event filter using this contract instance's provider and address.
        ///
        /// Note that the type can be any event, not just those defined in this contract.
        /// Prefer using the other methods for building type-safe event filters.
        pub fn event_filter<E: alloy_sol_types::SolEvent>(
            &self,
        ) -> alloy_contract::Event<T, &P, E, N> {
            alloy_contract::Event::new_sol(&self.provider, &self.address)
        }
        ///Creates a new event filter for the [`RollupMigrated`] event.
        pub fn RollupMigrated_filter(
            &self,
        ) -> alloy_contract::Event<T, &P, RollupMigrated, N> {
            self.event_filter::<RollupMigrated>()
        }
    }
}
