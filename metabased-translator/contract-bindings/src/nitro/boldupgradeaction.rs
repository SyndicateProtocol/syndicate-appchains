/**

Generated by the following Solidity interface...
```solidity
interface BOLDUpgradeAction {
    struct BufferConfig {
        uint64 threshold;
        uint64 max;
        uint64 replenishRateInBasis;
    }
    struct Contracts {
        address excessStakeReceiver;
        address rollup;
        address bridge;
        address sequencerInbox;
        address rollupEventInbox;
        address outbox;
        address inbox;
        address osp;
    }
    struct Implementations {
        address bridge;
        address seqInbox;
        address inbox;
        address rei;
        address outbox;
        address newRollupUser;
        address newRollupAdmin;
        address challengeManager;
    }
    struct ProxyAdmins {
        address outbox;
        address bridge;
        address rei;
        address seqInbox;
        address inbox;
    }
    struct Settings {
        uint64 confirmPeriodBlocks;
        uint64 challengePeriodBlocks;
        address stakeToken;
        uint256 stakeAmt;
        uint256[] miniStakeAmounts;
        uint256 chainId;
        uint256 minimumAssertionPeriod;
        uint64 validatorAfkBlocks;
        bool disableValidatorWhitelist;
        uint256 blockLeafSize;
        uint256 bigStepLeafSize;
        uint256 smallStepLeafSize;
        uint8 numBigStepLevel;
        uint64 challengeGracePeriodBlocks;
        bool isDelayBufferable;
        BufferConfig bufferConfig;
    }

    event RollupMigrated(address rollup, address challengeManager);

    constructor(Contracts contracts, ProxyAdmins proxyAdmins, Implementations implementations, Settings settings);

    function BIGSTEP_LEAF_SIZE() external view returns (uint256);
    function BLOCK_LEAF_SIZE() external view returns (uint256);
    function BRIDGE() external view returns (address);
    function CHAIN_ID() external view returns (uint256);
    function CHALLENGE_GRACE_PERIOD_BLOCKS() external view returns (uint64);
    function CHALLENGE_PERIOD_BLOCKS() external view returns (uint64);
    function CONFIRM_PERIOD_BLOCKS() external view returns (uint64);
    function DISABLE_VALIDATOR_WHITELIST() external view returns (bool);
    function EXCESS_STAKE_RECEIVER() external view returns (address);
    function IMPL_BRIDGE() external view returns (address);
    function IMPL_CHALLENGE_MANAGER() external view returns (address);
    function IMPL_INBOX() external view returns (address);
    function IMPL_NEW_ROLLUP_ADMIN() external view returns (address);
    function IMPL_NEW_ROLLUP_USER() external view returns (address);
    function IMPL_OUTBOX() external view returns (address);
    function IMPL_REI() external view returns (address);
    function IMPL_SEQUENCER_INBOX() external view returns (address);
    function INBOX() external view returns (address);
    function IS_DELAY_BUFFERABLE() external view returns (bool);
    function MAX() external view returns (uint64);
    function MINIMUM_ASSERTION_PERIOD() external view returns (uint256);
    function MINI_STAKE_AMOUNTS_STORAGE() external view returns (address);
    function NUM_BIGSTEP_LEVEL() external view returns (uint8);
    function OLD_ROLLUP() external view returns (address);
    function OSP() external view returns (address);
    function OUTBOX() external view returns (address);
    function PREIMAGE_LOOKUP() external view returns (address);
    function PROXY_ADMIN_BRIDGE() external view returns (address);
    function PROXY_ADMIN_INBOX() external view returns (address);
    function PROXY_ADMIN_OUTBOX() external view returns (address);
    function PROXY_ADMIN_REI() external view returns (address);
    function PROXY_ADMIN_SEQUENCER_INBOX() external view returns (address);
    function REI() external view returns (address);
    function REPLENISH_RATE_IN_BASIS() external view returns (uint64);
    function SECONDS_PER_SLOT() external view returns (uint256);
    function SEQ_INBOX() external view returns (address);
    function SMALLSTEP_LEAF_SIZE() external view returns (uint256);
    function STAKE_AMOUNT() external view returns (uint256);
    function STAKE_TOKEN() external view returns (address);
    function THRESHOLD() external view returns (uint64);
    function VALIDATOR_AFK_BLOCKS() external view returns (uint64);
    function expectedRollupAddress(address deployer, uint256 chainId) external pure returns (address);
    function perform(address[] memory validators) external;
    function validateRollupDeployedAtAddress(address rollupAddress, address deployer, uint256 chainId) external view;
}
```

...which was generated by the following JSON ABI:
```json
[
  {
    "type": "constructor",
    "inputs": [
      {
        "name": "contracts",
        "type": "tuple",
        "internalType": "struct BOLDUpgradeAction.Contracts",
        "components": [
          {
            "name": "excessStakeReceiver",
            "type": "address",
            "internalType": "address"
          },
          {
            "name": "rollup",
            "type": "address",
            "internalType": "contract IOldRollup"
          },
          {
            "name": "bridge",
            "type": "address",
            "internalType": "address"
          },
          {
            "name": "sequencerInbox",
            "type": "address",
            "internalType": "address"
          },
          {
            "name": "rollupEventInbox",
            "type": "address",
            "internalType": "address"
          },
          {
            "name": "outbox",
            "type": "address",
            "internalType": "address"
          },
          {
            "name": "inbox",
            "type": "address",
            "internalType": "address"
          },
          {
            "name": "osp",
            "type": "address",
            "internalType": "contract IOneStepProofEntry"
          }
        ]
      },
      {
        "name": "proxyAdmins",
        "type": "tuple",
        "internalType": "struct BOLDUpgradeAction.ProxyAdmins",
        "components": [
          {
            "name": "outbox",
            "type": "address",
            "internalType": "address"
          },
          {
            "name": "bridge",
            "type": "address",
            "internalType": "address"
          },
          {
            "name": "rei",
            "type": "address",
            "internalType": "address"
          },
          {
            "name": "seqInbox",
            "type": "address",
            "internalType": "address"
          },
          {
            "name": "inbox",
            "type": "address",
            "internalType": "address"
          }
        ]
      },
      {
        "name": "implementations",
        "type": "tuple",
        "internalType": "struct BOLDUpgradeAction.Implementations",
        "components": [
          {
            "name": "bridge",
            "type": "address",
            "internalType": "address"
          },
          {
            "name": "seqInbox",
            "type": "address",
            "internalType": "address"
          },
          {
            "name": "inbox",
            "type": "address",
            "internalType": "address"
          },
          {
            "name": "rei",
            "type": "address",
            "internalType": "address"
          },
          {
            "name": "outbox",
            "type": "address",
            "internalType": "address"
          },
          {
            "name": "newRollupUser",
            "type": "address",
            "internalType": "address"
          },
          {
            "name": "newRollupAdmin",
            "type": "address",
            "internalType": "address"
          },
          {
            "name": "challengeManager",
            "type": "address",
            "internalType": "address"
          }
        ]
      },
      {
        "name": "settings",
        "type": "tuple",
        "internalType": "struct BOLDUpgradeAction.Settings",
        "components": [
          {
            "name": "confirmPeriodBlocks",
            "type": "uint64",
            "internalType": "uint64"
          },
          {
            "name": "challengePeriodBlocks",
            "type": "uint64",
            "internalType": "uint64"
          },
          {
            "name": "stakeToken",
            "type": "address",
            "internalType": "address"
          },
          {
            "name": "stakeAmt",
            "type": "uint256",
            "internalType": "uint256"
          },
          {
            "name": "miniStakeAmounts",
            "type": "uint256[]",
            "internalType": "uint256[]"
          },
          {
            "name": "chainId",
            "type": "uint256",
            "internalType": "uint256"
          },
          {
            "name": "minimumAssertionPeriod",
            "type": "uint256",
            "internalType": "uint256"
          },
          {
            "name": "validatorAfkBlocks",
            "type": "uint64",
            "internalType": "uint64"
          },
          {
            "name": "disableValidatorWhitelist",
            "type": "bool",
            "internalType": "bool"
          },
          {
            "name": "blockLeafSize",
            "type": "uint256",
            "internalType": "uint256"
          },
          {
            "name": "bigStepLeafSize",
            "type": "uint256",
            "internalType": "uint256"
          },
          {
            "name": "smallStepLeafSize",
            "type": "uint256",
            "internalType": "uint256"
          },
          {
            "name": "numBigStepLevel",
            "type": "uint8",
            "internalType": "uint8"
          },
          {
            "name": "challengeGracePeriodBlocks",
            "type": "uint64",
            "internalType": "uint64"
          },
          {
            "name": "isDelayBufferable",
            "type": "bool",
            "internalType": "bool"
          },
          {
            "name": "bufferConfig",
            "type": "tuple",
            "internalType": "struct BufferConfig",
            "components": [
              {
                "name": "threshold",
                "type": "uint64",
                "internalType": "uint64"
              },
              {
                "name": "max",
                "type": "uint64",
                "internalType": "uint64"
              },
              {
                "name": "replenishRateInBasis",
                "type": "uint64",
                "internalType": "uint64"
              }
            ]
          }
        ]
      }
    ],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "BIGSTEP_LEAF_SIZE",
    "inputs": [],
    "outputs": [
      {
        "name": "",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "BLOCK_LEAF_SIZE",
    "inputs": [],
    "outputs": [
      {
        "name": "",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "BRIDGE",
    "inputs": [],
    "outputs": [
      {
        "name": "",
        "type": "address",
        "internalType": "address"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "CHAIN_ID",
    "inputs": [],
    "outputs": [
      {
        "name": "",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "CHALLENGE_GRACE_PERIOD_BLOCKS",
    "inputs": [],
    "outputs": [
      {
        "name": "",
        "type": "uint64",
        "internalType": "uint64"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "CHALLENGE_PERIOD_BLOCKS",
    "inputs": [],
    "outputs": [
      {
        "name": "",
        "type": "uint64",
        "internalType": "uint64"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "CONFIRM_PERIOD_BLOCKS",
    "inputs": [],
    "outputs": [
      {
        "name": "",
        "type": "uint64",
        "internalType": "uint64"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "DISABLE_VALIDATOR_WHITELIST",
    "inputs": [],
    "outputs": [
      {
        "name": "",
        "type": "bool",
        "internalType": "bool"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "EXCESS_STAKE_RECEIVER",
    "inputs": [],
    "outputs": [
      {
        "name": "",
        "type": "address",
        "internalType": "address"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "IMPL_BRIDGE",
    "inputs": [],
    "outputs": [
      {
        "name": "",
        "type": "address",
        "internalType": "address"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "IMPL_CHALLENGE_MANAGER",
    "inputs": [],
    "outputs": [
      {
        "name": "",
        "type": "address",
        "internalType": "address"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "IMPL_INBOX",
    "inputs": [],
    "outputs": [
      {
        "name": "",
        "type": "address",
        "internalType": "address"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "IMPL_NEW_ROLLUP_ADMIN",
    "inputs": [],
    "outputs": [
      {
        "name": "",
        "type": "address",
        "internalType": "address"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "IMPL_NEW_ROLLUP_USER",
    "inputs": [],
    "outputs": [
      {
        "name": "",
        "type": "address",
        "internalType": "address"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "IMPL_OUTBOX",
    "inputs": [],
    "outputs": [
      {
        "name": "",
        "type": "address",
        "internalType": "address"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "IMPL_REI",
    "inputs": [],
    "outputs": [
      {
        "name": "",
        "type": "address",
        "internalType": "address"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "IMPL_SEQUENCER_INBOX",
    "inputs": [],
    "outputs": [
      {
        "name": "",
        "type": "address",
        "internalType": "address"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "INBOX",
    "inputs": [],
    "outputs": [
      {
        "name": "",
        "type": "address",
        "internalType": "address"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "IS_DELAY_BUFFERABLE",
    "inputs": [],
    "outputs": [
      {
        "name": "",
        "type": "bool",
        "internalType": "bool"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "MAX",
    "inputs": [],
    "outputs": [
      {
        "name": "",
        "type": "uint64",
        "internalType": "uint64"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "MINIMUM_ASSERTION_PERIOD",
    "inputs": [],
    "outputs": [
      {
        "name": "",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "MINI_STAKE_AMOUNTS_STORAGE",
    "inputs": [],
    "outputs": [
      {
        "name": "",
        "type": "address",
        "internalType": "address"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "NUM_BIGSTEP_LEVEL",
    "inputs": [],
    "outputs": [
      {
        "name": "",
        "type": "uint8",
        "internalType": "uint8"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "OLD_ROLLUP",
    "inputs": [],
    "outputs": [
      {
        "name": "",
        "type": "address",
        "internalType": "contract IOldRollup"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "OSP",
    "inputs": [],
    "outputs": [
      {
        "name": "",
        "type": "address",
        "internalType": "contract IOneStepProofEntry"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "OUTBOX",
    "inputs": [],
    "outputs": [
      {
        "name": "",
        "type": "address",
        "internalType": "address"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "PREIMAGE_LOOKUP",
    "inputs": [],
    "outputs": [
      {
        "name": "",
        "type": "address",
        "internalType": "contract StateHashPreImageLookup"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "PROXY_ADMIN_BRIDGE",
    "inputs": [],
    "outputs": [
      {
        "name": "",
        "type": "address",
        "internalType": "contract ProxyAdmin"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "PROXY_ADMIN_INBOX",
    "inputs": [],
    "outputs": [
      {
        "name": "",
        "type": "address",
        "internalType": "contract ProxyAdmin"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "PROXY_ADMIN_OUTBOX",
    "inputs": [],
    "outputs": [
      {
        "name": "",
        "type": "address",
        "internalType": "contract ProxyAdmin"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "PROXY_ADMIN_REI",
    "inputs": [],
    "outputs": [
      {
        "name": "",
        "type": "address",
        "internalType": "contract ProxyAdmin"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "PROXY_ADMIN_SEQUENCER_INBOX",
    "inputs": [],
    "outputs": [
      {
        "name": "",
        "type": "address",
        "internalType": "contract ProxyAdmin"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "REI",
    "inputs": [],
    "outputs": [
      {
        "name": "",
        "type": "address",
        "internalType": "address"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "REPLENISH_RATE_IN_BASIS",
    "inputs": [],
    "outputs": [
      {
        "name": "",
        "type": "uint64",
        "internalType": "uint64"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "SECONDS_PER_SLOT",
    "inputs": [],
    "outputs": [
      {
        "name": "",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "SEQ_INBOX",
    "inputs": [],
    "outputs": [
      {
        "name": "",
        "type": "address",
        "internalType": "address"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "SMALLSTEP_LEAF_SIZE",
    "inputs": [],
    "outputs": [
      {
        "name": "",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "STAKE_AMOUNT",
    "inputs": [],
    "outputs": [
      {
        "name": "",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "STAKE_TOKEN",
    "inputs": [],
    "outputs": [
      {
        "name": "",
        "type": "address",
        "internalType": "address"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "THRESHOLD",
    "inputs": [],
    "outputs": [
      {
        "name": "",
        "type": "uint64",
        "internalType": "uint64"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "VALIDATOR_AFK_BLOCKS",
    "inputs": [],
    "outputs": [
      {
        "name": "",
        "type": "uint64",
        "internalType": "uint64"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "expectedRollupAddress",
    "inputs": [
      {
        "name": "deployer",
        "type": "address",
        "internalType": "address"
      },
      {
        "name": "chainId",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "address",
        "internalType": "address"
      }
    ],
    "stateMutability": "pure"
  },
  {
    "type": "function",
    "name": "perform",
    "inputs": [
      {
        "name": "validators",
        "type": "address[]",
        "internalType": "address[]"
      }
    ],
    "outputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "validateRollupDeployedAtAddress",
    "inputs": [
      {
        "name": "rollupAddress",
        "type": "address",
        "internalType": "address"
      },
      {
        "name": "deployer",
        "type": "address",
        "internalType": "address"
      },
      {
        "name": "chainId",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "outputs": [],
    "stateMutability": "view"
  },
  {
    "type": "event",
    "name": "RollupMigrated",
    "inputs": [
      {
        "name": "rollup",
        "type": "address",
        "indexed": false,
        "internalType": "address"
      },
      {
        "name": "challengeManager",
        "type": "address",
        "indexed": false,
        "internalType": "address"
      }
    ],
    "anonymous": false
  }
]
```*/
#[allow(
    non_camel_case_types,
    non_snake_case,
    clippy::pub_underscore_fields,
    clippy::style,
    clippy::empty_structs_with_brackets
)]
pub mod BOLDUpgradeAction {
    use super::*;
    use alloy::sol_types as alloy_sol_types;
    /// The creation / init bytecode of the contract.
    ///
    /// ```text
    ///0x610580604052348015610010575f5ffd5b50604051616fdc380380616fdc83398101604081905261002f916106b1565b83516001600160a01b039081166101005260208086015182166101205260408087015183166101405260608088015184166101605260808089015185166101805260a089015185166101a05260c089015185166101c05260e089015185166103a052875185166103c0529287015184166103e052868201518416610400528601518316610420529085015190911661044052516100cb90610258565b604051809103905ff0801580156100e4573d5f5f3e3d5ffd5b506001600160a01b0390811661046052825181166104805260208084015182166104a05260408085015183166104c05260608086015184166104e05260808087015185166105005260a08088015186166105205260c08089015187166105405260e0808a01518816610560529188015161026052870151610280528601516001600160401b039081166102a052865181166101e05293860151909316610200528482015190931661022052918301516102405282015190516101a590610265565b6101af91906107b5565b604051809103905ff0801580156101c8573d5f5f3e3d5ffd5b506001600160a01b03166103005261010081015115156102c05261012081015160805261014081015160a05261016081015160c05261018081015160ff1660e0526101a08101516001600160401b039081166102e0526101c08201511515610320526101e090910180516020015182166103405280515182166103605251604001511661038052506107f7915050565b610a308061631383390190565b61029980616d4383390190565b634e487b7160e01b5f52604160045260245ffd5b60405161010081016001600160401b03811182821017156102a9576102a9610272565b60405290565b60405161020081016001600160401b03811182821017156102a9576102a9610272565b604051601f8201601f191681016001600160401b03811182821017156102fa576102fa610272565b604052919050565b6001600160a01b0381168114610316575f5ffd5b50565b805161032481610302565b919050565b5f60a08284031215610339575f5ffd5b60405160a081016001600160401b038111828210171561035b5761035b610272565b8060405250809150825161036e81610302565b8152602083015161037e81610302565b6020820152604083015161039181610302565b604082015260608301516103a481610302565b606082015260808301516103b781610302565b6080919091015292915050565b5f61010082840312156103d5575f5ffd5b6103dd610286565b905081516103ea81610302565b81526103f860208301610319565b602082015261040960408301610319565b604082015261041a60608301610319565b606082015261042b60808301610319565b608082015261043c60a08301610319565b60a082015261044d60c08301610319565b60c082015261045e60e08301610319565b60e082015292915050565b80516001600160401b0381168114610324575f5ffd5b5f82601f83011261048e575f5ffd5b81516001600160401b038111156104a7576104a7610272565b8060051b6104b7602082016102d2565b918252602081850181019290810190868411156104d2575f5ffd5b6020860192505b838310156104f45782518252602092830192909101906104d9565b9695505050505050565b80518015158114610324575f5ffd5b805160ff81168114610324575f5ffd5b5f6060828403121561052d575f5ffd5b604051606081016001600160401b038111828210171561054f5761054f610272565b60405290508061055e83610469565b815261056c60208401610469565b602082015261057d60408401610469565b60408201525092915050565b5f610240828403121561059a575f5ffd5b6105a26102af565b90506105ad82610469565b81526105bb60208301610469565b60208201526105cc60408301610319565b60408201526060828101519082015260808201516001600160401b038111156105f3575f5ffd5b6105ff8482850161047f565b60808301525060a0828101519082015260c0808301519082015261062560e08301610469565b60e082015261063761010083016104fe565b61010082015261012082810151908201526101408083015190820152610160808301519082015261066b610180830161050d565b61018082015261067e6101a08301610469565b6101a08201526106916101c083016104fe565b6101c08201526106a5836101e0840161051d565b6101e082015292915050565b5f5f5f5f8486036102c08112156106c6575f5ffd5b6101008112156106d4575f5ffd5b506106dd610286565b85516106e881610302565b81526106f660208701610319565b602082015261070760408701610319565b604082015261071860608701610319565b606082015261072960808701610319565b608082015261073a60a08701610319565b60a082015261074b60c08701610319565b60c082015261075c60e08701610319565b60e08201529350610771866101008701610329565b9250610781866101a087016103c4565b6102a08601519092506001600160401b0381111561079d575f5ffd5b6107a987828801610589565b91505092959194509250565b602080825282518282018190525f918401906040840190835b818110156107ec5783518352602093840193909201916001016107ce565b509095945050505050565b60805160a05160c05160e05161010051610120516101405161016051610180516101a0516101c0516101e05161020051610220516102405161026051610280516102a0516102c0516102e05161030051610320516103405161036051610380516103a0516103c0516103e05161040051610420516104405161046051610480516104a0516104c0516104e051610500516105205161054051610560516157ac610b675f395f81816103f10152610ab101525f81816103240152610c4701525f81816104f60152610c7601525f81816107eb015261223a01525f818161079d015261210c01525f8181610619015261204c01525f81816107c4015281816123e4015261258e01525f81816108870152611ef301525f8181610812015281816119750152611a3201525f818161051d015261207501525f81816104a0015281816123b401526125b601525f81816104cf015261213601525f818161038a01528181610ad20152611f1c01525f8181610363015261226401525f81816106ca0152610dae01525f81816108d5015261247001525f81816105f2015261241001525f8181610860015261244001525f81816108ae015261238e01525f81816107280152611d3301525f818161090f0152611e7601525f81816106f10152818161116e01526111ba01525f81816105440152611d0301525f81816102ea0152611cdd01525f81816106400152611ca301525f81816109840152611bba01525f818161043f0152611b8b01525f818161068e0152610d8d01525f81816103b10152611b5b01525f818161074f01528181610bab015261202301525f818161041801528181610bda0152818161221101526122be01525f818161077601528181610c09015281816120e3015261219001525f818161083901528181610b7c0152818161236d01528181612614015281816126e8015261278101525f818161093601528181610b4d01528181611eca0152611fab01525f818161066701528181610ca501528181610fcc0152818161122401528181611469015281816114d8015281816115c7015281816116750152818161177401528181611811015281816118400152611be001525f81816105cb01528181610de60152611c7401525f818161056b0152611e4d01525f818161095d0152611e0c01525f81816104660152611de601525f81816105a40152611dc001526157ac5ff3fe608060405234801561000f575f5ffd5b50600436106102e1575f3560e01c80638765240f11610187578063cc8089bb116100dd578063eb657a4e11610093578063ee9a31a21161006e578063ee9a31a214610931578063fa28742014610958578063faf5625f1461097f575f5ffd5b8063eb657a4e146108d0578063ebe03a93146108f7578063ec4f74ce1461090a575f5ffd5b8063d49d5181116100c3578063d49d51811461085b578063dae7cb8b14610882578063e8180c29146108a9575f5ffd5b8063cc8089bb1461080d578063d384cb9514610834575f5ffd5b8063b5e00c3f1161013d578063c21c423311610118578063c21c423314610798578063c519d151146107bf578063c897f55e146107e6575f5ffd5b8063b5e00c3f14610723578063b70106971461074a578063be41b36714610771575f5ffd5b8063999f20db1161016d578063999f20db146106b05780639f9854e5146106c5578063b38d57f0146106ec575f5ffd5b80638765240f1461066257806391ddb28514610689575f5ffd5b8063304b90711161023c5780635d9e2444116101f2578063785ffb37116101cd578063785ffb37146105ed578063817cd3121461061457806385e1f4d01461063b575f5ffd5b80635d9e244414610566578063609fb5031461059f57806364f4992a146105c6575f5ffd5b80634692de5d116102225780634692de5d146104f15780634b2f51ef146105185780634ceccfe51461053f575f5ffd5b8063304b9071146104c25780633c2b7840146104ca575f5ffd5b806310a662e21161029c5780631ccc2cd1116102775780631ccc2cd11461046157806328fb228c146104885780632cfb7ca31461049b575f5ffd5b806310a662e2146103ec5780631b142ea7146104135780631c39b6721461043a575f5ffd5b80630787484b116102cc5780630787484b1461035e5780630a54257d146103855780631047fc52146103ac575f5ffd5b80623c78fb146102e5578062f9731e1461031f575b5f5ffd5b61030c7f000000000000000000000000000000000000000000000000000000000000000081565b6040519081526020015b60405180910390f35b6103467f000000000000000000000000000000000000000000000000000000000000000081565b6040516001600160a01b039091168152602001610316565b6103467f000000000000000000000000000000000000000000000000000000000000000081565b6103467f000000000000000000000000000000000000000000000000000000000000000081565b6103d37f000000000000000000000000000000000000000000000000000000000000000081565b60405167ffffffffffffffff9091168152602001610316565b6103467f000000000000000000000000000000000000000000000000000000000000000081565b6103467f000000000000000000000000000000000000000000000000000000000000000081565b6103467f000000000000000000000000000000000000000000000000000000000000000081565b61030c7f000000000000000000000000000000000000000000000000000000000000000081565b6103466104963660046129ae565b6109a6565b6103467f000000000000000000000000000000000000000000000000000000000000000081565b61030c600c81565b6103467f000000000000000000000000000000000000000000000000000000000000000081565b6103467f000000000000000000000000000000000000000000000000000000000000000081565b6103467f000000000000000000000000000000000000000000000000000000000000000081565b6103d37f000000000000000000000000000000000000000000000000000000000000000081565b61058d7f000000000000000000000000000000000000000000000000000000000000000081565b60405160ff9091168152602001610316565b61030c7f000000000000000000000000000000000000000000000000000000000000000081565b6103467f000000000000000000000000000000000000000000000000000000000000000081565b6103d37f000000000000000000000000000000000000000000000000000000000000000081565b6103467f000000000000000000000000000000000000000000000000000000000000000081565b61030c7f000000000000000000000000000000000000000000000000000000000000000081565b6103467f000000000000000000000000000000000000000000000000000000000000000081565b6103d37f000000000000000000000000000000000000000000000000000000000000000081565b6106c36106be3660046129d8565b610a12565b005b6103467f000000000000000000000000000000000000000000000000000000000000000081565b6107137f000000000000000000000000000000000000000000000000000000000000000081565b6040519015158152602001610316565b6103467f000000000000000000000000000000000000000000000000000000000000000081565b6103467f000000000000000000000000000000000000000000000000000000000000000081565b6103467f000000000000000000000000000000000000000000000000000000000000000081565b6103467f000000000000000000000000000000000000000000000000000000000000000081565b6103467f000000000000000000000000000000000000000000000000000000000000000081565b6103467f000000000000000000000000000000000000000000000000000000000000000081565b6103467f000000000000000000000000000000000000000000000000000000000000000081565b6103467f000000000000000000000000000000000000000000000000000000000000000081565b6103d37f000000000000000000000000000000000000000000000000000000000000000081565b6103467f000000000000000000000000000000000000000000000000000000000000000081565b6107137f000000000000000000000000000000000000000000000000000000000000000081565b6103d37f000000000000000000000000000000000000000000000000000000000000000081565b6106c3610905366004612acb565b610a9b565b6103d37f000000000000000000000000000000000000000000000000000000000000000081565b6103467f000000000000000000000000000000000000000000000000000000000000000081565b61030c7f000000000000000000000000000000000000000000000000000000000000000081565b61030c7f000000000000000000000000000000000000000000000000000000000000000081565b5f5f826040516020016109bb91815260200190565b604051602081830303815290604052805190602001209050610a0881604051806020016109e7906127f5565b6020820181038252601f19601f8201166040525080519060200120866113df565b9150505b92915050565b5f836001600160a01b03163b118015610a455750826001600160a01b0316610a3a83836109a6565b6001600160a01b0316145b610a965760405162461bcd60e51b815260206004820152600d60248201527f414444525f4d49534d415443480000000000000000000000000000000000000060448201526064015b60405180910390fd5b505050565b610aa3611467565b5f610aac611806565b90505f7f00000000000000000000000000000000000000000000000000000000000000007f0000000000000000000000000000000000000000000000000000000000000000604051610afd90612802565b6001600160a01b039283168152911660208201526060604082018190525f90820152608001604051809103905ff080158015610b3b573d5f5f3e3d5ffd5b5090505f6040518061012001604052807f00000000000000000000000000000000000000000000000000000000000000006001600160a01b031681526020017f00000000000000000000000000000000000000000000000000000000000000006001600160a01b031681526020017f00000000000000000000000000000000000000000000000000000000000000006001600160a01b031681526020017f00000000000000000000000000000000000000000000000000000000000000006001600160a01b031681526020017f00000000000000000000000000000000000000000000000000000000000000006001600160a01b03168152602001836001600160a01b031681526020017f00000000000000000000000000000000000000000000000000000000000000006001600160a01b031681526020017f00000000000000000000000000000000000000000000000000000000000000006001600160a01b031681526020017f00000000000000000000000000000000000000000000000000000000000000006001600160a01b031663bc45e0ae6040518163ffffffff1660e01b8152600401602060405180830381865afa158015610cff573d5f5f3e3d5ffd5b505050506040513d601f19601f82011682018060405250810190610d239190612b6a565b6001600160a01b031681525090505f8360c00151604051602001610d4991815260200190565b6040516020818303038152906040528051906020012090505f610d70308660c001516109a6565b9050610d7b81611eb3565b836001600160a01b0316631a72d54c827f00000000000000000000000000000000000000000000000000000000000000007f00000000000000000000000000000000000000000000000000000000000000008961018001518a6101a001518b6101c001518c602001517f00000000000000000000000000000000000000000000000000000000000000008e61024001518f61014001516040518b63ffffffff1660e01b8152600401610e369a99989796959493929190612bbf565b5f604051808303815f87803b158015610e4d575f5ffd5b505af1158015610e5f573d5f5f3e3d5ffd5b505050505f82604051610e71906127f5565b8190604051809103905ff5905080158015610e8e573d5f5f3e3d5ffd5b509050816001600160a01b0316816001600160a01b031614610ef25760405162461bcd60e51b815260206004820152601560248201527f554e455850435445445f524f4c4c55505f4144445200000000000000000000006044820152606401610a8d565b608086018051309091526040517fadfef6ac0000000000000000000000000000000000000000000000000000000081526001600160a01b0383169063adfef6ac90610f43908a908990600401612e21565b5f604051808303815f87803b158015610f5a575f5ffd5b505af1158015610f6c573d5f5f3e3d5ffd5b5050505087515f1461116c575f885167ffffffffffffffff811115610f9357610f93612a16565b604051908082528060200260200182016040528015610fbc578160200160208202803683370190505b5090505f5b89518110156110f5577f00000000000000000000000000000000000000000000000000000000000000006001600160a01b031663facd743b8b838151811061100b5761100b613011565b60200260200101516040518263ffffffff1660e01b815260040161103e91906001600160a01b0391909116815260200190565b602060405180830381865afa158015611059573d5f5f3e3d5ffd5b505050506040513d601f19601f8201168201806040525081019061107d9190613039565b6110c95760405162461bcd60e51b815260206004820152601860248201527f554e45585045435445445f4e45575f56414c494441544f5200000000000000006044820152606401610a8d565b60018282815181106110dd576110dd613011565b91151560209283029190910190910152600101610fc1565b506040517fa3ffb7720000000000000000000000000000000000000000000000000000000081526001600160a01b0384169063a3ffb7729061113d908c90859060040161308b565b5f604051808303815f87803b158015611154575f5ffd5b505af1158015611166573d5f5f3e3d5ffd5b50505050505b7f000000000000000000000000000000000000000000000000000000000000000015611222576040517fa2b4f1d80000000000000000000000000000000000000000000000000000000081527f0000000000000000000000000000000000000000000000000000000000000000151560048201526001600160a01b0383169063a2b4f1d8906024015f604051808303815f87803b15801561120b575f5ffd5b505af115801561121d573d5f5f3e3d5ffd5b505050505b7f00000000000000000000000000000000000000000000000000000000000000006001600160a01b03166355840a586040518163ffffffff1660e01b8152600401602060405180830381865afa92505050801561129c575060408051601f3d908101601f1916820190925261129991810190612b6a565b60015b15611322576001600160a01b03811615611320576040517f0d561b370000000000000000000000000000000000000000000000000000000081526001600160a01b038281166004830152841690630d561b37906024015f604051808303815f87803b158015611309575f5ffd5b505af115801561131b573d5f5f3e3d5ffd5b505050505b505b6040517f13af40350000000000000000000000000000000000000000000000000000000081526001600160a01b0382811660048301528316906313af4035906024015f604051808303815f87803b15801561137b575f5ffd5b505af115801561138d573d5f5f3e3d5ffd5b5050604080516001600160a01b0380881682528a1660208201527f7e5cc5c3fce046d868d5918548df8d3e8ef9f09e6fb30a68081f1f1348cd0314935001905060405180910390a15050505050505050565b604080517fff00000000000000000000000000000000000000000000000000000000000000602080830191909152606084901b7fffffffffffffffffffffffffffffffffffffffff00000000000000000000000016602183015260358201869052605580830186905283518084039091018152607590920190925280519101205b9392505050565b7f00000000000000000000000000000000000000000000000000000000000000006001600160a01b0316638456cb596040518163ffffffff1660e01b81526004015f604051808303815f87803b1580156114bf575f5ffd5b505af11580156114d1573d5f5f3e3d5ffd5b505050505f7f00000000000000000000000000000000000000000000000000000000000000006001600160a01b031663dff697876040518163ffffffff1660e01b8152600401602060405180830381865afa158015611532573d5f5f3e3d5ffd5b505050506040513d601f19601f8201168201806040525081019061155691906130fc565b905060328167ffffffffffffffff16111561156f575060325b5f5b8167ffffffffffffffff168167ffffffffffffffff161015611802576040517f6ddd374400000000000000000000000000000000000000000000000000000000815267ffffffffffffffff821660048201525f907f00000000000000000000000000000000000000000000000000000000000000006001600160a01b031690636ddd374490602401602060405180830381865afa158015611614573d5f5f3e3d5ffd5b505050506040513d601f19601f820116820180604052508101906116389190612b6a565b6040517fa23c44b10000000000000000000000000000000000000000000000000000000081526001600160a01b0380831660048301529192505f917f0000000000000000000000000000000000000000000000000000000000000000169063a23c44b19060240160a060405180830381865afa1580156116ba573d5f5f3e3d5ffd5b505050506040513d601f19601f820116820180604052508101906116de9190613115565b9050806080015180156116fd5750606081015167ffffffffffffffff16155b156117ed576040805160018082528183019092525f916020808301908036833701905050905082815f8151811061173657611736613011565b6001600160a01b0392831660209182029290920101526040517f7c75c2980000000000000000000000000000000000000000000000000000000081527f000000000000000000000000000000000000000000000000000000000000000090911690637c75c298906117ab90849060040161319c565b5f604051808303815f87803b1580156117c2575f5ffd5b505af11580156117d4573d5f5f3e3d5ffd5b505050506001856117e591906131c2565b9450506117fb565b826117f7816131e2565b9350505b5050611571565b5050565b61180e61280f565b5f7f00000000000000000000000000000000000000000000000000000000000000006001600160a01b03166392c8134c7f00000000000000000000000000000000000000000000000000000000000000006001600160a01b03166365f7f80d6040518163ffffffff1660e01b8152600401602060405180830381865afa15801561189a573d5f5f3e3d5ffd5b505050506040513d601f19601f820116820180604052508101906118be91906130fc565b6040517fffffffff0000000000000000000000000000000000000000000000000000000060e084901b16815267ffffffffffffffff909116600482015260240161018060405180830381865afa15801561191a573d5f5f3e3d5ffd5b505050506040513d601f19601f8201168201806040525081019061193e919061320e565b516040517f8eaa6ac0000000000000000000000000000000000000000000000000000000008152600481018290529091505f9081907f00000000000000000000000000000000000000000000000000000000000000006001600160a01b031690638eaa6ac09060240160c060405180830381865afa1580156119c2573d5f5f3e3d5ffd5b505050506040513d601f19601f820116820180604052508101906119e69190613347565b915091506119f261291a565b82518152602080840151908201906002811115611a1157611a11612cdc565b90816002811115611a2457611a24612cdc565b905250836001600160a01b037f0000000000000000000000000000000000000000000000000000000000000000166331644130611a6084612331565b856040518363ffffffff1660e01b8152600401611a7e929190613403565b602060405180830381865afa158015611a99573d5f5f3e3d5ffd5b505050506040513d601f19601f82011682018060405250810190611abd9190613435565b14611b0a5760405162461bcd60e51b815260206004820152601d60248201527f496e76616c6964206c617465737420657865637574696f6e20686173680000006044820152606401610a8d565b611b3160405180608001604052805f81526020015f81526020015f81526020015f81525090565b604080516060810182525f8082526020820181905291810191909152604051806102a001604052807f000000000000000000000000000000000000000000000000000000000000000067ffffffffffffffff1681526020017f00000000000000000000000000000000000000000000000000000000000000006001600160a01b031681526020017f000000000000000000000000000000000000000000000000000000000000000081526020017f00000000000000000000000000000000000000000000000000000000000000006001600160a01b0316638ee1a1266040518163ffffffff1660e01b8152600401602060405180830381865afa158015611c3a573d5f5f3e3d5ffd5b505050506040513d601f19601f82011682018060405250810190611c5e9190613435565b8152602001306001600160a01b031681526020017f00000000000000000000000000000000000000000000000000000000000000006001600160a01b031681526020017f0000000000000000000000000000000000000000000000000000000000000000815260200160405180602001604052805f81525081526020017f000000000000000000000000000000000000000000000000000000000000000081526020017f000000000000000000000000000000000000000000000000000000000000000067ffffffffffffffff1681526020017f00000000000000000000000000000000000000000000000000000000000000006001600160a01b031663b0ec2ae16040518163ffffffff1660e01b81526004015f60405180830381865afa158015611d8c573d5f5f3e3d5ffd5b505050506040513d5f823e601f3d908101601f19168201604052611db3919081019061344c565b81526020018381526020017f000000000000000000000000000000000000000000000000000000000000000081526020017f000000000000000000000000000000000000000000000000000000000000000081526020017f000000000000000000000000000000000000000000000000000000000000000081526020018481526020018581526020015f6001600160a01b031681526020017f000000000000000000000000000000000000000000000000000000000000000060ff1681526020017f000000000000000000000000000000000000000000000000000000000000000067ffffffffffffffff16815260200182815250965050505050505090565b60405163266a23b160e21b81526001600160a01b037f000000000000000000000000000000000000000000000000000000000000000081811660048401527f000000000000000000000000000000000000000000000000000000000000000082166024840152917f0000000000000000000000000000000000000000000000000000000000000000909116906399a88ec4906044015f604051808303815f87803b158015611f5f575f5ffd5b505af1158015611f71573d5f5f3e3d5ffd5b50506040517f919cc7060000000000000000000000000000000000000000000000000000000081526001600160a01b0385811660048301527f000000000000000000000000000000000000000000000000000000000000000016925063919cc70691506024015f604051808303815f87803b158015611fee575f5ffd5b505af1158015612000573d5f5f3e3d5ffd5b5050505061200c61236b565b60405163266a23b160e21b81526001600160a01b037f000000000000000000000000000000000000000000000000000000000000000081811660048401527f000000000000000000000000000000000000000000000000000000000000000082166024840152917f0000000000000000000000000000000000000000000000000000000000000000909116906399a88ec4906044015f604051808303815f87803b1580156120b8575f5ffd5b505af11580156120ca573d5f5f3e3d5ffd5b505060405163266a23b160e21b81526001600160a01b037f000000000000000000000000000000000000000000000000000000000000000081811660048401527f00000000000000000000000000000000000000000000000000000000000000008216602484015293507f00000000000000000000000000000000000000000000000000000000000000001691506399a88ec4906044015f604051808303815f87803b158015612178575f5ffd5b505af115801561218a573d5f5f3e3d5ffd5b505050507f00000000000000000000000000000000000000000000000000000000000000006001600160a01b0316636ae71f126040518163ffffffff1660e01b81526004015f604051808303815f87803b1580156121e6575f5ffd5b505af11580156121f8573d5f5f3e3d5ffd5b505060405163266a23b160e21b81526001600160a01b037f000000000000000000000000000000000000000000000000000000000000000081811660048401527f00000000000000000000000000000000000000000000000000000000000000008216602484015293507f00000000000000000000000000000000000000000000000000000000000000001691506399a88ec4906044015f604051808303815f87803b1580156122a6575f5ffd5b505af11580156122b8573d5f5f3e3d5ffd5b505050507f00000000000000000000000000000000000000000000000000000000000000006001600160a01b0316636ae71f126040518163ffffffff1660e01b81526004015f604051808303815f87803b158015612314575f5ffd5b505af1158015612326573d5f5f3e3d5ffd5b505050505050505050565b61233961293f565b6040518060400160405280835f015181526020018360200151600281111561236357612363612cdc565b905292915050565b7f00000000000000000000000000000000000000000000000000000000000000007f00000000000000000000000000000000000000000000000000000000000000001561256f577f00000000000000000000000000000000000000000000000000000000000000006001600160a01b0316639623609d827f000000000000000000000000000000000000000000000000000000000000000060405180606001604052807f000000000000000000000000000000000000000000000000000000000000000067ffffffffffffffff1681526020017f000000000000000000000000000000000000000000000000000000000000000067ffffffffffffffff1681526020017f000000000000000000000000000000000000000000000000000000000000000067ffffffffffffffff168152506040516024016124ac91906134d3565b60408051601f198184030181529181526020820180517bffffffffffffffffffffffffffffffffffffffffffffffffffffffff167fa655d93700000000000000000000000000000000000000000000000000000000179052517fffffffff0000000000000000000000000000000000000000000000000000000060e086901b16815261253d93929190600401613516565b5f604051808303815f87803b158015612554575f5ffd5b505af1158015612566573d5f5f3e3d5ffd5b5050505061260e565b60405163266a23b160e21b81526001600160a01b0382811660048301527f0000000000000000000000000000000000000000000000000000000000000000811660248301527f000000000000000000000000000000000000000000000000000000000000000016906399a88ec4906044015f604051808303815f87803b1580156125f7575f5ffd5b505af1158015612609573d5f5f3e3d5ffd5b505050505b5f5f5f5f7f00000000000000000000000000000000000000000000000000000000000000006001600160a01b031663ebea461d6040518163ffffffff1660e01b8152600401608060405180830381865afa15801561266e573d5f5f3e3d5ffd5b505050506040513d601f19601f82011682018060405250810190612692919061354f565b93509350935093505f600c836126a89190613596565b156126c8576126b8600c846135a9565b6126c39060016135bc565b6126d3565b6126d3600c846135a9565b90508481116126e257846126e4565b805b94507f00000000000000000000000000000000000000000000000000000000000000006001600160a01b031663b31761f86040518060800160405280888152602001878152602001868152602001858152506040518263ffffffff1660e01b815260040161275291906135cf565b5f604051808303815f87803b158015612769575f5ffd5b505af115801561277b573d5f5f3e3d5ffd5b505050507f00000000000000000000000000000000000000000000000000000000000000006001600160a01b0316636ae71f126040518163ffffffff1660e01b81526004015f604051808303815f87803b1580156127d7575f5ffd5b505af11580156127e9573d5f5f3e3d5ffd5b50505050505050505050565b6113eb806135fb83390190565b610d91806149e683390190565b604051806102a001604052805f67ffffffffffffffff1681526020015f6001600160a01b031681526020015f81526020015f81526020015f6001600160a01b031681526020015f6001600160a01b031681526020015f8152602001606081526020015f81526020015f67ffffffffffffffff168152602001606081526020016128b560405180608001604052805f81526020015f81526020015f81526020015f81525090565b81526020015f81526020015f81526020015f81526020016128d461291a565b81525f602080830182905260408084018390526060808501849052608085018490528151908101825283815291820183905281019190915260a09091015290565b905290565b604051806060016040528061292d61295d565b81526020015f81526020015f81525090565b604051806040016040528061295261295d565b81526020015f905290565b6040518060400160405280612970612979565b81526020016129155b60405180604001604052806002906020820280368337509192915050565b6001600160a01b03811681146129ab575f5ffd5b50565b5f5f604083850312156129bf575f5ffd5b82356129ca81612997565b946020939093013593505050565b5f5f5f606084860312156129ea575f5ffd5b83356129f581612997565b92506020840135612a0581612997565b929592945050506040919091013590565b634e487b7160e01b5f52604160045260245ffd5b604051610180810167ffffffffffffffff81118282101715612a4e57612a4e612a16565b60405290565b6040805190810167ffffffffffffffff81118282101715612a4e57612a4e612a16565b604051601f8201601f1916810167ffffffffffffffff81118282101715612aa057612aa0612a16565b604052919050565b5f67ffffffffffffffff821115612ac157612ac1612a16565b5060051b60200190565b5f60208284031215612adb575f5ffd5b813567ffffffffffffffff811115612af1575f5ffd5b8201601f81018413612b01575f5ffd5b8035612b14612b0f82612aa8565b612a77565b8082825260208201915060208360051b850101925086831115612b35575f5ffd5b6020840193505b82841015612b60578335612b4f81612997565b825260209384019390910190612b3c565b9695505050505050565b5f60208284031215612b7a575f5ffd5b815161146081612997565b5f8151808452602084019350602083015f5b82811015612bb5578151865260209586019590910190600101612b97565b5093949350505050565b6001600160a01b038b16815267ffffffffffffffff8a1660208201526001600160a01b03891660408201528760608201528660808201528560a08201526001600160a01b03851660c08201526001600160a01b03841660e082015260ff83166101008201526101406101208201525f612c3c610140830184612b85565b9c9b505050505050505050505050565b5f81518084528060208401602086015e5f602082860101526020601f19601f83011685010191505092915050565b8051825f5b6002811015612c9e578251825260209283019290910190600101612c7f565b5050506020810151604083015f5b6002811015612cd557825167ffffffffffffffff16825260209283019290910190600101612cac565b5050505050565b634e487b7160e01b5f52602160045260245ffd5b60038110612d0c57634e487b7160e01b5f52602160045260245ffd5b9052565b612d1b828251612c7a565b6020810151612d2d6080840182612cf0565b506040015160a09190910152565b6001600160a01b0381511682526020810151612d6260208401826001600160a01b03169052565b506040810151612d7d60408401826001600160a01b03169052565b506060810151612d9860608401826001600160a01b03169052565b506080810151612db360808401826001600160a01b03169052565b5060a0810151612dce60a08401826001600160a01b03169052565b5060c0810151612de960c08401826001600160a01b03169052565b5060e0810151612e0460e08401826001600160a01b03169052565b50610100810151610a966101008401826001600160a01b03169052565b6101408152612e3e6101408201845167ffffffffffffffff169052565b5f6020840151612e5a6101608401826001600160a01b03169052565b50604084015161018083015260608401516101a083015260808401516001600160a01b039081166101c084015260a0850151166101e083015260c084015161020083015260e08401516103e0610220840152612eba610520840182612c4c565b9050610100850151610240840152610120850151612ee561026085018267ffffffffffffffff169052565b506101408501517ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffec084830301610280850152612f218282612b85565b61016087015180516102a087015260208101516102c087015260408101516102e0870152606001516103008601526101808701516103208601526101a08701516103408601526101c08701516103608601526101e08701519092509050612f8c610380850182612d10565b506102008501516104408401526102208501516001600160a01b031661046084015261024085015160ff1661048084015261026085015167ffffffffffffffff9081166104a0850152610280860151805182166104c086015260208082015183166104e087015260409091015190911661050085015290915061146090830184612d3b565b634e487b7160e01b5f52603260045260245ffd5b80518015158114613034575f5ffd5b919050565b5f60208284031215613049575f5ffd5b61146082613025565b5f8151808452602084019350602083015f5b82811015612bb55781516001600160a01b0316865260209586019590910190600101613064565b604081525f61309d6040830185613052565b82810360208401528084518083526020830191506020860192505f5b818110156130d957835115158352602093840193909201916001016130b9565b50909695505050505050565b805167ffffffffffffffff81168114613034575f5ffd5b5f6020828403121561310c575f5ffd5b611460826130e5565b5f60a0828403128015613126575f5ffd5b5060405160a0810167ffffffffffffffff8111828210171561314a5761314a612a16565b6040528251815261315d602084016130e5565b602082015261316e604084016130e5565b604082015261317f606084016130e5565b606082015261319060808401613025565b60808201529392505050565b602081525f6114606020830184613052565b634e487b7160e01b5f52601160045260245ffd5b67ffffffffffffffff8281168282160390811115610a0c57610a0c6131ae565b5f67ffffffffffffffff821667ffffffffffffffff8103613205576132056131ae565b60010192915050565b5f610180828403128015613220575f5ffd5b50613229612a2a565b82518152602080840151908201526040808401519082015261324d606084016130e5565b606082015261325e608084016130e5565b608082015261326f60a084016130e5565b60a082015261328060c084016130e5565b60c082015261329160e084016130e5565b60e08201526132a361010084016130e5565b6101008201526132b661012084016130e5565b6101208201526132c961014084016130e5565b610140820152610160928301519281019290925250919050565b5f82601f8301126132f2575f5ffd5b6132fc6040612a77565b80604084018581111561330d575f5ffd5b845b8181101561332e57613320816130e5565b84526020938401930161330f565b509095945050505050565b805160038110613034575f5ffd5b5f5f82840360c0811215613359575f5ffd5b60a0811215613366575f5ffd5b61336e612a54565b608082121561337b575f5ffd5b613383612a54565b915085601f860112613393575f5ffd5b61339d6040612a77565b8060408701888111156133ae575f5ffd5b875b818110156133c85780518452602093840193016133b0565b508185526133d689826132e3565b60208601525050508181526133ed60808601613339565b602082015260a094909401519395939450505050565b5f60c082019050613415828551612c7a565b60208401516134276080840182612cf0565b508260a08301529392505050565b5f60208284031215613445575f5ffd5b5051919050565b5f6020828403121561345c575f5ffd5b815167ffffffffffffffff811115613472575f5ffd5b8201601f81018413613482575f5ffd5b8051613490612b0f82612aa8565b8082825260208201915060208360051b8501019250868311156134b1575f5ffd5b6020840193505b82841015612b605783518252602093840193909101906134b8565b60608101610a0c828467ffffffffffffffff815116825267ffffffffffffffff602082015116602083015267ffffffffffffffff60408201511660408301525050565b6001600160a01b03841681526001600160a01b0383166020820152606060408201525f6135466060830184612c4c565b95945050505050565b5f5f5f5f60808587031215613562575f5ffd5b505082516020840151604085015160609095015191969095509092509050565b634e487b7160e01b5f52601260045260245ffd5b5f826135a4576135a4613582565b500690565b5f826135b7576135b7613582565b500490565b80820180821115610a0c57610a0c6131ae565b8151815260208083015190820152604080830151908201526060808301519082015260808101610a0c56fe6080604052348015600e575f5ffd5b506113cf8061001c5f395ff3fe608060405260043610610021575f3560e01c8063adfef6ac1461003857610030565b366100305761002e610057565b005b61002e610057565b348015610043575f5ffd5b5061002e610052366004610d67565b610069565b6100676100626101b8565b61029a565b565b5f6100726102bd565b6001600160a01b031614801561009757505f61008c6102ef565b6001600160a01b0316145b80156100b257505f6100a7610316565b6001600160a01b0316145b156101b0576101ac8160c0015183836040516024016100d2929190611127565b60408051601f19818403018152918152602080830180517bffffffffffffffffffffffffffffffffffffffffffffffffffffffff167f0ee5ef0c0000000000000000000000000000000000000000000000000000000017905260e08601519087015191516001600160a01b0390921660248301529060440160408051601f198184030181529190526020810180517bffffffffffffffffffffffffffffffffffffffffffffffffffffffff167fc4d66de800000000000000000000000000000000000000000000000000000000179052608087015161033d565b5050565b6101ac610057565b5f600436101561020f5760405162461bcd60e51b815260206004820152600b60248201527f4e4f5f46554e435f53494700000000000000000000000000000000000000000060448201526064015b60405180910390fd5b5f336102196102bd565b6001600160a01b0316036102345761022f6102ef565b61023c565b61023c610316565b90506001600160a01b0381163b6102955760405162461bcd60e51b815260206004820152601360248201527f5441524745545f4e4f545f434f4e5452414354000000000000000000000000006044820152606401610206565b919050565b365f5f375f5f365f845af43d5f5f3e8080156102b4573d5ff35b3d5ffd5b505050565b5f7fb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d61035b546001600160a01b0316919050565b5f7f360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc6102e0565b5f7f2b1dbce74324248c222f0ec2d5ed7bd323cfc425b336f0253c5ccfda7265546d6102e0565b61036860017fb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6104611317565b7fb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d61031461039657610396611336565b6103c160017f360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbd611317565b7f360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc146103ef576103ef611336565b61041a60017f2b1dbce74324248c222f0ec2d5ed7bd323cfc425b336f0253c5ccfda7265546e611317565b7f2b1dbce74324248c222f0ec2d5ed7bd323cfc425b336f0253c5ccfda7265546d1461044857610448611336565b6104518161046e565b61045c85855f6104c5565b61046783835f6104ef565b5050505050565b7f7e644d79422f17c01e4894b5f4f588d331ebfa28653d42ae832dc59e38c9798f6104976102bd565b604080516001600160a01b03928316815291841660208301520160405180910390a16104c2816104f8565b50565b6104ce836105d0565b5f825111806104da5750805b156102b8576104e9838361060f565b50505050565b6104ce8361063d565b6001600160a01b0381166105745760405162461bcd60e51b815260206004820152602660248201527f455243313936373a206e65772061646d696e20697320746865207a65726f206160448201527f64647265737300000000000000000000000000000000000000000000000000006064820152608401610206565b807fb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d61035b80547fffffffffffffffffffffffff0000000000000000000000000000000000000000166001600160a01b039290921691909117905550565b6105d98161067c565b6040516001600160a01b038216907fbc7cd75a20ee27fd9adebab32041f755214dbc6bffa90cc0225b39da2e5c2d3b905f90a250565b6060610634838360405180606001604052806027815260200161137360279139610720565b90505b92915050565b61064681610812565b6040516001600160a01b038216907ff7eed2a7fabbf1bec8d55ed5e785cc76622376dde5df4ff15470551e030b8134905f90a250565b6001600160a01b0381163b6106f95760405162461bcd60e51b815260206004820152602d60248201527f455243313936373a206e657720696d706c656d656e746174696f6e206973206e60448201527f6f74206120636f6e7472616374000000000000000000000000000000000000006064820152608401610206565b807f360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc610597565b60606001600160a01b0384163b61079f5760405162461bcd60e51b815260206004820152602660248201527f416464726573733a2064656c65676174652063616c6c20746f206e6f6e2d636f60448201527f6e747261637400000000000000000000000000000000000000000000000000006064820152608401610206565b5f5f856001600160a01b0316856040516107b9919061134a565b5f60405180830381855af49150503d805f81146107f1576040519150601f19603f3d011682016040523d82523d5f602084013e6107f6565b606091505b50915091506108068282866108b6565b925050505b9392505050565b6001600160a01b0381163b61088f5760405162461bcd60e51b815260206004820152603760248201527f455243313936373a206e6577207365636f6e6461727920696d706c656d656e7460448201527f6174696f6e206973206e6f74206120636f6e74726163740000000000000000006064820152608401610206565b807f2b1dbce74324248c222f0ec2d5ed7bd323cfc425b336f0253c5ccfda7265546d610597565b606083156108c557508161080b565b8251156108d55782518084602001fd5b8160405162461bcd60e51b81526004016102069190611360565b634e487b7160e01b5f52604160045260245ffd5b6040516060810167ffffffffffffffff81118282101715610926576109266108ef565b60405290565b6040805190810167ffffffffffffffff81118282101715610926576109266108ef565b604051610120810167ffffffffffffffff81118282101715610926576109266108ef565b6040516102a0810167ffffffffffffffff81118282101715610926576109266108ef565b604051601f8201601f1916810167ffffffffffffffff811182821017156109c0576109c06108ef565b604052919050565b803567ffffffffffffffff81168114610295575f5ffd5b80356001600160a01b0381168114610295575f5ffd5b5f82601f830112610a04575f5ffd5b813567ffffffffffffffff811115610a1e57610a1e6108ef565b610a316020601f19601f84011601610997565b818152846020838601011115610a45575f5ffd5b816020850160208301375f918101602001919091529392505050565b5f82601f830112610a70575f5ffd5b813567ffffffffffffffff811115610a8a57610a8a6108ef565b8060051b610a9a60208201610997565b91825260208185018101929081019086841115610ab5575f5ffd5b6020860192505b83831015610ad7578235825260209283019290910190610abc565b9695505050505050565b5f60808284031215610af1575f5ffd5b6040516080810167ffffffffffffffff81118282101715610b1457610b146108ef565b6040908152833582526020808501359083015283810135908201526060928301359281019290925250919050565b5f82601f830112610b51575f5ffd5b610b5b6040610997565b806040840185811115610b6c575f5ffd5b845b81811015610b8d57610b7f816109c8565b845260209384019301610b6e565b509095945050505050565b803560038110610295575f5ffd5b5f81830360c0811215610bb7575f5ffd5b610bbf610903565b91506080811215610bce575f5ffd5b50610bd761092c565b83601f840112610be5575f5ffd5b610bef6040610997565b806040850186811115610c00575f5ffd5b855b81811015610c1a578035845260209384019301610c02565b50818452610c288782610b42565b60208501525050508152610c3e60808301610b98565b602082015260a091909101356040820152919050565b803560ff81168114610295575f5ffd5b5f60608284031215610c74575f5ffd5b610c7c610903565b9050610c87826109c8565b8152610c95602083016109c8565b6020820152610ca6604083016109c8565b604082015292915050565b5f6101208284031215610cc2575f5ffd5b610cca61094f565b9050610cd5826109df565b8152610ce3602083016109df565b6020820152610cf4604083016109df565b6040820152610d05606083016109df565b6060820152610d16608083016109df565b6080820152610d2760a083016109df565b60a0820152610d3860c083016109df565b60c0820152610d4960e083016109df565b60e0820152610d5b61010083016109df565b61010082015292915050565b5f5f6101408385031215610d79575f5ffd5b823567ffffffffffffffff811115610d8f575f5ffd5b83016103e08186031215610da1575f5ffd5b610da9610973565b610db2826109c8565b8152610dc0602083016109df565b60208201526040828101359082015260608083013590820152610de5608083016109df565b6080820152610df660a083016109df565b60a082015260c0828101359082015260e082013567ffffffffffffffff811115610e1e575f5ffd5b610e2a878285016109f5565b60e0830152506101008281013590820152610e4861012083016109c8565b61012082015261014082013567ffffffffffffffff811115610e68575f5ffd5b610e7487828501610a61565b61014083015250610e89866101608401610ae1565b6101608201526101e08201356101808201526102008201356101a08201526102208201356101c0820152610ec1866102408401610ba6565b6101e0820152610300820135610200820152610ee061032083016109df565b610220820152610ef36103408301610c54565b610240820152610f0661036083016109c8565b610260820152610f1a866103808401610c64565b6102808201529250610f3190508460208501610cb1565b90509250929050565b5f81518084528060208401602086015e5f602082860101526020601f19601f83011685010191505092915050565b5f8151808452602084019350602083015f5b82811015610f98578151865260209586019590910190600101610f7a565b5093949350505050565b60038110610fbe57634e487b7160e01b5f52602160045260245ffd5b9052565b80518051835f5b6002811015610fe8578251825260209283019290910190600101610fc9565b50505060200151604083015f5b600281101561101e57825167ffffffffffffffff16825260209283019290910190600101610ff5565b50505060208101516110336080840182610fa2565b506040015160a09190910152565b6001600160a01b038151168252602081015161106860208401826001600160a01b03169052565b50604081015161108360408401826001600160a01b03169052565b50606081015161109e60608401826001600160a01b03169052565b5060808101516110b960808401826001600160a01b03169052565b5060a08101516110d460a08401826001600160a01b03169052565b5060c08101516110ef60c08401826001600160a01b03169052565b5060e081015161110a60e08401826001600160a01b03169052565b506101008101516102b86101008401826001600160a01b03169052565b61014081526111446101408201845167ffffffffffffffff169052565b5f60208401516111606101608401826001600160a01b03169052565b50604084015161018083015260608401516101a083015260808401516001600160a01b039081166101c084015260a0850151166101e083015260c084015161020083015260e08401516103e06102208401526111c0610520840182610f3a565b90506101008501516102408401526101208501516111eb61026085018267ffffffffffffffff169052565b506101408501517ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffec0848303016102808501526112278282610f68565b61016087015180516102a087015260208101516102c087015260408101516102e0870152606001516103008601526101808701516103208601526101a08701516103408601526101c08701516103608601526101e08701519092509050611292610380850182610fc2565b506102008501516104408401526102208501516001600160a01b031661046084015261024085015160ff1661048084015261026085015167ffffffffffffffff9081166104a0850152610280860151805182166104c086015260208082015183166104e087015260409091015190911661050085015290915061080b90830184611041565b8181038181111561063757634e487b7160e01b5f52601160045260245ffd5b634e487b7160e01b5f52600160045260245ffd5b5f82518060208501845e5f920191825250919050565b602081525f6106346020830184610f3a56fe416464726573733a206c6f772d6c6576656c2064656c65676174652063616c6c206661696c6564a26469706673582212209bf2c0238c2505716be0e1d04df7889d4edb5024e1ba28c8c320a9287abfd25c64736f6c634300081c00336080604052604051610d91380380610d91833981016040819052610022916103b7565b828161002f82825f610043565b5061003b90508261006e565b5050506104d3565b61004c836100db565b5f825111806100585750805b1561006957610067838361011a565b505b505050565b7f7e644d79422f17c01e4894b5f4f588d331ebfa28653d42ae832dc59e38c9798f6100ad5f516020610d4a5f395f51905f52546001600160a01b031690565b604080516001600160a01b03928316815291841660208301520160405180910390a16100d881610146565b50565b6100e4816101e1565b6040516001600160a01b038216907fbc7cd75a20ee27fd9adebab32041f755214dbc6bffa90cc0225b39da2e5c2d3b905f90a250565b606061013f8383604051806060016040528060278152602001610d6a60279139610275565b9392505050565b6001600160a01b0381166101b05760405162461bcd60e51b815260206004820152602660248201527f455243313936373a206e65772061646d696e20697320746865207a65726f206160448201526564647265737360d01b60648201526084015b60405180910390fd5b805f516020610d4a5f395f51905f525b80546001600160a01b0319166001600160a01b039290921691909117905550565b6001600160a01b0381163b61024e5760405162461bcd60e51b815260206004820152602d60248201527f455243313936373a206e657720696d706c656d656e746174696f6e206973206e60448201526c1bdd08184818dbdb9d1c9858dd609a1b60648201526084016101a7565b807f360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc6101c0565b60606001600160a01b0384163b6102dd5760405162461bcd60e51b815260206004820152602660248201527f416464726573733a2064656c65676174652063616c6c20746f206e6f6e2d636f6044820152651b9d1c9858dd60d21b60648201526084016101a7565b5f5f856001600160a01b0316856040516102f79190610488565b5f60405180830381855af49150503d805f811461032f576040519150601f19603f3d011682016040523d82523d5f602084013e610334565b606091505b50909250905061034582828661034f565b9695505050505050565b6060831561035e57508161013f565b82511561036e5782518084602001fd5b8160405162461bcd60e51b81526004016101a7919061049e565b80516001600160a01b038116811461039e575f5ffd5b919050565b634e487b7160e01b5f52604160045260245ffd5b5f5f5f606084860312156103c9575f5ffd5b6103d284610388565b92506103e060208501610388565b60408501519092506001600160401b038111156103fb575f5ffd5b8401601f8101861361040b575f5ffd5b80516001600160401b03811115610424576104246103a3565b604051601f8201601f19908116603f011681016001600160401b0381118282101715610452576104526103a3565b604052818152828201602001881015610469575f5ffd5b8160208401602083015e5f602083830101528093505050509250925092565b5f82518060208501845e5f920191825250919050565b602081525f82518060208401528060208501604085015e5f604082850101526040601f19601f83011684010191505092915050565b61086a806104e05f395ff3fe60806040526004361061005d575f3560e01c80635c60da1b116100425780635c60da1b146100a65780638f283970146100d6578063f851a440146100f55761006c565b80633659cfe6146100745780634f1ef286146100935761006c565b3661006c5761006a610109565b005b61006a610109565b34801561007f575f5ffd5b5061006a61008e36600461070d565b610123565b61006a6100a1366004610726565b61015e565b3480156100b1575f5ffd5b506100ba6101c4565b6040516001600160a01b03909116815260200160405180910390f35b3480156100e1575f5ffd5b5061006a6100f036600461070d565b6101f4565b348015610100575f5ffd5b506100ba610214565b610111610234565b61012161011c6102e4565b6102ed565b565b61012b61030b565b6001600160a01b03163303610156576101538160405180602001604052805f8152505f61033d565b50565b610153610109565b61016661030b565b6001600160a01b031633036101bc576101b78383838080601f0160208091040260200160405190810160405280939291908181526020018383808284375f920191909152506001925061033d915050565b505050565b6101b7610109565b5f6101cd61030b565b6001600160a01b031633036101e9576101e46102e4565b905090565b6101f1610109565b90565b6101fc61030b565b6001600160a01b031633036101565761015381610367565b5f61021d61030b565b6001600160a01b031633036101e9576101e461030b565b61023c61030b565b6001600160a01b031633036101215760405162461bcd60e51b815260206004820152604260248201527f5472616e73706172656e745570677261646561626c6550726f78793a2061646d60448201527f696e2063616e6e6f742066616c6c6261636b20746f2070726f7879207461726760648201527f6574000000000000000000000000000000000000000000000000000000000000608482015260a4015b60405180910390fd5b5f6101e46103bb565b365f5f375f5f365f845af43d5f5f3e808015610307573d5ff35b3d5ffd5b5f7fb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d61035b546001600160a01b0316919050565b610346836103e2565b5f825111806103525750805b156101b7576103618383610421565b50505050565b7f7e644d79422f17c01e4894b5f4f588d331ebfa28653d42ae832dc59e38c9798f61039061030b565b604080516001600160a01b03928316815291841660208301520160405180910390a16101538161044d565b5f7f360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc61032e565b6103eb81610525565b6040516001600160a01b038216907fbc7cd75a20ee27fd9adebab32041f755214dbc6bffa90cc0225b39da2e5c2d3b905f90a250565b6060610446838360405180606001604052806027815260200161080e602791396105c9565b9392505050565b6001600160a01b0381166104c95760405162461bcd60e51b815260206004820152602660248201527f455243313936373a206e65772061646d696e20697320746865207a65726f206160448201527f646472657373000000000000000000000000000000000000000000000000000060648201526084016102db565b807fb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d61035b80547fffffffffffffffffffffffff0000000000000000000000000000000000000000166001600160a01b039290921691909117905550565b6001600160a01b0381163b6105a25760405162461bcd60e51b815260206004820152602d60248201527f455243313936373a206e657720696d706c656d656e746174696f6e206973206e60448201527f6f74206120636f6e74726163740000000000000000000000000000000000000060648201526084016102db565b807f360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc6104ec565b60606001600160a01b0384163b6106485760405162461bcd60e51b815260206004820152602660248201527f416464726573733a2064656c65676174652063616c6c20746f206e6f6e2d636f60448201527f6e7472616374000000000000000000000000000000000000000000000000000060648201526084016102db565b5f5f856001600160a01b03168560405161066291906107a4565b5f60405180830381855af49150503d805f811461069a576040519150601f19603f3d011682016040523d82523d5f602084013e61069f565b606091505b50915091506106af8282866106b9565b9695505050505050565b606083156106c8575081610446565b8251156106d85782518084602001fd5b8160405162461bcd60e51b81526004016102db91906107ba565b80356001600160a01b0381168114610708575f5ffd5b919050565b5f6020828403121561071d575f5ffd5b610446826106f2565b5f5f5f60408486031215610738575f5ffd5b610741846106f2565b9250602084013567ffffffffffffffff81111561075c575f5ffd5b8401601f8101861361076c575f5ffd5b803567ffffffffffffffff811115610782575f5ffd5b866020828401011115610793575f5ffd5b939660209190910195509293505050565b5f82518060208501845e5f920191825250919050565b602081525f82518060208401528060208501604085015e5f6040828501015260407fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe0601f8301168401019150509291505056fe416464726573733a206c6f772d6c6576656c2064656c65676174652063616c6c206661696c6564a2646970667358221220a45c5c13909613fb1c44f249ce77bfb03cdf47a4f42bcc05d796fa83a595accb64736f6c634300081c0033b53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103416464726573733a206c6f772d6c6576656c2064656c65676174652063616c6c206661696c6564a264697066735822122099e383a163f14c482f5ba664222263ef94d08f1018d289953292ed7d3d49866464736f6c634300081c00336080604052348015600e575f5ffd5b50610a148061001c5f395ff3fe608060405234801561000f575f5ffd5b506004361061003f575f3560e01c806331644130146100435780638eaa6ac014610069578063945c94941461008a575b5f5ffd5b610056610051366004610411565b61009f565b6040519081526020015b60405180910390f35b61007c61007736600461043a565b61018f565b604051610060929190610471565b61009d6100983660046104f6565b6102b7565b005b5f61014e6100b2368590038501856105b0565b8051805160209182015192820151805190830151604080517f476c6f62616c2073746174653a0000000000000000000000000000000000000081870152602d810194909452604d8401959095527fffffffffffffffff00000000000000000000000000000000000000000000000060c092831b8116606d850152911b1660758201528251808203605d018152607d909101909252815191012090565b8261015f60a0860160808701610683565b604051602001610171939291906106a5565b60405160208183030381529060405280519060200120905092915050565b6101976103a2565b5f82815260208190526040812080546101af906106e0565b80601f01602080910402602001604051908101604052809291908181526020018280546101db906106e0565b80156102265780601f106101fd57610100808354040283529160200191610226565b820191905f5260205f20905b81548152906001019060200180831161020957829003601f168201915b505050505080602001905181019061023e919061077a565b90925090505f8190036102b2576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152601060248201527f48617368206e6f7420796574207365740000000000000000000000000000000060448201526064015b60405180910390fd5b915091565b6102c1828261009f565b8314610329576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152600c60248201527f496e76616c69642068617368000000000000000000000000000000000000000060448201526064016102a9565b818160405160200161033c92919061089b565b60408051601f198184030181529181525f858152602081905220906103619082610901565b507f14c0a6b8d81f5915dacfd85e41ae4798343ec29de408ac4c13360c7238ae0ad9838383604051610395939291906109bc565b60405180910390a1505050565b60405180604001604052806103b56103c1565b81526020015f5b905290565b60405180604001604052806103d46103dd565b81526020016103bc5b60405180604001604052806002906020820280368337509192915050565b5f60a0828403121561040b575f5ffd5b50919050565b5f5f60c08385031215610422575f5ffd5b61042c84846103fb565b9460a0939093013593505050565b5f6020828403121561044a575f5ffd5b5035919050565b6003811061046d57634e487b7160e01b5f52602160045260245ffd5b9052565b8251805160c083019190835f5b600281101561049d57825182526020928301929091019060010161047e565b50505060200151604083015f5b60028110156104d357825167ffffffffffffffff168252602092830192909101906001016104aa565b50505060208401516104e86080840182610451565b508260a08301529392505050565b5f5f5f60e08486031215610508575f5ffd5b8335925061051985602086016103fb565b9295929450505060c0919091013590565b634e487b7160e01b5f52604160045260245ffd5b6040805190810167ffffffffffffffff811182821017156105615761056161052a565b60405290565b604051601f8201601f1916810167ffffffffffffffff811182821017156105905761059061052a565b604052919050565b67ffffffffffffffff811681146105ad575f5ffd5b50565b5f60808284031280156105c1575f5ffd5b506105ca61053e565b83601f8401126105d8575f5ffd5b60406105e381610567565b80828601878111156105f3575f5ffd5b865b8181101561060d5780358452602093840193016105f5565b508185525f925087601f820112610622575f5ffd5b83915061062e82610567565b9381019391508188851115610641575f5ffd5b8482101561066657813561065481610598565b83526020928301929190910190610641565b602086015250929695505050505050565b600381106105ad575f5ffd5b5f60208284031215610693575f5ffd5b813561069e81610677565b9392505050565b8381528260208201525f600383106106cb57634e487b7160e01b5f52602160045260245ffd5b5060f89190911b604082015260410192915050565b600181811c908216806106f457607f821691505b60208210810361040b57634e487b7160e01b5f52602260045260245ffd5b5f82601f830112610721575f5ffd5b61072b6040610567565b80604084018581111561073c575f5ffd5b845b8181101561075f57805161075181610598565b84526020938401930161073e565b509095945050505050565b805161077581610677565b919050565b5f5f82840360c081121561078c575f5ffd5b60a0811215610799575f5ffd5b6107a161053e565b60808212156107ae575f5ffd5b6107b661053e565b915085601f8601126107c6575f5ffd5b6107d06040610567565b8060408701888111156107e1575f5ffd5b875b818110156107fb5780518452602093840193016107e3565b508185526108098982610712565b60208601525050508181526108206080860161076a565b602082015260a094909401519395939450505050565b604081833760408201604082015f5b600281101561087857813561085981610598565b67ffffffffffffffff1683526020928301929190910190600101610845565b505050608081013561088981610677565b6108966080840182610451565b505050565b60c081016108a98285610836565b8260a08301529392505050565b601f82111561089657805f5260205f20601f840160051c810160208510156108db5750805b601f840160051c820191505b818110156108fa575f81556001016108e7565b5050505050565b815167ffffffffffffffff81111561091b5761091b61052a565b61092f8161092984546106e0565b846108b6565b6020601f821160018114610961575f831561094a5750848201515b5f19600385901b1c1916600184901b1784556108fa565b5f84815260208120601f198516915b828110156109905787850151825560209485019460019092019101610970565b50848210156109ad57868401515f19600387901b60f8161c191681555b50505050600190811b01905550565b83815260e081016109d06020830185610836565b8260c083015294935050505056fea26469706673582212203d3457c992281e1291ace21a85ee138807ac208b46611b5efe9aa318ab0d089f64736f6c634300081c0033608060405234801561000f575f5ffd5b5060405161029938038061029983398101604081905261002e916100b8565b8051610040905f906020840190610047565b505061017f565b828054828255905f5260205f20908101928215610080579160200282015b82811115610080578251825591602001919060010190610065565b5061008c929150610090565b5090565b5b8082111561008c575f8155600101610091565b634e487b7160e01b5f52604160045260245ffd5b5f602082840312156100c8575f5ffd5b81516001600160401b038111156100dd575f5ffd5b8201601f810184136100ed575f5ffd5b80516001600160401b03811115610106576101066100a4565b604051600582901b90603f8201601f191681016001600160401b0381118282101715610134576101346100a4565b604052918252602081840181019290810187841115610151575f5ffd5b6020850194505b8385101561017457845180825260209586019590935001610158565b509695505050505050565b61010d8061018c5f395ff3fe6080604052348015600e575f5ffd5b50600436106026575f3560e01c8063b0ec2ae114602a575b5f5ffd5b60306044565b604051603b91906097565b60405180910390f35b60605f805480602002602001604051908101604052809291908181526020018280548015608d57602002820191905f5260205f20905b815481526020019060010190808311607a575b5050505050905090565b602080825282518282018190525f918401906040840190835b8181101560cc57835183526020938401939092019160010160b0565b50909594505050505056fea264697066735822122058ee6450870e5d48741d10db10242bc95999b7783c96e726baa4afb184f96a6f64736f6c634300081c0033
    /// ```
    #[rustfmt::skip]
    #[allow(clippy::all)]
    pub static BYTECODE: alloy_sol_types::private::Bytes = alloy_sol_types::private::Bytes::from_static(
        b"a\x05\x80`@R4\x80\x15a\0\x10W__\xFD[P`@Qao\xDC8\x03\x80ao\xDC\x839\x81\x01`@\x81\x90Ra\0/\x91a\x06\xB1V[\x83Q`\x01`\x01`\xA0\x1B\x03\x90\x81\x16a\x01\0R` \x80\x86\x01Q\x82\x16a\x01 R`@\x80\x87\x01Q\x83\x16a\x01@R``\x80\x88\x01Q\x84\x16a\x01`R`\x80\x80\x89\x01Q\x85\x16a\x01\x80R`\xA0\x89\x01Q\x85\x16a\x01\xA0R`\xC0\x89\x01Q\x85\x16a\x01\xC0R`\xE0\x89\x01Q\x85\x16a\x03\xA0R\x87Q\x85\x16a\x03\xC0R\x92\x87\x01Q\x84\x16a\x03\xE0R\x86\x82\x01Q\x84\x16a\x04\0R\x86\x01Q\x83\x16a\x04 R\x90\x85\x01Q\x90\x91\x16a\x04@RQa\0\xCB\x90a\x02XV[`@Q\x80\x91\x03\x90_\xF0\x80\x15\x80\x15a\0\xE4W=__>=_\xFD[P`\x01`\x01`\xA0\x1B\x03\x90\x81\x16a\x04`R\x82Q\x81\x16a\x04\x80R` \x80\x84\x01Q\x82\x16a\x04\xA0R`@\x80\x85\x01Q\x83\x16a\x04\xC0R``\x80\x86\x01Q\x84\x16a\x04\xE0R`\x80\x80\x87\x01Q\x85\x16a\x05\0R`\xA0\x80\x88\x01Q\x86\x16a\x05 R`\xC0\x80\x89\x01Q\x87\x16a\x05@R`\xE0\x80\x8A\x01Q\x88\x16a\x05`R\x91\x88\x01Qa\x02`R\x87\x01Qa\x02\x80R\x86\x01Q`\x01`\x01`@\x1B\x03\x90\x81\x16a\x02\xA0R\x86Q\x81\x16a\x01\xE0R\x93\x86\x01Q\x90\x93\x16a\x02\0R\x84\x82\x01Q\x90\x93\x16a\x02 R\x91\x83\x01Qa\x02@R\x82\x01Q\x90Qa\x01\xA5\x90a\x02eV[a\x01\xAF\x91\x90a\x07\xB5V[`@Q\x80\x91\x03\x90_\xF0\x80\x15\x80\x15a\x01\xC8W=__>=_\xFD[P`\x01`\x01`\xA0\x1B\x03\x16a\x03\0Ra\x01\0\x81\x01Q\x15\x15a\x02\xC0Ra\x01 \x81\x01Q`\x80Ra\x01@\x81\x01Q`\xA0Ra\x01`\x81\x01Q`\xC0Ra\x01\x80\x81\x01Q`\xFF\x16`\xE0Ra\x01\xA0\x81\x01Q`\x01`\x01`@\x1B\x03\x90\x81\x16a\x02\xE0Ra\x01\xC0\x82\x01Q\x15\x15a\x03 Ra\x01\xE0\x90\x91\x01\x80Q` \x01Q\x82\x16a\x03@R\x80QQ\x82\x16a\x03`RQ`@\x01Q\x16a\x03\x80RPa\x07\xF7\x91PPV[a\n0\x80ac\x13\x839\x01\x90V[a\x02\x99\x80amC\x839\x01\x90V[cNH{q`\xE0\x1B_R`A`\x04R`$_\xFD[`@Qa\x01\0\x81\x01`\x01`\x01`@\x1B\x03\x81\x11\x82\x82\x10\x17\x15a\x02\xA9Wa\x02\xA9a\x02rV[`@R\x90V[`@Qa\x02\0\x81\x01`\x01`\x01`@\x1B\x03\x81\x11\x82\x82\x10\x17\x15a\x02\xA9Wa\x02\xA9a\x02rV[`@Q`\x1F\x82\x01`\x1F\x19\x16\x81\x01`\x01`\x01`@\x1B\x03\x81\x11\x82\x82\x10\x17\x15a\x02\xFAWa\x02\xFAa\x02rV[`@R\x91\x90PV[`\x01`\x01`\xA0\x1B\x03\x81\x16\x81\x14a\x03\x16W__\xFD[PV[\x80Qa\x03$\x81a\x03\x02V[\x91\x90PV[_`\xA0\x82\x84\x03\x12\x15a\x039W__\xFD[`@Q`\xA0\x81\x01`\x01`\x01`@\x1B\x03\x81\x11\x82\x82\x10\x17\x15a\x03[Wa\x03[a\x02rV[\x80`@RP\x80\x91P\x82Qa\x03n\x81a\x03\x02V[\x81R` \x83\x01Qa\x03~\x81a\x03\x02V[` \x82\x01R`@\x83\x01Qa\x03\x91\x81a\x03\x02V[`@\x82\x01R``\x83\x01Qa\x03\xA4\x81a\x03\x02V[``\x82\x01R`\x80\x83\x01Qa\x03\xB7\x81a\x03\x02V[`\x80\x91\x90\x91\x01R\x92\x91PPV[_a\x01\0\x82\x84\x03\x12\x15a\x03\xD5W__\xFD[a\x03\xDDa\x02\x86V[\x90P\x81Qa\x03\xEA\x81a\x03\x02V[\x81Ra\x03\xF8` \x83\x01a\x03\x19V[` \x82\x01Ra\x04\t`@\x83\x01a\x03\x19V[`@\x82\x01Ra\x04\x1A``\x83\x01a\x03\x19V[``\x82\x01Ra\x04+`\x80\x83\x01a\x03\x19V[`\x80\x82\x01Ra\x04<`\xA0\x83\x01a\x03\x19V[`\xA0\x82\x01Ra\x04M`\xC0\x83\x01a\x03\x19V[`\xC0\x82\x01Ra\x04^`\xE0\x83\x01a\x03\x19V[`\xE0\x82\x01R\x92\x91PPV[\x80Q`\x01`\x01`@\x1B\x03\x81\x16\x81\x14a\x03$W__\xFD[_\x82`\x1F\x83\x01\x12a\x04\x8EW__\xFD[\x81Q`\x01`\x01`@\x1B\x03\x81\x11\x15a\x04\xA7Wa\x04\xA7a\x02rV[\x80`\x05\x1Ba\x04\xB7` \x82\x01a\x02\xD2V[\x91\x82R` \x81\x85\x01\x81\x01\x92\x90\x81\x01\x90\x86\x84\x11\x15a\x04\xD2W__\xFD[` \x86\x01\x92P[\x83\x83\x10\x15a\x04\xF4W\x82Q\x82R` \x92\x83\x01\x92\x90\x91\x01\x90a\x04\xD9V[\x96\x95PPPPPPV[\x80Q\x80\x15\x15\x81\x14a\x03$W__\xFD[\x80Q`\xFF\x81\x16\x81\x14a\x03$W__\xFD[_``\x82\x84\x03\x12\x15a\x05-W__\xFD[`@Q``\x81\x01`\x01`\x01`@\x1B\x03\x81\x11\x82\x82\x10\x17\x15a\x05OWa\x05Oa\x02rV[`@R\x90P\x80a\x05^\x83a\x04iV[\x81Ra\x05l` \x84\x01a\x04iV[` \x82\x01Ra\x05}`@\x84\x01a\x04iV[`@\x82\x01RP\x92\x91PPV[_a\x02@\x82\x84\x03\x12\x15a\x05\x9AW__\xFD[a\x05\xA2a\x02\xAFV[\x90Pa\x05\xAD\x82a\x04iV[\x81Ra\x05\xBB` \x83\x01a\x04iV[` \x82\x01Ra\x05\xCC`@\x83\x01a\x03\x19V[`@\x82\x01R``\x82\x81\x01Q\x90\x82\x01R`\x80\x82\x01Q`\x01`\x01`@\x1B\x03\x81\x11\x15a\x05\xF3W__\xFD[a\x05\xFF\x84\x82\x85\x01a\x04\x7FV[`\x80\x83\x01RP`\xA0\x82\x81\x01Q\x90\x82\x01R`\xC0\x80\x83\x01Q\x90\x82\x01Ra\x06%`\xE0\x83\x01a\x04iV[`\xE0\x82\x01Ra\x067a\x01\0\x83\x01a\x04\xFEV[a\x01\0\x82\x01Ra\x01 \x82\x81\x01Q\x90\x82\x01Ra\x01@\x80\x83\x01Q\x90\x82\x01Ra\x01`\x80\x83\x01Q\x90\x82\x01Ra\x06ka\x01\x80\x83\x01a\x05\rV[a\x01\x80\x82\x01Ra\x06~a\x01\xA0\x83\x01a\x04iV[a\x01\xA0\x82\x01Ra\x06\x91a\x01\xC0\x83\x01a\x04\xFEV[a\x01\xC0\x82\x01Ra\x06\xA5\x83a\x01\xE0\x84\x01a\x05\x1DV[a\x01\xE0\x82\x01R\x92\x91PPV[____\x84\x86\x03a\x02\xC0\x81\x12\x15a\x06\xC6W__\xFD[a\x01\0\x81\x12\x15a\x06\xD4W__\xFD[Pa\x06\xDDa\x02\x86V[\x85Qa\x06\xE8\x81a\x03\x02V[\x81Ra\x06\xF6` \x87\x01a\x03\x19V[` \x82\x01Ra\x07\x07`@\x87\x01a\x03\x19V[`@\x82\x01Ra\x07\x18``\x87\x01a\x03\x19V[``\x82\x01Ra\x07)`\x80\x87\x01a\x03\x19V[`\x80\x82\x01Ra\x07:`\xA0\x87\x01a\x03\x19V[`\xA0\x82\x01Ra\x07K`\xC0\x87\x01a\x03\x19V[`\xC0\x82\x01Ra\x07\\`\xE0\x87\x01a\x03\x19V[`\xE0\x82\x01R\x93Pa\x07q\x86a\x01\0\x87\x01a\x03)V[\x92Pa\x07\x81\x86a\x01\xA0\x87\x01a\x03\xC4V[a\x02\xA0\x86\x01Q\x90\x92P`\x01`\x01`@\x1B\x03\x81\x11\x15a\x07\x9DW__\xFD[a\x07\xA9\x87\x82\x88\x01a\x05\x89V[\x91PP\x92\x95\x91\x94P\x92PV[` \x80\x82R\x82Q\x82\x82\x01\x81\x90R_\x91\x84\x01\x90`@\x84\x01\x90\x83[\x81\x81\x10\x15a\x07\xECW\x83Q\x83R` \x93\x84\x01\x93\x90\x92\x01\x91`\x01\x01a\x07\xCEV[P\x90\x95\x94PPPPPV[`\x80Q`\xA0Q`\xC0Q`\xE0Qa\x01\0Qa\x01 Qa\x01@Qa\x01`Qa\x01\x80Qa\x01\xA0Qa\x01\xC0Qa\x01\xE0Qa\x02\0Qa\x02 Qa\x02@Qa\x02`Qa\x02\x80Qa\x02\xA0Qa\x02\xC0Qa\x02\xE0Qa\x03\0Qa\x03 Qa\x03@Qa\x03`Qa\x03\x80Qa\x03\xA0Qa\x03\xC0Qa\x03\xE0Qa\x04\0Qa\x04 Qa\x04@Qa\x04`Qa\x04\x80Qa\x04\xA0Qa\x04\xC0Qa\x04\xE0Qa\x05\0Qa\x05 Qa\x05@Qa\x05`QaW\xACa\x0Bg_9_\x81\x81a\x03\xF1\x01Ra\n\xB1\x01R_\x81\x81a\x03$\x01Ra\x0CG\x01R_\x81\x81a\x04\xF6\x01Ra\x0Cv\x01R_\x81\x81a\x07\xEB\x01Ra\":\x01R_\x81\x81a\x07\x9D\x01Ra!\x0C\x01R_\x81\x81a\x06\x19\x01Ra L\x01R_\x81\x81a\x07\xC4\x01R\x81\x81a#\xE4\x01Ra%\x8E\x01R_\x81\x81a\x08\x87\x01Ra\x1E\xF3\x01R_\x81\x81a\x08\x12\x01R\x81\x81a\x19u\x01Ra\x1A2\x01R_\x81\x81a\x05\x1D\x01Ra u\x01R_\x81\x81a\x04\xA0\x01R\x81\x81a#\xB4\x01Ra%\xB6\x01R_\x81\x81a\x04\xCF\x01Ra!6\x01R_\x81\x81a\x03\x8A\x01R\x81\x81a\n\xD2\x01Ra\x1F\x1C\x01R_\x81\x81a\x03c\x01Ra\"d\x01R_\x81\x81a\x06\xCA\x01Ra\r\xAE\x01R_\x81\x81a\x08\xD5\x01Ra$p\x01R_\x81\x81a\x05\xF2\x01Ra$\x10\x01R_\x81\x81a\x08`\x01Ra$@\x01R_\x81\x81a\x08\xAE\x01Ra#\x8E\x01R_\x81\x81a\x07(\x01Ra\x1D3\x01R_\x81\x81a\t\x0F\x01Ra\x1Ev\x01R_\x81\x81a\x06\xF1\x01R\x81\x81a\x11n\x01Ra\x11\xBA\x01R_\x81\x81a\x05D\x01Ra\x1D\x03\x01R_\x81\x81a\x02\xEA\x01Ra\x1C\xDD\x01R_\x81\x81a\x06@\x01Ra\x1C\xA3\x01R_\x81\x81a\t\x84\x01Ra\x1B\xBA\x01R_\x81\x81a\x04?\x01Ra\x1B\x8B\x01R_\x81\x81a\x06\x8E\x01Ra\r\x8D\x01R_\x81\x81a\x03\xB1\x01Ra\x1B[\x01R_\x81\x81a\x07O\x01R\x81\x81a\x0B\xAB\x01Ra #\x01R_\x81\x81a\x04\x18\x01R\x81\x81a\x0B\xDA\x01R\x81\x81a\"\x11\x01Ra\"\xBE\x01R_\x81\x81a\x07v\x01R\x81\x81a\x0C\t\x01R\x81\x81a \xE3\x01Ra!\x90\x01R_\x81\x81a\x089\x01R\x81\x81a\x0B|\x01R\x81\x81a#m\x01R\x81\x81a&\x14\x01R\x81\x81a&\xE8\x01Ra'\x81\x01R_\x81\x81a\t6\x01R\x81\x81a\x0BM\x01R\x81\x81a\x1E\xCA\x01Ra\x1F\xAB\x01R_\x81\x81a\x06g\x01R\x81\x81a\x0C\xA5\x01R\x81\x81a\x0F\xCC\x01R\x81\x81a\x12$\x01R\x81\x81a\x14i\x01R\x81\x81a\x14\xD8\x01R\x81\x81a\x15\xC7\x01R\x81\x81a\x16u\x01R\x81\x81a\x17t\x01R\x81\x81a\x18\x11\x01R\x81\x81a\x18@\x01Ra\x1B\xE0\x01R_\x81\x81a\x05\xCB\x01R\x81\x81a\r\xE6\x01Ra\x1Ct\x01R_\x81\x81a\x05k\x01Ra\x1EM\x01R_\x81\x81a\t]\x01Ra\x1E\x0C\x01R_\x81\x81a\x04f\x01Ra\x1D\xE6\x01R_\x81\x81a\x05\xA4\x01Ra\x1D\xC0\x01RaW\xAC_\xF3\xFE`\x80`@R4\x80\x15a\0\x0FW__\xFD[P`\x046\x10a\x02\xE1W_5`\xE0\x1C\x80c\x87e$\x0F\x11a\x01\x87W\x80c\xCC\x80\x89\xBB\x11a\0\xDDW\x80c\xEBezN\x11a\0\x93W\x80c\xEE\x9A1\xA2\x11a\0nW\x80c\xEE\x9A1\xA2\x14a\t1W\x80c\xFA(t \x14a\tXW\x80c\xFA\xF5b_\x14a\t\x7FW__\xFD[\x80c\xEBezN\x14a\x08\xD0W\x80c\xEB\xE0:\x93\x14a\x08\xF7W\x80c\xECOt\xCE\x14a\t\nW__\xFD[\x80c\xD4\x9DQ\x81\x11a\0\xC3W\x80c\xD4\x9DQ\x81\x14a\x08[W\x80c\xDA\xE7\xCB\x8B\x14a\x08\x82W\x80c\xE8\x18\x0C)\x14a\x08\xA9W__\xFD[\x80c\xCC\x80\x89\xBB\x14a\x08\rW\x80c\xD3\x84\xCB\x95\x14a\x084W__\xFD[\x80c\xB5\xE0\x0C?\x11a\x01=W\x80c\xC2\x1CB3\x11a\x01\x18W\x80c\xC2\x1CB3\x14a\x07\x98W\x80c\xC5\x19\xD1Q\x14a\x07\xBFW\x80c\xC8\x97\xF5^\x14a\x07\xE6W__\xFD[\x80c\xB5\xE0\x0C?\x14a\x07#W\x80c\xB7\x01\x06\x97\x14a\x07JW\x80c\xBEA\xB3g\x14a\x07qW__\xFD[\x80c\x99\x9F \xDB\x11a\x01mW\x80c\x99\x9F \xDB\x14a\x06\xB0W\x80c\x9F\x98T\xE5\x14a\x06\xC5W\x80c\xB3\x8DW\xF0\x14a\x06\xECW__\xFD[\x80c\x87e$\x0F\x14a\x06bW\x80c\x91\xDD\xB2\x85\x14a\x06\x89W__\xFD[\x80c0K\x90q\x11a\x02<W\x80c]\x9E$D\x11a\x01\xF2W\x80cx_\xFB7\x11a\x01\xCDW\x80cx_\xFB7\x14a\x05\xEDW\x80c\x81|\xD3\x12\x14a\x06\x14W\x80c\x85\xE1\xF4\xD0\x14a\x06;W__\xFD[\x80c]\x9E$D\x14a\x05fW\x80c`\x9F\xB5\x03\x14a\x05\x9FW\x80cd\xF4\x99*\x14a\x05\xC6W__\xFD[\x80cF\x92\xDE]\x11a\x02\"W\x80cF\x92\xDE]\x14a\x04\xF1W\x80cK/Q\xEF\x14a\x05\x18W\x80cL\xEC\xCF\xE5\x14a\x05?W__\xFD[\x80c0K\x90q\x14a\x04\xC2W\x80c<+x@\x14a\x04\xCAW__\xFD[\x80c\x10\xA6b\xE2\x11a\x02\x9CW\x80c\x1C\xCC,\xD1\x11a\x02wW\x80c\x1C\xCC,\xD1\x14a\x04aW\x80c(\xFB\"\x8C\x14a\x04\x88W\x80c,\xFB|\xA3\x14a\x04\x9BW__\xFD[\x80c\x10\xA6b\xE2\x14a\x03\xECW\x80c\x1B\x14.\xA7\x14a\x04\x13W\x80c\x1C9\xB6r\x14a\x04:W__\xFD[\x80c\x07\x87HK\x11a\x02\xCCW\x80c\x07\x87HK\x14a\x03^W\x80c\nT%}\x14a\x03\x85W\x80c\x10G\xFCR\x14a\x03\xACW__\xFD[\x80b<x\xFB\x14a\x02\xE5W\x80b\xF9s\x1E\x14a\x03\x1FW[__\xFD[a\x03\x0C\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81V[`@Q\x90\x81R` \x01[`@Q\x80\x91\x03\x90\xF3[a\x03F\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81V[`@Q`\x01`\x01`\xA0\x1B\x03\x90\x91\x16\x81R` \x01a\x03\x16V[a\x03F\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81V[a\x03F\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81V[a\x03\xD3\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81V[`@Qg\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x90\x91\x16\x81R` \x01a\x03\x16V[a\x03F\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81V[a\x03F\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81V[a\x03F\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81V[a\x03\x0C\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81V[a\x03Fa\x04\x966`\x04a)\xAEV[a\t\xA6V[a\x03F\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81V[a\x03\x0C`\x0C\x81V[a\x03F\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81V[a\x03F\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81V[a\x03F\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81V[a\x03\xD3\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81V[a\x05\x8D\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81V[`@Q`\xFF\x90\x91\x16\x81R` \x01a\x03\x16V[a\x03\x0C\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81V[a\x03F\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81V[a\x03\xD3\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81V[a\x03F\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81V[a\x03\x0C\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81V[a\x03F\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81V[a\x03\xD3\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81V[a\x06\xC3a\x06\xBE6`\x04a)\xD8V[a\n\x12V[\0[a\x03F\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81V[a\x07\x13\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81V[`@Q\x90\x15\x15\x81R` \x01a\x03\x16V[a\x03F\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81V[a\x03F\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81V[a\x03F\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81V[a\x03F\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81V[a\x03F\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81V[a\x03F\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81V[a\x03F\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81V[a\x03F\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81V[a\x03\xD3\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81V[a\x03F\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81V[a\x07\x13\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81V[a\x03\xD3\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81V[a\x06\xC3a\t\x056`\x04a*\xCBV[a\n\x9BV[a\x03\xD3\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81V[a\x03F\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81V[a\x03\x0C\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81V[a\x03\x0C\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81V[__\x82`@Q` \x01a\t\xBB\x91\x81R` \x01\x90V[`@Q` \x81\x83\x03\x03\x81R\x90`@R\x80Q\x90` \x01 \x90Pa\n\x08\x81`@Q\x80` \x01a\t\xE7\x90a'\xF5V[` \x82\x01\x81\x03\x82R`\x1F\x19`\x1F\x82\x01\x16`@RP\x80Q\x90` \x01 \x86a\x13\xDFV[\x91PP[\x92\x91PPV[_\x83`\x01`\x01`\xA0\x1B\x03\x16;\x11\x80\x15a\nEWP\x82`\x01`\x01`\xA0\x1B\x03\x16a\n:\x83\x83a\t\xA6V[`\x01`\x01`\xA0\x1B\x03\x16\x14[a\n\x96W`@QbF\x1B\xCD`\xE5\x1B\x81R` `\x04\x82\x01R`\r`$\x82\x01R\x7FADDR_MISMATCH\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0`D\x82\x01R`d\x01[`@Q\x80\x91\x03\x90\xFD[PPPV[a\n\xA3a\x14gV[_a\n\xACa\x18\x06V[\x90P_\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0`@Qa\n\xFD\x90a(\x02V[`\x01`\x01`\xA0\x1B\x03\x92\x83\x16\x81R\x91\x16` \x82\x01R```@\x82\x01\x81\x90R_\x90\x82\x01R`\x80\x01`@Q\x80\x91\x03\x90_\xF0\x80\x15\x80\x15a\x0B;W=__>=_\xFD[P\x90P_`@Q\x80a\x01 \x01`@R\x80\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0`\x01`\x01`\xA0\x1B\x03\x16\x81R` \x01\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0`\x01`\x01`\xA0\x1B\x03\x16\x81R` \x01\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0`\x01`\x01`\xA0\x1B\x03\x16\x81R` \x01\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0`\x01`\x01`\xA0\x1B\x03\x16\x81R` \x01\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0`\x01`\x01`\xA0\x1B\x03\x16\x81R` \x01\x83`\x01`\x01`\xA0\x1B\x03\x16\x81R` \x01\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0`\x01`\x01`\xA0\x1B\x03\x16\x81R` \x01\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0`\x01`\x01`\xA0\x1B\x03\x16\x81R` \x01\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0`\x01`\x01`\xA0\x1B\x03\x16c\xBCE\xE0\xAE`@Q\x81c\xFF\xFF\xFF\xFF\x16`\xE0\x1B\x81R`\x04\x01` `@Q\x80\x83\x03\x81\x86Z\xFA\x15\x80\x15a\x0C\xFFW=__>=_\xFD[PPPP`@Q=`\x1F\x19`\x1F\x82\x01\x16\x82\x01\x80`@RP\x81\x01\x90a\r#\x91\x90a+jV[`\x01`\x01`\xA0\x1B\x03\x16\x81RP\x90P_\x83`\xC0\x01Q`@Q` \x01a\rI\x91\x81R` \x01\x90V[`@Q` \x81\x83\x03\x03\x81R\x90`@R\x80Q\x90` \x01 \x90P_a\rp0\x86`\xC0\x01Qa\t\xA6V[\x90Pa\r{\x81a\x1E\xB3V[\x83`\x01`\x01`\xA0\x1B\x03\x16c\x1Ar\xD5L\x82\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x89a\x01\x80\x01Q\x8Aa\x01\xA0\x01Q\x8Ba\x01\xC0\x01Q\x8C` \x01Q\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x8Ea\x02@\x01Q\x8Fa\x01@\x01Q`@Q\x8Bc\xFF\xFF\xFF\xFF\x16`\xE0\x1B\x81R`\x04\x01a\x0E6\x9A\x99\x98\x97\x96\x95\x94\x93\x92\x91\x90a+\xBFV[_`@Q\x80\x83\x03\x81_\x87\x80;\x15\x80\x15a\x0EMW__\xFD[PZ\xF1\x15\x80\x15a\x0E_W=__>=_\xFD[PPPP_\x82`@Qa\x0Eq\x90a'\xF5V[\x81\x90`@Q\x80\x91\x03\x90_\xF5\x90P\x80\x15\x80\x15a\x0E\x8EW=__>=_\xFD[P\x90P\x81`\x01`\x01`\xA0\x1B\x03\x16\x81`\x01`\x01`\xA0\x1B\x03\x16\x14a\x0E\xF2W`@QbF\x1B\xCD`\xE5\x1B\x81R` `\x04\x82\x01R`\x15`$\x82\x01R\x7FUNEXPCTED_ROLLUP_ADDR\0\0\0\0\0\0\0\0\0\0\0`D\x82\x01R`d\x01a\n\x8DV[`\x80\x86\x01\x80Q0\x90\x91R`@Q\x7F\xAD\xFE\xF6\xAC\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x01`\x01`\xA0\x1B\x03\x83\x16\x90c\xAD\xFE\xF6\xAC\x90a\x0FC\x90\x8A\x90\x89\x90`\x04\x01a.!V[_`@Q\x80\x83\x03\x81_\x87\x80;\x15\x80\x15a\x0FZW__\xFD[PZ\xF1\x15\x80\x15a\x0FlW=__>=_\xFD[PPPP\x87Q_\x14a\x11lW_\x88Qg\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x11\x15a\x0F\x93Wa\x0F\x93a*\x16V[`@Q\x90\x80\x82R\x80` \x02` \x01\x82\x01`@R\x80\x15a\x0F\xBCW\x81` \x01` \x82\x02\x806\x837\x01\x90P[P\x90P_[\x89Q\x81\x10\x15a\x10\xF5W\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0`\x01`\x01`\xA0\x1B\x03\x16c\xFA\xCDt;\x8B\x83\x81Q\x81\x10a\x10\x0BWa\x10\x0Ba0\x11V[` \x02` \x01\x01Q`@Q\x82c\xFF\xFF\xFF\xFF\x16`\xE0\x1B\x81R`\x04\x01a\x10>\x91\x90`\x01`\x01`\xA0\x1B\x03\x91\x90\x91\x16\x81R` \x01\x90V[` `@Q\x80\x83\x03\x81\x86Z\xFA\x15\x80\x15a\x10YW=__>=_\xFD[PPPP`@Q=`\x1F\x19`\x1F\x82\x01\x16\x82\x01\x80`@RP\x81\x01\x90a\x10}\x91\x90a09V[a\x10\xC9W`@QbF\x1B\xCD`\xE5\x1B\x81R` `\x04\x82\x01R`\x18`$\x82\x01R\x7FUNEXPECTED_NEW_VALIDATOR\0\0\0\0\0\0\0\0`D\x82\x01R`d\x01a\n\x8DV[`\x01\x82\x82\x81Q\x81\x10a\x10\xDDWa\x10\xDDa0\x11V[\x91\x15\x15` \x92\x83\x02\x91\x90\x91\x01\x90\x91\x01R`\x01\x01a\x0F\xC1V[P`@Q\x7F\xA3\xFF\xB7r\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x01`\x01`\xA0\x1B\x03\x84\x16\x90c\xA3\xFF\xB7r\x90a\x11=\x90\x8C\x90\x85\x90`\x04\x01a0\x8BV[_`@Q\x80\x83\x03\x81_\x87\x80;\x15\x80\x15a\x11TW__\xFD[PZ\xF1\x15\x80\x15a\x11fW=__>=_\xFD[PPPPP[\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x15a\x12\"W`@Q\x7F\xA2\xB4\xF1\xD8\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x15\x15`\x04\x82\x01R`\x01`\x01`\xA0\x1B\x03\x83\x16\x90c\xA2\xB4\xF1\xD8\x90`$\x01_`@Q\x80\x83\x03\x81_\x87\x80;\x15\x80\x15a\x12\x0BW__\xFD[PZ\xF1\x15\x80\x15a\x12\x1DW=__>=_\xFD[PPPP[\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0`\x01`\x01`\xA0\x1B\x03\x16cU\x84\nX`@Q\x81c\xFF\xFF\xFF\xFF\x16`\xE0\x1B\x81R`\x04\x01` `@Q\x80\x83\x03\x81\x86Z\xFA\x92PPP\x80\x15a\x12\x9CWP`@\x80Q`\x1F=\x90\x81\x01`\x1F\x19\x16\x82\x01\x90\x92Ra\x12\x99\x91\x81\x01\x90a+jV[`\x01[\x15a\x13\"W`\x01`\x01`\xA0\x1B\x03\x81\x16\x15a\x13 W`@Q\x7F\rV\x1B7\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x01`\x01`\xA0\x1B\x03\x82\x81\x16`\x04\x83\x01R\x84\x16\x90c\rV\x1B7\x90`$\x01_`@Q\x80\x83\x03\x81_\x87\x80;\x15\x80\x15a\x13\tW__\xFD[PZ\xF1\x15\x80\x15a\x13\x1BW=__>=_\xFD[PPPP[P[`@Q\x7F\x13\xAF@5\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x01`\x01`\xA0\x1B\x03\x82\x81\x16`\x04\x83\x01R\x83\x16\x90c\x13\xAF@5\x90`$\x01_`@Q\x80\x83\x03\x81_\x87\x80;\x15\x80\x15a\x13{W__\xFD[PZ\xF1\x15\x80\x15a\x13\x8DW=__>=_\xFD[PP`@\x80Q`\x01`\x01`\xA0\x1B\x03\x80\x88\x16\x82R\x8A\x16` \x82\x01R\x7F~\\\xC5\xC3\xFC\xE0F\xD8h\xD5\x91\x85H\xDF\x8D>\x8E\xF9\xF0\x9Eo\xB3\nh\x08\x1F\x1F\x13H\xCD\x03\x14\x93P\x01\x90P`@Q\x80\x91\x03\x90\xA1PPPPPPPPV[`@\x80Q\x7F\xFF\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0` \x80\x83\x01\x91\x90\x91R``\x84\x90\x1B\x7F\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\0\0\0\0\0\0\0\0\0\0\0\0\x16`!\x83\x01R`5\x82\x01\x86\x90R`U\x80\x83\x01\x86\x90R\x83Q\x80\x84\x03\x90\x91\x01\x81R`u\x90\x92\x01\x90\x92R\x80Q\x91\x01 [\x93\x92PPPV[\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0`\x01`\x01`\xA0\x1B\x03\x16c\x84V\xCBY`@Q\x81c\xFF\xFF\xFF\xFF\x16`\xE0\x1B\x81R`\x04\x01_`@Q\x80\x83\x03\x81_\x87\x80;\x15\x80\x15a\x14\xBFW__\xFD[PZ\xF1\x15\x80\x15a\x14\xD1W=__>=_\xFD[PPPP_\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0`\x01`\x01`\xA0\x1B\x03\x16c\xDF\xF6\x97\x87`@Q\x81c\xFF\xFF\xFF\xFF\x16`\xE0\x1B\x81R`\x04\x01` `@Q\x80\x83\x03\x81\x86Z\xFA\x15\x80\x15a\x152W=__>=_\xFD[PPPP`@Q=`\x1F\x19`\x1F\x82\x01\x16\x82\x01\x80`@RP\x81\x01\x90a\x15V\x91\x90a0\xFCV[\x90P`2\x81g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x11\x15a\x15oWP`2[_[\x81g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x81g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x10\x15a\x18\x02W`@Q\x7Fm\xDD7D\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81Rg\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x82\x16`\x04\x82\x01R_\x90\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0`\x01`\x01`\xA0\x1B\x03\x16\x90cm\xDD7D\x90`$\x01` `@Q\x80\x83\x03\x81\x86Z\xFA\x15\x80\x15a\x16\x14W=__>=_\xFD[PPPP`@Q=`\x1F\x19`\x1F\x82\x01\x16\x82\x01\x80`@RP\x81\x01\x90a\x168\x91\x90a+jV[`@Q\x7F\xA2<D\xB1\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x01`\x01`\xA0\x1B\x03\x80\x83\x16`\x04\x83\x01R\x91\x92P_\x91\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x16\x90c\xA2<D\xB1\x90`$\x01`\xA0`@Q\x80\x83\x03\x81\x86Z\xFA\x15\x80\x15a\x16\xBAW=__>=_\xFD[PPPP`@Q=`\x1F\x19`\x1F\x82\x01\x16\x82\x01\x80`@RP\x81\x01\x90a\x16\xDE\x91\x90a1\x15V[\x90P\x80`\x80\x01Q\x80\x15a\x16\xFDWP``\x81\x01Qg\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x15[\x15a\x17\xEDW`@\x80Q`\x01\x80\x82R\x81\x83\x01\x90\x92R_\x91` \x80\x83\x01\x90\x806\x837\x01\x90PP\x90P\x82\x81_\x81Q\x81\x10a\x176Wa\x176a0\x11V[`\x01`\x01`\xA0\x1B\x03\x92\x83\x16` \x91\x82\x02\x92\x90\x92\x01\x01R`@Q\x7F|u\xC2\x98\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x90\x91\x16\x90c|u\xC2\x98\x90a\x17\xAB\x90\x84\x90`\x04\x01a1\x9CV[_`@Q\x80\x83\x03\x81_\x87\x80;\x15\x80\x15a\x17\xC2W__\xFD[PZ\xF1\x15\x80\x15a\x17\xD4W=__>=_\xFD[PPPP`\x01\x85a\x17\xE5\x91\x90a1\xC2V[\x94PPa\x17\xFBV[\x82a\x17\xF7\x81a1\xE2V[\x93PP[PPa\x15qV[PPV[a\x18\x0Ea(\x0FV[_\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0`\x01`\x01`\xA0\x1B\x03\x16c\x92\xC8\x13L\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0`\x01`\x01`\xA0\x1B\x03\x16ce\xF7\xF8\r`@Q\x81c\xFF\xFF\xFF\xFF\x16`\xE0\x1B\x81R`\x04\x01` `@Q\x80\x83\x03\x81\x86Z\xFA\x15\x80\x15a\x18\x9AW=__>=_\xFD[PPPP`@Q=`\x1F\x19`\x1F\x82\x01\x16\x82\x01\x80`@RP\x81\x01\x90a\x18\xBE\x91\x90a0\xFCV[`@Q\x7F\xFF\xFF\xFF\xFF\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0`\xE0\x84\x90\x1B\x16\x81Rg\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x90\x91\x16`\x04\x82\x01R`$\x01a\x01\x80`@Q\x80\x83\x03\x81\x86Z\xFA\x15\x80\x15a\x19\x1AW=__>=_\xFD[PPPP`@Q=`\x1F\x19`\x1F\x82\x01\x16\x82\x01\x80`@RP\x81\x01\x90a\x19>\x91\x90a2\x0EV[Q`@Q\x7F\x8E\xAAj\xC0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x81\x01\x82\x90R\x90\x91P_\x90\x81\x90\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0`\x01`\x01`\xA0\x1B\x03\x16\x90c\x8E\xAAj\xC0\x90`$\x01`\xC0`@Q\x80\x83\x03\x81\x86Z\xFA\x15\x80\x15a\x19\xC2W=__>=_\xFD[PPPP`@Q=`\x1F\x19`\x1F\x82\x01\x16\x82\x01\x80`@RP\x81\x01\x90a\x19\xE6\x91\x90a3GV[\x91P\x91Pa\x19\xF2a)\x1AV[\x82Q\x81R` \x80\x84\x01Q\x90\x82\x01\x90`\x02\x81\x11\x15a\x1A\x11Wa\x1A\x11a,\xDCV[\x90\x81`\x02\x81\x11\x15a\x1A$Wa\x1A$a,\xDCV[\x90RP\x83`\x01`\x01`\xA0\x1B\x03\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x16c1dA0a\x1A`\x84a#1V[\x85`@Q\x83c\xFF\xFF\xFF\xFF\x16`\xE0\x1B\x81R`\x04\x01a\x1A~\x92\x91\x90a4\x03V[` `@Q\x80\x83\x03\x81\x86Z\xFA\x15\x80\x15a\x1A\x99W=__>=_\xFD[PPPP`@Q=`\x1F\x19`\x1F\x82\x01\x16\x82\x01\x80`@RP\x81\x01\x90a\x1A\xBD\x91\x90a45V[\x14a\x1B\nW`@QbF\x1B\xCD`\xE5\x1B\x81R` `\x04\x82\x01R`\x1D`$\x82\x01R\x7FInvalid latest execution hash\0\0\0`D\x82\x01R`d\x01a\n\x8DV[a\x1B1`@Q\x80`\x80\x01`@R\x80_\x81R` \x01_\x81R` \x01_\x81R` \x01_\x81RP\x90V[`@\x80Q``\x81\x01\x82R_\x80\x82R` \x82\x01\x81\x90R\x91\x81\x01\x91\x90\x91R`@Q\x80a\x02\xA0\x01`@R\x80\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x81R` \x01\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0`\x01`\x01`\xA0\x1B\x03\x16\x81R` \x01\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R` \x01\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0`\x01`\x01`\xA0\x1B\x03\x16c\x8E\xE1\xA1&`@Q\x81c\xFF\xFF\xFF\xFF\x16`\xE0\x1B\x81R`\x04\x01` `@Q\x80\x83\x03\x81\x86Z\xFA\x15\x80\x15a\x1C:W=__>=_\xFD[PPPP`@Q=`\x1F\x19`\x1F\x82\x01\x16\x82\x01\x80`@RP\x81\x01\x90a\x1C^\x91\x90a45V[\x81R` \x010`\x01`\x01`\xA0\x1B\x03\x16\x81R` \x01\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0`\x01`\x01`\xA0\x1B\x03\x16\x81R` \x01\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R` \x01`@Q\x80` \x01`@R\x80_\x81RP\x81R` \x01\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R` \x01\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x81R` \x01\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0`\x01`\x01`\xA0\x1B\x03\x16c\xB0\xEC*\xE1`@Q\x81c\xFF\xFF\xFF\xFF\x16`\xE0\x1B\x81R`\x04\x01_`@Q\x80\x83\x03\x81\x86Z\xFA\x15\x80\x15a\x1D\x8CW=__>=_\xFD[PPPP`@Q=_\x82>`\x1F=\x90\x81\x01`\x1F\x19\x16\x82\x01`@Ra\x1D\xB3\x91\x90\x81\x01\x90a4LV[\x81R` \x01\x83\x81R` \x01\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R` \x01\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R` \x01\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R` \x01\x84\x81R` \x01\x85\x81R` \x01_`\x01`\x01`\xA0\x1B\x03\x16\x81R` \x01\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0`\xFF\x16\x81R` \x01\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x81R` \x01\x82\x81RP\x96PPPPPPP\x90V[`@Qc&j#\xB1`\xE2\x1B\x81R`\x01`\x01`\xA0\x1B\x03\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81\x81\x16`\x04\x84\x01R\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x82\x16`$\x84\x01R\x91\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x90\x91\x16\x90c\x99\xA8\x8E\xC4\x90`D\x01_`@Q\x80\x83\x03\x81_\x87\x80;\x15\x80\x15a\x1F_W__\xFD[PZ\xF1\x15\x80\x15a\x1FqW=__>=_\xFD[PP`@Q\x7F\x91\x9C\xC7\x06\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x01`\x01`\xA0\x1B\x03\x85\x81\x16`\x04\x83\x01R\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x16\x92Pc\x91\x9C\xC7\x06\x91P`$\x01_`@Q\x80\x83\x03\x81_\x87\x80;\x15\x80\x15a\x1F\xEEW__\xFD[PZ\xF1\x15\x80\x15a \0W=__>=_\xFD[PPPPa \x0Ca#kV[`@Qc&j#\xB1`\xE2\x1B\x81R`\x01`\x01`\xA0\x1B\x03\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81\x81\x16`\x04\x84\x01R\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x82\x16`$\x84\x01R\x91\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x90\x91\x16\x90c\x99\xA8\x8E\xC4\x90`D\x01_`@Q\x80\x83\x03\x81_\x87\x80;\x15\x80\x15a \xB8W__\xFD[PZ\xF1\x15\x80\x15a \xCAW=__>=_\xFD[PP`@Qc&j#\xB1`\xE2\x1B\x81R`\x01`\x01`\xA0\x1B\x03\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81\x81\x16`\x04\x84\x01R\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x82\x16`$\x84\x01R\x93P\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x16\x91Pc\x99\xA8\x8E\xC4\x90`D\x01_`@Q\x80\x83\x03\x81_\x87\x80;\x15\x80\x15a!xW__\xFD[PZ\xF1\x15\x80\x15a!\x8AW=__>=_\xFD[PPPP\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0`\x01`\x01`\xA0\x1B\x03\x16cj\xE7\x1F\x12`@Q\x81c\xFF\xFF\xFF\xFF\x16`\xE0\x1B\x81R`\x04\x01_`@Q\x80\x83\x03\x81_\x87\x80;\x15\x80\x15a!\xE6W__\xFD[PZ\xF1\x15\x80\x15a!\xF8W=__>=_\xFD[PP`@Qc&j#\xB1`\xE2\x1B\x81R`\x01`\x01`\xA0\x1B\x03\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81\x81\x16`\x04\x84\x01R\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x82\x16`$\x84\x01R\x93P\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x16\x91Pc\x99\xA8\x8E\xC4\x90`D\x01_`@Q\x80\x83\x03\x81_\x87\x80;\x15\x80\x15a\"\xA6W__\xFD[PZ\xF1\x15\x80\x15a\"\xB8W=__>=_\xFD[PPPP\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0`\x01`\x01`\xA0\x1B\x03\x16cj\xE7\x1F\x12`@Q\x81c\xFF\xFF\xFF\xFF\x16`\xE0\x1B\x81R`\x04\x01_`@Q\x80\x83\x03\x81_\x87\x80;\x15\x80\x15a#\x14W__\xFD[PZ\xF1\x15\x80\x15a#&W=__>=_\xFD[PPPPPPPPPV[a#9a)?V[`@Q\x80`@\x01`@R\x80\x83_\x01Q\x81R` \x01\x83` \x01Q`\x02\x81\x11\x15a#cWa#ca,\xDCV[\x90R\x92\x91PPV[\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x15a%oW\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0`\x01`\x01`\xA0\x1B\x03\x16c\x96#`\x9D\x82\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0`@Q\x80``\x01`@R\x80\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x81R` \x01\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x81R` \x01\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x81RP`@Q`$\x01a$\xAC\x91\x90a4\xD3V[`@\x80Q`\x1F\x19\x81\x84\x03\x01\x81R\x91\x81R` \x82\x01\x80Q{\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x7F\xA6U\xD97\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x17\x90RQ\x7F\xFF\xFF\xFF\xFF\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0`\xE0\x86\x90\x1B\x16\x81Ra%=\x93\x92\x91\x90`\x04\x01a5\x16V[_`@Q\x80\x83\x03\x81_\x87\x80;\x15\x80\x15a%TW__\xFD[PZ\xF1\x15\x80\x15a%fW=__>=_\xFD[PPPPa&\x0EV[`@Qc&j#\xB1`\xE2\x1B\x81R`\x01`\x01`\xA0\x1B\x03\x82\x81\x16`\x04\x83\x01R\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81\x16`$\x83\x01R\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x16\x90c\x99\xA8\x8E\xC4\x90`D\x01_`@Q\x80\x83\x03\x81_\x87\x80;\x15\x80\x15a%\xF7W__\xFD[PZ\xF1\x15\x80\x15a&\tW=__>=_\xFD[PPPP[____\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0`\x01`\x01`\xA0\x1B\x03\x16c\xEB\xEAF\x1D`@Q\x81c\xFF\xFF\xFF\xFF\x16`\xE0\x1B\x81R`\x04\x01`\x80`@Q\x80\x83\x03\x81\x86Z\xFA\x15\x80\x15a&nW=__>=_\xFD[PPPP`@Q=`\x1F\x19`\x1F\x82\x01\x16\x82\x01\x80`@RP\x81\x01\x90a&\x92\x91\x90a5OV[\x93P\x93P\x93P\x93P_`\x0C\x83a&\xA8\x91\x90a5\x96V[\x15a&\xC8Wa&\xB8`\x0C\x84a5\xA9V[a&\xC3\x90`\x01a5\xBCV[a&\xD3V[a&\xD3`\x0C\x84a5\xA9V[\x90P\x84\x81\x11a&\xE2W\x84a&\xE4V[\x80[\x94P\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0`\x01`\x01`\xA0\x1B\x03\x16c\xB3\x17a\xF8`@Q\x80`\x80\x01`@R\x80\x88\x81R` \x01\x87\x81R` \x01\x86\x81R` \x01\x85\x81RP`@Q\x82c\xFF\xFF\xFF\xFF\x16`\xE0\x1B\x81R`\x04\x01a'R\x91\x90a5\xCFV[_`@Q\x80\x83\x03\x81_\x87\x80;\x15\x80\x15a'iW__\xFD[PZ\xF1\x15\x80\x15a'{W=__>=_\xFD[PPPP\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0`\x01`\x01`\xA0\x1B\x03\x16cj\xE7\x1F\x12`@Q\x81c\xFF\xFF\xFF\xFF\x16`\xE0\x1B\x81R`\x04\x01_`@Q\x80\x83\x03\x81_\x87\x80;\x15\x80\x15a'\xD7W__\xFD[PZ\xF1\x15\x80\x15a'\xE9W=__>=_\xFD[PPPPPPPPPPV[a\x13\xEB\x80a5\xFB\x839\x01\x90V[a\r\x91\x80aI\xE6\x839\x01\x90V[`@Q\x80a\x02\xA0\x01`@R\x80_g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x81R` \x01_`\x01`\x01`\xA0\x1B\x03\x16\x81R` \x01_\x81R` \x01_\x81R` \x01_`\x01`\x01`\xA0\x1B\x03\x16\x81R` \x01_`\x01`\x01`\xA0\x1B\x03\x16\x81R` \x01_\x81R` \x01``\x81R` \x01_\x81R` \x01_g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x81R` \x01``\x81R` \x01a(\xB5`@Q\x80`\x80\x01`@R\x80_\x81R` \x01_\x81R` \x01_\x81R` \x01_\x81RP\x90V[\x81R` \x01_\x81R` \x01_\x81R` \x01_\x81R` \x01a(\xD4a)\x1AV[\x81R_` \x80\x83\x01\x82\x90R`@\x80\x84\x01\x83\x90R``\x80\x85\x01\x84\x90R`\x80\x85\x01\x84\x90R\x81Q\x90\x81\x01\x82R\x83\x81R\x91\x82\x01\x83\x90R\x81\x01\x91\x90\x91R`\xA0\x90\x91\x01R\x90V[\x90R\x90V[`@Q\x80``\x01`@R\x80a)-a)]V[\x81R` \x01_\x81R` \x01_\x81RP\x90V[`@Q\x80`@\x01`@R\x80a)Ra)]V[\x81R` \x01_\x90R\x90V[`@Q\x80`@\x01`@R\x80a)pa)yV[\x81R` \x01a)\x15[`@Q\x80`@\x01`@R\x80`\x02\x90` \x82\x02\x806\x837P\x91\x92\x91PPV[`\x01`\x01`\xA0\x1B\x03\x81\x16\x81\x14a)\xABW__\xFD[PV[__`@\x83\x85\x03\x12\x15a)\xBFW__\xFD[\x825a)\xCA\x81a)\x97V[\x94` \x93\x90\x93\x015\x93PPPV[___``\x84\x86\x03\x12\x15a)\xEAW__\xFD[\x835a)\xF5\x81a)\x97V[\x92P` \x84\x015a*\x05\x81a)\x97V[\x92\x95\x92\x94PPP`@\x91\x90\x91\x015\x90V[cNH{q`\xE0\x1B_R`A`\x04R`$_\xFD[`@Qa\x01\x80\x81\x01g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x11\x82\x82\x10\x17\x15a*NWa*Na*\x16V[`@R\x90V[`@\x80Q\x90\x81\x01g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x11\x82\x82\x10\x17\x15a*NWa*Na*\x16V[`@Q`\x1F\x82\x01`\x1F\x19\x16\x81\x01g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x11\x82\x82\x10\x17\x15a*\xA0Wa*\xA0a*\x16V[`@R\x91\x90PV[_g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x82\x11\x15a*\xC1Wa*\xC1a*\x16V[P`\x05\x1B` \x01\x90V[_` \x82\x84\x03\x12\x15a*\xDBW__\xFD[\x815g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x11\x15a*\xF1W__\xFD[\x82\x01`\x1F\x81\x01\x84\x13a+\x01W__\xFD[\x805a+\x14a+\x0F\x82a*\xA8V[a*wV[\x80\x82\x82R` \x82\x01\x91P` \x83`\x05\x1B\x85\x01\x01\x92P\x86\x83\x11\x15a+5W__\xFD[` \x84\x01\x93P[\x82\x84\x10\x15a+`W\x835a+O\x81a)\x97V[\x82R` \x93\x84\x01\x93\x90\x91\x01\x90a+<V[\x96\x95PPPPPPV[_` \x82\x84\x03\x12\x15a+zW__\xFD[\x81Qa\x14`\x81a)\x97V[_\x81Q\x80\x84R` \x84\x01\x93P` \x83\x01_[\x82\x81\x10\x15a+\xB5W\x81Q\x86R` \x95\x86\x01\x95\x90\x91\x01\x90`\x01\x01a+\x97V[P\x93\x94\x93PPPPV[`\x01`\x01`\xA0\x1B\x03\x8B\x16\x81Rg\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x8A\x16` \x82\x01R`\x01`\x01`\xA0\x1B\x03\x89\x16`@\x82\x01R\x87``\x82\x01R\x86`\x80\x82\x01R\x85`\xA0\x82\x01R`\x01`\x01`\xA0\x1B\x03\x85\x16`\xC0\x82\x01R`\x01`\x01`\xA0\x1B\x03\x84\x16`\xE0\x82\x01R`\xFF\x83\x16a\x01\0\x82\x01Ra\x01@a\x01 \x82\x01R_a,<a\x01@\x83\x01\x84a+\x85V[\x9C\x9BPPPPPPPPPPPPV[_\x81Q\x80\x84R\x80` \x84\x01` \x86\x01^_` \x82\x86\x01\x01R` `\x1F\x19`\x1F\x83\x01\x16\x85\x01\x01\x91PP\x92\x91PPV[\x80Q\x82_[`\x02\x81\x10\x15a,\x9EW\x82Q\x82R` \x92\x83\x01\x92\x90\x91\x01\x90`\x01\x01a,\x7FV[PPP` \x81\x01Q`@\x83\x01_[`\x02\x81\x10\x15a,\xD5W\x82Qg\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x82R` \x92\x83\x01\x92\x90\x91\x01\x90`\x01\x01a,\xACV[PPPPPV[cNH{q`\xE0\x1B_R`!`\x04R`$_\xFD[`\x03\x81\x10a-\x0CWcNH{q`\xE0\x1B_R`!`\x04R`$_\xFD[\x90RV[a-\x1B\x82\x82Qa,zV[` \x81\x01Qa--`\x80\x84\x01\x82a,\xF0V[P`@\x01Q`\xA0\x91\x90\x91\x01RV[`\x01`\x01`\xA0\x1B\x03\x81Q\x16\x82R` \x81\x01Qa-b` \x84\x01\x82`\x01`\x01`\xA0\x1B\x03\x16\x90RV[P`@\x81\x01Qa-}`@\x84\x01\x82`\x01`\x01`\xA0\x1B\x03\x16\x90RV[P``\x81\x01Qa-\x98``\x84\x01\x82`\x01`\x01`\xA0\x1B\x03\x16\x90RV[P`\x80\x81\x01Qa-\xB3`\x80\x84\x01\x82`\x01`\x01`\xA0\x1B\x03\x16\x90RV[P`\xA0\x81\x01Qa-\xCE`\xA0\x84\x01\x82`\x01`\x01`\xA0\x1B\x03\x16\x90RV[P`\xC0\x81\x01Qa-\xE9`\xC0\x84\x01\x82`\x01`\x01`\xA0\x1B\x03\x16\x90RV[P`\xE0\x81\x01Qa.\x04`\xE0\x84\x01\x82`\x01`\x01`\xA0\x1B\x03\x16\x90RV[Pa\x01\0\x81\x01Qa\n\x96a\x01\0\x84\x01\x82`\x01`\x01`\xA0\x1B\x03\x16\x90RV[a\x01@\x81Ra.>a\x01@\x82\x01\x84Qg\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x90RV[_` \x84\x01Qa.Za\x01`\x84\x01\x82`\x01`\x01`\xA0\x1B\x03\x16\x90RV[P`@\x84\x01Qa\x01\x80\x83\x01R``\x84\x01Qa\x01\xA0\x83\x01R`\x80\x84\x01Q`\x01`\x01`\xA0\x1B\x03\x90\x81\x16a\x01\xC0\x84\x01R`\xA0\x85\x01Q\x16a\x01\xE0\x83\x01R`\xC0\x84\x01Qa\x02\0\x83\x01R`\xE0\x84\x01Qa\x03\xE0a\x02 \x84\x01Ra.\xBAa\x05 \x84\x01\x82a,LV[\x90Pa\x01\0\x85\x01Qa\x02@\x84\x01Ra\x01 \x85\x01Qa.\xE5a\x02`\x85\x01\x82g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x90RV[Pa\x01@\x85\x01Q\x7F\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFE\xC0\x84\x83\x03\x01a\x02\x80\x85\x01Ra/!\x82\x82a+\x85V[a\x01`\x87\x01Q\x80Qa\x02\xA0\x87\x01R` \x81\x01Qa\x02\xC0\x87\x01R`@\x81\x01Qa\x02\xE0\x87\x01R``\x01Qa\x03\0\x86\x01Ra\x01\x80\x87\x01Qa\x03 \x86\x01Ra\x01\xA0\x87\x01Qa\x03@\x86\x01Ra\x01\xC0\x87\x01Qa\x03`\x86\x01Ra\x01\xE0\x87\x01Q\x90\x92P\x90Pa/\x8Ca\x03\x80\x85\x01\x82a-\x10V[Pa\x02\0\x85\x01Qa\x04@\x84\x01Ra\x02 \x85\x01Q`\x01`\x01`\xA0\x1B\x03\x16a\x04`\x84\x01Ra\x02@\x85\x01Q`\xFF\x16a\x04\x80\x84\x01Ra\x02`\x85\x01Qg\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x90\x81\x16a\x04\xA0\x85\x01Ra\x02\x80\x86\x01Q\x80Q\x82\x16a\x04\xC0\x86\x01R` \x80\x82\x01Q\x83\x16a\x04\xE0\x87\x01R`@\x90\x91\x01Q\x90\x91\x16a\x05\0\x85\x01R\x90\x91Pa\x14`\x90\x83\x01\x84a-;V[cNH{q`\xE0\x1B_R`2`\x04R`$_\xFD[\x80Q\x80\x15\x15\x81\x14a04W__\xFD[\x91\x90PV[_` \x82\x84\x03\x12\x15a0IW__\xFD[a\x14`\x82a0%V[_\x81Q\x80\x84R` \x84\x01\x93P` \x83\x01_[\x82\x81\x10\x15a+\xB5W\x81Q`\x01`\x01`\xA0\x1B\x03\x16\x86R` \x95\x86\x01\x95\x90\x91\x01\x90`\x01\x01a0dV[`@\x81R_a0\x9D`@\x83\x01\x85a0RV[\x82\x81\x03` \x84\x01R\x80\x84Q\x80\x83R` \x83\x01\x91P` \x86\x01\x92P_[\x81\x81\x10\x15a0\xD9W\x83Q\x15\x15\x83R` \x93\x84\x01\x93\x90\x92\x01\x91`\x01\x01a0\xB9V[P\x90\x96\x95PPPPPPV[\x80Qg\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x16\x81\x14a04W__\xFD[_` \x82\x84\x03\x12\x15a1\x0CW__\xFD[a\x14`\x82a0\xE5V[_`\xA0\x82\x84\x03\x12\x80\x15a1&W__\xFD[P`@Q`\xA0\x81\x01g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x11\x82\x82\x10\x17\x15a1JWa1Ja*\x16V[`@R\x82Q\x81Ra1]` \x84\x01a0\xE5V[` \x82\x01Ra1n`@\x84\x01a0\xE5V[`@\x82\x01Ra1\x7F``\x84\x01a0\xE5V[``\x82\x01Ra1\x90`\x80\x84\x01a0%V[`\x80\x82\x01R\x93\x92PPPV[` \x81R_a\x14`` \x83\x01\x84a0RV[cNH{q`\xE0\x1B_R`\x11`\x04R`$_\xFD[g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x82\x81\x16\x82\x82\x16\x03\x90\x81\x11\x15a\n\x0CWa\n\x0Ca1\xAEV[_g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x82\x16g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x03a2\x05Wa2\x05a1\xAEV[`\x01\x01\x92\x91PPV[_a\x01\x80\x82\x84\x03\x12\x80\x15a2 W__\xFD[Pa2)a**V[\x82Q\x81R` \x80\x84\x01Q\x90\x82\x01R`@\x80\x84\x01Q\x90\x82\x01Ra2M``\x84\x01a0\xE5V[``\x82\x01Ra2^`\x80\x84\x01a0\xE5V[`\x80\x82\x01Ra2o`\xA0\x84\x01a0\xE5V[`\xA0\x82\x01Ra2\x80`\xC0\x84\x01a0\xE5V[`\xC0\x82\x01Ra2\x91`\xE0\x84\x01a0\xE5V[`\xE0\x82\x01Ra2\xA3a\x01\0\x84\x01a0\xE5V[a\x01\0\x82\x01Ra2\xB6a\x01 \x84\x01a0\xE5V[a\x01 \x82\x01Ra2\xC9a\x01@\x84\x01a0\xE5V[a\x01@\x82\x01Ra\x01`\x92\x83\x01Q\x92\x81\x01\x92\x90\x92RP\x91\x90PV[_\x82`\x1F\x83\x01\x12a2\xF2W__\xFD[a2\xFC`@a*wV[\x80`@\x84\x01\x85\x81\x11\x15a3\rW__\xFD[\x84[\x81\x81\x10\x15a3.Wa3 \x81a0\xE5V[\x84R` \x93\x84\x01\x93\x01a3\x0FV[P\x90\x95\x94PPPPPV[\x80Q`\x03\x81\x10a04W__\xFD[__\x82\x84\x03`\xC0\x81\x12\x15a3YW__\xFD[`\xA0\x81\x12\x15a3fW__\xFD[a3na*TV[`\x80\x82\x12\x15a3{W__\xFD[a3\x83a*TV[\x91P\x85`\x1F\x86\x01\x12a3\x93W__\xFD[a3\x9D`@a*wV[\x80`@\x87\x01\x88\x81\x11\x15a3\xAEW__\xFD[\x87[\x81\x81\x10\x15a3\xC8W\x80Q\x84R` \x93\x84\x01\x93\x01a3\xB0V[P\x81\x85Ra3\xD6\x89\x82a2\xE3V[` \x86\x01RPPP\x81\x81Ra3\xED`\x80\x86\x01a39V[` \x82\x01R`\xA0\x94\x90\x94\x01Q\x93\x95\x93\x94PPPPV[_`\xC0\x82\x01\x90Pa4\x15\x82\x85Qa,zV[` \x84\x01Qa4'`\x80\x84\x01\x82a,\xF0V[P\x82`\xA0\x83\x01R\x93\x92PPPV[_` \x82\x84\x03\x12\x15a4EW__\xFD[PQ\x91\x90PV[_` \x82\x84\x03\x12\x15a4\\W__\xFD[\x81Qg\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x11\x15a4rW__\xFD[\x82\x01`\x1F\x81\x01\x84\x13a4\x82W__\xFD[\x80Qa4\x90a+\x0F\x82a*\xA8V[\x80\x82\x82R` \x82\x01\x91P` \x83`\x05\x1B\x85\x01\x01\x92P\x86\x83\x11\x15a4\xB1W__\xFD[` \x84\x01\x93P[\x82\x84\x10\x15a+`W\x83Q\x82R` \x93\x84\x01\x93\x90\x91\x01\x90a4\xB8V[``\x81\x01a\n\x0C\x82\x84g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81Q\x16\x82Rg\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF` \x82\x01Q\x16` \x83\x01Rg\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF`@\x82\x01Q\x16`@\x83\x01RPPV[`\x01`\x01`\xA0\x1B\x03\x84\x16\x81R`\x01`\x01`\xA0\x1B\x03\x83\x16` \x82\x01R```@\x82\x01R_a5F``\x83\x01\x84a,LV[\x95\x94PPPPPV[____`\x80\x85\x87\x03\x12\x15a5bW__\xFD[PP\x82Q` \x84\x01Q`@\x85\x01Q``\x90\x95\x01Q\x91\x96\x90\x95P\x90\x92P\x90PV[cNH{q`\xE0\x1B_R`\x12`\x04R`$_\xFD[_\x82a5\xA4Wa5\xA4a5\x82V[P\x06\x90V[_\x82a5\xB7Wa5\xB7a5\x82V[P\x04\x90V[\x80\x82\x01\x80\x82\x11\x15a\n\x0CWa\n\x0Ca1\xAEV[\x81Q\x81R` \x80\x83\x01Q\x90\x82\x01R`@\x80\x83\x01Q\x90\x82\x01R``\x80\x83\x01Q\x90\x82\x01R`\x80\x81\x01a\n\x0CV\xFE`\x80`@R4\x80\x15`\x0EW__\xFD[Pa\x13\xCF\x80a\0\x1C_9_\xF3\xFE`\x80`@R`\x046\x10a\0!W_5`\xE0\x1C\x80c\xAD\xFE\xF6\xAC\x14a\08Wa\x000V[6a\x000Wa\0.a\0WV[\0[a\0.a\0WV[4\x80\x15a\0CW__\xFD[Pa\0.a\0R6`\x04a\rgV[a\0iV[a\0ga\0ba\x01\xB8V[a\x02\x9AV[V[_a\0ra\x02\xBDV[`\x01`\x01`\xA0\x1B\x03\x16\x14\x80\x15a\0\x97WP_a\0\x8Ca\x02\xEFV[`\x01`\x01`\xA0\x1B\x03\x16\x14[\x80\x15a\0\xB2WP_a\0\xA7a\x03\x16V[`\x01`\x01`\xA0\x1B\x03\x16\x14[\x15a\x01\xB0Wa\x01\xAC\x81`\xC0\x01Q\x83\x83`@Q`$\x01a\0\xD2\x92\x91\x90a\x11'V[`@\x80Q`\x1F\x19\x81\x84\x03\x01\x81R\x91\x81R` \x80\x83\x01\x80Q{\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x7F\x0E\xE5\xEF\x0C\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x17\x90R`\xE0\x86\x01Q\x90\x87\x01Q\x91Q`\x01`\x01`\xA0\x1B\x03\x90\x92\x16`$\x83\x01R\x90`D\x01`@\x80Q`\x1F\x19\x81\x84\x03\x01\x81R\x91\x90R` \x81\x01\x80Q{\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x7F\xC4\xD6m\xE8\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x17\x90R`\x80\x87\x01Qa\x03=V[PPV[a\x01\xACa\0WV[_`\x046\x10\x15a\x02\x0FW`@QbF\x1B\xCD`\xE5\x1B\x81R` `\x04\x82\x01R`\x0B`$\x82\x01R\x7FNO_FUNC_SIG\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0`D\x82\x01R`d\x01[`@Q\x80\x91\x03\x90\xFD[_3a\x02\x19a\x02\xBDV[`\x01`\x01`\xA0\x1B\x03\x16\x03a\x024Wa\x02/a\x02\xEFV[a\x02<V[a\x02<a\x03\x16V[\x90P`\x01`\x01`\xA0\x1B\x03\x81\x16;a\x02\x95W`@QbF\x1B\xCD`\xE5\x1B\x81R` `\x04\x82\x01R`\x13`$\x82\x01R\x7FTARGET_NOT_CONTRACT\0\0\0\0\0\0\0\0\0\0\0\0\0`D\x82\x01R`d\x01a\x02\x06V[\x91\x90PV[6__7__6_\x84Z\xF4=__>\x80\x80\x15a\x02\xB4W=_\xF3[=_\xFD[PPPV[_\x7F\xB51'hJV\x8B1s\xAE\x13\xB9\xF8\xA6\x01n$>c\xB6\xE8\xEE\x11x\xD6\xA7\x17\x85\x0B]a\x03[T`\x01`\x01`\xA0\x1B\x03\x16\x91\x90PV[_\x7F6\x08\x94\xA1;\xA1\xA3!\x06g\xC8(I-\xB9\x8D\xCA> v\xCC75\xA9 \xA3\xCAP]8+\xBCa\x02\xE0V[_\x7F+\x1D\xBC\xE7C$$\x8C\"/\x0E\xC2\xD5\xED{\xD3#\xCF\xC4%\xB36\xF0%<\\\xCF\xDAreTma\x02\xE0V[a\x03h`\x01\x7F\xB51'hJV\x8B1s\xAE\x13\xB9\xF8\xA6\x01n$>c\xB6\xE8\xEE\x11x\xD6\xA7\x17\x85\x0B]a\x04a\x13\x17V[\x7F\xB51'hJV\x8B1s\xAE\x13\xB9\xF8\xA6\x01n$>c\xB6\xE8\xEE\x11x\xD6\xA7\x17\x85\x0B]a\x03\x14a\x03\x96Wa\x03\x96a\x136V[a\x03\xC1`\x01\x7F6\x08\x94\xA1;\xA1\xA3!\x06g\xC8(I-\xB9\x8D\xCA> v\xCC75\xA9 \xA3\xCAP]8+\xBDa\x13\x17V[\x7F6\x08\x94\xA1;\xA1\xA3!\x06g\xC8(I-\xB9\x8D\xCA> v\xCC75\xA9 \xA3\xCAP]8+\xBC\x14a\x03\xEFWa\x03\xEFa\x136V[a\x04\x1A`\x01\x7F+\x1D\xBC\xE7C$$\x8C\"/\x0E\xC2\xD5\xED{\xD3#\xCF\xC4%\xB36\xF0%<\\\xCF\xDAreTna\x13\x17V[\x7F+\x1D\xBC\xE7C$$\x8C\"/\x0E\xC2\xD5\xED{\xD3#\xCF\xC4%\xB36\xF0%<\\\xCF\xDAreTm\x14a\x04HWa\x04Ha\x136V[a\x04Q\x81a\x04nV[a\x04\\\x85\x85_a\x04\xC5V[a\x04g\x83\x83_a\x04\xEFV[PPPPPV[\x7F~dMyB/\x17\xC0\x1EH\x94\xB5\xF4\xF5\x88\xD31\xEB\xFA(e=B\xAE\x83-\xC5\x9E8\xC9y\x8Fa\x04\x97a\x02\xBDV[`@\x80Q`\x01`\x01`\xA0\x1B\x03\x92\x83\x16\x81R\x91\x84\x16` \x83\x01R\x01`@Q\x80\x91\x03\x90\xA1a\x04\xC2\x81a\x04\xF8V[PV[a\x04\xCE\x83a\x05\xD0V[_\x82Q\x11\x80a\x04\xDAWP\x80[\x15a\x02\xB8Wa\x04\xE9\x83\x83a\x06\x0FV[PPPPV[a\x04\xCE\x83a\x06=V[`\x01`\x01`\xA0\x1B\x03\x81\x16a\x05tW`@QbF\x1B\xCD`\xE5\x1B\x81R` `\x04\x82\x01R`&`$\x82\x01R\x7FERC1967: new admin is the zero a`D\x82\x01R\x7Fddress\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0`d\x82\x01R`\x84\x01a\x02\x06V[\x80\x7F\xB51'hJV\x8B1s\xAE\x13\xB9\xF8\xA6\x01n$>c\xB6\xE8\xEE\x11x\xD6\xA7\x17\x85\x0B]a\x03[\x80T\x7F\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x16`\x01`\x01`\xA0\x1B\x03\x92\x90\x92\x16\x91\x90\x91\x17\x90UPV[a\x05\xD9\x81a\x06|V[`@Q`\x01`\x01`\xA0\x1B\x03\x82\x16\x90\x7F\xBC|\xD7Z \xEE'\xFD\x9A\xDE\xBA\xB3 A\xF7U!M\xBCk\xFF\xA9\x0C\xC0\"[9\xDA.\\-;\x90_\x90\xA2PV[``a\x064\x83\x83`@Q\x80``\x01`@R\x80`'\x81R` \x01a\x13s`'\x919a\x07 V[\x90P[\x92\x91PPV[a\x06F\x81a\x08\x12V[`@Q`\x01`\x01`\xA0\x1B\x03\x82\x16\x90\x7F\xF7\xEE\xD2\xA7\xFA\xBB\xF1\xBE\xC8\xD5^\xD5\xE7\x85\xCCvb#v\xDD\xE5\xDFO\xF1TpU\x1E\x03\x0B\x814\x90_\x90\xA2PV[`\x01`\x01`\xA0\x1B\x03\x81\x16;a\x06\xF9W`@QbF\x1B\xCD`\xE5\x1B\x81R` `\x04\x82\x01R`-`$\x82\x01R\x7FERC1967: new implementation is n`D\x82\x01R\x7Fot a contract\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0`d\x82\x01R`\x84\x01a\x02\x06V[\x80\x7F6\x08\x94\xA1;\xA1\xA3!\x06g\xC8(I-\xB9\x8D\xCA> v\xCC75\xA9 \xA3\xCAP]8+\xBCa\x05\x97V[```\x01`\x01`\xA0\x1B\x03\x84\x16;a\x07\x9FW`@QbF\x1B\xCD`\xE5\x1B\x81R` `\x04\x82\x01R`&`$\x82\x01R\x7FAddress: delegate call to non-co`D\x82\x01R\x7Fntract\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0`d\x82\x01R`\x84\x01a\x02\x06V[__\x85`\x01`\x01`\xA0\x1B\x03\x16\x85`@Qa\x07\xB9\x91\x90a\x13JV[_`@Q\x80\x83\x03\x81\x85Z\xF4\x91PP=\x80_\x81\x14a\x07\xF1W`@Q\x91P`\x1F\x19`?=\x01\x16\x82\x01`@R=\x82R=_` \x84\x01>a\x07\xF6V[``\x91P[P\x91P\x91Pa\x08\x06\x82\x82\x86a\x08\xB6V[\x92PPP[\x93\x92PPPV[`\x01`\x01`\xA0\x1B\x03\x81\x16;a\x08\x8FW`@QbF\x1B\xCD`\xE5\x1B\x81R` `\x04\x82\x01R`7`$\x82\x01R\x7FERC1967: new secondary implement`D\x82\x01R\x7Fation is not a contract\0\0\0\0\0\0\0\0\0`d\x82\x01R`\x84\x01a\x02\x06V[\x80\x7F+\x1D\xBC\xE7C$$\x8C\"/\x0E\xC2\xD5\xED{\xD3#\xCF\xC4%\xB36\xF0%<\\\xCF\xDAreTma\x05\x97V[``\x83\x15a\x08\xC5WP\x81a\x08\x0BV[\x82Q\x15a\x08\xD5W\x82Q\x80\x84` \x01\xFD[\x81`@QbF\x1B\xCD`\xE5\x1B\x81R`\x04\x01a\x02\x06\x91\x90a\x13`V[cNH{q`\xE0\x1B_R`A`\x04R`$_\xFD[`@Q``\x81\x01g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x11\x82\x82\x10\x17\x15a\t&Wa\t&a\x08\xEFV[`@R\x90V[`@\x80Q\x90\x81\x01g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x11\x82\x82\x10\x17\x15a\t&Wa\t&a\x08\xEFV[`@Qa\x01 \x81\x01g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x11\x82\x82\x10\x17\x15a\t&Wa\t&a\x08\xEFV[`@Qa\x02\xA0\x81\x01g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x11\x82\x82\x10\x17\x15a\t&Wa\t&a\x08\xEFV[`@Q`\x1F\x82\x01`\x1F\x19\x16\x81\x01g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x11\x82\x82\x10\x17\x15a\t\xC0Wa\t\xC0a\x08\xEFV[`@R\x91\x90PV[\x805g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x16\x81\x14a\x02\x95W__\xFD[\x805`\x01`\x01`\xA0\x1B\x03\x81\x16\x81\x14a\x02\x95W__\xFD[_\x82`\x1F\x83\x01\x12a\n\x04W__\xFD[\x815g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x11\x15a\n\x1EWa\n\x1Ea\x08\xEFV[a\n1` `\x1F\x19`\x1F\x84\x01\x16\x01a\t\x97V[\x81\x81R\x84` \x83\x86\x01\x01\x11\x15a\nEW__\xFD[\x81` \x85\x01` \x83\x017_\x91\x81\x01` \x01\x91\x90\x91R\x93\x92PPPV[_\x82`\x1F\x83\x01\x12a\npW__\xFD[\x815g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x11\x15a\n\x8AWa\n\x8Aa\x08\xEFV[\x80`\x05\x1Ba\n\x9A` \x82\x01a\t\x97V[\x91\x82R` \x81\x85\x01\x81\x01\x92\x90\x81\x01\x90\x86\x84\x11\x15a\n\xB5W__\xFD[` \x86\x01\x92P[\x83\x83\x10\x15a\n\xD7W\x825\x82R` \x92\x83\x01\x92\x90\x91\x01\x90a\n\xBCV[\x96\x95PPPPPPV[_`\x80\x82\x84\x03\x12\x15a\n\xF1W__\xFD[`@Q`\x80\x81\x01g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x11\x82\x82\x10\x17\x15a\x0B\x14Wa\x0B\x14a\x08\xEFV[`@\x90\x81R\x835\x82R` \x80\x85\x015\x90\x83\x01R\x83\x81\x015\x90\x82\x01R``\x92\x83\x015\x92\x81\x01\x92\x90\x92RP\x91\x90PV[_\x82`\x1F\x83\x01\x12a\x0BQW__\xFD[a\x0B[`@a\t\x97V[\x80`@\x84\x01\x85\x81\x11\x15a\x0BlW__\xFD[\x84[\x81\x81\x10\x15a\x0B\x8DWa\x0B\x7F\x81a\t\xC8V[\x84R` \x93\x84\x01\x93\x01a\x0BnV[P\x90\x95\x94PPPPPV[\x805`\x03\x81\x10a\x02\x95W__\xFD[_\x81\x83\x03`\xC0\x81\x12\x15a\x0B\xB7W__\xFD[a\x0B\xBFa\t\x03V[\x91P`\x80\x81\x12\x15a\x0B\xCEW__\xFD[Pa\x0B\xD7a\t,V[\x83`\x1F\x84\x01\x12a\x0B\xE5W__\xFD[a\x0B\xEF`@a\t\x97V[\x80`@\x85\x01\x86\x81\x11\x15a\x0C\0W__\xFD[\x85[\x81\x81\x10\x15a\x0C\x1AW\x805\x84R` \x93\x84\x01\x93\x01a\x0C\x02V[P\x81\x84Ra\x0C(\x87\x82a\x0BBV[` \x85\x01RPPP\x81Ra\x0C>`\x80\x83\x01a\x0B\x98V[` \x82\x01R`\xA0\x91\x90\x91\x015`@\x82\x01R\x91\x90PV[\x805`\xFF\x81\x16\x81\x14a\x02\x95W__\xFD[_``\x82\x84\x03\x12\x15a\x0CtW__\xFD[a\x0C|a\t\x03V[\x90Pa\x0C\x87\x82a\t\xC8V[\x81Ra\x0C\x95` \x83\x01a\t\xC8V[` \x82\x01Ra\x0C\xA6`@\x83\x01a\t\xC8V[`@\x82\x01R\x92\x91PPV[_a\x01 \x82\x84\x03\x12\x15a\x0C\xC2W__\xFD[a\x0C\xCAa\tOV[\x90Pa\x0C\xD5\x82a\t\xDFV[\x81Ra\x0C\xE3` \x83\x01a\t\xDFV[` \x82\x01Ra\x0C\xF4`@\x83\x01a\t\xDFV[`@\x82\x01Ra\r\x05``\x83\x01a\t\xDFV[``\x82\x01Ra\r\x16`\x80\x83\x01a\t\xDFV[`\x80\x82\x01Ra\r'`\xA0\x83\x01a\t\xDFV[`\xA0\x82\x01Ra\r8`\xC0\x83\x01a\t\xDFV[`\xC0\x82\x01Ra\rI`\xE0\x83\x01a\t\xDFV[`\xE0\x82\x01Ra\r[a\x01\0\x83\x01a\t\xDFV[a\x01\0\x82\x01R\x92\x91PPV[__a\x01@\x83\x85\x03\x12\x15a\ryW__\xFD[\x825g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x11\x15a\r\x8FW__\xFD[\x83\x01a\x03\xE0\x81\x86\x03\x12\x15a\r\xA1W__\xFD[a\r\xA9a\tsV[a\r\xB2\x82a\t\xC8V[\x81Ra\r\xC0` \x83\x01a\t\xDFV[` \x82\x01R`@\x82\x81\x015\x90\x82\x01R``\x80\x83\x015\x90\x82\x01Ra\r\xE5`\x80\x83\x01a\t\xDFV[`\x80\x82\x01Ra\r\xF6`\xA0\x83\x01a\t\xDFV[`\xA0\x82\x01R`\xC0\x82\x81\x015\x90\x82\x01R`\xE0\x82\x015g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x11\x15a\x0E\x1EW__\xFD[a\x0E*\x87\x82\x85\x01a\t\xF5V[`\xE0\x83\x01RPa\x01\0\x82\x81\x015\x90\x82\x01Ra\x0EHa\x01 \x83\x01a\t\xC8V[a\x01 \x82\x01Ra\x01@\x82\x015g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x11\x15a\x0EhW__\xFD[a\x0Et\x87\x82\x85\x01a\naV[a\x01@\x83\x01RPa\x0E\x89\x86a\x01`\x84\x01a\n\xE1V[a\x01`\x82\x01Ra\x01\xE0\x82\x015a\x01\x80\x82\x01Ra\x02\0\x82\x015a\x01\xA0\x82\x01Ra\x02 \x82\x015a\x01\xC0\x82\x01Ra\x0E\xC1\x86a\x02@\x84\x01a\x0B\xA6V[a\x01\xE0\x82\x01Ra\x03\0\x82\x015a\x02\0\x82\x01Ra\x0E\xE0a\x03 \x83\x01a\t\xDFV[a\x02 \x82\x01Ra\x0E\xF3a\x03@\x83\x01a\x0CTV[a\x02@\x82\x01Ra\x0F\x06a\x03`\x83\x01a\t\xC8V[a\x02`\x82\x01Ra\x0F\x1A\x86a\x03\x80\x84\x01a\x0CdV[a\x02\x80\x82\x01R\x92Pa\x0F1\x90P\x84` \x85\x01a\x0C\xB1V[\x90P\x92P\x92\x90PV[_\x81Q\x80\x84R\x80` \x84\x01` \x86\x01^_` \x82\x86\x01\x01R` `\x1F\x19`\x1F\x83\x01\x16\x85\x01\x01\x91PP\x92\x91PPV[_\x81Q\x80\x84R` \x84\x01\x93P` \x83\x01_[\x82\x81\x10\x15a\x0F\x98W\x81Q\x86R` \x95\x86\x01\x95\x90\x91\x01\x90`\x01\x01a\x0FzV[P\x93\x94\x93PPPPV[`\x03\x81\x10a\x0F\xBEWcNH{q`\xE0\x1B_R`!`\x04R`$_\xFD[\x90RV[\x80Q\x80Q\x83_[`\x02\x81\x10\x15a\x0F\xE8W\x82Q\x82R` \x92\x83\x01\x92\x90\x91\x01\x90`\x01\x01a\x0F\xC9V[PPP` \x01Q`@\x83\x01_[`\x02\x81\x10\x15a\x10\x1EW\x82Qg\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x82R` \x92\x83\x01\x92\x90\x91\x01\x90`\x01\x01a\x0F\xF5V[PPP` \x81\x01Qa\x103`\x80\x84\x01\x82a\x0F\xA2V[P`@\x01Q`\xA0\x91\x90\x91\x01RV[`\x01`\x01`\xA0\x1B\x03\x81Q\x16\x82R` \x81\x01Qa\x10h` \x84\x01\x82`\x01`\x01`\xA0\x1B\x03\x16\x90RV[P`@\x81\x01Qa\x10\x83`@\x84\x01\x82`\x01`\x01`\xA0\x1B\x03\x16\x90RV[P``\x81\x01Qa\x10\x9E``\x84\x01\x82`\x01`\x01`\xA0\x1B\x03\x16\x90RV[P`\x80\x81\x01Qa\x10\xB9`\x80\x84\x01\x82`\x01`\x01`\xA0\x1B\x03\x16\x90RV[P`\xA0\x81\x01Qa\x10\xD4`\xA0\x84\x01\x82`\x01`\x01`\xA0\x1B\x03\x16\x90RV[P`\xC0\x81\x01Qa\x10\xEF`\xC0\x84\x01\x82`\x01`\x01`\xA0\x1B\x03\x16\x90RV[P`\xE0\x81\x01Qa\x11\n`\xE0\x84\x01\x82`\x01`\x01`\xA0\x1B\x03\x16\x90RV[Pa\x01\0\x81\x01Qa\x02\xB8a\x01\0\x84\x01\x82`\x01`\x01`\xA0\x1B\x03\x16\x90RV[a\x01@\x81Ra\x11Da\x01@\x82\x01\x84Qg\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x90RV[_` \x84\x01Qa\x11`a\x01`\x84\x01\x82`\x01`\x01`\xA0\x1B\x03\x16\x90RV[P`@\x84\x01Qa\x01\x80\x83\x01R``\x84\x01Qa\x01\xA0\x83\x01R`\x80\x84\x01Q`\x01`\x01`\xA0\x1B\x03\x90\x81\x16a\x01\xC0\x84\x01R`\xA0\x85\x01Q\x16a\x01\xE0\x83\x01R`\xC0\x84\x01Qa\x02\0\x83\x01R`\xE0\x84\x01Qa\x03\xE0a\x02 \x84\x01Ra\x11\xC0a\x05 \x84\x01\x82a\x0F:V[\x90Pa\x01\0\x85\x01Qa\x02@\x84\x01Ra\x01 \x85\x01Qa\x11\xEBa\x02`\x85\x01\x82g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x90RV[Pa\x01@\x85\x01Q\x7F\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFE\xC0\x84\x83\x03\x01a\x02\x80\x85\x01Ra\x12'\x82\x82a\x0FhV[a\x01`\x87\x01Q\x80Qa\x02\xA0\x87\x01R` \x81\x01Qa\x02\xC0\x87\x01R`@\x81\x01Qa\x02\xE0\x87\x01R``\x01Qa\x03\0\x86\x01Ra\x01\x80\x87\x01Qa\x03 \x86\x01Ra\x01\xA0\x87\x01Qa\x03@\x86\x01Ra\x01\xC0\x87\x01Qa\x03`\x86\x01Ra\x01\xE0\x87\x01Q\x90\x92P\x90Pa\x12\x92a\x03\x80\x85\x01\x82a\x0F\xC2V[Pa\x02\0\x85\x01Qa\x04@\x84\x01Ra\x02 \x85\x01Q`\x01`\x01`\xA0\x1B\x03\x16a\x04`\x84\x01Ra\x02@\x85\x01Q`\xFF\x16a\x04\x80\x84\x01Ra\x02`\x85\x01Qg\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x90\x81\x16a\x04\xA0\x85\x01Ra\x02\x80\x86\x01Q\x80Q\x82\x16a\x04\xC0\x86\x01R` \x80\x82\x01Q\x83\x16a\x04\xE0\x87\x01R`@\x90\x91\x01Q\x90\x91\x16a\x05\0\x85\x01R\x90\x91Pa\x08\x0B\x90\x83\x01\x84a\x10AV[\x81\x81\x03\x81\x81\x11\x15a\x067WcNH{q`\xE0\x1B_R`\x11`\x04R`$_\xFD[cNH{q`\xE0\x1B_R`\x01`\x04R`$_\xFD[_\x82Q\x80` \x85\x01\x84^_\x92\x01\x91\x82RP\x91\x90PV[` \x81R_a\x064` \x83\x01\x84a\x0F:V\xFEAddress: low-level delegate call failed\xA2dipfsX\"\x12 \x9B\xF2\xC0#\x8C%\x05qk\xE0\xE1\xD0M\xF7\x88\x9DN\xDBP$\xE1\xBA(\xC8\xC3 \xA9(z\xBF\xD2\\dsolcC\0\x08\x1C\x003`\x80`@R`@Qa\r\x918\x03\x80a\r\x91\x839\x81\x01`@\x81\x90Ra\0\"\x91a\x03\xB7V[\x82\x81a\0/\x82\x82_a\0CV[Pa\0;\x90P\x82a\0nV[PPPa\x04\xD3V[a\0L\x83a\0\xDBV[_\x82Q\x11\x80a\0XWP\x80[\x15a\0iWa\0g\x83\x83a\x01\x1AV[P[PPPV[\x7F~dMyB/\x17\xC0\x1EH\x94\xB5\xF4\xF5\x88\xD31\xEB\xFA(e=B\xAE\x83-\xC5\x9E8\xC9y\x8Fa\0\xAD_Q` a\rJ_9_Q\x90_RT`\x01`\x01`\xA0\x1B\x03\x16\x90V[`@\x80Q`\x01`\x01`\xA0\x1B\x03\x92\x83\x16\x81R\x91\x84\x16` \x83\x01R\x01`@Q\x80\x91\x03\x90\xA1a\0\xD8\x81a\x01FV[PV[a\0\xE4\x81a\x01\xE1V[`@Q`\x01`\x01`\xA0\x1B\x03\x82\x16\x90\x7F\xBC|\xD7Z \xEE'\xFD\x9A\xDE\xBA\xB3 A\xF7U!M\xBCk\xFF\xA9\x0C\xC0\"[9\xDA.\\-;\x90_\x90\xA2PV[``a\x01?\x83\x83`@Q\x80``\x01`@R\x80`'\x81R` \x01a\rj`'\x919a\x02uV[\x93\x92PPPV[`\x01`\x01`\xA0\x1B\x03\x81\x16a\x01\xB0W`@QbF\x1B\xCD`\xE5\x1B\x81R` `\x04\x82\x01R`&`$\x82\x01R\x7FERC1967: new admin is the zero a`D\x82\x01Reddress`\xD0\x1B`d\x82\x01R`\x84\x01[`@Q\x80\x91\x03\x90\xFD[\x80_Q` a\rJ_9_Q\x90_R[\x80T`\x01`\x01`\xA0\x1B\x03\x19\x16`\x01`\x01`\xA0\x1B\x03\x92\x90\x92\x16\x91\x90\x91\x17\x90UPV[`\x01`\x01`\xA0\x1B\x03\x81\x16;a\x02NW`@QbF\x1B\xCD`\xE5\x1B\x81R` `\x04\x82\x01R`-`$\x82\x01R\x7FERC1967: new implementation is n`D\x82\x01Rl\x1B\xDD\x08\x18H\x18\xDB\xDB\x9D\x1C\x98X\xDD`\x9A\x1B`d\x82\x01R`\x84\x01a\x01\xA7V[\x80\x7F6\x08\x94\xA1;\xA1\xA3!\x06g\xC8(I-\xB9\x8D\xCA> v\xCC75\xA9 \xA3\xCAP]8+\xBCa\x01\xC0V[```\x01`\x01`\xA0\x1B\x03\x84\x16;a\x02\xDDW`@QbF\x1B\xCD`\xE5\x1B\x81R` `\x04\x82\x01R`&`$\x82\x01R\x7FAddress: delegate call to non-co`D\x82\x01Re\x1B\x9D\x1C\x98X\xDD`\xD2\x1B`d\x82\x01R`\x84\x01a\x01\xA7V[__\x85`\x01`\x01`\xA0\x1B\x03\x16\x85`@Qa\x02\xF7\x91\x90a\x04\x88V[_`@Q\x80\x83\x03\x81\x85Z\xF4\x91PP=\x80_\x81\x14a\x03/W`@Q\x91P`\x1F\x19`?=\x01\x16\x82\x01`@R=\x82R=_` \x84\x01>a\x034V[``\x91P[P\x90\x92P\x90Pa\x03E\x82\x82\x86a\x03OV[\x96\x95PPPPPPV[``\x83\x15a\x03^WP\x81a\x01?V[\x82Q\x15a\x03nW\x82Q\x80\x84` \x01\xFD[\x81`@QbF\x1B\xCD`\xE5\x1B\x81R`\x04\x01a\x01\xA7\x91\x90a\x04\x9EV[\x80Q`\x01`\x01`\xA0\x1B\x03\x81\x16\x81\x14a\x03\x9EW__\xFD[\x91\x90PV[cNH{q`\xE0\x1B_R`A`\x04R`$_\xFD[___``\x84\x86\x03\x12\x15a\x03\xC9W__\xFD[a\x03\xD2\x84a\x03\x88V[\x92Pa\x03\xE0` \x85\x01a\x03\x88V[`@\x85\x01Q\x90\x92P`\x01`\x01`@\x1B\x03\x81\x11\x15a\x03\xFBW__\xFD[\x84\x01`\x1F\x81\x01\x86\x13a\x04\x0BW__\xFD[\x80Q`\x01`\x01`@\x1B\x03\x81\x11\x15a\x04$Wa\x04$a\x03\xA3V[`@Q`\x1F\x82\x01`\x1F\x19\x90\x81\x16`?\x01\x16\x81\x01`\x01`\x01`@\x1B\x03\x81\x11\x82\x82\x10\x17\x15a\x04RWa\x04Ra\x03\xA3V[`@R\x81\x81R\x82\x82\x01` \x01\x88\x10\x15a\x04iW__\xFD[\x81` \x84\x01` \x83\x01^_` \x83\x83\x01\x01R\x80\x93PPPP\x92P\x92P\x92V[_\x82Q\x80` \x85\x01\x84^_\x92\x01\x91\x82RP\x91\x90PV[` \x81R_\x82Q\x80` \x84\x01R\x80` \x85\x01`@\x85\x01^_`@\x82\x85\x01\x01R`@`\x1F\x19`\x1F\x83\x01\x16\x84\x01\x01\x91PP\x92\x91PPV[a\x08j\x80a\x04\xE0_9_\xF3\xFE`\x80`@R`\x046\x10a\0]W_5`\xE0\x1C\x80c\\`\xDA\x1B\x11a\0BW\x80c\\`\xDA\x1B\x14a\0\xA6W\x80c\x8F(9p\x14a\0\xD6W\x80c\xF8Q\xA4@\x14a\0\xF5Wa\0lV[\x80c6Y\xCF\xE6\x14a\0tW\x80cO\x1E\xF2\x86\x14a\0\x93Wa\0lV[6a\0lWa\0ja\x01\tV[\0[a\0ja\x01\tV[4\x80\x15a\0\x7FW__\xFD[Pa\0ja\0\x8E6`\x04a\x07\rV[a\x01#V[a\0ja\0\xA16`\x04a\x07&V[a\x01^V[4\x80\x15a\0\xB1W__\xFD[Pa\0\xBAa\x01\xC4V[`@Q`\x01`\x01`\xA0\x1B\x03\x90\x91\x16\x81R` \x01`@Q\x80\x91\x03\x90\xF3[4\x80\x15a\0\xE1W__\xFD[Pa\0ja\0\xF06`\x04a\x07\rV[a\x01\xF4V[4\x80\x15a\x01\0W__\xFD[Pa\0\xBAa\x02\x14V[a\x01\x11a\x024V[a\x01!a\x01\x1Ca\x02\xE4V[a\x02\xEDV[V[a\x01+a\x03\x0BV[`\x01`\x01`\xA0\x1B\x03\x163\x03a\x01VWa\x01S\x81`@Q\x80` \x01`@R\x80_\x81RP_a\x03=V[PV[a\x01Sa\x01\tV[a\x01fa\x03\x0BV[`\x01`\x01`\xA0\x1B\x03\x163\x03a\x01\xBCWa\x01\xB7\x83\x83\x83\x80\x80`\x1F\x01` \x80\x91\x04\x02` \x01`@Q\x90\x81\x01`@R\x80\x93\x92\x91\x90\x81\x81R` \x01\x83\x83\x80\x82\x847_\x92\x01\x91\x90\x91RP`\x01\x92Pa\x03=\x91PPV[PPPV[a\x01\xB7a\x01\tV[_a\x01\xCDa\x03\x0BV[`\x01`\x01`\xA0\x1B\x03\x163\x03a\x01\xE9Wa\x01\xE4a\x02\xE4V[\x90P\x90V[a\x01\xF1a\x01\tV[\x90V[a\x01\xFCa\x03\x0BV[`\x01`\x01`\xA0\x1B\x03\x163\x03a\x01VWa\x01S\x81a\x03gV[_a\x02\x1Da\x03\x0BV[`\x01`\x01`\xA0\x1B\x03\x163\x03a\x01\xE9Wa\x01\xE4a\x03\x0BV[a\x02<a\x03\x0BV[`\x01`\x01`\xA0\x1B\x03\x163\x03a\x01!W`@QbF\x1B\xCD`\xE5\x1B\x81R` `\x04\x82\x01R`B`$\x82\x01R\x7FTransparentUpgradeableProxy: adm`D\x82\x01R\x7Fin cannot fallback to proxy targ`d\x82\x01R\x7Fet\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0`\x84\x82\x01R`\xA4\x01[`@Q\x80\x91\x03\x90\xFD[_a\x01\xE4a\x03\xBBV[6__7__6_\x84Z\xF4=__>\x80\x80\x15a\x03\x07W=_\xF3[=_\xFD[_\x7F\xB51'hJV\x8B1s\xAE\x13\xB9\xF8\xA6\x01n$>c\xB6\xE8\xEE\x11x\xD6\xA7\x17\x85\x0B]a\x03[T`\x01`\x01`\xA0\x1B\x03\x16\x91\x90PV[a\x03F\x83a\x03\xE2V[_\x82Q\x11\x80a\x03RWP\x80[\x15a\x01\xB7Wa\x03a\x83\x83a\x04!V[PPPPV[\x7F~dMyB/\x17\xC0\x1EH\x94\xB5\xF4\xF5\x88\xD31\xEB\xFA(e=B\xAE\x83-\xC5\x9E8\xC9y\x8Fa\x03\x90a\x03\x0BV[`@\x80Q`\x01`\x01`\xA0\x1B\x03\x92\x83\x16\x81R\x91\x84\x16` \x83\x01R\x01`@Q\x80\x91\x03\x90\xA1a\x01S\x81a\x04MV[_\x7F6\x08\x94\xA1;\xA1\xA3!\x06g\xC8(I-\xB9\x8D\xCA> v\xCC75\xA9 \xA3\xCAP]8+\xBCa\x03.V[a\x03\xEB\x81a\x05%V[`@Q`\x01`\x01`\xA0\x1B\x03\x82\x16\x90\x7F\xBC|\xD7Z \xEE'\xFD\x9A\xDE\xBA\xB3 A\xF7U!M\xBCk\xFF\xA9\x0C\xC0\"[9\xDA.\\-;\x90_\x90\xA2PV[``a\x04F\x83\x83`@Q\x80``\x01`@R\x80`'\x81R` \x01a\x08\x0E`'\x919a\x05\xC9V[\x93\x92PPPV[`\x01`\x01`\xA0\x1B\x03\x81\x16a\x04\xC9W`@QbF\x1B\xCD`\xE5\x1B\x81R` `\x04\x82\x01R`&`$\x82\x01R\x7FERC1967: new admin is the zero a`D\x82\x01R\x7Fddress\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0`d\x82\x01R`\x84\x01a\x02\xDBV[\x80\x7F\xB51'hJV\x8B1s\xAE\x13\xB9\xF8\xA6\x01n$>c\xB6\xE8\xEE\x11x\xD6\xA7\x17\x85\x0B]a\x03[\x80T\x7F\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x16`\x01`\x01`\xA0\x1B\x03\x92\x90\x92\x16\x91\x90\x91\x17\x90UPV[`\x01`\x01`\xA0\x1B\x03\x81\x16;a\x05\xA2W`@QbF\x1B\xCD`\xE5\x1B\x81R` `\x04\x82\x01R`-`$\x82\x01R\x7FERC1967: new implementation is n`D\x82\x01R\x7Fot a contract\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0`d\x82\x01R`\x84\x01a\x02\xDBV[\x80\x7F6\x08\x94\xA1;\xA1\xA3!\x06g\xC8(I-\xB9\x8D\xCA> v\xCC75\xA9 \xA3\xCAP]8+\xBCa\x04\xECV[```\x01`\x01`\xA0\x1B\x03\x84\x16;a\x06HW`@QbF\x1B\xCD`\xE5\x1B\x81R` `\x04\x82\x01R`&`$\x82\x01R\x7FAddress: delegate call to non-co`D\x82\x01R\x7Fntract\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0`d\x82\x01R`\x84\x01a\x02\xDBV[__\x85`\x01`\x01`\xA0\x1B\x03\x16\x85`@Qa\x06b\x91\x90a\x07\xA4V[_`@Q\x80\x83\x03\x81\x85Z\xF4\x91PP=\x80_\x81\x14a\x06\x9AW`@Q\x91P`\x1F\x19`?=\x01\x16\x82\x01`@R=\x82R=_` \x84\x01>a\x06\x9FV[``\x91P[P\x91P\x91Pa\x06\xAF\x82\x82\x86a\x06\xB9V[\x96\x95PPPPPPV[``\x83\x15a\x06\xC8WP\x81a\x04FV[\x82Q\x15a\x06\xD8W\x82Q\x80\x84` \x01\xFD[\x81`@QbF\x1B\xCD`\xE5\x1B\x81R`\x04\x01a\x02\xDB\x91\x90a\x07\xBAV[\x805`\x01`\x01`\xA0\x1B\x03\x81\x16\x81\x14a\x07\x08W__\xFD[\x91\x90PV[_` \x82\x84\x03\x12\x15a\x07\x1DW__\xFD[a\x04F\x82a\x06\xF2V[___`@\x84\x86\x03\x12\x15a\x078W__\xFD[a\x07A\x84a\x06\xF2V[\x92P` \x84\x015g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x11\x15a\x07\\W__\xFD[\x84\x01`\x1F\x81\x01\x86\x13a\x07lW__\xFD[\x805g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x11\x15a\x07\x82W__\xFD[\x86` \x82\x84\x01\x01\x11\x15a\x07\x93W__\xFD[\x93\x96` \x91\x90\x91\x01\x95P\x92\x93PPPV[_\x82Q\x80` \x85\x01\x84^_\x92\x01\x91\x82RP\x91\x90PV[` \x81R_\x82Q\x80` \x84\x01R\x80` \x85\x01`@\x85\x01^_`@\x82\x85\x01\x01R`@\x7F\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xE0`\x1F\x83\x01\x16\x84\x01\x01\x91PP\x92\x91PPV\xFEAddress: low-level delegate call failed\xA2dipfsX\"\x12 \xA4\\\\\x13\x90\x96\x13\xFB\x1CD\xF2I\xCEw\xBF\xB0<\xDFG\xA4\xF4+\xCC\x05\xD7\x96\xFA\x83\xA5\x95\xAC\xCBdsolcC\0\x08\x1C\x003\xB51'hJV\x8B1s\xAE\x13\xB9\xF8\xA6\x01n$>c\xB6\xE8\xEE\x11x\xD6\xA7\x17\x85\x0B]a\x03Address: low-level delegate call failed\xA2dipfsX\"\x12 \x99\xE3\x83\xA1c\xF1LH/[\xA6d\"\"c\xEF\x94\xD0\x8F\x10\x18\xD2\x89\x952\x92\xED}=I\x86ddsolcC\0\x08\x1C\x003`\x80`@R4\x80\x15`\x0EW__\xFD[Pa\n\x14\x80a\0\x1C_9_\xF3\xFE`\x80`@R4\x80\x15a\0\x0FW__\xFD[P`\x046\x10a\0?W_5`\xE0\x1C\x80c1dA0\x14a\0CW\x80c\x8E\xAAj\xC0\x14a\0iW\x80c\x94\\\x94\x94\x14a\0\x8AW[__\xFD[a\0Va\0Q6`\x04a\x04\x11V[a\0\x9FV[`@Q\x90\x81R` \x01[`@Q\x80\x91\x03\x90\xF3[a\0|a\0w6`\x04a\x04:V[a\x01\x8FV[`@Qa\0`\x92\x91\x90a\x04qV[a\0\x9Da\0\x986`\x04a\x04\xF6V[a\x02\xB7V[\0[_a\x01Na\0\xB26\x85\x90\x03\x85\x01\x85a\x05\xB0V[\x80Q\x80Q` \x91\x82\x01Q\x92\x82\x01Q\x80Q\x90\x83\x01Q`@\x80Q\x7FGlobal state:\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81\x87\x01R`-\x81\x01\x94\x90\x94R`M\x84\x01\x95\x90\x95R\x7F\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0`\xC0\x92\x83\x1B\x81\x16`m\x85\x01R\x91\x1B\x16`u\x82\x01R\x82Q\x80\x82\x03`]\x01\x81R`}\x90\x91\x01\x90\x92R\x81Q\x91\x01 \x90V[\x82a\x01_`\xA0\x86\x01`\x80\x87\x01a\x06\x83V[`@Q` \x01a\x01q\x93\x92\x91\x90a\x06\xA5V[`@Q` \x81\x83\x03\x03\x81R\x90`@R\x80Q\x90` \x01 \x90P\x92\x91PPV[a\x01\x97a\x03\xA2V[_\x82\x81R` \x81\x90R`@\x81 \x80Ta\x01\xAF\x90a\x06\xE0V[\x80`\x1F\x01` \x80\x91\x04\x02` \x01`@Q\x90\x81\x01`@R\x80\x92\x91\x90\x81\x81R` \x01\x82\x80Ta\x01\xDB\x90a\x06\xE0V[\x80\x15a\x02&W\x80`\x1F\x10a\x01\xFDWa\x01\0\x80\x83T\x04\x02\x83R\x91` \x01\x91a\x02&V[\x82\x01\x91\x90_R` _ \x90[\x81T\x81R\x90`\x01\x01\x90` \x01\x80\x83\x11a\x02\tW\x82\x90\x03`\x1F\x16\x82\x01\x91[PPPPP\x80` \x01\x90Q\x81\x01\x90a\x02>\x91\x90a\x07zV[\x90\x92P\x90P_\x81\x90\x03a\x02\xB2W`@Q\x7F\x08\xC3y\xA0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R` `\x04\x82\x01R`\x10`$\x82\x01R\x7FHash not yet set\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0`D\x82\x01R`d\x01[`@Q\x80\x91\x03\x90\xFD[\x91P\x91V[a\x02\xC1\x82\x82a\0\x9FV[\x83\x14a\x03)W`@Q\x7F\x08\xC3y\xA0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R` `\x04\x82\x01R`\x0C`$\x82\x01R\x7FInvalid hash\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0`D\x82\x01R`d\x01a\x02\xA9V[\x81\x81`@Q` \x01a\x03<\x92\x91\x90a\x08\x9BV[`@\x80Q`\x1F\x19\x81\x84\x03\x01\x81R\x91\x81R_\x85\x81R` \x81\x90R \x90a\x03a\x90\x82a\t\x01V[P\x7F\x14\xC0\xA6\xB8\xD8\x1FY\x15\xDA\xCF\xD8^A\xAEG\x984>\xC2\x9D\xE4\x08\xACL\x136\x0Cr8\xAE\n\xD9\x83\x83\x83`@Qa\x03\x95\x93\x92\x91\x90a\t\xBCV[`@Q\x80\x91\x03\x90\xA1PPPV[`@Q\x80`@\x01`@R\x80a\x03\xB5a\x03\xC1V[\x81R` \x01_[\x90R\x90V[`@Q\x80`@\x01`@R\x80a\x03\xD4a\x03\xDDV[\x81R` \x01a\x03\xBC[`@Q\x80`@\x01`@R\x80`\x02\x90` \x82\x02\x806\x837P\x91\x92\x91PPV[_`\xA0\x82\x84\x03\x12\x15a\x04\x0BW__\xFD[P\x91\x90PV[__`\xC0\x83\x85\x03\x12\x15a\x04\"W__\xFD[a\x04,\x84\x84a\x03\xFBV[\x94`\xA0\x93\x90\x93\x015\x93PPPV[_` \x82\x84\x03\x12\x15a\x04JW__\xFD[P5\x91\x90PV[`\x03\x81\x10a\x04mWcNH{q`\xE0\x1B_R`!`\x04R`$_\xFD[\x90RV[\x82Q\x80Q`\xC0\x83\x01\x91\x90\x83_[`\x02\x81\x10\x15a\x04\x9DW\x82Q\x82R` \x92\x83\x01\x92\x90\x91\x01\x90`\x01\x01a\x04~V[PPP` \x01Q`@\x83\x01_[`\x02\x81\x10\x15a\x04\xD3W\x82Qg\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x82R` \x92\x83\x01\x92\x90\x91\x01\x90`\x01\x01a\x04\xAAV[PPP` \x84\x01Qa\x04\xE8`\x80\x84\x01\x82a\x04QV[P\x82`\xA0\x83\x01R\x93\x92PPPV[___`\xE0\x84\x86\x03\x12\x15a\x05\x08W__\xFD[\x835\x92Pa\x05\x19\x85` \x86\x01a\x03\xFBV[\x92\x95\x92\x94PPP`\xC0\x91\x90\x91\x015\x90V[cNH{q`\xE0\x1B_R`A`\x04R`$_\xFD[`@\x80Q\x90\x81\x01g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x11\x82\x82\x10\x17\x15a\x05aWa\x05aa\x05*V[`@R\x90V[`@Q`\x1F\x82\x01`\x1F\x19\x16\x81\x01g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x11\x82\x82\x10\x17\x15a\x05\x90Wa\x05\x90a\x05*V[`@R\x91\x90PV[g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x16\x81\x14a\x05\xADW__\xFD[PV[_`\x80\x82\x84\x03\x12\x80\x15a\x05\xC1W__\xFD[Pa\x05\xCAa\x05>V[\x83`\x1F\x84\x01\x12a\x05\xD8W__\xFD[`@a\x05\xE3\x81a\x05gV[\x80\x82\x86\x01\x87\x81\x11\x15a\x05\xF3W__\xFD[\x86[\x81\x81\x10\x15a\x06\rW\x805\x84R` \x93\x84\x01\x93\x01a\x05\xF5V[P\x81\x85R_\x92P\x87`\x1F\x82\x01\x12a\x06\"W__\xFD[\x83\x91Pa\x06.\x82a\x05gV[\x93\x81\x01\x93\x91P\x81\x88\x85\x11\x15a\x06AW__\xFD[\x84\x82\x10\x15a\x06fW\x815a\x06T\x81a\x05\x98V[\x83R` \x92\x83\x01\x92\x91\x90\x91\x01\x90a\x06AV[` \x86\x01RP\x92\x96\x95PPPPPPV[`\x03\x81\x10a\x05\xADW__\xFD[_` \x82\x84\x03\x12\x15a\x06\x93W__\xFD[\x815a\x06\x9E\x81a\x06wV[\x93\x92PPPV[\x83\x81R\x82` \x82\x01R_`\x03\x83\x10a\x06\xCBWcNH{q`\xE0\x1B_R`!`\x04R`$_\xFD[P`\xF8\x91\x90\x91\x1B`@\x82\x01R`A\x01\x92\x91PPV[`\x01\x81\x81\x1C\x90\x82\x16\x80a\x06\xF4W`\x7F\x82\x16\x91P[` \x82\x10\x81\x03a\x04\x0BWcNH{q`\xE0\x1B_R`\"`\x04R`$_\xFD[_\x82`\x1F\x83\x01\x12a\x07!W__\xFD[a\x07+`@a\x05gV[\x80`@\x84\x01\x85\x81\x11\x15a\x07<W__\xFD[\x84[\x81\x81\x10\x15a\x07_W\x80Qa\x07Q\x81a\x05\x98V[\x84R` \x93\x84\x01\x93\x01a\x07>V[P\x90\x95\x94PPPPPV[\x80Qa\x07u\x81a\x06wV[\x91\x90PV[__\x82\x84\x03`\xC0\x81\x12\x15a\x07\x8CW__\xFD[`\xA0\x81\x12\x15a\x07\x99W__\xFD[a\x07\xA1a\x05>V[`\x80\x82\x12\x15a\x07\xAEW__\xFD[a\x07\xB6a\x05>V[\x91P\x85`\x1F\x86\x01\x12a\x07\xC6W__\xFD[a\x07\xD0`@a\x05gV[\x80`@\x87\x01\x88\x81\x11\x15a\x07\xE1W__\xFD[\x87[\x81\x81\x10\x15a\x07\xFBW\x80Q\x84R` \x93\x84\x01\x93\x01a\x07\xE3V[P\x81\x85Ra\x08\t\x89\x82a\x07\x12V[` \x86\x01RPPP\x81\x81Ra\x08 `\x80\x86\x01a\x07jV[` \x82\x01R`\xA0\x94\x90\x94\x01Q\x93\x95\x93\x94PPPPV[`@\x81\x837`@\x82\x01`@\x82\x01_[`\x02\x81\x10\x15a\x08xW\x815a\x08Y\x81a\x05\x98V[g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x83R` \x92\x83\x01\x92\x91\x90\x91\x01\x90`\x01\x01a\x08EV[PPP`\x80\x81\x015a\x08\x89\x81a\x06wV[a\x08\x96`\x80\x84\x01\x82a\x04QV[PPPV[`\xC0\x81\x01a\x08\xA9\x82\x85a\x086V[\x82`\xA0\x83\x01R\x93\x92PPPV[`\x1F\x82\x11\x15a\x08\x96W\x80_R` _ `\x1F\x84\x01`\x05\x1C\x81\x01` \x85\x10\x15a\x08\xDBWP\x80[`\x1F\x84\x01`\x05\x1C\x82\x01\x91P[\x81\x81\x10\x15a\x08\xFAW_\x81U`\x01\x01a\x08\xE7V[PPPPPV[\x81Qg\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x11\x15a\t\x1BWa\t\x1Ba\x05*V[a\t/\x81a\t)\x84Ta\x06\xE0V[\x84a\x08\xB6V[` `\x1F\x82\x11`\x01\x81\x14a\taW_\x83\x15a\tJWP\x84\x82\x01Q[_\x19`\x03\x85\x90\x1B\x1C\x19\x16`\x01\x84\x90\x1B\x17\x84Ua\x08\xFAV[_\x84\x81R` \x81 `\x1F\x19\x85\x16\x91[\x82\x81\x10\x15a\t\x90W\x87\x85\x01Q\x82U` \x94\x85\x01\x94`\x01\x90\x92\x01\x91\x01a\tpV[P\x84\x82\x10\x15a\t\xADW\x86\x84\x01Q_\x19`\x03\x87\x90\x1B`\xF8\x16\x1C\x19\x16\x81U[PPPP`\x01\x90\x81\x1B\x01\x90UPV[\x83\x81R`\xE0\x81\x01a\t\xD0` \x83\x01\x85a\x086V[\x82`\xC0\x83\x01R\x94\x93PPPPV\xFE\xA2dipfsX\"\x12 =4W\xC9\x92(\x1E\x12\x91\xAC\xE2\x1A\x85\xEE\x13\x88\x07\xAC \x8BFa\x1B^\xFE\x9A\xA3\x18\xAB\r\x08\x9FdsolcC\0\x08\x1C\x003`\x80`@R4\x80\x15a\0\x0FW__\xFD[P`@Qa\x02\x998\x03\x80a\x02\x99\x839\x81\x01`@\x81\x90Ra\0.\x91a\0\xB8V[\x80Qa\0@\x90_\x90` \x84\x01\x90a\0GV[PPa\x01\x7FV[\x82\x80T\x82\x82U\x90_R` _ \x90\x81\x01\x92\x82\x15a\0\x80W\x91` \x02\x82\x01[\x82\x81\x11\x15a\0\x80W\x82Q\x82U\x91` \x01\x91\x90`\x01\x01\x90a\0eV[Pa\0\x8C\x92\x91Pa\0\x90V[P\x90V[[\x80\x82\x11\x15a\0\x8CW_\x81U`\x01\x01a\0\x91V[cNH{q`\xE0\x1B_R`A`\x04R`$_\xFD[_` \x82\x84\x03\x12\x15a\0\xC8W__\xFD[\x81Q`\x01`\x01`@\x1B\x03\x81\x11\x15a\0\xDDW__\xFD[\x82\x01`\x1F\x81\x01\x84\x13a\0\xEDW__\xFD[\x80Q`\x01`\x01`@\x1B\x03\x81\x11\x15a\x01\x06Wa\x01\x06a\0\xA4V[`@Q`\x05\x82\x90\x1B\x90`?\x82\x01`\x1F\x19\x16\x81\x01`\x01`\x01`@\x1B\x03\x81\x11\x82\x82\x10\x17\x15a\x014Wa\x014a\0\xA4V[`@R\x91\x82R` \x81\x84\x01\x81\x01\x92\x90\x81\x01\x87\x84\x11\x15a\x01QW__\xFD[` \x85\x01\x94P[\x83\x85\x10\x15a\x01tW\x84Q\x80\x82R` \x95\x86\x01\x95\x90\x93P\x01a\x01XV[P\x96\x95PPPPPPV[a\x01\r\x80a\x01\x8C_9_\xF3\xFE`\x80`@R4\x80\x15`\x0EW__\xFD[P`\x046\x10`&W_5`\xE0\x1C\x80c\xB0\xEC*\xE1\x14`*W[__\xFD[`0`DV[`@Q`;\x91\x90`\x97V[`@Q\x80\x91\x03\x90\xF3[``_\x80T\x80` \x02` \x01`@Q\x90\x81\x01`@R\x80\x92\x91\x90\x81\x81R` \x01\x82\x80T\x80\x15`\x8DW` \x02\x82\x01\x91\x90_R` _ \x90[\x81T\x81R` \x01\x90`\x01\x01\x90\x80\x83\x11`zW[PPPPP\x90P\x90V[` \x80\x82R\x82Q\x82\x82\x01\x81\x90R_\x91\x84\x01\x90`@\x84\x01\x90\x83[\x81\x81\x10\x15`\xCCW\x83Q\x83R` \x93\x84\x01\x93\x90\x92\x01\x91`\x01\x01`\xB0V[P\x90\x95\x94PPPPPV\xFE\xA2dipfsX\"\x12 X\xEEdP\x87\x0E]Ht\x1D\x10\xDB\x10$+\xC9Y\x99\xB7x<\x96\xE7&\xBA\xA4\xAF\xB1\x84\xF9jodsolcC\0\x08\x1C\x003",
    );
    /// The runtime bytecode of the contract, as deployed on the network.
    ///
    /// ```text
    ///0x608060405234801561000f575f5ffd5b50600436106102e1575f3560e01c80638765240f11610187578063cc8089bb116100dd578063eb657a4e11610093578063ee9a31a21161006e578063ee9a31a214610931578063fa28742014610958578063faf5625f1461097f575f5ffd5b8063eb657a4e146108d0578063ebe03a93146108f7578063ec4f74ce1461090a575f5ffd5b8063d49d5181116100c3578063d49d51811461085b578063dae7cb8b14610882578063e8180c29146108a9575f5ffd5b8063cc8089bb1461080d578063d384cb9514610834575f5ffd5b8063b5e00c3f1161013d578063c21c423311610118578063c21c423314610798578063c519d151146107bf578063c897f55e146107e6575f5ffd5b8063b5e00c3f14610723578063b70106971461074a578063be41b36714610771575f5ffd5b8063999f20db1161016d578063999f20db146106b05780639f9854e5146106c5578063b38d57f0146106ec575f5ffd5b80638765240f1461066257806391ddb28514610689575f5ffd5b8063304b90711161023c5780635d9e2444116101f2578063785ffb37116101cd578063785ffb37146105ed578063817cd3121461061457806385e1f4d01461063b575f5ffd5b80635d9e244414610566578063609fb5031461059f57806364f4992a146105c6575f5ffd5b80634692de5d116102225780634692de5d146104f15780634b2f51ef146105185780634ceccfe51461053f575f5ffd5b8063304b9071146104c25780633c2b7840146104ca575f5ffd5b806310a662e21161029c5780631ccc2cd1116102775780631ccc2cd11461046157806328fb228c146104885780632cfb7ca31461049b575f5ffd5b806310a662e2146103ec5780631b142ea7146104135780631c39b6721461043a575f5ffd5b80630787484b116102cc5780630787484b1461035e5780630a54257d146103855780631047fc52146103ac575f5ffd5b80623c78fb146102e5578062f9731e1461031f575b5f5ffd5b61030c7f000000000000000000000000000000000000000000000000000000000000000081565b6040519081526020015b60405180910390f35b6103467f000000000000000000000000000000000000000000000000000000000000000081565b6040516001600160a01b039091168152602001610316565b6103467f000000000000000000000000000000000000000000000000000000000000000081565b6103467f000000000000000000000000000000000000000000000000000000000000000081565b6103d37f000000000000000000000000000000000000000000000000000000000000000081565b60405167ffffffffffffffff9091168152602001610316565b6103467f000000000000000000000000000000000000000000000000000000000000000081565b6103467f000000000000000000000000000000000000000000000000000000000000000081565b6103467f000000000000000000000000000000000000000000000000000000000000000081565b61030c7f000000000000000000000000000000000000000000000000000000000000000081565b6103466104963660046129ae565b6109a6565b6103467f000000000000000000000000000000000000000000000000000000000000000081565b61030c600c81565b6103467f000000000000000000000000000000000000000000000000000000000000000081565b6103467f000000000000000000000000000000000000000000000000000000000000000081565b6103467f000000000000000000000000000000000000000000000000000000000000000081565b6103d37f000000000000000000000000000000000000000000000000000000000000000081565b61058d7f000000000000000000000000000000000000000000000000000000000000000081565b60405160ff9091168152602001610316565b61030c7f000000000000000000000000000000000000000000000000000000000000000081565b6103467f000000000000000000000000000000000000000000000000000000000000000081565b6103d37f000000000000000000000000000000000000000000000000000000000000000081565b6103467f000000000000000000000000000000000000000000000000000000000000000081565b61030c7f000000000000000000000000000000000000000000000000000000000000000081565b6103467f000000000000000000000000000000000000000000000000000000000000000081565b6103d37f000000000000000000000000000000000000000000000000000000000000000081565b6106c36106be3660046129d8565b610a12565b005b6103467f000000000000000000000000000000000000000000000000000000000000000081565b6107137f000000000000000000000000000000000000000000000000000000000000000081565b6040519015158152602001610316565b6103467f000000000000000000000000000000000000000000000000000000000000000081565b6103467f000000000000000000000000000000000000000000000000000000000000000081565b6103467f000000000000000000000000000000000000000000000000000000000000000081565b6103467f000000000000000000000000000000000000000000000000000000000000000081565b6103467f000000000000000000000000000000000000000000000000000000000000000081565b6103467f000000000000000000000000000000000000000000000000000000000000000081565b6103467f000000000000000000000000000000000000000000000000000000000000000081565b6103467f000000000000000000000000000000000000000000000000000000000000000081565b6103d37f000000000000000000000000000000000000000000000000000000000000000081565b6103467f000000000000000000000000000000000000000000000000000000000000000081565b6107137f000000000000000000000000000000000000000000000000000000000000000081565b6103d37f000000000000000000000000000000000000000000000000000000000000000081565b6106c3610905366004612acb565b610a9b565b6103d37f000000000000000000000000000000000000000000000000000000000000000081565b6103467f000000000000000000000000000000000000000000000000000000000000000081565b61030c7f000000000000000000000000000000000000000000000000000000000000000081565b61030c7f000000000000000000000000000000000000000000000000000000000000000081565b5f5f826040516020016109bb91815260200190565b604051602081830303815290604052805190602001209050610a0881604051806020016109e7906127f5565b6020820181038252601f19601f8201166040525080519060200120866113df565b9150505b92915050565b5f836001600160a01b03163b118015610a455750826001600160a01b0316610a3a83836109a6565b6001600160a01b0316145b610a965760405162461bcd60e51b815260206004820152600d60248201527f414444525f4d49534d415443480000000000000000000000000000000000000060448201526064015b60405180910390fd5b505050565b610aa3611467565b5f610aac611806565b90505f7f00000000000000000000000000000000000000000000000000000000000000007f0000000000000000000000000000000000000000000000000000000000000000604051610afd90612802565b6001600160a01b039283168152911660208201526060604082018190525f90820152608001604051809103905ff080158015610b3b573d5f5f3e3d5ffd5b5090505f6040518061012001604052807f00000000000000000000000000000000000000000000000000000000000000006001600160a01b031681526020017f00000000000000000000000000000000000000000000000000000000000000006001600160a01b031681526020017f00000000000000000000000000000000000000000000000000000000000000006001600160a01b031681526020017f00000000000000000000000000000000000000000000000000000000000000006001600160a01b031681526020017f00000000000000000000000000000000000000000000000000000000000000006001600160a01b03168152602001836001600160a01b031681526020017f00000000000000000000000000000000000000000000000000000000000000006001600160a01b031681526020017f00000000000000000000000000000000000000000000000000000000000000006001600160a01b031681526020017f00000000000000000000000000000000000000000000000000000000000000006001600160a01b031663bc45e0ae6040518163ffffffff1660e01b8152600401602060405180830381865afa158015610cff573d5f5f3e3d5ffd5b505050506040513d601f19601f82011682018060405250810190610d239190612b6a565b6001600160a01b031681525090505f8360c00151604051602001610d4991815260200190565b6040516020818303038152906040528051906020012090505f610d70308660c001516109a6565b9050610d7b81611eb3565b836001600160a01b0316631a72d54c827f00000000000000000000000000000000000000000000000000000000000000007f00000000000000000000000000000000000000000000000000000000000000008961018001518a6101a001518b6101c001518c602001517f00000000000000000000000000000000000000000000000000000000000000008e61024001518f61014001516040518b63ffffffff1660e01b8152600401610e369a99989796959493929190612bbf565b5f604051808303815f87803b158015610e4d575f5ffd5b505af1158015610e5f573d5f5f3e3d5ffd5b505050505f82604051610e71906127f5565b8190604051809103905ff5905080158015610e8e573d5f5f3e3d5ffd5b509050816001600160a01b0316816001600160a01b031614610ef25760405162461bcd60e51b815260206004820152601560248201527f554e455850435445445f524f4c4c55505f4144445200000000000000000000006044820152606401610a8d565b608086018051309091526040517fadfef6ac0000000000000000000000000000000000000000000000000000000081526001600160a01b0383169063adfef6ac90610f43908a908990600401612e21565b5f604051808303815f87803b158015610f5a575f5ffd5b505af1158015610f6c573d5f5f3e3d5ffd5b5050505087515f1461116c575f885167ffffffffffffffff811115610f9357610f93612a16565b604051908082528060200260200182016040528015610fbc578160200160208202803683370190505b5090505f5b89518110156110f5577f00000000000000000000000000000000000000000000000000000000000000006001600160a01b031663facd743b8b838151811061100b5761100b613011565b60200260200101516040518263ffffffff1660e01b815260040161103e91906001600160a01b0391909116815260200190565b602060405180830381865afa158015611059573d5f5f3e3d5ffd5b505050506040513d601f19601f8201168201806040525081019061107d9190613039565b6110c95760405162461bcd60e51b815260206004820152601860248201527f554e45585045435445445f4e45575f56414c494441544f5200000000000000006044820152606401610a8d565b60018282815181106110dd576110dd613011565b91151560209283029190910190910152600101610fc1565b506040517fa3ffb7720000000000000000000000000000000000000000000000000000000081526001600160a01b0384169063a3ffb7729061113d908c90859060040161308b565b5f604051808303815f87803b158015611154575f5ffd5b505af1158015611166573d5f5f3e3d5ffd5b50505050505b7f000000000000000000000000000000000000000000000000000000000000000015611222576040517fa2b4f1d80000000000000000000000000000000000000000000000000000000081527f0000000000000000000000000000000000000000000000000000000000000000151560048201526001600160a01b0383169063a2b4f1d8906024015f604051808303815f87803b15801561120b575f5ffd5b505af115801561121d573d5f5f3e3d5ffd5b505050505b7f00000000000000000000000000000000000000000000000000000000000000006001600160a01b03166355840a586040518163ffffffff1660e01b8152600401602060405180830381865afa92505050801561129c575060408051601f3d908101601f1916820190925261129991810190612b6a565b60015b15611322576001600160a01b03811615611320576040517f0d561b370000000000000000000000000000000000000000000000000000000081526001600160a01b038281166004830152841690630d561b37906024015f604051808303815f87803b158015611309575f5ffd5b505af115801561131b573d5f5f3e3d5ffd5b505050505b505b6040517f13af40350000000000000000000000000000000000000000000000000000000081526001600160a01b0382811660048301528316906313af4035906024015f604051808303815f87803b15801561137b575f5ffd5b505af115801561138d573d5f5f3e3d5ffd5b5050604080516001600160a01b0380881682528a1660208201527f7e5cc5c3fce046d868d5918548df8d3e8ef9f09e6fb30a68081f1f1348cd0314935001905060405180910390a15050505050505050565b604080517fff00000000000000000000000000000000000000000000000000000000000000602080830191909152606084901b7fffffffffffffffffffffffffffffffffffffffff00000000000000000000000016602183015260358201869052605580830186905283518084039091018152607590920190925280519101205b9392505050565b7f00000000000000000000000000000000000000000000000000000000000000006001600160a01b0316638456cb596040518163ffffffff1660e01b81526004015f604051808303815f87803b1580156114bf575f5ffd5b505af11580156114d1573d5f5f3e3d5ffd5b505050505f7f00000000000000000000000000000000000000000000000000000000000000006001600160a01b031663dff697876040518163ffffffff1660e01b8152600401602060405180830381865afa158015611532573d5f5f3e3d5ffd5b505050506040513d601f19601f8201168201806040525081019061155691906130fc565b905060328167ffffffffffffffff16111561156f575060325b5f5b8167ffffffffffffffff168167ffffffffffffffff161015611802576040517f6ddd374400000000000000000000000000000000000000000000000000000000815267ffffffffffffffff821660048201525f907f00000000000000000000000000000000000000000000000000000000000000006001600160a01b031690636ddd374490602401602060405180830381865afa158015611614573d5f5f3e3d5ffd5b505050506040513d601f19601f820116820180604052508101906116389190612b6a565b6040517fa23c44b10000000000000000000000000000000000000000000000000000000081526001600160a01b0380831660048301529192505f917f0000000000000000000000000000000000000000000000000000000000000000169063a23c44b19060240160a060405180830381865afa1580156116ba573d5f5f3e3d5ffd5b505050506040513d601f19601f820116820180604052508101906116de9190613115565b9050806080015180156116fd5750606081015167ffffffffffffffff16155b156117ed576040805160018082528183019092525f916020808301908036833701905050905082815f8151811061173657611736613011565b6001600160a01b0392831660209182029290920101526040517f7c75c2980000000000000000000000000000000000000000000000000000000081527f000000000000000000000000000000000000000000000000000000000000000090911690637c75c298906117ab90849060040161319c565b5f604051808303815f87803b1580156117c2575f5ffd5b505af11580156117d4573d5f5f3e3d5ffd5b505050506001856117e591906131c2565b9450506117fb565b826117f7816131e2565b9350505b5050611571565b5050565b61180e61280f565b5f7f00000000000000000000000000000000000000000000000000000000000000006001600160a01b03166392c8134c7f00000000000000000000000000000000000000000000000000000000000000006001600160a01b03166365f7f80d6040518163ffffffff1660e01b8152600401602060405180830381865afa15801561189a573d5f5f3e3d5ffd5b505050506040513d601f19601f820116820180604052508101906118be91906130fc565b6040517fffffffff0000000000000000000000000000000000000000000000000000000060e084901b16815267ffffffffffffffff909116600482015260240161018060405180830381865afa15801561191a573d5f5f3e3d5ffd5b505050506040513d601f19601f8201168201806040525081019061193e919061320e565b516040517f8eaa6ac0000000000000000000000000000000000000000000000000000000008152600481018290529091505f9081907f00000000000000000000000000000000000000000000000000000000000000006001600160a01b031690638eaa6ac09060240160c060405180830381865afa1580156119c2573d5f5f3e3d5ffd5b505050506040513d601f19601f820116820180604052508101906119e69190613347565b915091506119f261291a565b82518152602080840151908201906002811115611a1157611a11612cdc565b90816002811115611a2457611a24612cdc565b905250836001600160a01b037f0000000000000000000000000000000000000000000000000000000000000000166331644130611a6084612331565b856040518363ffffffff1660e01b8152600401611a7e929190613403565b602060405180830381865afa158015611a99573d5f5f3e3d5ffd5b505050506040513d601f19601f82011682018060405250810190611abd9190613435565b14611b0a5760405162461bcd60e51b815260206004820152601d60248201527f496e76616c6964206c617465737420657865637574696f6e20686173680000006044820152606401610a8d565b611b3160405180608001604052805f81526020015f81526020015f81526020015f81525090565b604080516060810182525f8082526020820181905291810191909152604051806102a001604052807f000000000000000000000000000000000000000000000000000000000000000067ffffffffffffffff1681526020017f00000000000000000000000000000000000000000000000000000000000000006001600160a01b031681526020017f000000000000000000000000000000000000000000000000000000000000000081526020017f00000000000000000000000000000000000000000000000000000000000000006001600160a01b0316638ee1a1266040518163ffffffff1660e01b8152600401602060405180830381865afa158015611c3a573d5f5f3e3d5ffd5b505050506040513d601f19601f82011682018060405250810190611c5e9190613435565b8152602001306001600160a01b031681526020017f00000000000000000000000000000000000000000000000000000000000000006001600160a01b031681526020017f0000000000000000000000000000000000000000000000000000000000000000815260200160405180602001604052805f81525081526020017f000000000000000000000000000000000000000000000000000000000000000081526020017f000000000000000000000000000000000000000000000000000000000000000067ffffffffffffffff1681526020017f00000000000000000000000000000000000000000000000000000000000000006001600160a01b031663b0ec2ae16040518163ffffffff1660e01b81526004015f60405180830381865afa158015611d8c573d5f5f3e3d5ffd5b505050506040513d5f823e601f3d908101601f19168201604052611db3919081019061344c565b81526020018381526020017f000000000000000000000000000000000000000000000000000000000000000081526020017f000000000000000000000000000000000000000000000000000000000000000081526020017f000000000000000000000000000000000000000000000000000000000000000081526020018481526020018581526020015f6001600160a01b031681526020017f000000000000000000000000000000000000000000000000000000000000000060ff1681526020017f000000000000000000000000000000000000000000000000000000000000000067ffffffffffffffff16815260200182815250965050505050505090565b60405163266a23b160e21b81526001600160a01b037f000000000000000000000000000000000000000000000000000000000000000081811660048401527f000000000000000000000000000000000000000000000000000000000000000082166024840152917f0000000000000000000000000000000000000000000000000000000000000000909116906399a88ec4906044015f604051808303815f87803b158015611f5f575f5ffd5b505af1158015611f71573d5f5f3e3d5ffd5b50506040517f919cc7060000000000000000000000000000000000000000000000000000000081526001600160a01b0385811660048301527f000000000000000000000000000000000000000000000000000000000000000016925063919cc70691506024015f604051808303815f87803b158015611fee575f5ffd5b505af1158015612000573d5f5f3e3d5ffd5b5050505061200c61236b565b60405163266a23b160e21b81526001600160a01b037f000000000000000000000000000000000000000000000000000000000000000081811660048401527f000000000000000000000000000000000000000000000000000000000000000082166024840152917f0000000000000000000000000000000000000000000000000000000000000000909116906399a88ec4906044015f604051808303815f87803b1580156120b8575f5ffd5b505af11580156120ca573d5f5f3e3d5ffd5b505060405163266a23b160e21b81526001600160a01b037f000000000000000000000000000000000000000000000000000000000000000081811660048401527f00000000000000000000000000000000000000000000000000000000000000008216602484015293507f00000000000000000000000000000000000000000000000000000000000000001691506399a88ec4906044015f604051808303815f87803b158015612178575f5ffd5b505af115801561218a573d5f5f3e3d5ffd5b505050507f00000000000000000000000000000000000000000000000000000000000000006001600160a01b0316636ae71f126040518163ffffffff1660e01b81526004015f604051808303815f87803b1580156121e6575f5ffd5b505af11580156121f8573d5f5f3e3d5ffd5b505060405163266a23b160e21b81526001600160a01b037f000000000000000000000000000000000000000000000000000000000000000081811660048401527f00000000000000000000000000000000000000000000000000000000000000008216602484015293507f00000000000000000000000000000000000000000000000000000000000000001691506399a88ec4906044015f604051808303815f87803b1580156122a6575f5ffd5b505af11580156122b8573d5f5f3e3d5ffd5b505050507f00000000000000000000000000000000000000000000000000000000000000006001600160a01b0316636ae71f126040518163ffffffff1660e01b81526004015f604051808303815f87803b158015612314575f5ffd5b505af1158015612326573d5f5f3e3d5ffd5b505050505050505050565b61233961293f565b6040518060400160405280835f015181526020018360200151600281111561236357612363612cdc565b905292915050565b7f00000000000000000000000000000000000000000000000000000000000000007f00000000000000000000000000000000000000000000000000000000000000001561256f577f00000000000000000000000000000000000000000000000000000000000000006001600160a01b0316639623609d827f000000000000000000000000000000000000000000000000000000000000000060405180606001604052807f000000000000000000000000000000000000000000000000000000000000000067ffffffffffffffff1681526020017f000000000000000000000000000000000000000000000000000000000000000067ffffffffffffffff1681526020017f000000000000000000000000000000000000000000000000000000000000000067ffffffffffffffff168152506040516024016124ac91906134d3565b60408051601f198184030181529181526020820180517bffffffffffffffffffffffffffffffffffffffffffffffffffffffff167fa655d93700000000000000000000000000000000000000000000000000000000179052517fffffffff0000000000000000000000000000000000000000000000000000000060e086901b16815261253d93929190600401613516565b5f604051808303815f87803b158015612554575f5ffd5b505af1158015612566573d5f5f3e3d5ffd5b5050505061260e565b60405163266a23b160e21b81526001600160a01b0382811660048301527f0000000000000000000000000000000000000000000000000000000000000000811660248301527f000000000000000000000000000000000000000000000000000000000000000016906399a88ec4906044015f604051808303815f87803b1580156125f7575f5ffd5b505af1158015612609573d5f5f3e3d5ffd5b505050505b5f5f5f5f7f00000000000000000000000000000000000000000000000000000000000000006001600160a01b031663ebea461d6040518163ffffffff1660e01b8152600401608060405180830381865afa15801561266e573d5f5f3e3d5ffd5b505050506040513d601f19601f82011682018060405250810190612692919061354f565b93509350935093505f600c836126a89190613596565b156126c8576126b8600c846135a9565b6126c39060016135bc565b6126d3565b6126d3600c846135a9565b90508481116126e257846126e4565b805b94507f00000000000000000000000000000000000000000000000000000000000000006001600160a01b031663b31761f86040518060800160405280888152602001878152602001868152602001858152506040518263ffffffff1660e01b815260040161275291906135cf565b5f604051808303815f87803b158015612769575f5ffd5b505af115801561277b573d5f5f3e3d5ffd5b505050507f00000000000000000000000000000000000000000000000000000000000000006001600160a01b0316636ae71f126040518163ffffffff1660e01b81526004015f604051808303815f87803b1580156127d7575f5ffd5b505af11580156127e9573d5f5f3e3d5ffd5b50505050505050505050565b6113eb806135fb83390190565b610d91806149e683390190565b604051806102a001604052805f67ffffffffffffffff1681526020015f6001600160a01b031681526020015f81526020015f81526020015f6001600160a01b031681526020015f6001600160a01b031681526020015f8152602001606081526020015f81526020015f67ffffffffffffffff168152602001606081526020016128b560405180608001604052805f81526020015f81526020015f81526020015f81525090565b81526020015f81526020015f81526020015f81526020016128d461291a565b81525f602080830182905260408084018390526060808501849052608085018490528151908101825283815291820183905281019190915260a09091015290565b905290565b604051806060016040528061292d61295d565b81526020015f81526020015f81525090565b604051806040016040528061295261295d565b81526020015f905290565b6040518060400160405280612970612979565b81526020016129155b60405180604001604052806002906020820280368337509192915050565b6001600160a01b03811681146129ab575f5ffd5b50565b5f5f604083850312156129bf575f5ffd5b82356129ca81612997565b946020939093013593505050565b5f5f5f606084860312156129ea575f5ffd5b83356129f581612997565b92506020840135612a0581612997565b929592945050506040919091013590565b634e487b7160e01b5f52604160045260245ffd5b604051610180810167ffffffffffffffff81118282101715612a4e57612a4e612a16565b60405290565b6040805190810167ffffffffffffffff81118282101715612a4e57612a4e612a16565b604051601f8201601f1916810167ffffffffffffffff81118282101715612aa057612aa0612a16565b604052919050565b5f67ffffffffffffffff821115612ac157612ac1612a16565b5060051b60200190565b5f60208284031215612adb575f5ffd5b813567ffffffffffffffff811115612af1575f5ffd5b8201601f81018413612b01575f5ffd5b8035612b14612b0f82612aa8565b612a77565b8082825260208201915060208360051b850101925086831115612b35575f5ffd5b6020840193505b82841015612b60578335612b4f81612997565b825260209384019390910190612b3c565b9695505050505050565b5f60208284031215612b7a575f5ffd5b815161146081612997565b5f8151808452602084019350602083015f5b82811015612bb5578151865260209586019590910190600101612b97565b5093949350505050565b6001600160a01b038b16815267ffffffffffffffff8a1660208201526001600160a01b03891660408201528760608201528660808201528560a08201526001600160a01b03851660c08201526001600160a01b03841660e082015260ff83166101008201526101406101208201525f612c3c610140830184612b85565b9c9b505050505050505050505050565b5f81518084528060208401602086015e5f602082860101526020601f19601f83011685010191505092915050565b8051825f5b6002811015612c9e578251825260209283019290910190600101612c7f565b5050506020810151604083015f5b6002811015612cd557825167ffffffffffffffff16825260209283019290910190600101612cac565b5050505050565b634e487b7160e01b5f52602160045260245ffd5b60038110612d0c57634e487b7160e01b5f52602160045260245ffd5b9052565b612d1b828251612c7a565b6020810151612d2d6080840182612cf0565b506040015160a09190910152565b6001600160a01b0381511682526020810151612d6260208401826001600160a01b03169052565b506040810151612d7d60408401826001600160a01b03169052565b506060810151612d9860608401826001600160a01b03169052565b506080810151612db360808401826001600160a01b03169052565b5060a0810151612dce60a08401826001600160a01b03169052565b5060c0810151612de960c08401826001600160a01b03169052565b5060e0810151612e0460e08401826001600160a01b03169052565b50610100810151610a966101008401826001600160a01b03169052565b6101408152612e3e6101408201845167ffffffffffffffff169052565b5f6020840151612e5a6101608401826001600160a01b03169052565b50604084015161018083015260608401516101a083015260808401516001600160a01b039081166101c084015260a0850151166101e083015260c084015161020083015260e08401516103e0610220840152612eba610520840182612c4c565b9050610100850151610240840152610120850151612ee561026085018267ffffffffffffffff169052565b506101408501517ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffec084830301610280850152612f218282612b85565b61016087015180516102a087015260208101516102c087015260408101516102e0870152606001516103008601526101808701516103208601526101a08701516103408601526101c08701516103608601526101e08701519092509050612f8c610380850182612d10565b506102008501516104408401526102208501516001600160a01b031661046084015261024085015160ff1661048084015261026085015167ffffffffffffffff9081166104a0850152610280860151805182166104c086015260208082015183166104e087015260409091015190911661050085015290915061146090830184612d3b565b634e487b7160e01b5f52603260045260245ffd5b80518015158114613034575f5ffd5b919050565b5f60208284031215613049575f5ffd5b61146082613025565b5f8151808452602084019350602083015f5b82811015612bb55781516001600160a01b0316865260209586019590910190600101613064565b604081525f61309d6040830185613052565b82810360208401528084518083526020830191506020860192505f5b818110156130d957835115158352602093840193909201916001016130b9565b50909695505050505050565b805167ffffffffffffffff81168114613034575f5ffd5b5f6020828403121561310c575f5ffd5b611460826130e5565b5f60a0828403128015613126575f5ffd5b5060405160a0810167ffffffffffffffff8111828210171561314a5761314a612a16565b6040528251815261315d602084016130e5565b602082015261316e604084016130e5565b604082015261317f606084016130e5565b606082015261319060808401613025565b60808201529392505050565b602081525f6114606020830184613052565b634e487b7160e01b5f52601160045260245ffd5b67ffffffffffffffff8281168282160390811115610a0c57610a0c6131ae565b5f67ffffffffffffffff821667ffffffffffffffff8103613205576132056131ae565b60010192915050565b5f610180828403128015613220575f5ffd5b50613229612a2a565b82518152602080840151908201526040808401519082015261324d606084016130e5565b606082015261325e608084016130e5565b608082015261326f60a084016130e5565b60a082015261328060c084016130e5565b60c082015261329160e084016130e5565b60e08201526132a361010084016130e5565b6101008201526132b661012084016130e5565b6101208201526132c961014084016130e5565b610140820152610160928301519281019290925250919050565b5f82601f8301126132f2575f5ffd5b6132fc6040612a77565b80604084018581111561330d575f5ffd5b845b8181101561332e57613320816130e5565b84526020938401930161330f565b509095945050505050565b805160038110613034575f5ffd5b5f5f82840360c0811215613359575f5ffd5b60a0811215613366575f5ffd5b61336e612a54565b608082121561337b575f5ffd5b613383612a54565b915085601f860112613393575f5ffd5b61339d6040612a77565b8060408701888111156133ae575f5ffd5b875b818110156133c85780518452602093840193016133b0565b508185526133d689826132e3565b60208601525050508181526133ed60808601613339565b602082015260a094909401519395939450505050565b5f60c082019050613415828551612c7a565b60208401516134276080840182612cf0565b508260a08301529392505050565b5f60208284031215613445575f5ffd5b5051919050565b5f6020828403121561345c575f5ffd5b815167ffffffffffffffff811115613472575f5ffd5b8201601f81018413613482575f5ffd5b8051613490612b0f82612aa8565b8082825260208201915060208360051b8501019250868311156134b1575f5ffd5b6020840193505b82841015612b605783518252602093840193909101906134b8565b60608101610a0c828467ffffffffffffffff815116825267ffffffffffffffff602082015116602083015267ffffffffffffffff60408201511660408301525050565b6001600160a01b03841681526001600160a01b0383166020820152606060408201525f6135466060830184612c4c565b95945050505050565b5f5f5f5f60808587031215613562575f5ffd5b505082516020840151604085015160609095015191969095509092509050565b634e487b7160e01b5f52601260045260245ffd5b5f826135a4576135a4613582565b500690565b5f826135b7576135b7613582565b500490565b80820180821115610a0c57610a0c6131ae565b8151815260208083015190820152604080830151908201526060808301519082015260808101610a0c56fe6080604052348015600e575f5ffd5b506113cf8061001c5f395ff3fe608060405260043610610021575f3560e01c8063adfef6ac1461003857610030565b366100305761002e610057565b005b61002e610057565b348015610043575f5ffd5b5061002e610052366004610d67565b610069565b6100676100626101b8565b61029a565b565b5f6100726102bd565b6001600160a01b031614801561009757505f61008c6102ef565b6001600160a01b0316145b80156100b257505f6100a7610316565b6001600160a01b0316145b156101b0576101ac8160c0015183836040516024016100d2929190611127565b60408051601f19818403018152918152602080830180517bffffffffffffffffffffffffffffffffffffffffffffffffffffffff167f0ee5ef0c0000000000000000000000000000000000000000000000000000000017905260e08601519087015191516001600160a01b0390921660248301529060440160408051601f198184030181529190526020810180517bffffffffffffffffffffffffffffffffffffffffffffffffffffffff167fc4d66de800000000000000000000000000000000000000000000000000000000179052608087015161033d565b5050565b6101ac610057565b5f600436101561020f5760405162461bcd60e51b815260206004820152600b60248201527f4e4f5f46554e435f53494700000000000000000000000000000000000000000060448201526064015b60405180910390fd5b5f336102196102bd565b6001600160a01b0316036102345761022f6102ef565b61023c565b61023c610316565b90506001600160a01b0381163b6102955760405162461bcd60e51b815260206004820152601360248201527f5441524745545f4e4f545f434f4e5452414354000000000000000000000000006044820152606401610206565b919050565b365f5f375f5f365f845af43d5f5f3e8080156102b4573d5ff35b3d5ffd5b505050565b5f7fb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d61035b546001600160a01b0316919050565b5f7f360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc6102e0565b5f7f2b1dbce74324248c222f0ec2d5ed7bd323cfc425b336f0253c5ccfda7265546d6102e0565b61036860017fb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6104611317565b7fb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d61031461039657610396611336565b6103c160017f360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbd611317565b7f360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc146103ef576103ef611336565b61041a60017f2b1dbce74324248c222f0ec2d5ed7bd323cfc425b336f0253c5ccfda7265546e611317565b7f2b1dbce74324248c222f0ec2d5ed7bd323cfc425b336f0253c5ccfda7265546d1461044857610448611336565b6104518161046e565b61045c85855f6104c5565b61046783835f6104ef565b5050505050565b7f7e644d79422f17c01e4894b5f4f588d331ebfa28653d42ae832dc59e38c9798f6104976102bd565b604080516001600160a01b03928316815291841660208301520160405180910390a16104c2816104f8565b50565b6104ce836105d0565b5f825111806104da5750805b156102b8576104e9838361060f565b50505050565b6104ce8361063d565b6001600160a01b0381166105745760405162461bcd60e51b815260206004820152602660248201527f455243313936373a206e65772061646d696e20697320746865207a65726f206160448201527f64647265737300000000000000000000000000000000000000000000000000006064820152608401610206565b807fb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d61035b80547fffffffffffffffffffffffff0000000000000000000000000000000000000000166001600160a01b039290921691909117905550565b6105d98161067c565b6040516001600160a01b038216907fbc7cd75a20ee27fd9adebab32041f755214dbc6bffa90cc0225b39da2e5c2d3b905f90a250565b6060610634838360405180606001604052806027815260200161137360279139610720565b90505b92915050565b61064681610812565b6040516001600160a01b038216907ff7eed2a7fabbf1bec8d55ed5e785cc76622376dde5df4ff15470551e030b8134905f90a250565b6001600160a01b0381163b6106f95760405162461bcd60e51b815260206004820152602d60248201527f455243313936373a206e657720696d706c656d656e746174696f6e206973206e60448201527f6f74206120636f6e7472616374000000000000000000000000000000000000006064820152608401610206565b807f360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc610597565b60606001600160a01b0384163b61079f5760405162461bcd60e51b815260206004820152602660248201527f416464726573733a2064656c65676174652063616c6c20746f206e6f6e2d636f60448201527f6e747261637400000000000000000000000000000000000000000000000000006064820152608401610206565b5f5f856001600160a01b0316856040516107b9919061134a565b5f60405180830381855af49150503d805f81146107f1576040519150601f19603f3d011682016040523d82523d5f602084013e6107f6565b606091505b50915091506108068282866108b6565b925050505b9392505050565b6001600160a01b0381163b61088f5760405162461bcd60e51b815260206004820152603760248201527f455243313936373a206e6577207365636f6e6461727920696d706c656d656e7460448201527f6174696f6e206973206e6f74206120636f6e74726163740000000000000000006064820152608401610206565b807f2b1dbce74324248c222f0ec2d5ed7bd323cfc425b336f0253c5ccfda7265546d610597565b606083156108c557508161080b565b8251156108d55782518084602001fd5b8160405162461bcd60e51b81526004016102069190611360565b634e487b7160e01b5f52604160045260245ffd5b6040516060810167ffffffffffffffff81118282101715610926576109266108ef565b60405290565b6040805190810167ffffffffffffffff81118282101715610926576109266108ef565b604051610120810167ffffffffffffffff81118282101715610926576109266108ef565b6040516102a0810167ffffffffffffffff81118282101715610926576109266108ef565b604051601f8201601f1916810167ffffffffffffffff811182821017156109c0576109c06108ef565b604052919050565b803567ffffffffffffffff81168114610295575f5ffd5b80356001600160a01b0381168114610295575f5ffd5b5f82601f830112610a04575f5ffd5b813567ffffffffffffffff811115610a1e57610a1e6108ef565b610a316020601f19601f84011601610997565b818152846020838601011115610a45575f5ffd5b816020850160208301375f918101602001919091529392505050565b5f82601f830112610a70575f5ffd5b813567ffffffffffffffff811115610a8a57610a8a6108ef565b8060051b610a9a60208201610997565b91825260208185018101929081019086841115610ab5575f5ffd5b6020860192505b83831015610ad7578235825260209283019290910190610abc565b9695505050505050565b5f60808284031215610af1575f5ffd5b6040516080810167ffffffffffffffff81118282101715610b1457610b146108ef565b6040908152833582526020808501359083015283810135908201526060928301359281019290925250919050565b5f82601f830112610b51575f5ffd5b610b5b6040610997565b806040840185811115610b6c575f5ffd5b845b81811015610b8d57610b7f816109c8565b845260209384019301610b6e565b509095945050505050565b803560038110610295575f5ffd5b5f81830360c0811215610bb7575f5ffd5b610bbf610903565b91506080811215610bce575f5ffd5b50610bd761092c565b83601f840112610be5575f5ffd5b610bef6040610997565b806040850186811115610c00575f5ffd5b855b81811015610c1a578035845260209384019301610c02565b50818452610c288782610b42565b60208501525050508152610c3e60808301610b98565b602082015260a091909101356040820152919050565b803560ff81168114610295575f5ffd5b5f60608284031215610c74575f5ffd5b610c7c610903565b9050610c87826109c8565b8152610c95602083016109c8565b6020820152610ca6604083016109c8565b604082015292915050565b5f6101208284031215610cc2575f5ffd5b610cca61094f565b9050610cd5826109df565b8152610ce3602083016109df565b6020820152610cf4604083016109df565b6040820152610d05606083016109df565b6060820152610d16608083016109df565b6080820152610d2760a083016109df565b60a0820152610d3860c083016109df565b60c0820152610d4960e083016109df565b60e0820152610d5b61010083016109df565b61010082015292915050565b5f5f6101408385031215610d79575f5ffd5b823567ffffffffffffffff811115610d8f575f5ffd5b83016103e08186031215610da1575f5ffd5b610da9610973565b610db2826109c8565b8152610dc0602083016109df565b60208201526040828101359082015260608083013590820152610de5608083016109df565b6080820152610df660a083016109df565b60a082015260c0828101359082015260e082013567ffffffffffffffff811115610e1e575f5ffd5b610e2a878285016109f5565b60e0830152506101008281013590820152610e4861012083016109c8565b61012082015261014082013567ffffffffffffffff811115610e68575f5ffd5b610e7487828501610a61565b61014083015250610e89866101608401610ae1565b6101608201526101e08201356101808201526102008201356101a08201526102208201356101c0820152610ec1866102408401610ba6565b6101e0820152610300820135610200820152610ee061032083016109df565b610220820152610ef36103408301610c54565b610240820152610f0661036083016109c8565b610260820152610f1a866103808401610c64565b6102808201529250610f3190508460208501610cb1565b90509250929050565b5f81518084528060208401602086015e5f602082860101526020601f19601f83011685010191505092915050565b5f8151808452602084019350602083015f5b82811015610f98578151865260209586019590910190600101610f7a565b5093949350505050565b60038110610fbe57634e487b7160e01b5f52602160045260245ffd5b9052565b80518051835f5b6002811015610fe8578251825260209283019290910190600101610fc9565b50505060200151604083015f5b600281101561101e57825167ffffffffffffffff16825260209283019290910190600101610ff5565b50505060208101516110336080840182610fa2565b506040015160a09190910152565b6001600160a01b038151168252602081015161106860208401826001600160a01b03169052565b50604081015161108360408401826001600160a01b03169052565b50606081015161109e60608401826001600160a01b03169052565b5060808101516110b960808401826001600160a01b03169052565b5060a08101516110d460a08401826001600160a01b03169052565b5060c08101516110ef60c08401826001600160a01b03169052565b5060e081015161110a60e08401826001600160a01b03169052565b506101008101516102b86101008401826001600160a01b03169052565b61014081526111446101408201845167ffffffffffffffff169052565b5f60208401516111606101608401826001600160a01b03169052565b50604084015161018083015260608401516101a083015260808401516001600160a01b039081166101c084015260a0850151166101e083015260c084015161020083015260e08401516103e06102208401526111c0610520840182610f3a565b90506101008501516102408401526101208501516111eb61026085018267ffffffffffffffff169052565b506101408501517ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffec0848303016102808501526112278282610f68565b61016087015180516102a087015260208101516102c087015260408101516102e0870152606001516103008601526101808701516103208601526101a08701516103408601526101c08701516103608601526101e08701519092509050611292610380850182610fc2565b506102008501516104408401526102208501516001600160a01b031661046084015261024085015160ff1661048084015261026085015167ffffffffffffffff9081166104a0850152610280860151805182166104c086015260208082015183166104e087015260409091015190911661050085015290915061080b90830184611041565b8181038181111561063757634e487b7160e01b5f52601160045260245ffd5b634e487b7160e01b5f52600160045260245ffd5b5f82518060208501845e5f920191825250919050565b602081525f6106346020830184610f3a56fe416464726573733a206c6f772d6c6576656c2064656c65676174652063616c6c206661696c6564a26469706673582212209bf2c0238c2505716be0e1d04df7889d4edb5024e1ba28c8c320a9287abfd25c64736f6c634300081c00336080604052604051610d91380380610d91833981016040819052610022916103b7565b828161002f82825f610043565b5061003b90508261006e565b5050506104d3565b61004c836100db565b5f825111806100585750805b1561006957610067838361011a565b505b505050565b7f7e644d79422f17c01e4894b5f4f588d331ebfa28653d42ae832dc59e38c9798f6100ad5f516020610d4a5f395f51905f52546001600160a01b031690565b604080516001600160a01b03928316815291841660208301520160405180910390a16100d881610146565b50565b6100e4816101e1565b6040516001600160a01b038216907fbc7cd75a20ee27fd9adebab32041f755214dbc6bffa90cc0225b39da2e5c2d3b905f90a250565b606061013f8383604051806060016040528060278152602001610d6a60279139610275565b9392505050565b6001600160a01b0381166101b05760405162461bcd60e51b815260206004820152602660248201527f455243313936373a206e65772061646d696e20697320746865207a65726f206160448201526564647265737360d01b60648201526084015b60405180910390fd5b805f516020610d4a5f395f51905f525b80546001600160a01b0319166001600160a01b039290921691909117905550565b6001600160a01b0381163b61024e5760405162461bcd60e51b815260206004820152602d60248201527f455243313936373a206e657720696d706c656d656e746174696f6e206973206e60448201526c1bdd08184818dbdb9d1c9858dd609a1b60648201526084016101a7565b807f360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc6101c0565b60606001600160a01b0384163b6102dd5760405162461bcd60e51b815260206004820152602660248201527f416464726573733a2064656c65676174652063616c6c20746f206e6f6e2d636f6044820152651b9d1c9858dd60d21b60648201526084016101a7565b5f5f856001600160a01b0316856040516102f79190610488565b5f60405180830381855af49150503d805f811461032f576040519150601f19603f3d011682016040523d82523d5f602084013e610334565b606091505b50909250905061034582828661034f565b9695505050505050565b6060831561035e57508161013f565b82511561036e5782518084602001fd5b8160405162461bcd60e51b81526004016101a7919061049e565b80516001600160a01b038116811461039e575f5ffd5b919050565b634e487b7160e01b5f52604160045260245ffd5b5f5f5f606084860312156103c9575f5ffd5b6103d284610388565b92506103e060208501610388565b60408501519092506001600160401b038111156103fb575f5ffd5b8401601f8101861361040b575f5ffd5b80516001600160401b03811115610424576104246103a3565b604051601f8201601f19908116603f011681016001600160401b0381118282101715610452576104526103a3565b604052818152828201602001881015610469575f5ffd5b8160208401602083015e5f602083830101528093505050509250925092565b5f82518060208501845e5f920191825250919050565b602081525f82518060208401528060208501604085015e5f604082850101526040601f19601f83011684010191505092915050565b61086a806104e05f395ff3fe60806040526004361061005d575f3560e01c80635c60da1b116100425780635c60da1b146100a65780638f283970146100d6578063f851a440146100f55761006c565b80633659cfe6146100745780634f1ef286146100935761006c565b3661006c5761006a610109565b005b61006a610109565b34801561007f575f5ffd5b5061006a61008e36600461070d565b610123565b61006a6100a1366004610726565b61015e565b3480156100b1575f5ffd5b506100ba6101c4565b6040516001600160a01b03909116815260200160405180910390f35b3480156100e1575f5ffd5b5061006a6100f036600461070d565b6101f4565b348015610100575f5ffd5b506100ba610214565b610111610234565b61012161011c6102e4565b6102ed565b565b61012b61030b565b6001600160a01b03163303610156576101538160405180602001604052805f8152505f61033d565b50565b610153610109565b61016661030b565b6001600160a01b031633036101bc576101b78383838080601f0160208091040260200160405190810160405280939291908181526020018383808284375f920191909152506001925061033d915050565b505050565b6101b7610109565b5f6101cd61030b565b6001600160a01b031633036101e9576101e46102e4565b905090565b6101f1610109565b90565b6101fc61030b565b6001600160a01b031633036101565761015381610367565b5f61021d61030b565b6001600160a01b031633036101e9576101e461030b565b61023c61030b565b6001600160a01b031633036101215760405162461bcd60e51b815260206004820152604260248201527f5472616e73706172656e745570677261646561626c6550726f78793a2061646d60448201527f696e2063616e6e6f742066616c6c6261636b20746f2070726f7879207461726760648201527f6574000000000000000000000000000000000000000000000000000000000000608482015260a4015b60405180910390fd5b5f6101e46103bb565b365f5f375f5f365f845af43d5f5f3e808015610307573d5ff35b3d5ffd5b5f7fb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d61035b546001600160a01b0316919050565b610346836103e2565b5f825111806103525750805b156101b7576103618383610421565b50505050565b7f7e644d79422f17c01e4894b5f4f588d331ebfa28653d42ae832dc59e38c9798f61039061030b565b604080516001600160a01b03928316815291841660208301520160405180910390a16101538161044d565b5f7f360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc61032e565b6103eb81610525565b6040516001600160a01b038216907fbc7cd75a20ee27fd9adebab32041f755214dbc6bffa90cc0225b39da2e5c2d3b905f90a250565b6060610446838360405180606001604052806027815260200161080e602791396105c9565b9392505050565b6001600160a01b0381166104c95760405162461bcd60e51b815260206004820152602660248201527f455243313936373a206e65772061646d696e20697320746865207a65726f206160448201527f646472657373000000000000000000000000000000000000000000000000000060648201526084016102db565b807fb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d61035b80547fffffffffffffffffffffffff0000000000000000000000000000000000000000166001600160a01b039290921691909117905550565b6001600160a01b0381163b6105a25760405162461bcd60e51b815260206004820152602d60248201527f455243313936373a206e657720696d706c656d656e746174696f6e206973206e60448201527f6f74206120636f6e74726163740000000000000000000000000000000000000060648201526084016102db565b807f360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc6104ec565b60606001600160a01b0384163b6106485760405162461bcd60e51b815260206004820152602660248201527f416464726573733a2064656c65676174652063616c6c20746f206e6f6e2d636f60448201527f6e7472616374000000000000000000000000000000000000000000000000000060648201526084016102db565b5f5f856001600160a01b03168560405161066291906107a4565b5f60405180830381855af49150503d805f811461069a576040519150601f19603f3d011682016040523d82523d5f602084013e61069f565b606091505b50915091506106af8282866106b9565b9695505050505050565b606083156106c8575081610446565b8251156106d85782518084602001fd5b8160405162461bcd60e51b81526004016102db91906107ba565b80356001600160a01b0381168114610708575f5ffd5b919050565b5f6020828403121561071d575f5ffd5b610446826106f2565b5f5f5f60408486031215610738575f5ffd5b610741846106f2565b9250602084013567ffffffffffffffff81111561075c575f5ffd5b8401601f8101861361076c575f5ffd5b803567ffffffffffffffff811115610782575f5ffd5b866020828401011115610793575f5ffd5b939660209190910195509293505050565b5f82518060208501845e5f920191825250919050565b602081525f82518060208401528060208501604085015e5f6040828501015260407fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe0601f8301168401019150509291505056fe416464726573733a206c6f772d6c6576656c2064656c65676174652063616c6c206661696c6564a2646970667358221220a45c5c13909613fb1c44f249ce77bfb03cdf47a4f42bcc05d796fa83a595accb64736f6c634300081c0033b53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103416464726573733a206c6f772d6c6576656c2064656c65676174652063616c6c206661696c6564a264697066735822122099e383a163f14c482f5ba664222263ef94d08f1018d289953292ed7d3d49866464736f6c634300081c0033
    /// ```
    #[rustfmt::skip]
    #[allow(clippy::all)]
    pub static DEPLOYED_BYTECODE: alloy_sol_types::private::Bytes = alloy_sol_types::private::Bytes::from_static(
        b"`\x80`@R4\x80\x15a\0\x0FW__\xFD[P`\x046\x10a\x02\xE1W_5`\xE0\x1C\x80c\x87e$\x0F\x11a\x01\x87W\x80c\xCC\x80\x89\xBB\x11a\0\xDDW\x80c\xEBezN\x11a\0\x93W\x80c\xEE\x9A1\xA2\x11a\0nW\x80c\xEE\x9A1\xA2\x14a\t1W\x80c\xFA(t \x14a\tXW\x80c\xFA\xF5b_\x14a\t\x7FW__\xFD[\x80c\xEBezN\x14a\x08\xD0W\x80c\xEB\xE0:\x93\x14a\x08\xF7W\x80c\xECOt\xCE\x14a\t\nW__\xFD[\x80c\xD4\x9DQ\x81\x11a\0\xC3W\x80c\xD4\x9DQ\x81\x14a\x08[W\x80c\xDA\xE7\xCB\x8B\x14a\x08\x82W\x80c\xE8\x18\x0C)\x14a\x08\xA9W__\xFD[\x80c\xCC\x80\x89\xBB\x14a\x08\rW\x80c\xD3\x84\xCB\x95\x14a\x084W__\xFD[\x80c\xB5\xE0\x0C?\x11a\x01=W\x80c\xC2\x1CB3\x11a\x01\x18W\x80c\xC2\x1CB3\x14a\x07\x98W\x80c\xC5\x19\xD1Q\x14a\x07\xBFW\x80c\xC8\x97\xF5^\x14a\x07\xE6W__\xFD[\x80c\xB5\xE0\x0C?\x14a\x07#W\x80c\xB7\x01\x06\x97\x14a\x07JW\x80c\xBEA\xB3g\x14a\x07qW__\xFD[\x80c\x99\x9F \xDB\x11a\x01mW\x80c\x99\x9F \xDB\x14a\x06\xB0W\x80c\x9F\x98T\xE5\x14a\x06\xC5W\x80c\xB3\x8DW\xF0\x14a\x06\xECW__\xFD[\x80c\x87e$\x0F\x14a\x06bW\x80c\x91\xDD\xB2\x85\x14a\x06\x89W__\xFD[\x80c0K\x90q\x11a\x02<W\x80c]\x9E$D\x11a\x01\xF2W\x80cx_\xFB7\x11a\x01\xCDW\x80cx_\xFB7\x14a\x05\xEDW\x80c\x81|\xD3\x12\x14a\x06\x14W\x80c\x85\xE1\xF4\xD0\x14a\x06;W__\xFD[\x80c]\x9E$D\x14a\x05fW\x80c`\x9F\xB5\x03\x14a\x05\x9FW\x80cd\xF4\x99*\x14a\x05\xC6W__\xFD[\x80cF\x92\xDE]\x11a\x02\"W\x80cF\x92\xDE]\x14a\x04\xF1W\x80cK/Q\xEF\x14a\x05\x18W\x80cL\xEC\xCF\xE5\x14a\x05?W__\xFD[\x80c0K\x90q\x14a\x04\xC2W\x80c<+x@\x14a\x04\xCAW__\xFD[\x80c\x10\xA6b\xE2\x11a\x02\x9CW\x80c\x1C\xCC,\xD1\x11a\x02wW\x80c\x1C\xCC,\xD1\x14a\x04aW\x80c(\xFB\"\x8C\x14a\x04\x88W\x80c,\xFB|\xA3\x14a\x04\x9BW__\xFD[\x80c\x10\xA6b\xE2\x14a\x03\xECW\x80c\x1B\x14.\xA7\x14a\x04\x13W\x80c\x1C9\xB6r\x14a\x04:W__\xFD[\x80c\x07\x87HK\x11a\x02\xCCW\x80c\x07\x87HK\x14a\x03^W\x80c\nT%}\x14a\x03\x85W\x80c\x10G\xFCR\x14a\x03\xACW__\xFD[\x80b<x\xFB\x14a\x02\xE5W\x80b\xF9s\x1E\x14a\x03\x1FW[__\xFD[a\x03\x0C\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81V[`@Q\x90\x81R` \x01[`@Q\x80\x91\x03\x90\xF3[a\x03F\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81V[`@Q`\x01`\x01`\xA0\x1B\x03\x90\x91\x16\x81R` \x01a\x03\x16V[a\x03F\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81V[a\x03F\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81V[a\x03\xD3\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81V[`@Qg\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x90\x91\x16\x81R` \x01a\x03\x16V[a\x03F\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81V[a\x03F\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81V[a\x03F\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81V[a\x03\x0C\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81V[a\x03Fa\x04\x966`\x04a)\xAEV[a\t\xA6V[a\x03F\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81V[a\x03\x0C`\x0C\x81V[a\x03F\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81V[a\x03F\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81V[a\x03F\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81V[a\x03\xD3\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81V[a\x05\x8D\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81V[`@Q`\xFF\x90\x91\x16\x81R` \x01a\x03\x16V[a\x03\x0C\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81V[a\x03F\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81V[a\x03\xD3\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81V[a\x03F\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81V[a\x03\x0C\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81V[a\x03F\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81V[a\x03\xD3\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81V[a\x06\xC3a\x06\xBE6`\x04a)\xD8V[a\n\x12V[\0[a\x03F\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81V[a\x07\x13\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81V[`@Q\x90\x15\x15\x81R` \x01a\x03\x16V[a\x03F\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81V[a\x03F\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81V[a\x03F\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81V[a\x03F\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81V[a\x03F\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81V[a\x03F\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81V[a\x03F\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81V[a\x03F\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81V[a\x03\xD3\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81V[a\x03F\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81V[a\x07\x13\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81V[a\x03\xD3\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81V[a\x06\xC3a\t\x056`\x04a*\xCBV[a\n\x9BV[a\x03\xD3\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81V[a\x03F\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81V[a\x03\x0C\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81V[a\x03\x0C\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81V[__\x82`@Q` \x01a\t\xBB\x91\x81R` \x01\x90V[`@Q` \x81\x83\x03\x03\x81R\x90`@R\x80Q\x90` \x01 \x90Pa\n\x08\x81`@Q\x80` \x01a\t\xE7\x90a'\xF5V[` \x82\x01\x81\x03\x82R`\x1F\x19`\x1F\x82\x01\x16`@RP\x80Q\x90` \x01 \x86a\x13\xDFV[\x91PP[\x92\x91PPV[_\x83`\x01`\x01`\xA0\x1B\x03\x16;\x11\x80\x15a\nEWP\x82`\x01`\x01`\xA0\x1B\x03\x16a\n:\x83\x83a\t\xA6V[`\x01`\x01`\xA0\x1B\x03\x16\x14[a\n\x96W`@QbF\x1B\xCD`\xE5\x1B\x81R` `\x04\x82\x01R`\r`$\x82\x01R\x7FADDR_MISMATCH\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0`D\x82\x01R`d\x01[`@Q\x80\x91\x03\x90\xFD[PPPV[a\n\xA3a\x14gV[_a\n\xACa\x18\x06V[\x90P_\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0`@Qa\n\xFD\x90a(\x02V[`\x01`\x01`\xA0\x1B\x03\x92\x83\x16\x81R\x91\x16` \x82\x01R```@\x82\x01\x81\x90R_\x90\x82\x01R`\x80\x01`@Q\x80\x91\x03\x90_\xF0\x80\x15\x80\x15a\x0B;W=__>=_\xFD[P\x90P_`@Q\x80a\x01 \x01`@R\x80\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0`\x01`\x01`\xA0\x1B\x03\x16\x81R` \x01\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0`\x01`\x01`\xA0\x1B\x03\x16\x81R` \x01\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0`\x01`\x01`\xA0\x1B\x03\x16\x81R` \x01\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0`\x01`\x01`\xA0\x1B\x03\x16\x81R` \x01\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0`\x01`\x01`\xA0\x1B\x03\x16\x81R` \x01\x83`\x01`\x01`\xA0\x1B\x03\x16\x81R` \x01\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0`\x01`\x01`\xA0\x1B\x03\x16\x81R` \x01\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0`\x01`\x01`\xA0\x1B\x03\x16\x81R` \x01\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0`\x01`\x01`\xA0\x1B\x03\x16c\xBCE\xE0\xAE`@Q\x81c\xFF\xFF\xFF\xFF\x16`\xE0\x1B\x81R`\x04\x01` `@Q\x80\x83\x03\x81\x86Z\xFA\x15\x80\x15a\x0C\xFFW=__>=_\xFD[PPPP`@Q=`\x1F\x19`\x1F\x82\x01\x16\x82\x01\x80`@RP\x81\x01\x90a\r#\x91\x90a+jV[`\x01`\x01`\xA0\x1B\x03\x16\x81RP\x90P_\x83`\xC0\x01Q`@Q` \x01a\rI\x91\x81R` \x01\x90V[`@Q` \x81\x83\x03\x03\x81R\x90`@R\x80Q\x90` \x01 \x90P_a\rp0\x86`\xC0\x01Qa\t\xA6V[\x90Pa\r{\x81a\x1E\xB3V[\x83`\x01`\x01`\xA0\x1B\x03\x16c\x1Ar\xD5L\x82\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x89a\x01\x80\x01Q\x8Aa\x01\xA0\x01Q\x8Ba\x01\xC0\x01Q\x8C` \x01Q\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x8Ea\x02@\x01Q\x8Fa\x01@\x01Q`@Q\x8Bc\xFF\xFF\xFF\xFF\x16`\xE0\x1B\x81R`\x04\x01a\x0E6\x9A\x99\x98\x97\x96\x95\x94\x93\x92\x91\x90a+\xBFV[_`@Q\x80\x83\x03\x81_\x87\x80;\x15\x80\x15a\x0EMW__\xFD[PZ\xF1\x15\x80\x15a\x0E_W=__>=_\xFD[PPPP_\x82`@Qa\x0Eq\x90a'\xF5V[\x81\x90`@Q\x80\x91\x03\x90_\xF5\x90P\x80\x15\x80\x15a\x0E\x8EW=__>=_\xFD[P\x90P\x81`\x01`\x01`\xA0\x1B\x03\x16\x81`\x01`\x01`\xA0\x1B\x03\x16\x14a\x0E\xF2W`@QbF\x1B\xCD`\xE5\x1B\x81R` `\x04\x82\x01R`\x15`$\x82\x01R\x7FUNEXPCTED_ROLLUP_ADDR\0\0\0\0\0\0\0\0\0\0\0`D\x82\x01R`d\x01a\n\x8DV[`\x80\x86\x01\x80Q0\x90\x91R`@Q\x7F\xAD\xFE\xF6\xAC\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x01`\x01`\xA0\x1B\x03\x83\x16\x90c\xAD\xFE\xF6\xAC\x90a\x0FC\x90\x8A\x90\x89\x90`\x04\x01a.!V[_`@Q\x80\x83\x03\x81_\x87\x80;\x15\x80\x15a\x0FZW__\xFD[PZ\xF1\x15\x80\x15a\x0FlW=__>=_\xFD[PPPP\x87Q_\x14a\x11lW_\x88Qg\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x11\x15a\x0F\x93Wa\x0F\x93a*\x16V[`@Q\x90\x80\x82R\x80` \x02` \x01\x82\x01`@R\x80\x15a\x0F\xBCW\x81` \x01` \x82\x02\x806\x837\x01\x90P[P\x90P_[\x89Q\x81\x10\x15a\x10\xF5W\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0`\x01`\x01`\xA0\x1B\x03\x16c\xFA\xCDt;\x8B\x83\x81Q\x81\x10a\x10\x0BWa\x10\x0Ba0\x11V[` \x02` \x01\x01Q`@Q\x82c\xFF\xFF\xFF\xFF\x16`\xE0\x1B\x81R`\x04\x01a\x10>\x91\x90`\x01`\x01`\xA0\x1B\x03\x91\x90\x91\x16\x81R` \x01\x90V[` `@Q\x80\x83\x03\x81\x86Z\xFA\x15\x80\x15a\x10YW=__>=_\xFD[PPPP`@Q=`\x1F\x19`\x1F\x82\x01\x16\x82\x01\x80`@RP\x81\x01\x90a\x10}\x91\x90a09V[a\x10\xC9W`@QbF\x1B\xCD`\xE5\x1B\x81R` `\x04\x82\x01R`\x18`$\x82\x01R\x7FUNEXPECTED_NEW_VALIDATOR\0\0\0\0\0\0\0\0`D\x82\x01R`d\x01a\n\x8DV[`\x01\x82\x82\x81Q\x81\x10a\x10\xDDWa\x10\xDDa0\x11V[\x91\x15\x15` \x92\x83\x02\x91\x90\x91\x01\x90\x91\x01R`\x01\x01a\x0F\xC1V[P`@Q\x7F\xA3\xFF\xB7r\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x01`\x01`\xA0\x1B\x03\x84\x16\x90c\xA3\xFF\xB7r\x90a\x11=\x90\x8C\x90\x85\x90`\x04\x01a0\x8BV[_`@Q\x80\x83\x03\x81_\x87\x80;\x15\x80\x15a\x11TW__\xFD[PZ\xF1\x15\x80\x15a\x11fW=__>=_\xFD[PPPPP[\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x15a\x12\"W`@Q\x7F\xA2\xB4\xF1\xD8\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x15\x15`\x04\x82\x01R`\x01`\x01`\xA0\x1B\x03\x83\x16\x90c\xA2\xB4\xF1\xD8\x90`$\x01_`@Q\x80\x83\x03\x81_\x87\x80;\x15\x80\x15a\x12\x0BW__\xFD[PZ\xF1\x15\x80\x15a\x12\x1DW=__>=_\xFD[PPPP[\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0`\x01`\x01`\xA0\x1B\x03\x16cU\x84\nX`@Q\x81c\xFF\xFF\xFF\xFF\x16`\xE0\x1B\x81R`\x04\x01` `@Q\x80\x83\x03\x81\x86Z\xFA\x92PPP\x80\x15a\x12\x9CWP`@\x80Q`\x1F=\x90\x81\x01`\x1F\x19\x16\x82\x01\x90\x92Ra\x12\x99\x91\x81\x01\x90a+jV[`\x01[\x15a\x13\"W`\x01`\x01`\xA0\x1B\x03\x81\x16\x15a\x13 W`@Q\x7F\rV\x1B7\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x01`\x01`\xA0\x1B\x03\x82\x81\x16`\x04\x83\x01R\x84\x16\x90c\rV\x1B7\x90`$\x01_`@Q\x80\x83\x03\x81_\x87\x80;\x15\x80\x15a\x13\tW__\xFD[PZ\xF1\x15\x80\x15a\x13\x1BW=__>=_\xFD[PPPP[P[`@Q\x7F\x13\xAF@5\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x01`\x01`\xA0\x1B\x03\x82\x81\x16`\x04\x83\x01R\x83\x16\x90c\x13\xAF@5\x90`$\x01_`@Q\x80\x83\x03\x81_\x87\x80;\x15\x80\x15a\x13{W__\xFD[PZ\xF1\x15\x80\x15a\x13\x8DW=__>=_\xFD[PP`@\x80Q`\x01`\x01`\xA0\x1B\x03\x80\x88\x16\x82R\x8A\x16` \x82\x01R\x7F~\\\xC5\xC3\xFC\xE0F\xD8h\xD5\x91\x85H\xDF\x8D>\x8E\xF9\xF0\x9Eo\xB3\nh\x08\x1F\x1F\x13H\xCD\x03\x14\x93P\x01\x90P`@Q\x80\x91\x03\x90\xA1PPPPPPPPV[`@\x80Q\x7F\xFF\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0` \x80\x83\x01\x91\x90\x91R``\x84\x90\x1B\x7F\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\0\0\0\0\0\0\0\0\0\0\0\0\x16`!\x83\x01R`5\x82\x01\x86\x90R`U\x80\x83\x01\x86\x90R\x83Q\x80\x84\x03\x90\x91\x01\x81R`u\x90\x92\x01\x90\x92R\x80Q\x91\x01 [\x93\x92PPPV[\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0`\x01`\x01`\xA0\x1B\x03\x16c\x84V\xCBY`@Q\x81c\xFF\xFF\xFF\xFF\x16`\xE0\x1B\x81R`\x04\x01_`@Q\x80\x83\x03\x81_\x87\x80;\x15\x80\x15a\x14\xBFW__\xFD[PZ\xF1\x15\x80\x15a\x14\xD1W=__>=_\xFD[PPPP_\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0`\x01`\x01`\xA0\x1B\x03\x16c\xDF\xF6\x97\x87`@Q\x81c\xFF\xFF\xFF\xFF\x16`\xE0\x1B\x81R`\x04\x01` `@Q\x80\x83\x03\x81\x86Z\xFA\x15\x80\x15a\x152W=__>=_\xFD[PPPP`@Q=`\x1F\x19`\x1F\x82\x01\x16\x82\x01\x80`@RP\x81\x01\x90a\x15V\x91\x90a0\xFCV[\x90P`2\x81g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x11\x15a\x15oWP`2[_[\x81g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x81g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x10\x15a\x18\x02W`@Q\x7Fm\xDD7D\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81Rg\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x82\x16`\x04\x82\x01R_\x90\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0`\x01`\x01`\xA0\x1B\x03\x16\x90cm\xDD7D\x90`$\x01` `@Q\x80\x83\x03\x81\x86Z\xFA\x15\x80\x15a\x16\x14W=__>=_\xFD[PPPP`@Q=`\x1F\x19`\x1F\x82\x01\x16\x82\x01\x80`@RP\x81\x01\x90a\x168\x91\x90a+jV[`@Q\x7F\xA2<D\xB1\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x01`\x01`\xA0\x1B\x03\x80\x83\x16`\x04\x83\x01R\x91\x92P_\x91\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x16\x90c\xA2<D\xB1\x90`$\x01`\xA0`@Q\x80\x83\x03\x81\x86Z\xFA\x15\x80\x15a\x16\xBAW=__>=_\xFD[PPPP`@Q=`\x1F\x19`\x1F\x82\x01\x16\x82\x01\x80`@RP\x81\x01\x90a\x16\xDE\x91\x90a1\x15V[\x90P\x80`\x80\x01Q\x80\x15a\x16\xFDWP``\x81\x01Qg\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x15[\x15a\x17\xEDW`@\x80Q`\x01\x80\x82R\x81\x83\x01\x90\x92R_\x91` \x80\x83\x01\x90\x806\x837\x01\x90PP\x90P\x82\x81_\x81Q\x81\x10a\x176Wa\x176a0\x11V[`\x01`\x01`\xA0\x1B\x03\x92\x83\x16` \x91\x82\x02\x92\x90\x92\x01\x01R`@Q\x7F|u\xC2\x98\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x90\x91\x16\x90c|u\xC2\x98\x90a\x17\xAB\x90\x84\x90`\x04\x01a1\x9CV[_`@Q\x80\x83\x03\x81_\x87\x80;\x15\x80\x15a\x17\xC2W__\xFD[PZ\xF1\x15\x80\x15a\x17\xD4W=__>=_\xFD[PPPP`\x01\x85a\x17\xE5\x91\x90a1\xC2V[\x94PPa\x17\xFBV[\x82a\x17\xF7\x81a1\xE2V[\x93PP[PPa\x15qV[PPV[a\x18\x0Ea(\x0FV[_\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0`\x01`\x01`\xA0\x1B\x03\x16c\x92\xC8\x13L\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0`\x01`\x01`\xA0\x1B\x03\x16ce\xF7\xF8\r`@Q\x81c\xFF\xFF\xFF\xFF\x16`\xE0\x1B\x81R`\x04\x01` `@Q\x80\x83\x03\x81\x86Z\xFA\x15\x80\x15a\x18\x9AW=__>=_\xFD[PPPP`@Q=`\x1F\x19`\x1F\x82\x01\x16\x82\x01\x80`@RP\x81\x01\x90a\x18\xBE\x91\x90a0\xFCV[`@Q\x7F\xFF\xFF\xFF\xFF\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0`\xE0\x84\x90\x1B\x16\x81Rg\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x90\x91\x16`\x04\x82\x01R`$\x01a\x01\x80`@Q\x80\x83\x03\x81\x86Z\xFA\x15\x80\x15a\x19\x1AW=__>=_\xFD[PPPP`@Q=`\x1F\x19`\x1F\x82\x01\x16\x82\x01\x80`@RP\x81\x01\x90a\x19>\x91\x90a2\x0EV[Q`@Q\x7F\x8E\xAAj\xC0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x81\x01\x82\x90R\x90\x91P_\x90\x81\x90\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0`\x01`\x01`\xA0\x1B\x03\x16\x90c\x8E\xAAj\xC0\x90`$\x01`\xC0`@Q\x80\x83\x03\x81\x86Z\xFA\x15\x80\x15a\x19\xC2W=__>=_\xFD[PPPP`@Q=`\x1F\x19`\x1F\x82\x01\x16\x82\x01\x80`@RP\x81\x01\x90a\x19\xE6\x91\x90a3GV[\x91P\x91Pa\x19\xF2a)\x1AV[\x82Q\x81R` \x80\x84\x01Q\x90\x82\x01\x90`\x02\x81\x11\x15a\x1A\x11Wa\x1A\x11a,\xDCV[\x90\x81`\x02\x81\x11\x15a\x1A$Wa\x1A$a,\xDCV[\x90RP\x83`\x01`\x01`\xA0\x1B\x03\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x16c1dA0a\x1A`\x84a#1V[\x85`@Q\x83c\xFF\xFF\xFF\xFF\x16`\xE0\x1B\x81R`\x04\x01a\x1A~\x92\x91\x90a4\x03V[` `@Q\x80\x83\x03\x81\x86Z\xFA\x15\x80\x15a\x1A\x99W=__>=_\xFD[PPPP`@Q=`\x1F\x19`\x1F\x82\x01\x16\x82\x01\x80`@RP\x81\x01\x90a\x1A\xBD\x91\x90a45V[\x14a\x1B\nW`@QbF\x1B\xCD`\xE5\x1B\x81R` `\x04\x82\x01R`\x1D`$\x82\x01R\x7FInvalid latest execution hash\0\0\0`D\x82\x01R`d\x01a\n\x8DV[a\x1B1`@Q\x80`\x80\x01`@R\x80_\x81R` \x01_\x81R` \x01_\x81R` \x01_\x81RP\x90V[`@\x80Q``\x81\x01\x82R_\x80\x82R` \x82\x01\x81\x90R\x91\x81\x01\x91\x90\x91R`@Q\x80a\x02\xA0\x01`@R\x80\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x81R` \x01\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0`\x01`\x01`\xA0\x1B\x03\x16\x81R` \x01\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R` \x01\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0`\x01`\x01`\xA0\x1B\x03\x16c\x8E\xE1\xA1&`@Q\x81c\xFF\xFF\xFF\xFF\x16`\xE0\x1B\x81R`\x04\x01` `@Q\x80\x83\x03\x81\x86Z\xFA\x15\x80\x15a\x1C:W=__>=_\xFD[PPPP`@Q=`\x1F\x19`\x1F\x82\x01\x16\x82\x01\x80`@RP\x81\x01\x90a\x1C^\x91\x90a45V[\x81R` \x010`\x01`\x01`\xA0\x1B\x03\x16\x81R` \x01\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0`\x01`\x01`\xA0\x1B\x03\x16\x81R` \x01\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R` \x01`@Q\x80` \x01`@R\x80_\x81RP\x81R` \x01\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R` \x01\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x81R` \x01\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0`\x01`\x01`\xA0\x1B\x03\x16c\xB0\xEC*\xE1`@Q\x81c\xFF\xFF\xFF\xFF\x16`\xE0\x1B\x81R`\x04\x01_`@Q\x80\x83\x03\x81\x86Z\xFA\x15\x80\x15a\x1D\x8CW=__>=_\xFD[PPPP`@Q=_\x82>`\x1F=\x90\x81\x01`\x1F\x19\x16\x82\x01`@Ra\x1D\xB3\x91\x90\x81\x01\x90a4LV[\x81R` \x01\x83\x81R` \x01\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R` \x01\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R` \x01\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R` \x01\x84\x81R` \x01\x85\x81R` \x01_`\x01`\x01`\xA0\x1B\x03\x16\x81R` \x01\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0`\xFF\x16\x81R` \x01\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x81R` \x01\x82\x81RP\x96PPPPPPP\x90V[`@Qc&j#\xB1`\xE2\x1B\x81R`\x01`\x01`\xA0\x1B\x03\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81\x81\x16`\x04\x84\x01R\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x82\x16`$\x84\x01R\x91\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x90\x91\x16\x90c\x99\xA8\x8E\xC4\x90`D\x01_`@Q\x80\x83\x03\x81_\x87\x80;\x15\x80\x15a\x1F_W__\xFD[PZ\xF1\x15\x80\x15a\x1FqW=__>=_\xFD[PP`@Q\x7F\x91\x9C\xC7\x06\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x01`\x01`\xA0\x1B\x03\x85\x81\x16`\x04\x83\x01R\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x16\x92Pc\x91\x9C\xC7\x06\x91P`$\x01_`@Q\x80\x83\x03\x81_\x87\x80;\x15\x80\x15a\x1F\xEEW__\xFD[PZ\xF1\x15\x80\x15a \0W=__>=_\xFD[PPPPa \x0Ca#kV[`@Qc&j#\xB1`\xE2\x1B\x81R`\x01`\x01`\xA0\x1B\x03\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81\x81\x16`\x04\x84\x01R\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x82\x16`$\x84\x01R\x91\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x90\x91\x16\x90c\x99\xA8\x8E\xC4\x90`D\x01_`@Q\x80\x83\x03\x81_\x87\x80;\x15\x80\x15a \xB8W__\xFD[PZ\xF1\x15\x80\x15a \xCAW=__>=_\xFD[PP`@Qc&j#\xB1`\xE2\x1B\x81R`\x01`\x01`\xA0\x1B\x03\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81\x81\x16`\x04\x84\x01R\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x82\x16`$\x84\x01R\x93P\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x16\x91Pc\x99\xA8\x8E\xC4\x90`D\x01_`@Q\x80\x83\x03\x81_\x87\x80;\x15\x80\x15a!xW__\xFD[PZ\xF1\x15\x80\x15a!\x8AW=__>=_\xFD[PPPP\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0`\x01`\x01`\xA0\x1B\x03\x16cj\xE7\x1F\x12`@Q\x81c\xFF\xFF\xFF\xFF\x16`\xE0\x1B\x81R`\x04\x01_`@Q\x80\x83\x03\x81_\x87\x80;\x15\x80\x15a!\xE6W__\xFD[PZ\xF1\x15\x80\x15a!\xF8W=__>=_\xFD[PP`@Qc&j#\xB1`\xE2\x1B\x81R`\x01`\x01`\xA0\x1B\x03\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81\x81\x16`\x04\x84\x01R\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x82\x16`$\x84\x01R\x93P\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x16\x91Pc\x99\xA8\x8E\xC4\x90`D\x01_`@Q\x80\x83\x03\x81_\x87\x80;\x15\x80\x15a\"\xA6W__\xFD[PZ\xF1\x15\x80\x15a\"\xB8W=__>=_\xFD[PPPP\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0`\x01`\x01`\xA0\x1B\x03\x16cj\xE7\x1F\x12`@Q\x81c\xFF\xFF\xFF\xFF\x16`\xE0\x1B\x81R`\x04\x01_`@Q\x80\x83\x03\x81_\x87\x80;\x15\x80\x15a#\x14W__\xFD[PZ\xF1\x15\x80\x15a#&W=__>=_\xFD[PPPPPPPPPV[a#9a)?V[`@Q\x80`@\x01`@R\x80\x83_\x01Q\x81R` \x01\x83` \x01Q`\x02\x81\x11\x15a#cWa#ca,\xDCV[\x90R\x92\x91PPV[\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x15a%oW\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0`\x01`\x01`\xA0\x1B\x03\x16c\x96#`\x9D\x82\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0`@Q\x80``\x01`@R\x80\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x81R` \x01\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x81R` \x01\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x81RP`@Q`$\x01a$\xAC\x91\x90a4\xD3V[`@\x80Q`\x1F\x19\x81\x84\x03\x01\x81R\x91\x81R` \x82\x01\x80Q{\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x7F\xA6U\xD97\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x17\x90RQ\x7F\xFF\xFF\xFF\xFF\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0`\xE0\x86\x90\x1B\x16\x81Ra%=\x93\x92\x91\x90`\x04\x01a5\x16V[_`@Q\x80\x83\x03\x81_\x87\x80;\x15\x80\x15a%TW__\xFD[PZ\xF1\x15\x80\x15a%fW=__>=_\xFD[PPPPa&\x0EV[`@Qc&j#\xB1`\xE2\x1B\x81R`\x01`\x01`\xA0\x1B\x03\x82\x81\x16`\x04\x83\x01R\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81\x16`$\x83\x01R\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x16\x90c\x99\xA8\x8E\xC4\x90`D\x01_`@Q\x80\x83\x03\x81_\x87\x80;\x15\x80\x15a%\xF7W__\xFD[PZ\xF1\x15\x80\x15a&\tW=__>=_\xFD[PPPP[____\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0`\x01`\x01`\xA0\x1B\x03\x16c\xEB\xEAF\x1D`@Q\x81c\xFF\xFF\xFF\xFF\x16`\xE0\x1B\x81R`\x04\x01`\x80`@Q\x80\x83\x03\x81\x86Z\xFA\x15\x80\x15a&nW=__>=_\xFD[PPPP`@Q=`\x1F\x19`\x1F\x82\x01\x16\x82\x01\x80`@RP\x81\x01\x90a&\x92\x91\x90a5OV[\x93P\x93P\x93P\x93P_`\x0C\x83a&\xA8\x91\x90a5\x96V[\x15a&\xC8Wa&\xB8`\x0C\x84a5\xA9V[a&\xC3\x90`\x01a5\xBCV[a&\xD3V[a&\xD3`\x0C\x84a5\xA9V[\x90P\x84\x81\x11a&\xE2W\x84a&\xE4V[\x80[\x94P\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0`\x01`\x01`\xA0\x1B\x03\x16c\xB3\x17a\xF8`@Q\x80`\x80\x01`@R\x80\x88\x81R` \x01\x87\x81R` \x01\x86\x81R` \x01\x85\x81RP`@Q\x82c\xFF\xFF\xFF\xFF\x16`\xE0\x1B\x81R`\x04\x01a'R\x91\x90a5\xCFV[_`@Q\x80\x83\x03\x81_\x87\x80;\x15\x80\x15a'iW__\xFD[PZ\xF1\x15\x80\x15a'{W=__>=_\xFD[PPPP\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0`\x01`\x01`\xA0\x1B\x03\x16cj\xE7\x1F\x12`@Q\x81c\xFF\xFF\xFF\xFF\x16`\xE0\x1B\x81R`\x04\x01_`@Q\x80\x83\x03\x81_\x87\x80;\x15\x80\x15a'\xD7W__\xFD[PZ\xF1\x15\x80\x15a'\xE9W=__>=_\xFD[PPPPPPPPPPV[a\x13\xEB\x80a5\xFB\x839\x01\x90V[a\r\x91\x80aI\xE6\x839\x01\x90V[`@Q\x80a\x02\xA0\x01`@R\x80_g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x81R` \x01_`\x01`\x01`\xA0\x1B\x03\x16\x81R` \x01_\x81R` \x01_\x81R` \x01_`\x01`\x01`\xA0\x1B\x03\x16\x81R` \x01_`\x01`\x01`\xA0\x1B\x03\x16\x81R` \x01_\x81R` \x01``\x81R` \x01_\x81R` \x01_g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x81R` \x01``\x81R` \x01a(\xB5`@Q\x80`\x80\x01`@R\x80_\x81R` \x01_\x81R` \x01_\x81R` \x01_\x81RP\x90V[\x81R` \x01_\x81R` \x01_\x81R` \x01_\x81R` \x01a(\xD4a)\x1AV[\x81R_` \x80\x83\x01\x82\x90R`@\x80\x84\x01\x83\x90R``\x80\x85\x01\x84\x90R`\x80\x85\x01\x84\x90R\x81Q\x90\x81\x01\x82R\x83\x81R\x91\x82\x01\x83\x90R\x81\x01\x91\x90\x91R`\xA0\x90\x91\x01R\x90V[\x90R\x90V[`@Q\x80``\x01`@R\x80a)-a)]V[\x81R` \x01_\x81R` \x01_\x81RP\x90V[`@Q\x80`@\x01`@R\x80a)Ra)]V[\x81R` \x01_\x90R\x90V[`@Q\x80`@\x01`@R\x80a)pa)yV[\x81R` \x01a)\x15[`@Q\x80`@\x01`@R\x80`\x02\x90` \x82\x02\x806\x837P\x91\x92\x91PPV[`\x01`\x01`\xA0\x1B\x03\x81\x16\x81\x14a)\xABW__\xFD[PV[__`@\x83\x85\x03\x12\x15a)\xBFW__\xFD[\x825a)\xCA\x81a)\x97V[\x94` \x93\x90\x93\x015\x93PPPV[___``\x84\x86\x03\x12\x15a)\xEAW__\xFD[\x835a)\xF5\x81a)\x97V[\x92P` \x84\x015a*\x05\x81a)\x97V[\x92\x95\x92\x94PPP`@\x91\x90\x91\x015\x90V[cNH{q`\xE0\x1B_R`A`\x04R`$_\xFD[`@Qa\x01\x80\x81\x01g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x11\x82\x82\x10\x17\x15a*NWa*Na*\x16V[`@R\x90V[`@\x80Q\x90\x81\x01g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x11\x82\x82\x10\x17\x15a*NWa*Na*\x16V[`@Q`\x1F\x82\x01`\x1F\x19\x16\x81\x01g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x11\x82\x82\x10\x17\x15a*\xA0Wa*\xA0a*\x16V[`@R\x91\x90PV[_g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x82\x11\x15a*\xC1Wa*\xC1a*\x16V[P`\x05\x1B` \x01\x90V[_` \x82\x84\x03\x12\x15a*\xDBW__\xFD[\x815g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x11\x15a*\xF1W__\xFD[\x82\x01`\x1F\x81\x01\x84\x13a+\x01W__\xFD[\x805a+\x14a+\x0F\x82a*\xA8V[a*wV[\x80\x82\x82R` \x82\x01\x91P` \x83`\x05\x1B\x85\x01\x01\x92P\x86\x83\x11\x15a+5W__\xFD[` \x84\x01\x93P[\x82\x84\x10\x15a+`W\x835a+O\x81a)\x97V[\x82R` \x93\x84\x01\x93\x90\x91\x01\x90a+<V[\x96\x95PPPPPPV[_` \x82\x84\x03\x12\x15a+zW__\xFD[\x81Qa\x14`\x81a)\x97V[_\x81Q\x80\x84R` \x84\x01\x93P` \x83\x01_[\x82\x81\x10\x15a+\xB5W\x81Q\x86R` \x95\x86\x01\x95\x90\x91\x01\x90`\x01\x01a+\x97V[P\x93\x94\x93PPPPV[`\x01`\x01`\xA0\x1B\x03\x8B\x16\x81Rg\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x8A\x16` \x82\x01R`\x01`\x01`\xA0\x1B\x03\x89\x16`@\x82\x01R\x87``\x82\x01R\x86`\x80\x82\x01R\x85`\xA0\x82\x01R`\x01`\x01`\xA0\x1B\x03\x85\x16`\xC0\x82\x01R`\x01`\x01`\xA0\x1B\x03\x84\x16`\xE0\x82\x01R`\xFF\x83\x16a\x01\0\x82\x01Ra\x01@a\x01 \x82\x01R_a,<a\x01@\x83\x01\x84a+\x85V[\x9C\x9BPPPPPPPPPPPPV[_\x81Q\x80\x84R\x80` \x84\x01` \x86\x01^_` \x82\x86\x01\x01R` `\x1F\x19`\x1F\x83\x01\x16\x85\x01\x01\x91PP\x92\x91PPV[\x80Q\x82_[`\x02\x81\x10\x15a,\x9EW\x82Q\x82R` \x92\x83\x01\x92\x90\x91\x01\x90`\x01\x01a,\x7FV[PPP` \x81\x01Q`@\x83\x01_[`\x02\x81\x10\x15a,\xD5W\x82Qg\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x82R` \x92\x83\x01\x92\x90\x91\x01\x90`\x01\x01a,\xACV[PPPPPV[cNH{q`\xE0\x1B_R`!`\x04R`$_\xFD[`\x03\x81\x10a-\x0CWcNH{q`\xE0\x1B_R`!`\x04R`$_\xFD[\x90RV[a-\x1B\x82\x82Qa,zV[` \x81\x01Qa--`\x80\x84\x01\x82a,\xF0V[P`@\x01Q`\xA0\x91\x90\x91\x01RV[`\x01`\x01`\xA0\x1B\x03\x81Q\x16\x82R` \x81\x01Qa-b` \x84\x01\x82`\x01`\x01`\xA0\x1B\x03\x16\x90RV[P`@\x81\x01Qa-}`@\x84\x01\x82`\x01`\x01`\xA0\x1B\x03\x16\x90RV[P``\x81\x01Qa-\x98``\x84\x01\x82`\x01`\x01`\xA0\x1B\x03\x16\x90RV[P`\x80\x81\x01Qa-\xB3`\x80\x84\x01\x82`\x01`\x01`\xA0\x1B\x03\x16\x90RV[P`\xA0\x81\x01Qa-\xCE`\xA0\x84\x01\x82`\x01`\x01`\xA0\x1B\x03\x16\x90RV[P`\xC0\x81\x01Qa-\xE9`\xC0\x84\x01\x82`\x01`\x01`\xA0\x1B\x03\x16\x90RV[P`\xE0\x81\x01Qa.\x04`\xE0\x84\x01\x82`\x01`\x01`\xA0\x1B\x03\x16\x90RV[Pa\x01\0\x81\x01Qa\n\x96a\x01\0\x84\x01\x82`\x01`\x01`\xA0\x1B\x03\x16\x90RV[a\x01@\x81Ra.>a\x01@\x82\x01\x84Qg\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x90RV[_` \x84\x01Qa.Za\x01`\x84\x01\x82`\x01`\x01`\xA0\x1B\x03\x16\x90RV[P`@\x84\x01Qa\x01\x80\x83\x01R``\x84\x01Qa\x01\xA0\x83\x01R`\x80\x84\x01Q`\x01`\x01`\xA0\x1B\x03\x90\x81\x16a\x01\xC0\x84\x01R`\xA0\x85\x01Q\x16a\x01\xE0\x83\x01R`\xC0\x84\x01Qa\x02\0\x83\x01R`\xE0\x84\x01Qa\x03\xE0a\x02 \x84\x01Ra.\xBAa\x05 \x84\x01\x82a,LV[\x90Pa\x01\0\x85\x01Qa\x02@\x84\x01Ra\x01 \x85\x01Qa.\xE5a\x02`\x85\x01\x82g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x90RV[Pa\x01@\x85\x01Q\x7F\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFE\xC0\x84\x83\x03\x01a\x02\x80\x85\x01Ra/!\x82\x82a+\x85V[a\x01`\x87\x01Q\x80Qa\x02\xA0\x87\x01R` \x81\x01Qa\x02\xC0\x87\x01R`@\x81\x01Qa\x02\xE0\x87\x01R``\x01Qa\x03\0\x86\x01Ra\x01\x80\x87\x01Qa\x03 \x86\x01Ra\x01\xA0\x87\x01Qa\x03@\x86\x01Ra\x01\xC0\x87\x01Qa\x03`\x86\x01Ra\x01\xE0\x87\x01Q\x90\x92P\x90Pa/\x8Ca\x03\x80\x85\x01\x82a-\x10V[Pa\x02\0\x85\x01Qa\x04@\x84\x01Ra\x02 \x85\x01Q`\x01`\x01`\xA0\x1B\x03\x16a\x04`\x84\x01Ra\x02@\x85\x01Q`\xFF\x16a\x04\x80\x84\x01Ra\x02`\x85\x01Qg\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x90\x81\x16a\x04\xA0\x85\x01Ra\x02\x80\x86\x01Q\x80Q\x82\x16a\x04\xC0\x86\x01R` \x80\x82\x01Q\x83\x16a\x04\xE0\x87\x01R`@\x90\x91\x01Q\x90\x91\x16a\x05\0\x85\x01R\x90\x91Pa\x14`\x90\x83\x01\x84a-;V[cNH{q`\xE0\x1B_R`2`\x04R`$_\xFD[\x80Q\x80\x15\x15\x81\x14a04W__\xFD[\x91\x90PV[_` \x82\x84\x03\x12\x15a0IW__\xFD[a\x14`\x82a0%V[_\x81Q\x80\x84R` \x84\x01\x93P` \x83\x01_[\x82\x81\x10\x15a+\xB5W\x81Q`\x01`\x01`\xA0\x1B\x03\x16\x86R` \x95\x86\x01\x95\x90\x91\x01\x90`\x01\x01a0dV[`@\x81R_a0\x9D`@\x83\x01\x85a0RV[\x82\x81\x03` \x84\x01R\x80\x84Q\x80\x83R` \x83\x01\x91P` \x86\x01\x92P_[\x81\x81\x10\x15a0\xD9W\x83Q\x15\x15\x83R` \x93\x84\x01\x93\x90\x92\x01\x91`\x01\x01a0\xB9V[P\x90\x96\x95PPPPPPV[\x80Qg\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x16\x81\x14a04W__\xFD[_` \x82\x84\x03\x12\x15a1\x0CW__\xFD[a\x14`\x82a0\xE5V[_`\xA0\x82\x84\x03\x12\x80\x15a1&W__\xFD[P`@Q`\xA0\x81\x01g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x11\x82\x82\x10\x17\x15a1JWa1Ja*\x16V[`@R\x82Q\x81Ra1]` \x84\x01a0\xE5V[` \x82\x01Ra1n`@\x84\x01a0\xE5V[`@\x82\x01Ra1\x7F``\x84\x01a0\xE5V[``\x82\x01Ra1\x90`\x80\x84\x01a0%V[`\x80\x82\x01R\x93\x92PPPV[` \x81R_a\x14`` \x83\x01\x84a0RV[cNH{q`\xE0\x1B_R`\x11`\x04R`$_\xFD[g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x82\x81\x16\x82\x82\x16\x03\x90\x81\x11\x15a\n\x0CWa\n\x0Ca1\xAEV[_g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x82\x16g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x03a2\x05Wa2\x05a1\xAEV[`\x01\x01\x92\x91PPV[_a\x01\x80\x82\x84\x03\x12\x80\x15a2 W__\xFD[Pa2)a**V[\x82Q\x81R` \x80\x84\x01Q\x90\x82\x01R`@\x80\x84\x01Q\x90\x82\x01Ra2M``\x84\x01a0\xE5V[``\x82\x01Ra2^`\x80\x84\x01a0\xE5V[`\x80\x82\x01Ra2o`\xA0\x84\x01a0\xE5V[`\xA0\x82\x01Ra2\x80`\xC0\x84\x01a0\xE5V[`\xC0\x82\x01Ra2\x91`\xE0\x84\x01a0\xE5V[`\xE0\x82\x01Ra2\xA3a\x01\0\x84\x01a0\xE5V[a\x01\0\x82\x01Ra2\xB6a\x01 \x84\x01a0\xE5V[a\x01 \x82\x01Ra2\xC9a\x01@\x84\x01a0\xE5V[a\x01@\x82\x01Ra\x01`\x92\x83\x01Q\x92\x81\x01\x92\x90\x92RP\x91\x90PV[_\x82`\x1F\x83\x01\x12a2\xF2W__\xFD[a2\xFC`@a*wV[\x80`@\x84\x01\x85\x81\x11\x15a3\rW__\xFD[\x84[\x81\x81\x10\x15a3.Wa3 \x81a0\xE5V[\x84R` \x93\x84\x01\x93\x01a3\x0FV[P\x90\x95\x94PPPPPV[\x80Q`\x03\x81\x10a04W__\xFD[__\x82\x84\x03`\xC0\x81\x12\x15a3YW__\xFD[`\xA0\x81\x12\x15a3fW__\xFD[a3na*TV[`\x80\x82\x12\x15a3{W__\xFD[a3\x83a*TV[\x91P\x85`\x1F\x86\x01\x12a3\x93W__\xFD[a3\x9D`@a*wV[\x80`@\x87\x01\x88\x81\x11\x15a3\xAEW__\xFD[\x87[\x81\x81\x10\x15a3\xC8W\x80Q\x84R` \x93\x84\x01\x93\x01a3\xB0V[P\x81\x85Ra3\xD6\x89\x82a2\xE3V[` \x86\x01RPPP\x81\x81Ra3\xED`\x80\x86\x01a39V[` \x82\x01R`\xA0\x94\x90\x94\x01Q\x93\x95\x93\x94PPPPV[_`\xC0\x82\x01\x90Pa4\x15\x82\x85Qa,zV[` \x84\x01Qa4'`\x80\x84\x01\x82a,\xF0V[P\x82`\xA0\x83\x01R\x93\x92PPPV[_` \x82\x84\x03\x12\x15a4EW__\xFD[PQ\x91\x90PV[_` \x82\x84\x03\x12\x15a4\\W__\xFD[\x81Qg\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x11\x15a4rW__\xFD[\x82\x01`\x1F\x81\x01\x84\x13a4\x82W__\xFD[\x80Qa4\x90a+\x0F\x82a*\xA8V[\x80\x82\x82R` \x82\x01\x91P` \x83`\x05\x1B\x85\x01\x01\x92P\x86\x83\x11\x15a4\xB1W__\xFD[` \x84\x01\x93P[\x82\x84\x10\x15a+`W\x83Q\x82R` \x93\x84\x01\x93\x90\x91\x01\x90a4\xB8V[``\x81\x01a\n\x0C\x82\x84g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81Q\x16\x82Rg\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF` \x82\x01Q\x16` \x83\x01Rg\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF`@\x82\x01Q\x16`@\x83\x01RPPV[`\x01`\x01`\xA0\x1B\x03\x84\x16\x81R`\x01`\x01`\xA0\x1B\x03\x83\x16` \x82\x01R```@\x82\x01R_a5F``\x83\x01\x84a,LV[\x95\x94PPPPPV[____`\x80\x85\x87\x03\x12\x15a5bW__\xFD[PP\x82Q` \x84\x01Q`@\x85\x01Q``\x90\x95\x01Q\x91\x96\x90\x95P\x90\x92P\x90PV[cNH{q`\xE0\x1B_R`\x12`\x04R`$_\xFD[_\x82a5\xA4Wa5\xA4a5\x82V[P\x06\x90V[_\x82a5\xB7Wa5\xB7a5\x82V[P\x04\x90V[\x80\x82\x01\x80\x82\x11\x15a\n\x0CWa\n\x0Ca1\xAEV[\x81Q\x81R` \x80\x83\x01Q\x90\x82\x01R`@\x80\x83\x01Q\x90\x82\x01R``\x80\x83\x01Q\x90\x82\x01R`\x80\x81\x01a\n\x0CV\xFE`\x80`@R4\x80\x15`\x0EW__\xFD[Pa\x13\xCF\x80a\0\x1C_9_\xF3\xFE`\x80`@R`\x046\x10a\0!W_5`\xE0\x1C\x80c\xAD\xFE\xF6\xAC\x14a\08Wa\x000V[6a\x000Wa\0.a\0WV[\0[a\0.a\0WV[4\x80\x15a\0CW__\xFD[Pa\0.a\0R6`\x04a\rgV[a\0iV[a\0ga\0ba\x01\xB8V[a\x02\x9AV[V[_a\0ra\x02\xBDV[`\x01`\x01`\xA0\x1B\x03\x16\x14\x80\x15a\0\x97WP_a\0\x8Ca\x02\xEFV[`\x01`\x01`\xA0\x1B\x03\x16\x14[\x80\x15a\0\xB2WP_a\0\xA7a\x03\x16V[`\x01`\x01`\xA0\x1B\x03\x16\x14[\x15a\x01\xB0Wa\x01\xAC\x81`\xC0\x01Q\x83\x83`@Q`$\x01a\0\xD2\x92\x91\x90a\x11'V[`@\x80Q`\x1F\x19\x81\x84\x03\x01\x81R\x91\x81R` \x80\x83\x01\x80Q{\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x7F\x0E\xE5\xEF\x0C\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x17\x90R`\xE0\x86\x01Q\x90\x87\x01Q\x91Q`\x01`\x01`\xA0\x1B\x03\x90\x92\x16`$\x83\x01R\x90`D\x01`@\x80Q`\x1F\x19\x81\x84\x03\x01\x81R\x91\x90R` \x81\x01\x80Q{\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x7F\xC4\xD6m\xE8\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x17\x90R`\x80\x87\x01Qa\x03=V[PPV[a\x01\xACa\0WV[_`\x046\x10\x15a\x02\x0FW`@QbF\x1B\xCD`\xE5\x1B\x81R` `\x04\x82\x01R`\x0B`$\x82\x01R\x7FNO_FUNC_SIG\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0`D\x82\x01R`d\x01[`@Q\x80\x91\x03\x90\xFD[_3a\x02\x19a\x02\xBDV[`\x01`\x01`\xA0\x1B\x03\x16\x03a\x024Wa\x02/a\x02\xEFV[a\x02<V[a\x02<a\x03\x16V[\x90P`\x01`\x01`\xA0\x1B\x03\x81\x16;a\x02\x95W`@QbF\x1B\xCD`\xE5\x1B\x81R` `\x04\x82\x01R`\x13`$\x82\x01R\x7FTARGET_NOT_CONTRACT\0\0\0\0\0\0\0\0\0\0\0\0\0`D\x82\x01R`d\x01a\x02\x06V[\x91\x90PV[6__7__6_\x84Z\xF4=__>\x80\x80\x15a\x02\xB4W=_\xF3[=_\xFD[PPPV[_\x7F\xB51'hJV\x8B1s\xAE\x13\xB9\xF8\xA6\x01n$>c\xB6\xE8\xEE\x11x\xD6\xA7\x17\x85\x0B]a\x03[T`\x01`\x01`\xA0\x1B\x03\x16\x91\x90PV[_\x7F6\x08\x94\xA1;\xA1\xA3!\x06g\xC8(I-\xB9\x8D\xCA> v\xCC75\xA9 \xA3\xCAP]8+\xBCa\x02\xE0V[_\x7F+\x1D\xBC\xE7C$$\x8C\"/\x0E\xC2\xD5\xED{\xD3#\xCF\xC4%\xB36\xF0%<\\\xCF\xDAreTma\x02\xE0V[a\x03h`\x01\x7F\xB51'hJV\x8B1s\xAE\x13\xB9\xF8\xA6\x01n$>c\xB6\xE8\xEE\x11x\xD6\xA7\x17\x85\x0B]a\x04a\x13\x17V[\x7F\xB51'hJV\x8B1s\xAE\x13\xB9\xF8\xA6\x01n$>c\xB6\xE8\xEE\x11x\xD6\xA7\x17\x85\x0B]a\x03\x14a\x03\x96Wa\x03\x96a\x136V[a\x03\xC1`\x01\x7F6\x08\x94\xA1;\xA1\xA3!\x06g\xC8(I-\xB9\x8D\xCA> v\xCC75\xA9 \xA3\xCAP]8+\xBDa\x13\x17V[\x7F6\x08\x94\xA1;\xA1\xA3!\x06g\xC8(I-\xB9\x8D\xCA> v\xCC75\xA9 \xA3\xCAP]8+\xBC\x14a\x03\xEFWa\x03\xEFa\x136V[a\x04\x1A`\x01\x7F+\x1D\xBC\xE7C$$\x8C\"/\x0E\xC2\xD5\xED{\xD3#\xCF\xC4%\xB36\xF0%<\\\xCF\xDAreTna\x13\x17V[\x7F+\x1D\xBC\xE7C$$\x8C\"/\x0E\xC2\xD5\xED{\xD3#\xCF\xC4%\xB36\xF0%<\\\xCF\xDAreTm\x14a\x04HWa\x04Ha\x136V[a\x04Q\x81a\x04nV[a\x04\\\x85\x85_a\x04\xC5V[a\x04g\x83\x83_a\x04\xEFV[PPPPPV[\x7F~dMyB/\x17\xC0\x1EH\x94\xB5\xF4\xF5\x88\xD31\xEB\xFA(e=B\xAE\x83-\xC5\x9E8\xC9y\x8Fa\x04\x97a\x02\xBDV[`@\x80Q`\x01`\x01`\xA0\x1B\x03\x92\x83\x16\x81R\x91\x84\x16` \x83\x01R\x01`@Q\x80\x91\x03\x90\xA1a\x04\xC2\x81a\x04\xF8V[PV[a\x04\xCE\x83a\x05\xD0V[_\x82Q\x11\x80a\x04\xDAWP\x80[\x15a\x02\xB8Wa\x04\xE9\x83\x83a\x06\x0FV[PPPPV[a\x04\xCE\x83a\x06=V[`\x01`\x01`\xA0\x1B\x03\x81\x16a\x05tW`@QbF\x1B\xCD`\xE5\x1B\x81R` `\x04\x82\x01R`&`$\x82\x01R\x7FERC1967: new admin is the zero a`D\x82\x01R\x7Fddress\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0`d\x82\x01R`\x84\x01a\x02\x06V[\x80\x7F\xB51'hJV\x8B1s\xAE\x13\xB9\xF8\xA6\x01n$>c\xB6\xE8\xEE\x11x\xD6\xA7\x17\x85\x0B]a\x03[\x80T\x7F\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x16`\x01`\x01`\xA0\x1B\x03\x92\x90\x92\x16\x91\x90\x91\x17\x90UPV[a\x05\xD9\x81a\x06|V[`@Q`\x01`\x01`\xA0\x1B\x03\x82\x16\x90\x7F\xBC|\xD7Z \xEE'\xFD\x9A\xDE\xBA\xB3 A\xF7U!M\xBCk\xFF\xA9\x0C\xC0\"[9\xDA.\\-;\x90_\x90\xA2PV[``a\x064\x83\x83`@Q\x80``\x01`@R\x80`'\x81R` \x01a\x13s`'\x919a\x07 V[\x90P[\x92\x91PPV[a\x06F\x81a\x08\x12V[`@Q`\x01`\x01`\xA0\x1B\x03\x82\x16\x90\x7F\xF7\xEE\xD2\xA7\xFA\xBB\xF1\xBE\xC8\xD5^\xD5\xE7\x85\xCCvb#v\xDD\xE5\xDFO\xF1TpU\x1E\x03\x0B\x814\x90_\x90\xA2PV[`\x01`\x01`\xA0\x1B\x03\x81\x16;a\x06\xF9W`@QbF\x1B\xCD`\xE5\x1B\x81R` `\x04\x82\x01R`-`$\x82\x01R\x7FERC1967: new implementation is n`D\x82\x01R\x7Fot a contract\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0`d\x82\x01R`\x84\x01a\x02\x06V[\x80\x7F6\x08\x94\xA1;\xA1\xA3!\x06g\xC8(I-\xB9\x8D\xCA> v\xCC75\xA9 \xA3\xCAP]8+\xBCa\x05\x97V[```\x01`\x01`\xA0\x1B\x03\x84\x16;a\x07\x9FW`@QbF\x1B\xCD`\xE5\x1B\x81R` `\x04\x82\x01R`&`$\x82\x01R\x7FAddress: delegate call to non-co`D\x82\x01R\x7Fntract\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0`d\x82\x01R`\x84\x01a\x02\x06V[__\x85`\x01`\x01`\xA0\x1B\x03\x16\x85`@Qa\x07\xB9\x91\x90a\x13JV[_`@Q\x80\x83\x03\x81\x85Z\xF4\x91PP=\x80_\x81\x14a\x07\xF1W`@Q\x91P`\x1F\x19`?=\x01\x16\x82\x01`@R=\x82R=_` \x84\x01>a\x07\xF6V[``\x91P[P\x91P\x91Pa\x08\x06\x82\x82\x86a\x08\xB6V[\x92PPP[\x93\x92PPPV[`\x01`\x01`\xA0\x1B\x03\x81\x16;a\x08\x8FW`@QbF\x1B\xCD`\xE5\x1B\x81R` `\x04\x82\x01R`7`$\x82\x01R\x7FERC1967: new secondary implement`D\x82\x01R\x7Fation is not a contract\0\0\0\0\0\0\0\0\0`d\x82\x01R`\x84\x01a\x02\x06V[\x80\x7F+\x1D\xBC\xE7C$$\x8C\"/\x0E\xC2\xD5\xED{\xD3#\xCF\xC4%\xB36\xF0%<\\\xCF\xDAreTma\x05\x97V[``\x83\x15a\x08\xC5WP\x81a\x08\x0BV[\x82Q\x15a\x08\xD5W\x82Q\x80\x84` \x01\xFD[\x81`@QbF\x1B\xCD`\xE5\x1B\x81R`\x04\x01a\x02\x06\x91\x90a\x13`V[cNH{q`\xE0\x1B_R`A`\x04R`$_\xFD[`@Q``\x81\x01g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x11\x82\x82\x10\x17\x15a\t&Wa\t&a\x08\xEFV[`@R\x90V[`@\x80Q\x90\x81\x01g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x11\x82\x82\x10\x17\x15a\t&Wa\t&a\x08\xEFV[`@Qa\x01 \x81\x01g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x11\x82\x82\x10\x17\x15a\t&Wa\t&a\x08\xEFV[`@Qa\x02\xA0\x81\x01g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x11\x82\x82\x10\x17\x15a\t&Wa\t&a\x08\xEFV[`@Q`\x1F\x82\x01`\x1F\x19\x16\x81\x01g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x11\x82\x82\x10\x17\x15a\t\xC0Wa\t\xC0a\x08\xEFV[`@R\x91\x90PV[\x805g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x16\x81\x14a\x02\x95W__\xFD[\x805`\x01`\x01`\xA0\x1B\x03\x81\x16\x81\x14a\x02\x95W__\xFD[_\x82`\x1F\x83\x01\x12a\n\x04W__\xFD[\x815g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x11\x15a\n\x1EWa\n\x1Ea\x08\xEFV[a\n1` `\x1F\x19`\x1F\x84\x01\x16\x01a\t\x97V[\x81\x81R\x84` \x83\x86\x01\x01\x11\x15a\nEW__\xFD[\x81` \x85\x01` \x83\x017_\x91\x81\x01` \x01\x91\x90\x91R\x93\x92PPPV[_\x82`\x1F\x83\x01\x12a\npW__\xFD[\x815g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x11\x15a\n\x8AWa\n\x8Aa\x08\xEFV[\x80`\x05\x1Ba\n\x9A` \x82\x01a\t\x97V[\x91\x82R` \x81\x85\x01\x81\x01\x92\x90\x81\x01\x90\x86\x84\x11\x15a\n\xB5W__\xFD[` \x86\x01\x92P[\x83\x83\x10\x15a\n\xD7W\x825\x82R` \x92\x83\x01\x92\x90\x91\x01\x90a\n\xBCV[\x96\x95PPPPPPV[_`\x80\x82\x84\x03\x12\x15a\n\xF1W__\xFD[`@Q`\x80\x81\x01g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x11\x82\x82\x10\x17\x15a\x0B\x14Wa\x0B\x14a\x08\xEFV[`@\x90\x81R\x835\x82R` \x80\x85\x015\x90\x83\x01R\x83\x81\x015\x90\x82\x01R``\x92\x83\x015\x92\x81\x01\x92\x90\x92RP\x91\x90PV[_\x82`\x1F\x83\x01\x12a\x0BQW__\xFD[a\x0B[`@a\t\x97V[\x80`@\x84\x01\x85\x81\x11\x15a\x0BlW__\xFD[\x84[\x81\x81\x10\x15a\x0B\x8DWa\x0B\x7F\x81a\t\xC8V[\x84R` \x93\x84\x01\x93\x01a\x0BnV[P\x90\x95\x94PPPPPV[\x805`\x03\x81\x10a\x02\x95W__\xFD[_\x81\x83\x03`\xC0\x81\x12\x15a\x0B\xB7W__\xFD[a\x0B\xBFa\t\x03V[\x91P`\x80\x81\x12\x15a\x0B\xCEW__\xFD[Pa\x0B\xD7a\t,V[\x83`\x1F\x84\x01\x12a\x0B\xE5W__\xFD[a\x0B\xEF`@a\t\x97V[\x80`@\x85\x01\x86\x81\x11\x15a\x0C\0W__\xFD[\x85[\x81\x81\x10\x15a\x0C\x1AW\x805\x84R` \x93\x84\x01\x93\x01a\x0C\x02V[P\x81\x84Ra\x0C(\x87\x82a\x0BBV[` \x85\x01RPPP\x81Ra\x0C>`\x80\x83\x01a\x0B\x98V[` \x82\x01R`\xA0\x91\x90\x91\x015`@\x82\x01R\x91\x90PV[\x805`\xFF\x81\x16\x81\x14a\x02\x95W__\xFD[_``\x82\x84\x03\x12\x15a\x0CtW__\xFD[a\x0C|a\t\x03V[\x90Pa\x0C\x87\x82a\t\xC8V[\x81Ra\x0C\x95` \x83\x01a\t\xC8V[` \x82\x01Ra\x0C\xA6`@\x83\x01a\t\xC8V[`@\x82\x01R\x92\x91PPV[_a\x01 \x82\x84\x03\x12\x15a\x0C\xC2W__\xFD[a\x0C\xCAa\tOV[\x90Pa\x0C\xD5\x82a\t\xDFV[\x81Ra\x0C\xE3` \x83\x01a\t\xDFV[` \x82\x01Ra\x0C\xF4`@\x83\x01a\t\xDFV[`@\x82\x01Ra\r\x05``\x83\x01a\t\xDFV[``\x82\x01Ra\r\x16`\x80\x83\x01a\t\xDFV[`\x80\x82\x01Ra\r'`\xA0\x83\x01a\t\xDFV[`\xA0\x82\x01Ra\r8`\xC0\x83\x01a\t\xDFV[`\xC0\x82\x01Ra\rI`\xE0\x83\x01a\t\xDFV[`\xE0\x82\x01Ra\r[a\x01\0\x83\x01a\t\xDFV[a\x01\0\x82\x01R\x92\x91PPV[__a\x01@\x83\x85\x03\x12\x15a\ryW__\xFD[\x825g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x11\x15a\r\x8FW__\xFD[\x83\x01a\x03\xE0\x81\x86\x03\x12\x15a\r\xA1W__\xFD[a\r\xA9a\tsV[a\r\xB2\x82a\t\xC8V[\x81Ra\r\xC0` \x83\x01a\t\xDFV[` \x82\x01R`@\x82\x81\x015\x90\x82\x01R``\x80\x83\x015\x90\x82\x01Ra\r\xE5`\x80\x83\x01a\t\xDFV[`\x80\x82\x01Ra\r\xF6`\xA0\x83\x01a\t\xDFV[`\xA0\x82\x01R`\xC0\x82\x81\x015\x90\x82\x01R`\xE0\x82\x015g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x11\x15a\x0E\x1EW__\xFD[a\x0E*\x87\x82\x85\x01a\t\xF5V[`\xE0\x83\x01RPa\x01\0\x82\x81\x015\x90\x82\x01Ra\x0EHa\x01 \x83\x01a\t\xC8V[a\x01 \x82\x01Ra\x01@\x82\x015g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x11\x15a\x0EhW__\xFD[a\x0Et\x87\x82\x85\x01a\naV[a\x01@\x83\x01RPa\x0E\x89\x86a\x01`\x84\x01a\n\xE1V[a\x01`\x82\x01Ra\x01\xE0\x82\x015a\x01\x80\x82\x01Ra\x02\0\x82\x015a\x01\xA0\x82\x01Ra\x02 \x82\x015a\x01\xC0\x82\x01Ra\x0E\xC1\x86a\x02@\x84\x01a\x0B\xA6V[a\x01\xE0\x82\x01Ra\x03\0\x82\x015a\x02\0\x82\x01Ra\x0E\xE0a\x03 \x83\x01a\t\xDFV[a\x02 \x82\x01Ra\x0E\xF3a\x03@\x83\x01a\x0CTV[a\x02@\x82\x01Ra\x0F\x06a\x03`\x83\x01a\t\xC8V[a\x02`\x82\x01Ra\x0F\x1A\x86a\x03\x80\x84\x01a\x0CdV[a\x02\x80\x82\x01R\x92Pa\x0F1\x90P\x84` \x85\x01a\x0C\xB1V[\x90P\x92P\x92\x90PV[_\x81Q\x80\x84R\x80` \x84\x01` \x86\x01^_` \x82\x86\x01\x01R` `\x1F\x19`\x1F\x83\x01\x16\x85\x01\x01\x91PP\x92\x91PPV[_\x81Q\x80\x84R` \x84\x01\x93P` \x83\x01_[\x82\x81\x10\x15a\x0F\x98W\x81Q\x86R` \x95\x86\x01\x95\x90\x91\x01\x90`\x01\x01a\x0FzV[P\x93\x94\x93PPPPV[`\x03\x81\x10a\x0F\xBEWcNH{q`\xE0\x1B_R`!`\x04R`$_\xFD[\x90RV[\x80Q\x80Q\x83_[`\x02\x81\x10\x15a\x0F\xE8W\x82Q\x82R` \x92\x83\x01\x92\x90\x91\x01\x90`\x01\x01a\x0F\xC9V[PPP` \x01Q`@\x83\x01_[`\x02\x81\x10\x15a\x10\x1EW\x82Qg\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x82R` \x92\x83\x01\x92\x90\x91\x01\x90`\x01\x01a\x0F\xF5V[PPP` \x81\x01Qa\x103`\x80\x84\x01\x82a\x0F\xA2V[P`@\x01Q`\xA0\x91\x90\x91\x01RV[`\x01`\x01`\xA0\x1B\x03\x81Q\x16\x82R` \x81\x01Qa\x10h` \x84\x01\x82`\x01`\x01`\xA0\x1B\x03\x16\x90RV[P`@\x81\x01Qa\x10\x83`@\x84\x01\x82`\x01`\x01`\xA0\x1B\x03\x16\x90RV[P``\x81\x01Qa\x10\x9E``\x84\x01\x82`\x01`\x01`\xA0\x1B\x03\x16\x90RV[P`\x80\x81\x01Qa\x10\xB9`\x80\x84\x01\x82`\x01`\x01`\xA0\x1B\x03\x16\x90RV[P`\xA0\x81\x01Qa\x10\xD4`\xA0\x84\x01\x82`\x01`\x01`\xA0\x1B\x03\x16\x90RV[P`\xC0\x81\x01Qa\x10\xEF`\xC0\x84\x01\x82`\x01`\x01`\xA0\x1B\x03\x16\x90RV[P`\xE0\x81\x01Qa\x11\n`\xE0\x84\x01\x82`\x01`\x01`\xA0\x1B\x03\x16\x90RV[Pa\x01\0\x81\x01Qa\x02\xB8a\x01\0\x84\x01\x82`\x01`\x01`\xA0\x1B\x03\x16\x90RV[a\x01@\x81Ra\x11Da\x01@\x82\x01\x84Qg\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x90RV[_` \x84\x01Qa\x11`a\x01`\x84\x01\x82`\x01`\x01`\xA0\x1B\x03\x16\x90RV[P`@\x84\x01Qa\x01\x80\x83\x01R``\x84\x01Qa\x01\xA0\x83\x01R`\x80\x84\x01Q`\x01`\x01`\xA0\x1B\x03\x90\x81\x16a\x01\xC0\x84\x01R`\xA0\x85\x01Q\x16a\x01\xE0\x83\x01R`\xC0\x84\x01Qa\x02\0\x83\x01R`\xE0\x84\x01Qa\x03\xE0a\x02 \x84\x01Ra\x11\xC0a\x05 \x84\x01\x82a\x0F:V[\x90Pa\x01\0\x85\x01Qa\x02@\x84\x01Ra\x01 \x85\x01Qa\x11\xEBa\x02`\x85\x01\x82g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x90RV[Pa\x01@\x85\x01Q\x7F\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFE\xC0\x84\x83\x03\x01a\x02\x80\x85\x01Ra\x12'\x82\x82a\x0FhV[a\x01`\x87\x01Q\x80Qa\x02\xA0\x87\x01R` \x81\x01Qa\x02\xC0\x87\x01R`@\x81\x01Qa\x02\xE0\x87\x01R``\x01Qa\x03\0\x86\x01Ra\x01\x80\x87\x01Qa\x03 \x86\x01Ra\x01\xA0\x87\x01Qa\x03@\x86\x01Ra\x01\xC0\x87\x01Qa\x03`\x86\x01Ra\x01\xE0\x87\x01Q\x90\x92P\x90Pa\x12\x92a\x03\x80\x85\x01\x82a\x0F\xC2V[Pa\x02\0\x85\x01Qa\x04@\x84\x01Ra\x02 \x85\x01Q`\x01`\x01`\xA0\x1B\x03\x16a\x04`\x84\x01Ra\x02@\x85\x01Q`\xFF\x16a\x04\x80\x84\x01Ra\x02`\x85\x01Qg\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x90\x81\x16a\x04\xA0\x85\x01Ra\x02\x80\x86\x01Q\x80Q\x82\x16a\x04\xC0\x86\x01R` \x80\x82\x01Q\x83\x16a\x04\xE0\x87\x01R`@\x90\x91\x01Q\x90\x91\x16a\x05\0\x85\x01R\x90\x91Pa\x08\x0B\x90\x83\x01\x84a\x10AV[\x81\x81\x03\x81\x81\x11\x15a\x067WcNH{q`\xE0\x1B_R`\x11`\x04R`$_\xFD[cNH{q`\xE0\x1B_R`\x01`\x04R`$_\xFD[_\x82Q\x80` \x85\x01\x84^_\x92\x01\x91\x82RP\x91\x90PV[` \x81R_a\x064` \x83\x01\x84a\x0F:V\xFEAddress: low-level delegate call failed\xA2dipfsX\"\x12 \x9B\xF2\xC0#\x8C%\x05qk\xE0\xE1\xD0M\xF7\x88\x9DN\xDBP$\xE1\xBA(\xC8\xC3 \xA9(z\xBF\xD2\\dsolcC\0\x08\x1C\x003`\x80`@R`@Qa\r\x918\x03\x80a\r\x91\x839\x81\x01`@\x81\x90Ra\0\"\x91a\x03\xB7V[\x82\x81a\0/\x82\x82_a\0CV[Pa\0;\x90P\x82a\0nV[PPPa\x04\xD3V[a\0L\x83a\0\xDBV[_\x82Q\x11\x80a\0XWP\x80[\x15a\0iWa\0g\x83\x83a\x01\x1AV[P[PPPV[\x7F~dMyB/\x17\xC0\x1EH\x94\xB5\xF4\xF5\x88\xD31\xEB\xFA(e=B\xAE\x83-\xC5\x9E8\xC9y\x8Fa\0\xAD_Q` a\rJ_9_Q\x90_RT`\x01`\x01`\xA0\x1B\x03\x16\x90V[`@\x80Q`\x01`\x01`\xA0\x1B\x03\x92\x83\x16\x81R\x91\x84\x16` \x83\x01R\x01`@Q\x80\x91\x03\x90\xA1a\0\xD8\x81a\x01FV[PV[a\0\xE4\x81a\x01\xE1V[`@Q`\x01`\x01`\xA0\x1B\x03\x82\x16\x90\x7F\xBC|\xD7Z \xEE'\xFD\x9A\xDE\xBA\xB3 A\xF7U!M\xBCk\xFF\xA9\x0C\xC0\"[9\xDA.\\-;\x90_\x90\xA2PV[``a\x01?\x83\x83`@Q\x80``\x01`@R\x80`'\x81R` \x01a\rj`'\x919a\x02uV[\x93\x92PPPV[`\x01`\x01`\xA0\x1B\x03\x81\x16a\x01\xB0W`@QbF\x1B\xCD`\xE5\x1B\x81R` `\x04\x82\x01R`&`$\x82\x01R\x7FERC1967: new admin is the zero a`D\x82\x01Reddress`\xD0\x1B`d\x82\x01R`\x84\x01[`@Q\x80\x91\x03\x90\xFD[\x80_Q` a\rJ_9_Q\x90_R[\x80T`\x01`\x01`\xA0\x1B\x03\x19\x16`\x01`\x01`\xA0\x1B\x03\x92\x90\x92\x16\x91\x90\x91\x17\x90UPV[`\x01`\x01`\xA0\x1B\x03\x81\x16;a\x02NW`@QbF\x1B\xCD`\xE5\x1B\x81R` `\x04\x82\x01R`-`$\x82\x01R\x7FERC1967: new implementation is n`D\x82\x01Rl\x1B\xDD\x08\x18H\x18\xDB\xDB\x9D\x1C\x98X\xDD`\x9A\x1B`d\x82\x01R`\x84\x01a\x01\xA7V[\x80\x7F6\x08\x94\xA1;\xA1\xA3!\x06g\xC8(I-\xB9\x8D\xCA> v\xCC75\xA9 \xA3\xCAP]8+\xBCa\x01\xC0V[```\x01`\x01`\xA0\x1B\x03\x84\x16;a\x02\xDDW`@QbF\x1B\xCD`\xE5\x1B\x81R` `\x04\x82\x01R`&`$\x82\x01R\x7FAddress: delegate call to non-co`D\x82\x01Re\x1B\x9D\x1C\x98X\xDD`\xD2\x1B`d\x82\x01R`\x84\x01a\x01\xA7V[__\x85`\x01`\x01`\xA0\x1B\x03\x16\x85`@Qa\x02\xF7\x91\x90a\x04\x88V[_`@Q\x80\x83\x03\x81\x85Z\xF4\x91PP=\x80_\x81\x14a\x03/W`@Q\x91P`\x1F\x19`?=\x01\x16\x82\x01`@R=\x82R=_` \x84\x01>a\x034V[``\x91P[P\x90\x92P\x90Pa\x03E\x82\x82\x86a\x03OV[\x96\x95PPPPPPV[``\x83\x15a\x03^WP\x81a\x01?V[\x82Q\x15a\x03nW\x82Q\x80\x84` \x01\xFD[\x81`@QbF\x1B\xCD`\xE5\x1B\x81R`\x04\x01a\x01\xA7\x91\x90a\x04\x9EV[\x80Q`\x01`\x01`\xA0\x1B\x03\x81\x16\x81\x14a\x03\x9EW__\xFD[\x91\x90PV[cNH{q`\xE0\x1B_R`A`\x04R`$_\xFD[___``\x84\x86\x03\x12\x15a\x03\xC9W__\xFD[a\x03\xD2\x84a\x03\x88V[\x92Pa\x03\xE0` \x85\x01a\x03\x88V[`@\x85\x01Q\x90\x92P`\x01`\x01`@\x1B\x03\x81\x11\x15a\x03\xFBW__\xFD[\x84\x01`\x1F\x81\x01\x86\x13a\x04\x0BW__\xFD[\x80Q`\x01`\x01`@\x1B\x03\x81\x11\x15a\x04$Wa\x04$a\x03\xA3V[`@Q`\x1F\x82\x01`\x1F\x19\x90\x81\x16`?\x01\x16\x81\x01`\x01`\x01`@\x1B\x03\x81\x11\x82\x82\x10\x17\x15a\x04RWa\x04Ra\x03\xA3V[`@R\x81\x81R\x82\x82\x01` \x01\x88\x10\x15a\x04iW__\xFD[\x81` \x84\x01` \x83\x01^_` \x83\x83\x01\x01R\x80\x93PPPP\x92P\x92P\x92V[_\x82Q\x80` \x85\x01\x84^_\x92\x01\x91\x82RP\x91\x90PV[` \x81R_\x82Q\x80` \x84\x01R\x80` \x85\x01`@\x85\x01^_`@\x82\x85\x01\x01R`@`\x1F\x19`\x1F\x83\x01\x16\x84\x01\x01\x91PP\x92\x91PPV[a\x08j\x80a\x04\xE0_9_\xF3\xFE`\x80`@R`\x046\x10a\0]W_5`\xE0\x1C\x80c\\`\xDA\x1B\x11a\0BW\x80c\\`\xDA\x1B\x14a\0\xA6W\x80c\x8F(9p\x14a\0\xD6W\x80c\xF8Q\xA4@\x14a\0\xF5Wa\0lV[\x80c6Y\xCF\xE6\x14a\0tW\x80cO\x1E\xF2\x86\x14a\0\x93Wa\0lV[6a\0lWa\0ja\x01\tV[\0[a\0ja\x01\tV[4\x80\x15a\0\x7FW__\xFD[Pa\0ja\0\x8E6`\x04a\x07\rV[a\x01#V[a\0ja\0\xA16`\x04a\x07&V[a\x01^V[4\x80\x15a\0\xB1W__\xFD[Pa\0\xBAa\x01\xC4V[`@Q`\x01`\x01`\xA0\x1B\x03\x90\x91\x16\x81R` \x01`@Q\x80\x91\x03\x90\xF3[4\x80\x15a\0\xE1W__\xFD[Pa\0ja\0\xF06`\x04a\x07\rV[a\x01\xF4V[4\x80\x15a\x01\0W__\xFD[Pa\0\xBAa\x02\x14V[a\x01\x11a\x024V[a\x01!a\x01\x1Ca\x02\xE4V[a\x02\xEDV[V[a\x01+a\x03\x0BV[`\x01`\x01`\xA0\x1B\x03\x163\x03a\x01VWa\x01S\x81`@Q\x80` \x01`@R\x80_\x81RP_a\x03=V[PV[a\x01Sa\x01\tV[a\x01fa\x03\x0BV[`\x01`\x01`\xA0\x1B\x03\x163\x03a\x01\xBCWa\x01\xB7\x83\x83\x83\x80\x80`\x1F\x01` \x80\x91\x04\x02` \x01`@Q\x90\x81\x01`@R\x80\x93\x92\x91\x90\x81\x81R` \x01\x83\x83\x80\x82\x847_\x92\x01\x91\x90\x91RP`\x01\x92Pa\x03=\x91PPV[PPPV[a\x01\xB7a\x01\tV[_a\x01\xCDa\x03\x0BV[`\x01`\x01`\xA0\x1B\x03\x163\x03a\x01\xE9Wa\x01\xE4a\x02\xE4V[\x90P\x90V[a\x01\xF1a\x01\tV[\x90V[a\x01\xFCa\x03\x0BV[`\x01`\x01`\xA0\x1B\x03\x163\x03a\x01VWa\x01S\x81a\x03gV[_a\x02\x1Da\x03\x0BV[`\x01`\x01`\xA0\x1B\x03\x163\x03a\x01\xE9Wa\x01\xE4a\x03\x0BV[a\x02<a\x03\x0BV[`\x01`\x01`\xA0\x1B\x03\x163\x03a\x01!W`@QbF\x1B\xCD`\xE5\x1B\x81R` `\x04\x82\x01R`B`$\x82\x01R\x7FTransparentUpgradeableProxy: adm`D\x82\x01R\x7Fin cannot fallback to proxy targ`d\x82\x01R\x7Fet\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0`\x84\x82\x01R`\xA4\x01[`@Q\x80\x91\x03\x90\xFD[_a\x01\xE4a\x03\xBBV[6__7__6_\x84Z\xF4=__>\x80\x80\x15a\x03\x07W=_\xF3[=_\xFD[_\x7F\xB51'hJV\x8B1s\xAE\x13\xB9\xF8\xA6\x01n$>c\xB6\xE8\xEE\x11x\xD6\xA7\x17\x85\x0B]a\x03[T`\x01`\x01`\xA0\x1B\x03\x16\x91\x90PV[a\x03F\x83a\x03\xE2V[_\x82Q\x11\x80a\x03RWP\x80[\x15a\x01\xB7Wa\x03a\x83\x83a\x04!V[PPPPV[\x7F~dMyB/\x17\xC0\x1EH\x94\xB5\xF4\xF5\x88\xD31\xEB\xFA(e=B\xAE\x83-\xC5\x9E8\xC9y\x8Fa\x03\x90a\x03\x0BV[`@\x80Q`\x01`\x01`\xA0\x1B\x03\x92\x83\x16\x81R\x91\x84\x16` \x83\x01R\x01`@Q\x80\x91\x03\x90\xA1a\x01S\x81a\x04MV[_\x7F6\x08\x94\xA1;\xA1\xA3!\x06g\xC8(I-\xB9\x8D\xCA> v\xCC75\xA9 \xA3\xCAP]8+\xBCa\x03.V[a\x03\xEB\x81a\x05%V[`@Q`\x01`\x01`\xA0\x1B\x03\x82\x16\x90\x7F\xBC|\xD7Z \xEE'\xFD\x9A\xDE\xBA\xB3 A\xF7U!M\xBCk\xFF\xA9\x0C\xC0\"[9\xDA.\\-;\x90_\x90\xA2PV[``a\x04F\x83\x83`@Q\x80``\x01`@R\x80`'\x81R` \x01a\x08\x0E`'\x919a\x05\xC9V[\x93\x92PPPV[`\x01`\x01`\xA0\x1B\x03\x81\x16a\x04\xC9W`@QbF\x1B\xCD`\xE5\x1B\x81R` `\x04\x82\x01R`&`$\x82\x01R\x7FERC1967: new admin is the zero a`D\x82\x01R\x7Fddress\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0`d\x82\x01R`\x84\x01a\x02\xDBV[\x80\x7F\xB51'hJV\x8B1s\xAE\x13\xB9\xF8\xA6\x01n$>c\xB6\xE8\xEE\x11x\xD6\xA7\x17\x85\x0B]a\x03[\x80T\x7F\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x16`\x01`\x01`\xA0\x1B\x03\x92\x90\x92\x16\x91\x90\x91\x17\x90UPV[`\x01`\x01`\xA0\x1B\x03\x81\x16;a\x05\xA2W`@QbF\x1B\xCD`\xE5\x1B\x81R` `\x04\x82\x01R`-`$\x82\x01R\x7FERC1967: new implementation is n`D\x82\x01R\x7Fot a contract\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0`d\x82\x01R`\x84\x01a\x02\xDBV[\x80\x7F6\x08\x94\xA1;\xA1\xA3!\x06g\xC8(I-\xB9\x8D\xCA> v\xCC75\xA9 \xA3\xCAP]8+\xBCa\x04\xECV[```\x01`\x01`\xA0\x1B\x03\x84\x16;a\x06HW`@QbF\x1B\xCD`\xE5\x1B\x81R` `\x04\x82\x01R`&`$\x82\x01R\x7FAddress: delegate call to non-co`D\x82\x01R\x7Fntract\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0`d\x82\x01R`\x84\x01a\x02\xDBV[__\x85`\x01`\x01`\xA0\x1B\x03\x16\x85`@Qa\x06b\x91\x90a\x07\xA4V[_`@Q\x80\x83\x03\x81\x85Z\xF4\x91PP=\x80_\x81\x14a\x06\x9AW`@Q\x91P`\x1F\x19`?=\x01\x16\x82\x01`@R=\x82R=_` \x84\x01>a\x06\x9FV[``\x91P[P\x91P\x91Pa\x06\xAF\x82\x82\x86a\x06\xB9V[\x96\x95PPPPPPV[``\x83\x15a\x06\xC8WP\x81a\x04FV[\x82Q\x15a\x06\xD8W\x82Q\x80\x84` \x01\xFD[\x81`@QbF\x1B\xCD`\xE5\x1B\x81R`\x04\x01a\x02\xDB\x91\x90a\x07\xBAV[\x805`\x01`\x01`\xA0\x1B\x03\x81\x16\x81\x14a\x07\x08W__\xFD[\x91\x90PV[_` \x82\x84\x03\x12\x15a\x07\x1DW__\xFD[a\x04F\x82a\x06\xF2V[___`@\x84\x86\x03\x12\x15a\x078W__\xFD[a\x07A\x84a\x06\xF2V[\x92P` \x84\x015g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x11\x15a\x07\\W__\xFD[\x84\x01`\x1F\x81\x01\x86\x13a\x07lW__\xFD[\x805g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x11\x15a\x07\x82W__\xFD[\x86` \x82\x84\x01\x01\x11\x15a\x07\x93W__\xFD[\x93\x96` \x91\x90\x91\x01\x95P\x92\x93PPPV[_\x82Q\x80` \x85\x01\x84^_\x92\x01\x91\x82RP\x91\x90PV[` \x81R_\x82Q\x80` \x84\x01R\x80` \x85\x01`@\x85\x01^_`@\x82\x85\x01\x01R`@\x7F\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xE0`\x1F\x83\x01\x16\x84\x01\x01\x91PP\x92\x91PPV\xFEAddress: low-level delegate call failed\xA2dipfsX\"\x12 \xA4\\\\\x13\x90\x96\x13\xFB\x1CD\xF2I\xCEw\xBF\xB0<\xDFG\xA4\xF4+\xCC\x05\xD7\x96\xFA\x83\xA5\x95\xAC\xCBdsolcC\0\x08\x1C\x003\xB51'hJV\x8B1s\xAE\x13\xB9\xF8\xA6\x01n$>c\xB6\xE8\xEE\x11x\xD6\xA7\x17\x85\x0B]a\x03Address: low-level delegate call failed\xA2dipfsX\"\x12 \x99\xE3\x83\xA1c\xF1LH/[\xA6d\"\"c\xEF\x94\xD0\x8F\x10\x18\xD2\x89\x952\x92\xED}=I\x86ddsolcC\0\x08\x1C\x003",
    );
    /**```solidity
struct BufferConfig { uint64 threshold; uint64 max; uint64 replenishRateInBasis; }
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct BufferConfig {
        #[allow(missing_docs)]
        pub threshold: u64,
        #[allow(missing_docs)]
        pub max: u64,
        #[allow(missing_docs)]
        pub replenishRateInBasis: u64,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = (
            alloy::sol_types::sol_data::Uint<64>,
            alloy::sol_types::sol_data::Uint<64>,
            alloy::sol_types::sol_data::Uint<64>,
        );
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = (u64, u64, u64);
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<BufferConfig> for UnderlyingRustTuple<'_> {
            fn from(value: BufferConfig) -> Self {
                (value.threshold, value.max, value.replenishRateInBasis)
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for BufferConfig {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self {
                    threshold: tuple.0,
                    max: tuple.1,
                    replenishRateInBasis: tuple.2,
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolValue for BufferConfig {
            type SolType = Self;
        }
        #[automatically_derived]
        impl alloy_sol_types::private::SolTypeValue<Self> for BufferConfig {
            #[inline]
            fn stv_to_tokens(&self) -> <Self as alloy_sol_types::SolType>::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        64,
                    > as alloy_sol_types::SolType>::tokenize(&self.threshold),
                    <alloy::sol_types::sol_data::Uint<
                        64,
                    > as alloy_sol_types::SolType>::tokenize(&self.max),
                    <alloy::sol_types::sol_data::Uint<
                        64,
                    > as alloy_sol_types::SolType>::tokenize(&self.replenishRateInBasis),
                )
            }
            #[inline]
            fn stv_abi_encoded_size(&self) -> usize {
                if let Some(size) = <Self as alloy_sol_types::SolType>::ENCODED_SIZE {
                    return size;
                }
                let tuple = <UnderlyingRustTuple<
                    '_,
                > as ::core::convert::From<Self>>::from(self.clone());
                <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_encoded_size(&tuple)
            }
            #[inline]
            fn stv_eip712_data_word(&self) -> alloy_sol_types::Word {
                <Self as alloy_sol_types::SolStruct>::eip712_hash_struct(self)
            }
            #[inline]
            fn stv_abi_encode_packed_to(
                &self,
                out: &mut alloy_sol_types::private::Vec<u8>,
            ) {
                let tuple = <UnderlyingRustTuple<
                    '_,
                > as ::core::convert::From<Self>>::from(self.clone());
                <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_encode_packed_to(&tuple, out)
            }
            #[inline]
            fn stv_abi_packed_encoded_size(&self) -> usize {
                if let Some(size) = <Self as alloy_sol_types::SolType>::PACKED_ENCODED_SIZE {
                    return size;
                }
                let tuple = <UnderlyingRustTuple<
                    '_,
                > as ::core::convert::From<Self>>::from(self.clone());
                <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_packed_encoded_size(&tuple)
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolType for BufferConfig {
            type RustType = Self;
            type Token<'a> = <UnderlyingSolTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SOL_NAME: &'static str = <Self as alloy_sol_types::SolStruct>::NAME;
            const ENCODED_SIZE: Option<usize> = <UnderlyingSolTuple<
                '_,
            > as alloy_sol_types::SolType>::ENCODED_SIZE;
            const PACKED_ENCODED_SIZE: Option<usize> = <UnderlyingSolTuple<
                '_,
            > as alloy_sol_types::SolType>::PACKED_ENCODED_SIZE;
            #[inline]
            fn valid_token(token: &Self::Token<'_>) -> bool {
                <UnderlyingSolTuple<'_> as alloy_sol_types::SolType>::valid_token(token)
            }
            #[inline]
            fn detokenize(token: Self::Token<'_>) -> Self::RustType {
                let tuple = <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::detokenize(token);
                <Self as ::core::convert::From<UnderlyingRustTuple<'_>>>::from(tuple)
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolStruct for BufferConfig {
            const NAME: &'static str = "BufferConfig";
            #[inline]
            fn eip712_root_type() -> alloy_sol_types::private::Cow<'static, str> {
                alloy_sol_types::private::Cow::Borrowed(
                    "BufferConfig(uint64 threshold,uint64 max,uint64 replenishRateInBasis)",
                )
            }
            #[inline]
            fn eip712_components() -> alloy_sol_types::private::Vec<
                alloy_sol_types::private::Cow<'static, str>,
            > {
                alloy_sol_types::private::Vec::new()
            }
            #[inline]
            fn eip712_encode_type() -> alloy_sol_types::private::Cow<'static, str> {
                <Self as alloy_sol_types::SolStruct>::eip712_root_type()
            }
            #[inline]
            fn eip712_encode_data(&self) -> alloy_sol_types::private::Vec<u8> {
                [
                    <alloy::sol_types::sol_data::Uint<
                        64,
                    > as alloy_sol_types::SolType>::eip712_data_word(&self.threshold)
                        .0,
                    <alloy::sol_types::sol_data::Uint<
                        64,
                    > as alloy_sol_types::SolType>::eip712_data_word(&self.max)
                        .0,
                    <alloy::sol_types::sol_data::Uint<
                        64,
                    > as alloy_sol_types::SolType>::eip712_data_word(
                            &self.replenishRateInBasis,
                        )
                        .0,
                ]
                    .concat()
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::EventTopic for BufferConfig {
            #[inline]
            fn topic_preimage_length(rust: &Self::RustType) -> usize {
                0usize
                    + <alloy::sol_types::sol_data::Uint<
                        64,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.threshold,
                    )
                    + <alloy::sol_types::sol_data::Uint<
                        64,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(&rust.max)
                    + <alloy::sol_types::sol_data::Uint<
                        64,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.replenishRateInBasis,
                    )
            }
            #[inline]
            fn encode_topic_preimage(
                rust: &Self::RustType,
                out: &mut alloy_sol_types::private::Vec<u8>,
            ) {
                out.reserve(
                    <Self as alloy_sol_types::EventTopic>::topic_preimage_length(rust),
                );
                <alloy::sol_types::sol_data::Uint<
                    64,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.threshold,
                    out,
                );
                <alloy::sol_types::sol_data::Uint<
                    64,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(&rust.max, out);
                <alloy::sol_types::sol_data::Uint<
                    64,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.replenishRateInBasis,
                    out,
                );
            }
            #[inline]
            fn encode_topic(
                rust: &Self::RustType,
            ) -> alloy_sol_types::abi::token::WordToken {
                let mut out = alloy_sol_types::private::Vec::new();
                <Self as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    rust,
                    &mut out,
                );
                alloy_sol_types::abi::token::WordToken(
                    alloy_sol_types::private::keccak256(out),
                )
            }
        }
    };
    /**```solidity
struct Contracts { address excessStakeReceiver; address rollup; address bridge; address sequencerInbox; address rollupEventInbox; address outbox; address inbox; address osp; }
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct Contracts {
        #[allow(missing_docs)]
        pub excessStakeReceiver: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub rollup: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub bridge: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub sequencerInbox: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub rollupEventInbox: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub outbox: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub inbox: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub osp: alloy::sol_types::private::Address,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = (
            alloy::sol_types::sol_data::Address,
            alloy::sol_types::sol_data::Address,
            alloy::sol_types::sol_data::Address,
            alloy::sol_types::sol_data::Address,
            alloy::sol_types::sol_data::Address,
            alloy::sol_types::sol_data::Address,
            alloy::sol_types::sol_data::Address,
            alloy::sol_types::sol_data::Address,
        );
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = (
            alloy::sol_types::private::Address,
            alloy::sol_types::private::Address,
            alloy::sol_types::private::Address,
            alloy::sol_types::private::Address,
            alloy::sol_types::private::Address,
            alloy::sol_types::private::Address,
            alloy::sol_types::private::Address,
            alloy::sol_types::private::Address,
        );
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<Contracts> for UnderlyingRustTuple<'_> {
            fn from(value: Contracts) -> Self {
                (
                    value.excessStakeReceiver,
                    value.rollup,
                    value.bridge,
                    value.sequencerInbox,
                    value.rollupEventInbox,
                    value.outbox,
                    value.inbox,
                    value.osp,
                )
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for Contracts {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self {
                    excessStakeReceiver: tuple.0,
                    rollup: tuple.1,
                    bridge: tuple.2,
                    sequencerInbox: tuple.3,
                    rollupEventInbox: tuple.4,
                    outbox: tuple.5,
                    inbox: tuple.6,
                    osp: tuple.7,
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolValue for Contracts {
            type SolType = Self;
        }
        #[automatically_derived]
        impl alloy_sol_types::private::SolTypeValue<Self> for Contracts {
            #[inline]
            fn stv_to_tokens(&self) -> <Self as alloy_sol_types::SolType>::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.excessStakeReceiver,
                    ),
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.rollup,
                    ),
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.bridge,
                    ),
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.sequencerInbox,
                    ),
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.rollupEventInbox,
                    ),
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.outbox,
                    ),
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.inbox,
                    ),
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.osp,
                    ),
                )
            }
            #[inline]
            fn stv_abi_encoded_size(&self) -> usize {
                if let Some(size) = <Self as alloy_sol_types::SolType>::ENCODED_SIZE {
                    return size;
                }
                let tuple = <UnderlyingRustTuple<
                    '_,
                > as ::core::convert::From<Self>>::from(self.clone());
                <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_encoded_size(&tuple)
            }
            #[inline]
            fn stv_eip712_data_word(&self) -> alloy_sol_types::Word {
                <Self as alloy_sol_types::SolStruct>::eip712_hash_struct(self)
            }
            #[inline]
            fn stv_abi_encode_packed_to(
                &self,
                out: &mut alloy_sol_types::private::Vec<u8>,
            ) {
                let tuple = <UnderlyingRustTuple<
                    '_,
                > as ::core::convert::From<Self>>::from(self.clone());
                <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_encode_packed_to(&tuple, out)
            }
            #[inline]
            fn stv_abi_packed_encoded_size(&self) -> usize {
                if let Some(size) = <Self as alloy_sol_types::SolType>::PACKED_ENCODED_SIZE {
                    return size;
                }
                let tuple = <UnderlyingRustTuple<
                    '_,
                > as ::core::convert::From<Self>>::from(self.clone());
                <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_packed_encoded_size(&tuple)
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolType for Contracts {
            type RustType = Self;
            type Token<'a> = <UnderlyingSolTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SOL_NAME: &'static str = <Self as alloy_sol_types::SolStruct>::NAME;
            const ENCODED_SIZE: Option<usize> = <UnderlyingSolTuple<
                '_,
            > as alloy_sol_types::SolType>::ENCODED_SIZE;
            const PACKED_ENCODED_SIZE: Option<usize> = <UnderlyingSolTuple<
                '_,
            > as alloy_sol_types::SolType>::PACKED_ENCODED_SIZE;
            #[inline]
            fn valid_token(token: &Self::Token<'_>) -> bool {
                <UnderlyingSolTuple<'_> as alloy_sol_types::SolType>::valid_token(token)
            }
            #[inline]
            fn detokenize(token: Self::Token<'_>) -> Self::RustType {
                let tuple = <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::detokenize(token);
                <Self as ::core::convert::From<UnderlyingRustTuple<'_>>>::from(tuple)
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolStruct for Contracts {
            const NAME: &'static str = "Contracts";
            #[inline]
            fn eip712_root_type() -> alloy_sol_types::private::Cow<'static, str> {
                alloy_sol_types::private::Cow::Borrowed(
                    "Contracts(address excessStakeReceiver,address rollup,address bridge,address sequencerInbox,address rollupEventInbox,address outbox,address inbox,address osp)",
                )
            }
            #[inline]
            fn eip712_components() -> alloy_sol_types::private::Vec<
                alloy_sol_types::private::Cow<'static, str>,
            > {
                alloy_sol_types::private::Vec::new()
            }
            #[inline]
            fn eip712_encode_type() -> alloy_sol_types::private::Cow<'static, str> {
                <Self as alloy_sol_types::SolStruct>::eip712_root_type()
            }
            #[inline]
            fn eip712_encode_data(&self) -> alloy_sol_types::private::Vec<u8> {
                [
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::eip712_data_word(
                            &self.excessStakeReceiver,
                        )
                        .0,
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::eip712_data_word(
                            &self.rollup,
                        )
                        .0,
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::eip712_data_word(
                            &self.bridge,
                        )
                        .0,
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::eip712_data_word(
                            &self.sequencerInbox,
                        )
                        .0,
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::eip712_data_word(
                            &self.rollupEventInbox,
                        )
                        .0,
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::eip712_data_word(
                            &self.outbox,
                        )
                        .0,
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::eip712_data_word(
                            &self.inbox,
                        )
                        .0,
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::eip712_data_word(
                            &self.osp,
                        )
                        .0,
                ]
                    .concat()
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::EventTopic for Contracts {
            #[inline]
            fn topic_preimage_length(rust: &Self::RustType) -> usize {
                0usize
                    + <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.excessStakeReceiver,
                    )
                    + <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.rollup,
                    )
                    + <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.bridge,
                    )
                    + <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.sequencerInbox,
                    )
                    + <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.rollupEventInbox,
                    )
                    + <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.outbox,
                    )
                    + <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.inbox,
                    )
                    + <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.osp,
                    )
            }
            #[inline]
            fn encode_topic_preimage(
                rust: &Self::RustType,
                out: &mut alloy_sol_types::private::Vec<u8>,
            ) {
                out.reserve(
                    <Self as alloy_sol_types::EventTopic>::topic_preimage_length(rust),
                );
                <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.excessStakeReceiver,
                    out,
                );
                <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.rollup,
                    out,
                );
                <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.bridge,
                    out,
                );
                <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.sequencerInbox,
                    out,
                );
                <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.rollupEventInbox,
                    out,
                );
                <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.outbox,
                    out,
                );
                <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.inbox,
                    out,
                );
                <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.osp,
                    out,
                );
            }
            #[inline]
            fn encode_topic(
                rust: &Self::RustType,
            ) -> alloy_sol_types::abi::token::WordToken {
                let mut out = alloy_sol_types::private::Vec::new();
                <Self as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    rust,
                    &mut out,
                );
                alloy_sol_types::abi::token::WordToken(
                    alloy_sol_types::private::keccak256(out),
                )
            }
        }
    };
    /**```solidity
struct Implementations { address bridge; address seqInbox; address inbox; address rei; address outbox; address newRollupUser; address newRollupAdmin; address challengeManager; }
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct Implementations {
        #[allow(missing_docs)]
        pub bridge: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub seqInbox: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub inbox: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub rei: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub outbox: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub newRollupUser: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub newRollupAdmin: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub challengeManager: alloy::sol_types::private::Address,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = (
            alloy::sol_types::sol_data::Address,
            alloy::sol_types::sol_data::Address,
            alloy::sol_types::sol_data::Address,
            alloy::sol_types::sol_data::Address,
            alloy::sol_types::sol_data::Address,
            alloy::sol_types::sol_data::Address,
            alloy::sol_types::sol_data::Address,
            alloy::sol_types::sol_data::Address,
        );
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = (
            alloy::sol_types::private::Address,
            alloy::sol_types::private::Address,
            alloy::sol_types::private::Address,
            alloy::sol_types::private::Address,
            alloy::sol_types::private::Address,
            alloy::sol_types::private::Address,
            alloy::sol_types::private::Address,
            alloy::sol_types::private::Address,
        );
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<Implementations> for UnderlyingRustTuple<'_> {
            fn from(value: Implementations) -> Self {
                (
                    value.bridge,
                    value.seqInbox,
                    value.inbox,
                    value.rei,
                    value.outbox,
                    value.newRollupUser,
                    value.newRollupAdmin,
                    value.challengeManager,
                )
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for Implementations {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self {
                    bridge: tuple.0,
                    seqInbox: tuple.1,
                    inbox: tuple.2,
                    rei: tuple.3,
                    outbox: tuple.4,
                    newRollupUser: tuple.5,
                    newRollupAdmin: tuple.6,
                    challengeManager: tuple.7,
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolValue for Implementations {
            type SolType = Self;
        }
        #[automatically_derived]
        impl alloy_sol_types::private::SolTypeValue<Self> for Implementations {
            #[inline]
            fn stv_to_tokens(&self) -> <Self as alloy_sol_types::SolType>::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.bridge,
                    ),
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.seqInbox,
                    ),
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.inbox,
                    ),
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.rei,
                    ),
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.outbox,
                    ),
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.newRollupUser,
                    ),
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.newRollupAdmin,
                    ),
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.challengeManager,
                    ),
                )
            }
            #[inline]
            fn stv_abi_encoded_size(&self) -> usize {
                if let Some(size) = <Self as alloy_sol_types::SolType>::ENCODED_SIZE {
                    return size;
                }
                let tuple = <UnderlyingRustTuple<
                    '_,
                > as ::core::convert::From<Self>>::from(self.clone());
                <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_encoded_size(&tuple)
            }
            #[inline]
            fn stv_eip712_data_word(&self) -> alloy_sol_types::Word {
                <Self as alloy_sol_types::SolStruct>::eip712_hash_struct(self)
            }
            #[inline]
            fn stv_abi_encode_packed_to(
                &self,
                out: &mut alloy_sol_types::private::Vec<u8>,
            ) {
                let tuple = <UnderlyingRustTuple<
                    '_,
                > as ::core::convert::From<Self>>::from(self.clone());
                <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_encode_packed_to(&tuple, out)
            }
            #[inline]
            fn stv_abi_packed_encoded_size(&self) -> usize {
                if let Some(size) = <Self as alloy_sol_types::SolType>::PACKED_ENCODED_SIZE {
                    return size;
                }
                let tuple = <UnderlyingRustTuple<
                    '_,
                > as ::core::convert::From<Self>>::from(self.clone());
                <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_packed_encoded_size(&tuple)
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolType for Implementations {
            type RustType = Self;
            type Token<'a> = <UnderlyingSolTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SOL_NAME: &'static str = <Self as alloy_sol_types::SolStruct>::NAME;
            const ENCODED_SIZE: Option<usize> = <UnderlyingSolTuple<
                '_,
            > as alloy_sol_types::SolType>::ENCODED_SIZE;
            const PACKED_ENCODED_SIZE: Option<usize> = <UnderlyingSolTuple<
                '_,
            > as alloy_sol_types::SolType>::PACKED_ENCODED_SIZE;
            #[inline]
            fn valid_token(token: &Self::Token<'_>) -> bool {
                <UnderlyingSolTuple<'_> as alloy_sol_types::SolType>::valid_token(token)
            }
            #[inline]
            fn detokenize(token: Self::Token<'_>) -> Self::RustType {
                let tuple = <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::detokenize(token);
                <Self as ::core::convert::From<UnderlyingRustTuple<'_>>>::from(tuple)
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolStruct for Implementations {
            const NAME: &'static str = "Implementations";
            #[inline]
            fn eip712_root_type() -> alloy_sol_types::private::Cow<'static, str> {
                alloy_sol_types::private::Cow::Borrowed(
                    "Implementations(address bridge,address seqInbox,address inbox,address rei,address outbox,address newRollupUser,address newRollupAdmin,address challengeManager)",
                )
            }
            #[inline]
            fn eip712_components() -> alloy_sol_types::private::Vec<
                alloy_sol_types::private::Cow<'static, str>,
            > {
                alloy_sol_types::private::Vec::new()
            }
            #[inline]
            fn eip712_encode_type() -> alloy_sol_types::private::Cow<'static, str> {
                <Self as alloy_sol_types::SolStruct>::eip712_root_type()
            }
            #[inline]
            fn eip712_encode_data(&self) -> alloy_sol_types::private::Vec<u8> {
                [
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::eip712_data_word(
                            &self.bridge,
                        )
                        .0,
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::eip712_data_word(
                            &self.seqInbox,
                        )
                        .0,
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::eip712_data_word(
                            &self.inbox,
                        )
                        .0,
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::eip712_data_word(
                            &self.rei,
                        )
                        .0,
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::eip712_data_word(
                            &self.outbox,
                        )
                        .0,
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::eip712_data_word(
                            &self.newRollupUser,
                        )
                        .0,
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::eip712_data_word(
                            &self.newRollupAdmin,
                        )
                        .0,
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::eip712_data_word(
                            &self.challengeManager,
                        )
                        .0,
                ]
                    .concat()
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::EventTopic for Implementations {
            #[inline]
            fn topic_preimage_length(rust: &Self::RustType) -> usize {
                0usize
                    + <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.bridge,
                    )
                    + <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.seqInbox,
                    )
                    + <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.inbox,
                    )
                    + <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.rei,
                    )
                    + <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.outbox,
                    )
                    + <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.newRollupUser,
                    )
                    + <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.newRollupAdmin,
                    )
                    + <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.challengeManager,
                    )
            }
            #[inline]
            fn encode_topic_preimage(
                rust: &Self::RustType,
                out: &mut alloy_sol_types::private::Vec<u8>,
            ) {
                out.reserve(
                    <Self as alloy_sol_types::EventTopic>::topic_preimage_length(rust),
                );
                <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.bridge,
                    out,
                );
                <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.seqInbox,
                    out,
                );
                <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.inbox,
                    out,
                );
                <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.rei,
                    out,
                );
                <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.outbox,
                    out,
                );
                <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.newRollupUser,
                    out,
                );
                <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.newRollupAdmin,
                    out,
                );
                <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.challengeManager,
                    out,
                );
            }
            #[inline]
            fn encode_topic(
                rust: &Self::RustType,
            ) -> alloy_sol_types::abi::token::WordToken {
                let mut out = alloy_sol_types::private::Vec::new();
                <Self as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    rust,
                    &mut out,
                );
                alloy_sol_types::abi::token::WordToken(
                    alloy_sol_types::private::keccak256(out),
                )
            }
        }
    };
    /**```solidity
struct ProxyAdmins { address outbox; address bridge; address rei; address seqInbox; address inbox; }
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct ProxyAdmins {
        #[allow(missing_docs)]
        pub outbox: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub bridge: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub rei: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub seqInbox: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub inbox: alloy::sol_types::private::Address,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = (
            alloy::sol_types::sol_data::Address,
            alloy::sol_types::sol_data::Address,
            alloy::sol_types::sol_data::Address,
            alloy::sol_types::sol_data::Address,
            alloy::sol_types::sol_data::Address,
        );
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = (
            alloy::sol_types::private::Address,
            alloy::sol_types::private::Address,
            alloy::sol_types::private::Address,
            alloy::sol_types::private::Address,
            alloy::sol_types::private::Address,
        );
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<ProxyAdmins> for UnderlyingRustTuple<'_> {
            fn from(value: ProxyAdmins) -> Self {
                (value.outbox, value.bridge, value.rei, value.seqInbox, value.inbox)
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for ProxyAdmins {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self {
                    outbox: tuple.0,
                    bridge: tuple.1,
                    rei: tuple.2,
                    seqInbox: tuple.3,
                    inbox: tuple.4,
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolValue for ProxyAdmins {
            type SolType = Self;
        }
        #[automatically_derived]
        impl alloy_sol_types::private::SolTypeValue<Self> for ProxyAdmins {
            #[inline]
            fn stv_to_tokens(&self) -> <Self as alloy_sol_types::SolType>::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.outbox,
                    ),
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.bridge,
                    ),
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.rei,
                    ),
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.seqInbox,
                    ),
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.inbox,
                    ),
                )
            }
            #[inline]
            fn stv_abi_encoded_size(&self) -> usize {
                if let Some(size) = <Self as alloy_sol_types::SolType>::ENCODED_SIZE {
                    return size;
                }
                let tuple = <UnderlyingRustTuple<
                    '_,
                > as ::core::convert::From<Self>>::from(self.clone());
                <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_encoded_size(&tuple)
            }
            #[inline]
            fn stv_eip712_data_word(&self) -> alloy_sol_types::Word {
                <Self as alloy_sol_types::SolStruct>::eip712_hash_struct(self)
            }
            #[inline]
            fn stv_abi_encode_packed_to(
                &self,
                out: &mut alloy_sol_types::private::Vec<u8>,
            ) {
                let tuple = <UnderlyingRustTuple<
                    '_,
                > as ::core::convert::From<Self>>::from(self.clone());
                <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_encode_packed_to(&tuple, out)
            }
            #[inline]
            fn stv_abi_packed_encoded_size(&self) -> usize {
                if let Some(size) = <Self as alloy_sol_types::SolType>::PACKED_ENCODED_SIZE {
                    return size;
                }
                let tuple = <UnderlyingRustTuple<
                    '_,
                > as ::core::convert::From<Self>>::from(self.clone());
                <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_packed_encoded_size(&tuple)
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolType for ProxyAdmins {
            type RustType = Self;
            type Token<'a> = <UnderlyingSolTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SOL_NAME: &'static str = <Self as alloy_sol_types::SolStruct>::NAME;
            const ENCODED_SIZE: Option<usize> = <UnderlyingSolTuple<
                '_,
            > as alloy_sol_types::SolType>::ENCODED_SIZE;
            const PACKED_ENCODED_SIZE: Option<usize> = <UnderlyingSolTuple<
                '_,
            > as alloy_sol_types::SolType>::PACKED_ENCODED_SIZE;
            #[inline]
            fn valid_token(token: &Self::Token<'_>) -> bool {
                <UnderlyingSolTuple<'_> as alloy_sol_types::SolType>::valid_token(token)
            }
            #[inline]
            fn detokenize(token: Self::Token<'_>) -> Self::RustType {
                let tuple = <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::detokenize(token);
                <Self as ::core::convert::From<UnderlyingRustTuple<'_>>>::from(tuple)
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolStruct for ProxyAdmins {
            const NAME: &'static str = "ProxyAdmins";
            #[inline]
            fn eip712_root_type() -> alloy_sol_types::private::Cow<'static, str> {
                alloy_sol_types::private::Cow::Borrowed(
                    "ProxyAdmins(address outbox,address bridge,address rei,address seqInbox,address inbox)",
                )
            }
            #[inline]
            fn eip712_components() -> alloy_sol_types::private::Vec<
                alloy_sol_types::private::Cow<'static, str>,
            > {
                alloy_sol_types::private::Vec::new()
            }
            #[inline]
            fn eip712_encode_type() -> alloy_sol_types::private::Cow<'static, str> {
                <Self as alloy_sol_types::SolStruct>::eip712_root_type()
            }
            #[inline]
            fn eip712_encode_data(&self) -> alloy_sol_types::private::Vec<u8> {
                [
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::eip712_data_word(
                            &self.outbox,
                        )
                        .0,
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::eip712_data_word(
                            &self.bridge,
                        )
                        .0,
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::eip712_data_word(
                            &self.rei,
                        )
                        .0,
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::eip712_data_word(
                            &self.seqInbox,
                        )
                        .0,
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::eip712_data_word(
                            &self.inbox,
                        )
                        .0,
                ]
                    .concat()
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::EventTopic for ProxyAdmins {
            #[inline]
            fn topic_preimage_length(rust: &Self::RustType) -> usize {
                0usize
                    + <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.outbox,
                    )
                    + <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.bridge,
                    )
                    + <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.rei,
                    )
                    + <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.seqInbox,
                    )
                    + <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.inbox,
                    )
            }
            #[inline]
            fn encode_topic_preimage(
                rust: &Self::RustType,
                out: &mut alloy_sol_types::private::Vec<u8>,
            ) {
                out.reserve(
                    <Self as alloy_sol_types::EventTopic>::topic_preimage_length(rust),
                );
                <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.outbox,
                    out,
                );
                <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.bridge,
                    out,
                );
                <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.rei,
                    out,
                );
                <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.seqInbox,
                    out,
                );
                <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.inbox,
                    out,
                );
            }
            #[inline]
            fn encode_topic(
                rust: &Self::RustType,
            ) -> alloy_sol_types::abi::token::WordToken {
                let mut out = alloy_sol_types::private::Vec::new();
                <Self as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    rust,
                    &mut out,
                );
                alloy_sol_types::abi::token::WordToken(
                    alloy_sol_types::private::keccak256(out),
                )
            }
        }
    };
    /**```solidity
struct Settings { uint64 confirmPeriodBlocks; uint64 challengePeriodBlocks; address stakeToken; uint256 stakeAmt; uint256[] miniStakeAmounts; uint256 chainId; uint256 minimumAssertionPeriod; uint64 validatorAfkBlocks; bool disableValidatorWhitelist; uint256 blockLeafSize; uint256 bigStepLeafSize; uint256 smallStepLeafSize; uint8 numBigStepLevel; uint64 challengeGracePeriodBlocks; bool isDelayBufferable; BufferConfig bufferConfig; }
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct Settings {
        #[allow(missing_docs)]
        pub confirmPeriodBlocks: u64,
        #[allow(missing_docs)]
        pub challengePeriodBlocks: u64,
        #[allow(missing_docs)]
        pub stakeToken: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub stakeAmt: alloy::sol_types::private::primitives::aliases::U256,
        #[allow(missing_docs)]
        pub miniStakeAmounts: alloy::sol_types::private::Vec<
            alloy::sol_types::private::primitives::aliases::U256,
        >,
        #[allow(missing_docs)]
        pub chainId: alloy::sol_types::private::primitives::aliases::U256,
        #[allow(missing_docs)]
        pub minimumAssertionPeriod: alloy::sol_types::private::primitives::aliases::U256,
        #[allow(missing_docs)]
        pub validatorAfkBlocks: u64,
        #[allow(missing_docs)]
        pub disableValidatorWhitelist: bool,
        #[allow(missing_docs)]
        pub blockLeafSize: alloy::sol_types::private::primitives::aliases::U256,
        #[allow(missing_docs)]
        pub bigStepLeafSize: alloy::sol_types::private::primitives::aliases::U256,
        #[allow(missing_docs)]
        pub smallStepLeafSize: alloy::sol_types::private::primitives::aliases::U256,
        #[allow(missing_docs)]
        pub numBigStepLevel: u8,
        #[allow(missing_docs)]
        pub challengeGracePeriodBlocks: u64,
        #[allow(missing_docs)]
        pub isDelayBufferable: bool,
        #[allow(missing_docs)]
        pub bufferConfig: <BufferConfig as alloy::sol_types::SolType>::RustType,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = (
            alloy::sol_types::sol_data::Uint<64>,
            alloy::sol_types::sol_data::Uint<64>,
            alloy::sol_types::sol_data::Address,
            alloy::sol_types::sol_data::Uint<256>,
            alloy::sol_types::sol_data::Array<alloy::sol_types::sol_data::Uint<256>>,
            alloy::sol_types::sol_data::Uint<256>,
            alloy::sol_types::sol_data::Uint<256>,
            alloy::sol_types::sol_data::Uint<64>,
            alloy::sol_types::sol_data::Bool,
            alloy::sol_types::sol_data::Uint<256>,
            alloy::sol_types::sol_data::Uint<256>,
            alloy::sol_types::sol_data::Uint<256>,
            alloy::sol_types::sol_data::Uint<8>,
            alloy::sol_types::sol_data::Uint<64>,
            alloy::sol_types::sol_data::Bool,
            BufferConfig,
        );
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = (
            u64,
            u64,
            alloy::sol_types::private::Address,
            alloy::sol_types::private::primitives::aliases::U256,
            alloy::sol_types::private::Vec<
                alloy::sol_types::private::primitives::aliases::U256,
            >,
            alloy::sol_types::private::primitives::aliases::U256,
            alloy::sol_types::private::primitives::aliases::U256,
            u64,
            bool,
            alloy::sol_types::private::primitives::aliases::U256,
            alloy::sol_types::private::primitives::aliases::U256,
            alloy::sol_types::private::primitives::aliases::U256,
            u8,
            u64,
            bool,
            <BufferConfig as alloy::sol_types::SolType>::RustType,
        );
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<Settings> for UnderlyingRustTuple<'_> {
            fn from(value: Settings) -> Self {
                (
                    value.confirmPeriodBlocks,
                    value.challengePeriodBlocks,
                    value.stakeToken,
                    value.stakeAmt,
                    value.miniStakeAmounts,
                    value.chainId,
                    value.minimumAssertionPeriod,
                    value.validatorAfkBlocks,
                    value.disableValidatorWhitelist,
                    value.blockLeafSize,
                    value.bigStepLeafSize,
                    value.smallStepLeafSize,
                    value.numBigStepLevel,
                    value.challengeGracePeriodBlocks,
                    value.isDelayBufferable,
                    value.bufferConfig,
                )
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for Settings {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self {
                    confirmPeriodBlocks: tuple.0,
                    challengePeriodBlocks: tuple.1,
                    stakeToken: tuple.2,
                    stakeAmt: tuple.3,
                    miniStakeAmounts: tuple.4,
                    chainId: tuple.5,
                    minimumAssertionPeriod: tuple.6,
                    validatorAfkBlocks: tuple.7,
                    disableValidatorWhitelist: tuple.8,
                    blockLeafSize: tuple.9,
                    bigStepLeafSize: tuple.10,
                    smallStepLeafSize: tuple.11,
                    numBigStepLevel: tuple.12,
                    challengeGracePeriodBlocks: tuple.13,
                    isDelayBufferable: tuple.14,
                    bufferConfig: tuple.15,
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolValue for Settings {
            type SolType = Self;
        }
        #[automatically_derived]
        impl alloy_sol_types::private::SolTypeValue<Self> for Settings {
            #[inline]
            fn stv_to_tokens(&self) -> <Self as alloy_sol_types::SolType>::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        64,
                    > as alloy_sol_types::SolType>::tokenize(&self.confirmPeriodBlocks),
                    <alloy::sol_types::sol_data::Uint<
                        64,
                    > as alloy_sol_types::SolType>::tokenize(
                        &self.challengePeriodBlocks,
                    ),
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.stakeToken,
                    ),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.stakeAmt),
                    <alloy::sol_types::sol_data::Array<
                        alloy::sol_types::sol_data::Uint<256>,
                    > as alloy_sol_types::SolType>::tokenize(&self.miniStakeAmounts),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.chainId),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(
                        &self.minimumAssertionPeriod,
                    ),
                    <alloy::sol_types::sol_data::Uint<
                        64,
                    > as alloy_sol_types::SolType>::tokenize(&self.validatorAfkBlocks),
                    <alloy::sol_types::sol_data::Bool as alloy_sol_types::SolType>::tokenize(
                        &self.disableValidatorWhitelist,
                    ),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.blockLeafSize),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.bigStepLeafSize),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.smallStepLeafSize),
                    <alloy::sol_types::sol_data::Uint<
                        8,
                    > as alloy_sol_types::SolType>::tokenize(&self.numBigStepLevel),
                    <alloy::sol_types::sol_data::Uint<
                        64,
                    > as alloy_sol_types::SolType>::tokenize(
                        &self.challengeGracePeriodBlocks,
                    ),
                    <alloy::sol_types::sol_data::Bool as alloy_sol_types::SolType>::tokenize(
                        &self.isDelayBufferable,
                    ),
                    <BufferConfig as alloy_sol_types::SolType>::tokenize(
                        &self.bufferConfig,
                    ),
                )
            }
            #[inline]
            fn stv_abi_encoded_size(&self) -> usize {
                if let Some(size) = <Self as alloy_sol_types::SolType>::ENCODED_SIZE {
                    return size;
                }
                let tuple = <UnderlyingRustTuple<
                    '_,
                > as ::core::convert::From<Self>>::from(self.clone());
                <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_encoded_size(&tuple)
            }
            #[inline]
            fn stv_eip712_data_word(&self) -> alloy_sol_types::Word {
                <Self as alloy_sol_types::SolStruct>::eip712_hash_struct(self)
            }
            #[inline]
            fn stv_abi_encode_packed_to(
                &self,
                out: &mut alloy_sol_types::private::Vec<u8>,
            ) {
                let tuple = <UnderlyingRustTuple<
                    '_,
                > as ::core::convert::From<Self>>::from(self.clone());
                <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_encode_packed_to(&tuple, out)
            }
            #[inline]
            fn stv_abi_packed_encoded_size(&self) -> usize {
                if let Some(size) = <Self as alloy_sol_types::SolType>::PACKED_ENCODED_SIZE {
                    return size;
                }
                let tuple = <UnderlyingRustTuple<
                    '_,
                > as ::core::convert::From<Self>>::from(self.clone());
                <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_packed_encoded_size(&tuple)
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolType for Settings {
            type RustType = Self;
            type Token<'a> = <UnderlyingSolTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SOL_NAME: &'static str = <Self as alloy_sol_types::SolStruct>::NAME;
            const ENCODED_SIZE: Option<usize> = <UnderlyingSolTuple<
                '_,
            > as alloy_sol_types::SolType>::ENCODED_SIZE;
            const PACKED_ENCODED_SIZE: Option<usize> = <UnderlyingSolTuple<
                '_,
            > as alloy_sol_types::SolType>::PACKED_ENCODED_SIZE;
            #[inline]
            fn valid_token(token: &Self::Token<'_>) -> bool {
                <UnderlyingSolTuple<'_> as alloy_sol_types::SolType>::valid_token(token)
            }
            #[inline]
            fn detokenize(token: Self::Token<'_>) -> Self::RustType {
                let tuple = <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::detokenize(token);
                <Self as ::core::convert::From<UnderlyingRustTuple<'_>>>::from(tuple)
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolStruct for Settings {
            const NAME: &'static str = "Settings";
            #[inline]
            fn eip712_root_type() -> alloy_sol_types::private::Cow<'static, str> {
                alloy_sol_types::private::Cow::Borrowed(
                    "Settings(uint64 confirmPeriodBlocks,uint64 challengePeriodBlocks,address stakeToken,uint256 stakeAmt,uint256[] miniStakeAmounts,uint256 chainId,uint256 minimumAssertionPeriod,uint64 validatorAfkBlocks,bool disableValidatorWhitelist,uint256 blockLeafSize,uint256 bigStepLeafSize,uint256 smallStepLeafSize,uint8 numBigStepLevel,uint64 challengeGracePeriodBlocks,bool isDelayBufferable,BufferConfig bufferConfig)",
                )
            }
            #[inline]
            fn eip712_components() -> alloy_sol_types::private::Vec<
                alloy_sol_types::private::Cow<'static, str>,
            > {
                let mut components = alloy_sol_types::private::Vec::with_capacity(1);
                components
                    .push(
                        <BufferConfig as alloy_sol_types::SolStruct>::eip712_root_type(),
                    );
                components
                    .extend(
                        <BufferConfig as alloy_sol_types::SolStruct>::eip712_components(),
                    );
                components
            }
            #[inline]
            fn eip712_encode_data(&self) -> alloy_sol_types::private::Vec<u8> {
                [
                    <alloy::sol_types::sol_data::Uint<
                        64,
                    > as alloy_sol_types::SolType>::eip712_data_word(
                            &self.confirmPeriodBlocks,
                        )
                        .0,
                    <alloy::sol_types::sol_data::Uint<
                        64,
                    > as alloy_sol_types::SolType>::eip712_data_word(
                            &self.challengePeriodBlocks,
                        )
                        .0,
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::eip712_data_word(
                            &self.stakeToken,
                        )
                        .0,
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::eip712_data_word(&self.stakeAmt)
                        .0,
                    <alloy::sol_types::sol_data::Array<
                        alloy::sol_types::sol_data::Uint<256>,
                    > as alloy_sol_types::SolType>::eip712_data_word(
                            &self.miniStakeAmounts,
                        )
                        .0,
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::eip712_data_word(&self.chainId)
                        .0,
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::eip712_data_word(
                            &self.minimumAssertionPeriod,
                        )
                        .0,
                    <alloy::sol_types::sol_data::Uint<
                        64,
                    > as alloy_sol_types::SolType>::eip712_data_word(
                            &self.validatorAfkBlocks,
                        )
                        .0,
                    <alloy::sol_types::sol_data::Bool as alloy_sol_types::SolType>::eip712_data_word(
                            &self.disableValidatorWhitelist,
                        )
                        .0,
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::eip712_data_word(&self.blockLeafSize)
                        .0,
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::eip712_data_word(
                            &self.bigStepLeafSize,
                        )
                        .0,
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::eip712_data_word(
                            &self.smallStepLeafSize,
                        )
                        .0,
                    <alloy::sol_types::sol_data::Uint<
                        8,
                    > as alloy_sol_types::SolType>::eip712_data_word(
                            &self.numBigStepLevel,
                        )
                        .0,
                    <alloy::sol_types::sol_data::Uint<
                        64,
                    > as alloy_sol_types::SolType>::eip712_data_word(
                            &self.challengeGracePeriodBlocks,
                        )
                        .0,
                    <alloy::sol_types::sol_data::Bool as alloy_sol_types::SolType>::eip712_data_word(
                            &self.isDelayBufferable,
                        )
                        .0,
                    <BufferConfig as alloy_sol_types::SolType>::eip712_data_word(
                            &self.bufferConfig,
                        )
                        .0,
                ]
                    .concat()
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::EventTopic for Settings {
            #[inline]
            fn topic_preimage_length(rust: &Self::RustType) -> usize {
                0usize
                    + <alloy::sol_types::sol_data::Uint<
                        64,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.confirmPeriodBlocks,
                    )
                    + <alloy::sol_types::sol_data::Uint<
                        64,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.challengePeriodBlocks,
                    )
                    + <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.stakeToken,
                    )
                    + <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.stakeAmt,
                    )
                    + <alloy::sol_types::sol_data::Array<
                        alloy::sol_types::sol_data::Uint<256>,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.miniStakeAmounts,
                    )
                    + <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.chainId,
                    )
                    + <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.minimumAssertionPeriod,
                    )
                    + <alloy::sol_types::sol_data::Uint<
                        64,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.validatorAfkBlocks,
                    )
                    + <alloy::sol_types::sol_data::Bool as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.disableValidatorWhitelist,
                    )
                    + <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.blockLeafSize,
                    )
                    + <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.bigStepLeafSize,
                    )
                    + <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.smallStepLeafSize,
                    )
                    + <alloy::sol_types::sol_data::Uint<
                        8,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.numBigStepLevel,
                    )
                    + <alloy::sol_types::sol_data::Uint<
                        64,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.challengeGracePeriodBlocks,
                    )
                    + <alloy::sol_types::sol_data::Bool as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.isDelayBufferable,
                    )
                    + <BufferConfig as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.bufferConfig,
                    )
            }
            #[inline]
            fn encode_topic_preimage(
                rust: &Self::RustType,
                out: &mut alloy_sol_types::private::Vec<u8>,
            ) {
                out.reserve(
                    <Self as alloy_sol_types::EventTopic>::topic_preimage_length(rust),
                );
                <alloy::sol_types::sol_data::Uint<
                    64,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.confirmPeriodBlocks,
                    out,
                );
                <alloy::sol_types::sol_data::Uint<
                    64,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.challengePeriodBlocks,
                    out,
                );
                <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.stakeToken,
                    out,
                );
                <alloy::sol_types::sol_data::Uint<
                    256,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.stakeAmt,
                    out,
                );
                <alloy::sol_types::sol_data::Array<
                    alloy::sol_types::sol_data::Uint<256>,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.miniStakeAmounts,
                    out,
                );
                <alloy::sol_types::sol_data::Uint<
                    256,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.chainId,
                    out,
                );
                <alloy::sol_types::sol_data::Uint<
                    256,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.minimumAssertionPeriod,
                    out,
                );
                <alloy::sol_types::sol_data::Uint<
                    64,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.validatorAfkBlocks,
                    out,
                );
                <alloy::sol_types::sol_data::Bool as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.disableValidatorWhitelist,
                    out,
                );
                <alloy::sol_types::sol_data::Uint<
                    256,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.blockLeafSize,
                    out,
                );
                <alloy::sol_types::sol_data::Uint<
                    256,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.bigStepLeafSize,
                    out,
                );
                <alloy::sol_types::sol_data::Uint<
                    256,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.smallStepLeafSize,
                    out,
                );
                <alloy::sol_types::sol_data::Uint<
                    8,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.numBigStepLevel,
                    out,
                );
                <alloy::sol_types::sol_data::Uint<
                    64,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.challengeGracePeriodBlocks,
                    out,
                );
                <alloy::sol_types::sol_data::Bool as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.isDelayBufferable,
                    out,
                );
                <BufferConfig as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.bufferConfig,
                    out,
                );
            }
            #[inline]
            fn encode_topic(
                rust: &Self::RustType,
            ) -> alloy_sol_types::abi::token::WordToken {
                let mut out = alloy_sol_types::private::Vec::new();
                <Self as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    rust,
                    &mut out,
                );
                alloy_sol_types::abi::token::WordToken(
                    alloy_sol_types::private::keccak256(out),
                )
            }
        }
    };
    /**Event with signature `RollupMigrated(address,address)` and selector `0x7e5cc5c3fce046d868d5918548df8d3e8ef9f09e6fb30a68081f1f1348cd0314`.
```solidity
event RollupMigrated(address rollup, address challengeManager);
```*/
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    #[derive(Clone)]
    pub struct RollupMigrated {
        #[allow(missing_docs)]
        pub rollup: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub challengeManager: alloy::sol_types::private::Address,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[automatically_derived]
        impl alloy_sol_types::SolEvent for RollupMigrated {
            type DataTuple<'a> = (
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Address,
            );
            type DataToken<'a> = <Self::DataTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type TopicList = (alloy_sol_types::sol_data::FixedBytes<32>,);
            const SIGNATURE: &'static str = "RollupMigrated(address,address)";
            const SIGNATURE_HASH: alloy_sol_types::private::B256 = alloy_sol_types::private::B256::new([
                126u8,
                92u8,
                197u8,
                195u8,
                252u8,
                224u8,
                70u8,
                216u8,
                104u8,
                213u8,
                145u8,
                133u8,
                72u8,
                223u8,
                141u8,
                62u8,
                142u8,
                249u8,
                240u8,
                158u8,
                111u8,
                179u8,
                10u8,
                104u8,
                8u8,
                31u8,
                31u8,
                19u8,
                72u8,
                205u8,
                3u8,
                20u8,
            ]);
            const ANONYMOUS: bool = false;
            #[allow(unused_variables)]
            #[inline]
            fn new(
                topics: <Self::TopicList as alloy_sol_types::SolType>::RustType,
                data: <Self::DataTuple<'_> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                Self {
                    rollup: data.0,
                    challengeManager: data.1,
                }
            }
            #[inline]
            fn check_signature(
                topics: &<Self::TopicList as alloy_sol_types::SolType>::RustType,
            ) -> alloy_sol_types::Result<()> {
                if topics.0 != Self::SIGNATURE_HASH {
                    return Err(
                        alloy_sol_types::Error::invalid_event_signature_hash(
                            Self::SIGNATURE,
                            topics.0,
                            Self::SIGNATURE_HASH,
                        ),
                    );
                }
                Ok(())
            }
            #[inline]
            fn tokenize_body(&self) -> Self::DataToken<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.rollup,
                    ),
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.challengeManager,
                    ),
                )
            }
            #[inline]
            fn topics(&self) -> <Self::TopicList as alloy_sol_types::SolType>::RustType {
                (Self::SIGNATURE_HASH.into(),)
            }
            #[inline]
            fn encode_topics_raw(
                &self,
                out: &mut [alloy_sol_types::abi::token::WordToken],
            ) -> alloy_sol_types::Result<()> {
                if out.len() < <Self::TopicList as alloy_sol_types::TopicList>::COUNT {
                    return Err(alloy_sol_types::Error::Overrun);
                }
                out[0usize] = alloy_sol_types::abi::token::WordToken(
                    Self::SIGNATURE_HASH,
                );
                Ok(())
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::private::IntoLogData for RollupMigrated {
            fn to_log_data(&self) -> alloy_sol_types::private::LogData {
                From::from(self)
            }
            fn into_log_data(self) -> alloy_sol_types::private::LogData {
                From::from(&self)
            }
        }
        #[automatically_derived]
        impl From<&RollupMigrated> for alloy_sol_types::private::LogData {
            #[inline]
            fn from(this: &RollupMigrated) -> alloy_sol_types::private::LogData {
                alloy_sol_types::SolEvent::encode_log_data(this)
            }
        }
    };
    /**Constructor`.
```solidity
constructor(Contracts contracts, ProxyAdmins proxyAdmins, Implementations implementations, Settings settings);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct constructorCall {
        #[allow(missing_docs)]
        pub contracts: <Contracts as alloy::sol_types::SolType>::RustType,
        #[allow(missing_docs)]
        pub proxyAdmins: <ProxyAdmins as alloy::sol_types::SolType>::RustType,
        #[allow(missing_docs)]
        pub implementations: <Implementations as alloy::sol_types::SolType>::RustType,
        #[allow(missing_docs)]
        pub settings: <Settings as alloy::sol_types::SolType>::RustType,
    }
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                Contracts,
                ProxyAdmins,
                Implementations,
                Settings,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                <Contracts as alloy::sol_types::SolType>::RustType,
                <ProxyAdmins as alloy::sol_types::SolType>::RustType,
                <Implementations as alloy::sol_types::SolType>::RustType,
                <Settings as alloy::sol_types::SolType>::RustType,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<constructorCall> for UnderlyingRustTuple<'_> {
                fn from(value: constructorCall) -> Self {
                    (
                        value.contracts,
                        value.proxyAdmins,
                        value.implementations,
                        value.settings,
                    )
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for constructorCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        contracts: tuple.0,
                        proxyAdmins: tuple.1,
                        implementations: tuple.2,
                        settings: tuple.3,
                    }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolConstructor for constructorCall {
            type Parameters<'a> = (Contracts, ProxyAdmins, Implementations, Settings);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <Contracts as alloy_sol_types::SolType>::tokenize(&self.contracts),
                    <ProxyAdmins as alloy_sol_types::SolType>::tokenize(
                        &self.proxyAdmins,
                    ),
                    <Implementations as alloy_sol_types::SolType>::tokenize(
                        &self.implementations,
                    ),
                    <Settings as alloy_sol_types::SolType>::tokenize(&self.settings),
                )
            }
        }
    };
    /**Function with signature `BIGSTEP_LEAF_SIZE()` and selector `0x1ccc2cd1`.
```solidity
function BIGSTEP_LEAF_SIZE() external view returns (uint256);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct BIGSTEP_LEAF_SIZECall {}
    ///Container type for the return parameters of the [`BIGSTEP_LEAF_SIZE()`](BIGSTEP_LEAF_SIZECall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct BIGSTEP_LEAF_SIZEReturn {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<BIGSTEP_LEAF_SIZECall>
            for UnderlyingRustTuple<'_> {
                fn from(value: BIGSTEP_LEAF_SIZECall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for BIGSTEP_LEAF_SIZECall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<BIGSTEP_LEAF_SIZEReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: BIGSTEP_LEAF_SIZEReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for BIGSTEP_LEAF_SIZEReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for BIGSTEP_LEAF_SIZECall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = BIGSTEP_LEAF_SIZEReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "BIGSTEP_LEAF_SIZE()";
            const SELECTOR: [u8; 4] = [28u8, 204u8, 44u8, 209u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `BLOCK_LEAF_SIZE()` and selector `0x609fb503`.
```solidity
function BLOCK_LEAF_SIZE() external view returns (uint256);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct BLOCK_LEAF_SIZECall {}
    ///Container type for the return parameters of the [`BLOCK_LEAF_SIZE()`](BLOCK_LEAF_SIZECall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct BLOCK_LEAF_SIZEReturn {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<BLOCK_LEAF_SIZECall> for UnderlyingRustTuple<'_> {
                fn from(value: BLOCK_LEAF_SIZECall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for BLOCK_LEAF_SIZECall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<BLOCK_LEAF_SIZEReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: BLOCK_LEAF_SIZEReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for BLOCK_LEAF_SIZEReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for BLOCK_LEAF_SIZECall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = BLOCK_LEAF_SIZEReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "BLOCK_LEAF_SIZE()";
            const SELECTOR: [u8; 4] = [96u8, 159u8, 181u8, 3u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `BRIDGE()` and selector `0xee9a31a2`.
```solidity
function BRIDGE() external view returns (address);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct BRIDGECall {}
    ///Container type for the return parameters of the [`BRIDGE()`](BRIDGECall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct BRIDGEReturn {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::Address,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<BRIDGECall> for UnderlyingRustTuple<'_> {
                fn from(value: BRIDGECall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for BRIDGECall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Address,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::Address,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<BRIDGEReturn> for UnderlyingRustTuple<'_> {
                fn from(value: BRIDGEReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for BRIDGEReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for BRIDGECall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = BRIDGEReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Address,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "BRIDGE()";
            const SELECTOR: [u8; 4] = [238u8, 154u8, 49u8, 162u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `CHAIN_ID()` and selector `0x85e1f4d0`.
```solidity
function CHAIN_ID() external view returns (uint256);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct CHAIN_IDCall {}
    ///Container type for the return parameters of the [`CHAIN_ID()`](CHAIN_IDCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct CHAIN_IDReturn {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<CHAIN_IDCall> for UnderlyingRustTuple<'_> {
                fn from(value: CHAIN_IDCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for CHAIN_IDCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<CHAIN_IDReturn> for UnderlyingRustTuple<'_> {
                fn from(value: CHAIN_IDReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for CHAIN_IDReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for CHAIN_IDCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = CHAIN_IDReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "CHAIN_ID()";
            const SELECTOR: [u8; 4] = [133u8, 225u8, 244u8, 208u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `CHALLENGE_GRACE_PERIOD_BLOCKS()` and selector `0xec4f74ce`.
```solidity
function CHALLENGE_GRACE_PERIOD_BLOCKS() external view returns (uint64);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct CHALLENGE_GRACE_PERIOD_BLOCKSCall {}
    ///Container type for the return parameters of the [`CHALLENGE_GRACE_PERIOD_BLOCKS()`](CHALLENGE_GRACE_PERIOD_BLOCKSCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct CHALLENGE_GRACE_PERIOD_BLOCKSReturn {
        #[allow(missing_docs)]
        pub _0: u64,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<CHALLENGE_GRACE_PERIOD_BLOCKSCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: CHALLENGE_GRACE_PERIOD_BLOCKSCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for CHALLENGE_GRACE_PERIOD_BLOCKSCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<64>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (u64,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<CHALLENGE_GRACE_PERIOD_BLOCKSReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: CHALLENGE_GRACE_PERIOD_BLOCKSReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for CHALLENGE_GRACE_PERIOD_BLOCKSReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for CHALLENGE_GRACE_PERIOD_BLOCKSCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = CHALLENGE_GRACE_PERIOD_BLOCKSReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Uint<64>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "CHALLENGE_GRACE_PERIOD_BLOCKS()";
            const SELECTOR: [u8; 4] = [236u8, 79u8, 116u8, 206u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `CHALLENGE_PERIOD_BLOCKS()` and selector `0x91ddb285`.
```solidity
function CHALLENGE_PERIOD_BLOCKS() external view returns (uint64);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct CHALLENGE_PERIOD_BLOCKSCall {}
    ///Container type for the return parameters of the [`CHALLENGE_PERIOD_BLOCKS()`](CHALLENGE_PERIOD_BLOCKSCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct CHALLENGE_PERIOD_BLOCKSReturn {
        #[allow(missing_docs)]
        pub _0: u64,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<CHALLENGE_PERIOD_BLOCKSCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: CHALLENGE_PERIOD_BLOCKSCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for CHALLENGE_PERIOD_BLOCKSCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<64>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (u64,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<CHALLENGE_PERIOD_BLOCKSReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: CHALLENGE_PERIOD_BLOCKSReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for CHALLENGE_PERIOD_BLOCKSReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for CHALLENGE_PERIOD_BLOCKSCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = CHALLENGE_PERIOD_BLOCKSReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Uint<64>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "CHALLENGE_PERIOD_BLOCKS()";
            const SELECTOR: [u8; 4] = [145u8, 221u8, 178u8, 133u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `CONFIRM_PERIOD_BLOCKS()` and selector `0x1047fc52`.
```solidity
function CONFIRM_PERIOD_BLOCKS() external view returns (uint64);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct CONFIRM_PERIOD_BLOCKSCall {}
    ///Container type for the return parameters of the [`CONFIRM_PERIOD_BLOCKS()`](CONFIRM_PERIOD_BLOCKSCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct CONFIRM_PERIOD_BLOCKSReturn {
        #[allow(missing_docs)]
        pub _0: u64,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<CONFIRM_PERIOD_BLOCKSCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: CONFIRM_PERIOD_BLOCKSCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for CONFIRM_PERIOD_BLOCKSCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<64>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (u64,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<CONFIRM_PERIOD_BLOCKSReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: CONFIRM_PERIOD_BLOCKSReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for CONFIRM_PERIOD_BLOCKSReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for CONFIRM_PERIOD_BLOCKSCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = CONFIRM_PERIOD_BLOCKSReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Uint<64>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "CONFIRM_PERIOD_BLOCKS()";
            const SELECTOR: [u8; 4] = [16u8, 71u8, 252u8, 82u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `DISABLE_VALIDATOR_WHITELIST()` and selector `0xb38d57f0`.
```solidity
function DISABLE_VALIDATOR_WHITELIST() external view returns (bool);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct DISABLE_VALIDATOR_WHITELISTCall {}
    ///Container type for the return parameters of the [`DISABLE_VALIDATOR_WHITELIST()`](DISABLE_VALIDATOR_WHITELISTCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct DISABLE_VALIDATOR_WHITELISTReturn {
        #[allow(missing_docs)]
        pub _0: bool,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<DISABLE_VALIDATOR_WHITELISTCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: DISABLE_VALIDATOR_WHITELISTCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for DISABLE_VALIDATOR_WHITELISTCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Bool,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (bool,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<DISABLE_VALIDATOR_WHITELISTReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: DISABLE_VALIDATOR_WHITELISTReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for DISABLE_VALIDATOR_WHITELISTReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for DISABLE_VALIDATOR_WHITELISTCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = DISABLE_VALIDATOR_WHITELISTReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Bool,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "DISABLE_VALIDATOR_WHITELIST()";
            const SELECTOR: [u8; 4] = [179u8, 141u8, 87u8, 240u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `EXCESS_STAKE_RECEIVER()` and selector `0x64f4992a`.
```solidity
function EXCESS_STAKE_RECEIVER() external view returns (address);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct EXCESS_STAKE_RECEIVERCall {}
    ///Container type for the return parameters of the [`EXCESS_STAKE_RECEIVER()`](EXCESS_STAKE_RECEIVERCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct EXCESS_STAKE_RECEIVERReturn {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::Address,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<EXCESS_STAKE_RECEIVERCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: EXCESS_STAKE_RECEIVERCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for EXCESS_STAKE_RECEIVERCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Address,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::Address,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<EXCESS_STAKE_RECEIVERReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: EXCESS_STAKE_RECEIVERReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for EXCESS_STAKE_RECEIVERReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for EXCESS_STAKE_RECEIVERCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = EXCESS_STAKE_RECEIVERReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Address,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "EXCESS_STAKE_RECEIVER()";
            const SELECTOR: [u8; 4] = [100u8, 244u8, 153u8, 42u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `IMPL_BRIDGE()` and selector `0xdae7cb8b`.
```solidity
function IMPL_BRIDGE() external view returns (address);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct IMPL_BRIDGECall {}
    ///Container type for the return parameters of the [`IMPL_BRIDGE()`](IMPL_BRIDGECall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct IMPL_BRIDGEReturn {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::Address,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<IMPL_BRIDGECall> for UnderlyingRustTuple<'_> {
                fn from(value: IMPL_BRIDGECall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for IMPL_BRIDGECall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Address,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::Address,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<IMPL_BRIDGEReturn> for UnderlyingRustTuple<'_> {
                fn from(value: IMPL_BRIDGEReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for IMPL_BRIDGEReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for IMPL_BRIDGECall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = IMPL_BRIDGEReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Address,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "IMPL_BRIDGE()";
            const SELECTOR: [u8; 4] = [218u8, 231u8, 203u8, 139u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `IMPL_CHALLENGE_MANAGER()` and selector `0x10a662e2`.
```solidity
function IMPL_CHALLENGE_MANAGER() external view returns (address);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct IMPL_CHALLENGE_MANAGERCall {}
    ///Container type for the return parameters of the [`IMPL_CHALLENGE_MANAGER()`](IMPL_CHALLENGE_MANAGERCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct IMPL_CHALLENGE_MANAGERReturn {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::Address,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<IMPL_CHALLENGE_MANAGERCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: IMPL_CHALLENGE_MANAGERCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for IMPL_CHALLENGE_MANAGERCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Address,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::Address,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<IMPL_CHALLENGE_MANAGERReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: IMPL_CHALLENGE_MANAGERReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for IMPL_CHALLENGE_MANAGERReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for IMPL_CHALLENGE_MANAGERCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = IMPL_CHALLENGE_MANAGERReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Address,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "IMPL_CHALLENGE_MANAGER()";
            const SELECTOR: [u8; 4] = [16u8, 166u8, 98u8, 226u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `IMPL_INBOX()` and selector `0x817cd312`.
```solidity
function IMPL_INBOX() external view returns (address);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct IMPL_INBOXCall {}
    ///Container type for the return parameters of the [`IMPL_INBOX()`](IMPL_INBOXCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct IMPL_INBOXReturn {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::Address,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<IMPL_INBOXCall> for UnderlyingRustTuple<'_> {
                fn from(value: IMPL_INBOXCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for IMPL_INBOXCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Address,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::Address,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<IMPL_INBOXReturn> for UnderlyingRustTuple<'_> {
                fn from(value: IMPL_INBOXReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for IMPL_INBOXReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for IMPL_INBOXCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = IMPL_INBOXReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Address,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "IMPL_INBOX()";
            const SELECTOR: [u8; 4] = [129u8, 124u8, 211u8, 18u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `IMPL_NEW_ROLLUP_ADMIN()` and selector `0x00f9731e`.
```solidity
function IMPL_NEW_ROLLUP_ADMIN() external view returns (address);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct IMPL_NEW_ROLLUP_ADMINCall {}
    ///Container type for the return parameters of the [`IMPL_NEW_ROLLUP_ADMIN()`](IMPL_NEW_ROLLUP_ADMINCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct IMPL_NEW_ROLLUP_ADMINReturn {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::Address,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<IMPL_NEW_ROLLUP_ADMINCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: IMPL_NEW_ROLLUP_ADMINCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for IMPL_NEW_ROLLUP_ADMINCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Address,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::Address,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<IMPL_NEW_ROLLUP_ADMINReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: IMPL_NEW_ROLLUP_ADMINReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for IMPL_NEW_ROLLUP_ADMINReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for IMPL_NEW_ROLLUP_ADMINCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = IMPL_NEW_ROLLUP_ADMINReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Address,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "IMPL_NEW_ROLLUP_ADMIN()";
            const SELECTOR: [u8; 4] = [0u8, 249u8, 115u8, 30u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `IMPL_NEW_ROLLUP_USER()` and selector `0x4692de5d`.
```solidity
function IMPL_NEW_ROLLUP_USER() external view returns (address);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct IMPL_NEW_ROLLUP_USERCall {}
    ///Container type for the return parameters of the [`IMPL_NEW_ROLLUP_USER()`](IMPL_NEW_ROLLUP_USERCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct IMPL_NEW_ROLLUP_USERReturn {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::Address,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<IMPL_NEW_ROLLUP_USERCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: IMPL_NEW_ROLLUP_USERCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for IMPL_NEW_ROLLUP_USERCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Address,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::Address,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<IMPL_NEW_ROLLUP_USERReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: IMPL_NEW_ROLLUP_USERReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for IMPL_NEW_ROLLUP_USERReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for IMPL_NEW_ROLLUP_USERCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = IMPL_NEW_ROLLUP_USERReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Address,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "IMPL_NEW_ROLLUP_USER()";
            const SELECTOR: [u8; 4] = [70u8, 146u8, 222u8, 93u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `IMPL_OUTBOX()` and selector `0xc897f55e`.
```solidity
function IMPL_OUTBOX() external view returns (address);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct IMPL_OUTBOXCall {}
    ///Container type for the return parameters of the [`IMPL_OUTBOX()`](IMPL_OUTBOXCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct IMPL_OUTBOXReturn {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::Address,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<IMPL_OUTBOXCall> for UnderlyingRustTuple<'_> {
                fn from(value: IMPL_OUTBOXCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for IMPL_OUTBOXCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Address,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::Address,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<IMPL_OUTBOXReturn> for UnderlyingRustTuple<'_> {
                fn from(value: IMPL_OUTBOXReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for IMPL_OUTBOXReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for IMPL_OUTBOXCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = IMPL_OUTBOXReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Address,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "IMPL_OUTBOX()";
            const SELECTOR: [u8; 4] = [200u8, 151u8, 245u8, 94u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `IMPL_REI()` and selector `0xc21c4233`.
```solidity
function IMPL_REI() external view returns (address);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct IMPL_REICall {}
    ///Container type for the return parameters of the [`IMPL_REI()`](IMPL_REICall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct IMPL_REIReturn {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::Address,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<IMPL_REICall> for UnderlyingRustTuple<'_> {
                fn from(value: IMPL_REICall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for IMPL_REICall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Address,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::Address,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<IMPL_REIReturn> for UnderlyingRustTuple<'_> {
                fn from(value: IMPL_REIReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for IMPL_REIReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for IMPL_REICall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = IMPL_REIReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Address,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "IMPL_REI()";
            const SELECTOR: [u8; 4] = [194u8, 28u8, 66u8, 51u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `IMPL_SEQUENCER_INBOX()` and selector `0xc519d151`.
```solidity
function IMPL_SEQUENCER_INBOX() external view returns (address);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct IMPL_SEQUENCER_INBOXCall {}
    ///Container type for the return parameters of the [`IMPL_SEQUENCER_INBOX()`](IMPL_SEQUENCER_INBOXCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct IMPL_SEQUENCER_INBOXReturn {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::Address,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<IMPL_SEQUENCER_INBOXCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: IMPL_SEQUENCER_INBOXCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for IMPL_SEQUENCER_INBOXCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Address,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::Address,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<IMPL_SEQUENCER_INBOXReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: IMPL_SEQUENCER_INBOXReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for IMPL_SEQUENCER_INBOXReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for IMPL_SEQUENCER_INBOXCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = IMPL_SEQUENCER_INBOXReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Address,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "IMPL_SEQUENCER_INBOX()";
            const SELECTOR: [u8; 4] = [197u8, 25u8, 209u8, 81u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `INBOX()` and selector `0xb7010697`.
```solidity
function INBOX() external view returns (address);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct INBOXCall {}
    ///Container type for the return parameters of the [`INBOX()`](INBOXCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct INBOXReturn {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::Address,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<INBOXCall> for UnderlyingRustTuple<'_> {
                fn from(value: INBOXCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for INBOXCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Address,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::Address,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<INBOXReturn> for UnderlyingRustTuple<'_> {
                fn from(value: INBOXReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for INBOXReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for INBOXCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = INBOXReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Address,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "INBOX()";
            const SELECTOR: [u8; 4] = [183u8, 1u8, 6u8, 151u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `IS_DELAY_BUFFERABLE()` and selector `0xe8180c29`.
```solidity
function IS_DELAY_BUFFERABLE() external view returns (bool);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct IS_DELAY_BUFFERABLECall {}
    ///Container type for the return parameters of the [`IS_DELAY_BUFFERABLE()`](IS_DELAY_BUFFERABLECall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct IS_DELAY_BUFFERABLEReturn {
        #[allow(missing_docs)]
        pub _0: bool,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<IS_DELAY_BUFFERABLECall>
            for UnderlyingRustTuple<'_> {
                fn from(value: IS_DELAY_BUFFERABLECall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for IS_DELAY_BUFFERABLECall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Bool,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (bool,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<IS_DELAY_BUFFERABLEReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: IS_DELAY_BUFFERABLEReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for IS_DELAY_BUFFERABLEReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for IS_DELAY_BUFFERABLECall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = IS_DELAY_BUFFERABLEReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Bool,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "IS_DELAY_BUFFERABLE()";
            const SELECTOR: [u8; 4] = [232u8, 24u8, 12u8, 41u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `MAX()` and selector `0xd49d5181`.
```solidity
function MAX() external view returns (uint64);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct MAXCall {}
    ///Container type for the return parameters of the [`MAX()`](MAXCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct MAXReturn {
        #[allow(missing_docs)]
        pub _0: u64,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<MAXCall> for UnderlyingRustTuple<'_> {
                fn from(value: MAXCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for MAXCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<64>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (u64,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<MAXReturn> for UnderlyingRustTuple<'_> {
                fn from(value: MAXReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for MAXReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for MAXCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = MAXReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Uint<64>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "MAX()";
            const SELECTOR: [u8; 4] = [212u8, 157u8, 81u8, 129u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `MINIMUM_ASSERTION_PERIOD()` and selector `0x003c78fb`.
```solidity
function MINIMUM_ASSERTION_PERIOD() external view returns (uint256);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct MINIMUM_ASSERTION_PERIODCall {}
    ///Container type for the return parameters of the [`MINIMUM_ASSERTION_PERIOD()`](MINIMUM_ASSERTION_PERIODCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct MINIMUM_ASSERTION_PERIODReturn {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<MINIMUM_ASSERTION_PERIODCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: MINIMUM_ASSERTION_PERIODCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for MINIMUM_ASSERTION_PERIODCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<MINIMUM_ASSERTION_PERIODReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: MINIMUM_ASSERTION_PERIODReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for MINIMUM_ASSERTION_PERIODReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for MINIMUM_ASSERTION_PERIODCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = MINIMUM_ASSERTION_PERIODReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "MINIMUM_ASSERTION_PERIOD()";
            const SELECTOR: [u8; 4] = [0u8, 60u8, 120u8, 251u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `MINI_STAKE_AMOUNTS_STORAGE()` and selector `0xb5e00c3f`.
```solidity
function MINI_STAKE_AMOUNTS_STORAGE() external view returns (address);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct MINI_STAKE_AMOUNTS_STORAGECall {}
    ///Container type for the return parameters of the [`MINI_STAKE_AMOUNTS_STORAGE()`](MINI_STAKE_AMOUNTS_STORAGECall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct MINI_STAKE_AMOUNTS_STORAGEReturn {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::Address,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<MINI_STAKE_AMOUNTS_STORAGECall>
            for UnderlyingRustTuple<'_> {
                fn from(value: MINI_STAKE_AMOUNTS_STORAGECall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for MINI_STAKE_AMOUNTS_STORAGECall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Address,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::Address,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<MINI_STAKE_AMOUNTS_STORAGEReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: MINI_STAKE_AMOUNTS_STORAGEReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for MINI_STAKE_AMOUNTS_STORAGEReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for MINI_STAKE_AMOUNTS_STORAGECall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = MINI_STAKE_AMOUNTS_STORAGEReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Address,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "MINI_STAKE_AMOUNTS_STORAGE()";
            const SELECTOR: [u8; 4] = [181u8, 224u8, 12u8, 63u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `NUM_BIGSTEP_LEVEL()` and selector `0x5d9e2444`.
```solidity
function NUM_BIGSTEP_LEVEL() external view returns (uint8);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct NUM_BIGSTEP_LEVELCall {}
    ///Container type for the return parameters of the [`NUM_BIGSTEP_LEVEL()`](NUM_BIGSTEP_LEVELCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct NUM_BIGSTEP_LEVELReturn {
        #[allow(missing_docs)]
        pub _0: u8,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<NUM_BIGSTEP_LEVELCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: NUM_BIGSTEP_LEVELCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for NUM_BIGSTEP_LEVELCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<8>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (u8,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<NUM_BIGSTEP_LEVELReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: NUM_BIGSTEP_LEVELReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for NUM_BIGSTEP_LEVELReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for NUM_BIGSTEP_LEVELCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = NUM_BIGSTEP_LEVELReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Uint<8>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "NUM_BIGSTEP_LEVEL()";
            const SELECTOR: [u8; 4] = [93u8, 158u8, 36u8, 68u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `OLD_ROLLUP()` and selector `0x8765240f`.
```solidity
function OLD_ROLLUP() external view returns (address);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct OLD_ROLLUPCall {}
    ///Container type for the return parameters of the [`OLD_ROLLUP()`](OLD_ROLLUPCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct OLD_ROLLUPReturn {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::Address,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<OLD_ROLLUPCall> for UnderlyingRustTuple<'_> {
                fn from(value: OLD_ROLLUPCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for OLD_ROLLUPCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Address,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::Address,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<OLD_ROLLUPReturn> for UnderlyingRustTuple<'_> {
                fn from(value: OLD_ROLLUPReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for OLD_ROLLUPReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for OLD_ROLLUPCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = OLD_ROLLUPReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Address,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "OLD_ROLLUP()";
            const SELECTOR: [u8; 4] = [135u8, 101u8, 36u8, 15u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `OSP()` and selector `0x9f9854e5`.
```solidity
function OSP() external view returns (address);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct OSPCall {}
    ///Container type for the return parameters of the [`OSP()`](OSPCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct OSPReturn {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::Address,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<OSPCall> for UnderlyingRustTuple<'_> {
                fn from(value: OSPCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for OSPCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Address,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::Address,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<OSPReturn> for UnderlyingRustTuple<'_> {
                fn from(value: OSPReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for OSPReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for OSPCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = OSPReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Address,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "OSP()";
            const SELECTOR: [u8; 4] = [159u8, 152u8, 84u8, 229u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `OUTBOX()` and selector `0x1b142ea7`.
```solidity
function OUTBOX() external view returns (address);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct OUTBOXCall {}
    ///Container type for the return parameters of the [`OUTBOX()`](OUTBOXCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct OUTBOXReturn {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::Address,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<OUTBOXCall> for UnderlyingRustTuple<'_> {
                fn from(value: OUTBOXCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for OUTBOXCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Address,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::Address,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<OUTBOXReturn> for UnderlyingRustTuple<'_> {
                fn from(value: OUTBOXReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for OUTBOXReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for OUTBOXCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = OUTBOXReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Address,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "OUTBOX()";
            const SELECTOR: [u8; 4] = [27u8, 20u8, 46u8, 167u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `PREIMAGE_LOOKUP()` and selector `0xcc8089bb`.
```solidity
function PREIMAGE_LOOKUP() external view returns (address);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct PREIMAGE_LOOKUPCall {}
    ///Container type for the return parameters of the [`PREIMAGE_LOOKUP()`](PREIMAGE_LOOKUPCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct PREIMAGE_LOOKUPReturn {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::Address,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<PREIMAGE_LOOKUPCall> for UnderlyingRustTuple<'_> {
                fn from(value: PREIMAGE_LOOKUPCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for PREIMAGE_LOOKUPCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Address,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::Address,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<PREIMAGE_LOOKUPReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: PREIMAGE_LOOKUPReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for PREIMAGE_LOOKUPReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for PREIMAGE_LOOKUPCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = PREIMAGE_LOOKUPReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Address,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "PREIMAGE_LOOKUP()";
            const SELECTOR: [u8; 4] = [204u8, 128u8, 137u8, 187u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `PROXY_ADMIN_BRIDGE()` and selector `0x0a54257d`.
```solidity
function PROXY_ADMIN_BRIDGE() external view returns (address);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct PROXY_ADMIN_BRIDGECall {}
    ///Container type for the return parameters of the [`PROXY_ADMIN_BRIDGE()`](PROXY_ADMIN_BRIDGECall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct PROXY_ADMIN_BRIDGEReturn {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::Address,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<PROXY_ADMIN_BRIDGECall>
            for UnderlyingRustTuple<'_> {
                fn from(value: PROXY_ADMIN_BRIDGECall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for PROXY_ADMIN_BRIDGECall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Address,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::Address,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<PROXY_ADMIN_BRIDGEReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: PROXY_ADMIN_BRIDGEReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for PROXY_ADMIN_BRIDGEReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for PROXY_ADMIN_BRIDGECall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = PROXY_ADMIN_BRIDGEReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Address,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "PROXY_ADMIN_BRIDGE()";
            const SELECTOR: [u8; 4] = [10u8, 84u8, 37u8, 125u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `PROXY_ADMIN_INBOX()` and selector `0x4b2f51ef`.
```solidity
function PROXY_ADMIN_INBOX() external view returns (address);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct PROXY_ADMIN_INBOXCall {}
    ///Container type for the return parameters of the [`PROXY_ADMIN_INBOX()`](PROXY_ADMIN_INBOXCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct PROXY_ADMIN_INBOXReturn {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::Address,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<PROXY_ADMIN_INBOXCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: PROXY_ADMIN_INBOXCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for PROXY_ADMIN_INBOXCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Address,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::Address,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<PROXY_ADMIN_INBOXReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: PROXY_ADMIN_INBOXReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for PROXY_ADMIN_INBOXReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for PROXY_ADMIN_INBOXCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = PROXY_ADMIN_INBOXReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Address,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "PROXY_ADMIN_INBOX()";
            const SELECTOR: [u8; 4] = [75u8, 47u8, 81u8, 239u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `PROXY_ADMIN_OUTBOX()` and selector `0x0787484b`.
```solidity
function PROXY_ADMIN_OUTBOX() external view returns (address);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct PROXY_ADMIN_OUTBOXCall {}
    ///Container type for the return parameters of the [`PROXY_ADMIN_OUTBOX()`](PROXY_ADMIN_OUTBOXCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct PROXY_ADMIN_OUTBOXReturn {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::Address,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<PROXY_ADMIN_OUTBOXCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: PROXY_ADMIN_OUTBOXCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for PROXY_ADMIN_OUTBOXCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Address,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::Address,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<PROXY_ADMIN_OUTBOXReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: PROXY_ADMIN_OUTBOXReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for PROXY_ADMIN_OUTBOXReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for PROXY_ADMIN_OUTBOXCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = PROXY_ADMIN_OUTBOXReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Address,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "PROXY_ADMIN_OUTBOX()";
            const SELECTOR: [u8; 4] = [7u8, 135u8, 72u8, 75u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `PROXY_ADMIN_REI()` and selector `0x3c2b7840`.
```solidity
function PROXY_ADMIN_REI() external view returns (address);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct PROXY_ADMIN_REICall {}
    ///Container type for the return parameters of the [`PROXY_ADMIN_REI()`](PROXY_ADMIN_REICall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct PROXY_ADMIN_REIReturn {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::Address,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<PROXY_ADMIN_REICall> for UnderlyingRustTuple<'_> {
                fn from(value: PROXY_ADMIN_REICall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for PROXY_ADMIN_REICall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Address,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::Address,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<PROXY_ADMIN_REIReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: PROXY_ADMIN_REIReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for PROXY_ADMIN_REIReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for PROXY_ADMIN_REICall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = PROXY_ADMIN_REIReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Address,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "PROXY_ADMIN_REI()";
            const SELECTOR: [u8; 4] = [60u8, 43u8, 120u8, 64u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `PROXY_ADMIN_SEQUENCER_INBOX()` and selector `0x2cfb7ca3`.
```solidity
function PROXY_ADMIN_SEQUENCER_INBOX() external view returns (address);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct PROXY_ADMIN_SEQUENCER_INBOXCall {}
    ///Container type for the return parameters of the [`PROXY_ADMIN_SEQUENCER_INBOX()`](PROXY_ADMIN_SEQUENCER_INBOXCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct PROXY_ADMIN_SEQUENCER_INBOXReturn {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::Address,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<PROXY_ADMIN_SEQUENCER_INBOXCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: PROXY_ADMIN_SEQUENCER_INBOXCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for PROXY_ADMIN_SEQUENCER_INBOXCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Address,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::Address,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<PROXY_ADMIN_SEQUENCER_INBOXReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: PROXY_ADMIN_SEQUENCER_INBOXReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for PROXY_ADMIN_SEQUENCER_INBOXReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for PROXY_ADMIN_SEQUENCER_INBOXCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = PROXY_ADMIN_SEQUENCER_INBOXReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Address,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "PROXY_ADMIN_SEQUENCER_INBOX()";
            const SELECTOR: [u8; 4] = [44u8, 251u8, 124u8, 163u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `REI()` and selector `0xbe41b367`.
```solidity
function REI() external view returns (address);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct REICall {}
    ///Container type for the return parameters of the [`REI()`](REICall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct REIReturn {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::Address,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<REICall> for UnderlyingRustTuple<'_> {
                fn from(value: REICall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for REICall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Address,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::Address,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<REIReturn> for UnderlyingRustTuple<'_> {
                fn from(value: REIReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for REIReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for REICall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = REIReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Address,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "REI()";
            const SELECTOR: [u8; 4] = [190u8, 65u8, 179u8, 103u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `REPLENISH_RATE_IN_BASIS()` and selector `0xeb657a4e`.
```solidity
function REPLENISH_RATE_IN_BASIS() external view returns (uint64);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct REPLENISH_RATE_IN_BASISCall {}
    ///Container type for the return parameters of the [`REPLENISH_RATE_IN_BASIS()`](REPLENISH_RATE_IN_BASISCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct REPLENISH_RATE_IN_BASISReturn {
        #[allow(missing_docs)]
        pub _0: u64,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<REPLENISH_RATE_IN_BASISCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: REPLENISH_RATE_IN_BASISCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for REPLENISH_RATE_IN_BASISCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<64>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (u64,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<REPLENISH_RATE_IN_BASISReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: REPLENISH_RATE_IN_BASISReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for REPLENISH_RATE_IN_BASISReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for REPLENISH_RATE_IN_BASISCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = REPLENISH_RATE_IN_BASISReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Uint<64>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "REPLENISH_RATE_IN_BASIS()";
            const SELECTOR: [u8; 4] = [235u8, 101u8, 122u8, 78u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `SECONDS_PER_SLOT()` and selector `0x304b9071`.
```solidity
function SECONDS_PER_SLOT() external view returns (uint256);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct SECONDS_PER_SLOTCall {}
    ///Container type for the return parameters of the [`SECONDS_PER_SLOT()`](SECONDS_PER_SLOTCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct SECONDS_PER_SLOTReturn {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<SECONDS_PER_SLOTCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: SECONDS_PER_SLOTCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for SECONDS_PER_SLOTCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<SECONDS_PER_SLOTReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: SECONDS_PER_SLOTReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for SECONDS_PER_SLOTReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for SECONDS_PER_SLOTCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = SECONDS_PER_SLOTReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "SECONDS_PER_SLOT()";
            const SELECTOR: [u8; 4] = [48u8, 75u8, 144u8, 113u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `SEQ_INBOX()` and selector `0xd384cb95`.
```solidity
function SEQ_INBOX() external view returns (address);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct SEQ_INBOXCall {}
    ///Container type for the return parameters of the [`SEQ_INBOX()`](SEQ_INBOXCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct SEQ_INBOXReturn {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::Address,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<SEQ_INBOXCall> for UnderlyingRustTuple<'_> {
                fn from(value: SEQ_INBOXCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for SEQ_INBOXCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Address,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::Address,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<SEQ_INBOXReturn> for UnderlyingRustTuple<'_> {
                fn from(value: SEQ_INBOXReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for SEQ_INBOXReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for SEQ_INBOXCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = SEQ_INBOXReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Address,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "SEQ_INBOX()";
            const SELECTOR: [u8; 4] = [211u8, 132u8, 203u8, 149u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `SMALLSTEP_LEAF_SIZE()` and selector `0xfa287420`.
```solidity
function SMALLSTEP_LEAF_SIZE() external view returns (uint256);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct SMALLSTEP_LEAF_SIZECall {}
    ///Container type for the return parameters of the [`SMALLSTEP_LEAF_SIZE()`](SMALLSTEP_LEAF_SIZECall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct SMALLSTEP_LEAF_SIZEReturn {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<SMALLSTEP_LEAF_SIZECall>
            for UnderlyingRustTuple<'_> {
                fn from(value: SMALLSTEP_LEAF_SIZECall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for SMALLSTEP_LEAF_SIZECall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<SMALLSTEP_LEAF_SIZEReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: SMALLSTEP_LEAF_SIZEReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for SMALLSTEP_LEAF_SIZEReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for SMALLSTEP_LEAF_SIZECall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = SMALLSTEP_LEAF_SIZEReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "SMALLSTEP_LEAF_SIZE()";
            const SELECTOR: [u8; 4] = [250u8, 40u8, 116u8, 32u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `STAKE_AMOUNT()` and selector `0xfaf5625f`.
```solidity
function STAKE_AMOUNT() external view returns (uint256);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct STAKE_AMOUNTCall {}
    ///Container type for the return parameters of the [`STAKE_AMOUNT()`](STAKE_AMOUNTCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct STAKE_AMOUNTReturn {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<STAKE_AMOUNTCall> for UnderlyingRustTuple<'_> {
                fn from(value: STAKE_AMOUNTCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for STAKE_AMOUNTCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<STAKE_AMOUNTReturn> for UnderlyingRustTuple<'_> {
                fn from(value: STAKE_AMOUNTReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for STAKE_AMOUNTReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for STAKE_AMOUNTCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = STAKE_AMOUNTReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "STAKE_AMOUNT()";
            const SELECTOR: [u8; 4] = [250u8, 245u8, 98u8, 95u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `STAKE_TOKEN()` and selector `0x1c39b672`.
```solidity
function STAKE_TOKEN() external view returns (address);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct STAKE_TOKENCall {}
    ///Container type for the return parameters of the [`STAKE_TOKEN()`](STAKE_TOKENCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct STAKE_TOKENReturn {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::Address,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<STAKE_TOKENCall> for UnderlyingRustTuple<'_> {
                fn from(value: STAKE_TOKENCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for STAKE_TOKENCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Address,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::Address,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<STAKE_TOKENReturn> for UnderlyingRustTuple<'_> {
                fn from(value: STAKE_TOKENReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for STAKE_TOKENReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for STAKE_TOKENCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = STAKE_TOKENReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Address,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "STAKE_TOKEN()";
            const SELECTOR: [u8; 4] = [28u8, 57u8, 182u8, 114u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `THRESHOLD()` and selector `0x785ffb37`.
```solidity
function THRESHOLD() external view returns (uint64);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct THRESHOLDCall {}
    ///Container type for the return parameters of the [`THRESHOLD()`](THRESHOLDCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct THRESHOLDReturn {
        #[allow(missing_docs)]
        pub _0: u64,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<THRESHOLDCall> for UnderlyingRustTuple<'_> {
                fn from(value: THRESHOLDCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for THRESHOLDCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<64>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (u64,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<THRESHOLDReturn> for UnderlyingRustTuple<'_> {
                fn from(value: THRESHOLDReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for THRESHOLDReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for THRESHOLDCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = THRESHOLDReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Uint<64>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "THRESHOLD()";
            const SELECTOR: [u8; 4] = [120u8, 95u8, 251u8, 55u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `VALIDATOR_AFK_BLOCKS()` and selector `0x4ceccfe5`.
```solidity
function VALIDATOR_AFK_BLOCKS() external view returns (uint64);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct VALIDATOR_AFK_BLOCKSCall {}
    ///Container type for the return parameters of the [`VALIDATOR_AFK_BLOCKS()`](VALIDATOR_AFK_BLOCKSCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct VALIDATOR_AFK_BLOCKSReturn {
        #[allow(missing_docs)]
        pub _0: u64,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<VALIDATOR_AFK_BLOCKSCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: VALIDATOR_AFK_BLOCKSCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for VALIDATOR_AFK_BLOCKSCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<64>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (u64,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<VALIDATOR_AFK_BLOCKSReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: VALIDATOR_AFK_BLOCKSReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for VALIDATOR_AFK_BLOCKSReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for VALIDATOR_AFK_BLOCKSCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = VALIDATOR_AFK_BLOCKSReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Uint<64>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "VALIDATOR_AFK_BLOCKS()";
            const SELECTOR: [u8; 4] = [76u8, 236u8, 207u8, 229u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `expectedRollupAddress(address,uint256)` and selector `0x28fb228c`.
```solidity
function expectedRollupAddress(address deployer, uint256 chainId) external pure returns (address);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct expectedRollupAddressCall {
        #[allow(missing_docs)]
        pub deployer: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub chainId: alloy::sol_types::private::primitives::aliases::U256,
    }
    ///Container type for the return parameters of the [`expectedRollupAddress(address,uint256)`](expectedRollupAddressCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct expectedRollupAddressReturn {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::Address,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Uint<256>,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::Address,
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<expectedRollupAddressCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: expectedRollupAddressCall) -> Self {
                    (value.deployer, value.chainId)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for expectedRollupAddressCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        deployer: tuple.0,
                        chainId: tuple.1,
                    }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Address,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::Address,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<expectedRollupAddressReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: expectedRollupAddressReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for expectedRollupAddressReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for expectedRollupAddressCall {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Uint<256>,
            );
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = expectedRollupAddressReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Address,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "expectedRollupAddress(address,uint256)";
            const SELECTOR: [u8; 4] = [40u8, 251u8, 34u8, 140u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.deployer,
                    ),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.chainId),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `perform(address[])` and selector `0xebe03a93`.
```solidity
function perform(address[] memory validators) external;
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct performCall {
        #[allow(missing_docs)]
        pub validators: alloy::sol_types::private::Vec<
            alloy::sol_types::private::Address,
        >,
    }
    ///Container type for the return parameters of the [`perform(address[])`](performCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct performReturn {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::Array<alloy::sol_types::sol_data::Address>,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::Vec<alloy::sol_types::private::Address>,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<performCall> for UnderlyingRustTuple<'_> {
                fn from(value: performCall) -> Self {
                    (value.validators,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for performCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { validators: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<performReturn> for UnderlyingRustTuple<'_> {
                fn from(value: performReturn) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for performReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for performCall {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::Array<alloy::sol_types::sol_data::Address>,
            );
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = performReturn;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "perform(address[])";
            const SELECTOR: [u8; 4] = [235u8, 224u8, 58u8, 147u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Array<
                        alloy::sol_types::sol_data::Address,
                    > as alloy_sol_types::SolType>::tokenize(&self.validators),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `validateRollupDeployedAtAddress(address,address,uint256)` and selector `0x999f20db`.
```solidity
function validateRollupDeployedAtAddress(address rollupAddress, address deployer, uint256 chainId) external view;
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct validateRollupDeployedAtAddressCall {
        #[allow(missing_docs)]
        pub rollupAddress: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub deployer: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub chainId: alloy::sol_types::private::primitives::aliases::U256,
    }
    ///Container type for the return parameters of the [`validateRollupDeployedAtAddress(address,address,uint256)`](validateRollupDeployedAtAddressCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct validateRollupDeployedAtAddressReturn {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Uint<256>,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::Address,
                alloy::sol_types::private::Address,
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<validateRollupDeployedAtAddressCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: validateRollupDeployedAtAddressCall) -> Self {
                    (value.rollupAddress, value.deployer, value.chainId)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for validateRollupDeployedAtAddressCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        rollupAddress: tuple.0,
                        deployer: tuple.1,
                        chainId: tuple.2,
                    }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<validateRollupDeployedAtAddressReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: validateRollupDeployedAtAddressReturn) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for validateRollupDeployedAtAddressReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for validateRollupDeployedAtAddressCall {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Uint<256>,
            );
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = validateRollupDeployedAtAddressReturn;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "validateRollupDeployedAtAddress(address,address,uint256)";
            const SELECTOR: [u8; 4] = [153u8, 159u8, 32u8, 219u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.rollupAddress,
                    ),
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.deployer,
                    ),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.chainId),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    ///Container for all the [`BOLDUpgradeAction`](self) function calls.
    pub enum BOLDUpgradeActionCalls {
        #[allow(missing_docs)]
        BIGSTEP_LEAF_SIZE(BIGSTEP_LEAF_SIZECall),
        #[allow(missing_docs)]
        BLOCK_LEAF_SIZE(BLOCK_LEAF_SIZECall),
        #[allow(missing_docs)]
        BRIDGE(BRIDGECall),
        #[allow(missing_docs)]
        CHAIN_ID(CHAIN_IDCall),
        #[allow(missing_docs)]
        CHALLENGE_GRACE_PERIOD_BLOCKS(CHALLENGE_GRACE_PERIOD_BLOCKSCall),
        #[allow(missing_docs)]
        CHALLENGE_PERIOD_BLOCKS(CHALLENGE_PERIOD_BLOCKSCall),
        #[allow(missing_docs)]
        CONFIRM_PERIOD_BLOCKS(CONFIRM_PERIOD_BLOCKSCall),
        #[allow(missing_docs)]
        DISABLE_VALIDATOR_WHITELIST(DISABLE_VALIDATOR_WHITELISTCall),
        #[allow(missing_docs)]
        EXCESS_STAKE_RECEIVER(EXCESS_STAKE_RECEIVERCall),
        #[allow(missing_docs)]
        IMPL_BRIDGE(IMPL_BRIDGECall),
        #[allow(missing_docs)]
        IMPL_CHALLENGE_MANAGER(IMPL_CHALLENGE_MANAGERCall),
        #[allow(missing_docs)]
        IMPL_INBOX(IMPL_INBOXCall),
        #[allow(missing_docs)]
        IMPL_NEW_ROLLUP_ADMIN(IMPL_NEW_ROLLUP_ADMINCall),
        #[allow(missing_docs)]
        IMPL_NEW_ROLLUP_USER(IMPL_NEW_ROLLUP_USERCall),
        #[allow(missing_docs)]
        IMPL_OUTBOX(IMPL_OUTBOXCall),
        #[allow(missing_docs)]
        IMPL_REI(IMPL_REICall),
        #[allow(missing_docs)]
        IMPL_SEQUENCER_INBOX(IMPL_SEQUENCER_INBOXCall),
        #[allow(missing_docs)]
        INBOX(INBOXCall),
        #[allow(missing_docs)]
        IS_DELAY_BUFFERABLE(IS_DELAY_BUFFERABLECall),
        #[allow(missing_docs)]
        MAX(MAXCall),
        #[allow(missing_docs)]
        MINIMUM_ASSERTION_PERIOD(MINIMUM_ASSERTION_PERIODCall),
        #[allow(missing_docs)]
        MINI_STAKE_AMOUNTS_STORAGE(MINI_STAKE_AMOUNTS_STORAGECall),
        #[allow(missing_docs)]
        NUM_BIGSTEP_LEVEL(NUM_BIGSTEP_LEVELCall),
        #[allow(missing_docs)]
        OLD_ROLLUP(OLD_ROLLUPCall),
        #[allow(missing_docs)]
        OSP(OSPCall),
        #[allow(missing_docs)]
        OUTBOX(OUTBOXCall),
        #[allow(missing_docs)]
        PREIMAGE_LOOKUP(PREIMAGE_LOOKUPCall),
        #[allow(missing_docs)]
        PROXY_ADMIN_BRIDGE(PROXY_ADMIN_BRIDGECall),
        #[allow(missing_docs)]
        PROXY_ADMIN_INBOX(PROXY_ADMIN_INBOXCall),
        #[allow(missing_docs)]
        PROXY_ADMIN_OUTBOX(PROXY_ADMIN_OUTBOXCall),
        #[allow(missing_docs)]
        PROXY_ADMIN_REI(PROXY_ADMIN_REICall),
        #[allow(missing_docs)]
        PROXY_ADMIN_SEQUENCER_INBOX(PROXY_ADMIN_SEQUENCER_INBOXCall),
        #[allow(missing_docs)]
        REI(REICall),
        #[allow(missing_docs)]
        REPLENISH_RATE_IN_BASIS(REPLENISH_RATE_IN_BASISCall),
        #[allow(missing_docs)]
        SECONDS_PER_SLOT(SECONDS_PER_SLOTCall),
        #[allow(missing_docs)]
        SEQ_INBOX(SEQ_INBOXCall),
        #[allow(missing_docs)]
        SMALLSTEP_LEAF_SIZE(SMALLSTEP_LEAF_SIZECall),
        #[allow(missing_docs)]
        STAKE_AMOUNT(STAKE_AMOUNTCall),
        #[allow(missing_docs)]
        STAKE_TOKEN(STAKE_TOKENCall),
        #[allow(missing_docs)]
        THRESHOLD(THRESHOLDCall),
        #[allow(missing_docs)]
        VALIDATOR_AFK_BLOCKS(VALIDATOR_AFK_BLOCKSCall),
        #[allow(missing_docs)]
        expectedRollupAddress(expectedRollupAddressCall),
        #[allow(missing_docs)]
        perform(performCall),
        #[allow(missing_docs)]
        validateRollupDeployedAtAddress(validateRollupDeployedAtAddressCall),
    }
    #[automatically_derived]
    impl BOLDUpgradeActionCalls {
        /// All the selectors of this enum.
        ///
        /// Note that the selectors might not be in the same order as the variants.
        /// No guarantees are made about the order of the selectors.
        ///
        /// Prefer using `SolInterface` methods instead.
        pub const SELECTORS: &'static [[u8; 4usize]] = &[
            [0u8, 60u8, 120u8, 251u8],
            [0u8, 249u8, 115u8, 30u8],
            [7u8, 135u8, 72u8, 75u8],
            [10u8, 84u8, 37u8, 125u8],
            [16u8, 71u8, 252u8, 82u8],
            [16u8, 166u8, 98u8, 226u8],
            [27u8, 20u8, 46u8, 167u8],
            [28u8, 57u8, 182u8, 114u8],
            [28u8, 204u8, 44u8, 209u8],
            [40u8, 251u8, 34u8, 140u8],
            [44u8, 251u8, 124u8, 163u8],
            [48u8, 75u8, 144u8, 113u8],
            [60u8, 43u8, 120u8, 64u8],
            [70u8, 146u8, 222u8, 93u8],
            [75u8, 47u8, 81u8, 239u8],
            [76u8, 236u8, 207u8, 229u8],
            [93u8, 158u8, 36u8, 68u8],
            [96u8, 159u8, 181u8, 3u8],
            [100u8, 244u8, 153u8, 42u8],
            [120u8, 95u8, 251u8, 55u8],
            [129u8, 124u8, 211u8, 18u8],
            [133u8, 225u8, 244u8, 208u8],
            [135u8, 101u8, 36u8, 15u8],
            [145u8, 221u8, 178u8, 133u8],
            [153u8, 159u8, 32u8, 219u8],
            [159u8, 152u8, 84u8, 229u8],
            [179u8, 141u8, 87u8, 240u8],
            [181u8, 224u8, 12u8, 63u8],
            [183u8, 1u8, 6u8, 151u8],
            [190u8, 65u8, 179u8, 103u8],
            [194u8, 28u8, 66u8, 51u8],
            [197u8, 25u8, 209u8, 81u8],
            [200u8, 151u8, 245u8, 94u8],
            [204u8, 128u8, 137u8, 187u8],
            [211u8, 132u8, 203u8, 149u8],
            [212u8, 157u8, 81u8, 129u8],
            [218u8, 231u8, 203u8, 139u8],
            [232u8, 24u8, 12u8, 41u8],
            [235u8, 101u8, 122u8, 78u8],
            [235u8, 224u8, 58u8, 147u8],
            [236u8, 79u8, 116u8, 206u8],
            [238u8, 154u8, 49u8, 162u8],
            [250u8, 40u8, 116u8, 32u8],
            [250u8, 245u8, 98u8, 95u8],
        ];
    }
    #[automatically_derived]
    impl alloy_sol_types::SolInterface for BOLDUpgradeActionCalls {
        const NAME: &'static str = "BOLDUpgradeActionCalls";
        const MIN_DATA_LENGTH: usize = 0usize;
        const COUNT: usize = 44usize;
        #[inline]
        fn selector(&self) -> [u8; 4] {
            match self {
                Self::BIGSTEP_LEAF_SIZE(_) => {
                    <BIGSTEP_LEAF_SIZECall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::BLOCK_LEAF_SIZE(_) => {
                    <BLOCK_LEAF_SIZECall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::BRIDGE(_) => <BRIDGECall as alloy_sol_types::SolCall>::SELECTOR,
                Self::CHAIN_ID(_) => <CHAIN_IDCall as alloy_sol_types::SolCall>::SELECTOR,
                Self::CHALLENGE_GRACE_PERIOD_BLOCKS(_) => {
                    <CHALLENGE_GRACE_PERIOD_BLOCKSCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::CHALLENGE_PERIOD_BLOCKS(_) => {
                    <CHALLENGE_PERIOD_BLOCKSCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::CONFIRM_PERIOD_BLOCKS(_) => {
                    <CONFIRM_PERIOD_BLOCKSCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::DISABLE_VALIDATOR_WHITELIST(_) => {
                    <DISABLE_VALIDATOR_WHITELISTCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::EXCESS_STAKE_RECEIVER(_) => {
                    <EXCESS_STAKE_RECEIVERCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::IMPL_BRIDGE(_) => {
                    <IMPL_BRIDGECall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::IMPL_CHALLENGE_MANAGER(_) => {
                    <IMPL_CHALLENGE_MANAGERCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::IMPL_INBOX(_) => {
                    <IMPL_INBOXCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::IMPL_NEW_ROLLUP_ADMIN(_) => {
                    <IMPL_NEW_ROLLUP_ADMINCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::IMPL_NEW_ROLLUP_USER(_) => {
                    <IMPL_NEW_ROLLUP_USERCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::IMPL_OUTBOX(_) => {
                    <IMPL_OUTBOXCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::IMPL_REI(_) => <IMPL_REICall as alloy_sol_types::SolCall>::SELECTOR,
                Self::IMPL_SEQUENCER_INBOX(_) => {
                    <IMPL_SEQUENCER_INBOXCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::INBOX(_) => <INBOXCall as alloy_sol_types::SolCall>::SELECTOR,
                Self::IS_DELAY_BUFFERABLE(_) => {
                    <IS_DELAY_BUFFERABLECall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::MAX(_) => <MAXCall as alloy_sol_types::SolCall>::SELECTOR,
                Self::MINIMUM_ASSERTION_PERIOD(_) => {
                    <MINIMUM_ASSERTION_PERIODCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::MINI_STAKE_AMOUNTS_STORAGE(_) => {
                    <MINI_STAKE_AMOUNTS_STORAGECall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::NUM_BIGSTEP_LEVEL(_) => {
                    <NUM_BIGSTEP_LEVELCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::OLD_ROLLUP(_) => {
                    <OLD_ROLLUPCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::OSP(_) => <OSPCall as alloy_sol_types::SolCall>::SELECTOR,
                Self::OUTBOX(_) => <OUTBOXCall as alloy_sol_types::SolCall>::SELECTOR,
                Self::PREIMAGE_LOOKUP(_) => {
                    <PREIMAGE_LOOKUPCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::PROXY_ADMIN_BRIDGE(_) => {
                    <PROXY_ADMIN_BRIDGECall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::PROXY_ADMIN_INBOX(_) => {
                    <PROXY_ADMIN_INBOXCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::PROXY_ADMIN_OUTBOX(_) => {
                    <PROXY_ADMIN_OUTBOXCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::PROXY_ADMIN_REI(_) => {
                    <PROXY_ADMIN_REICall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::PROXY_ADMIN_SEQUENCER_INBOX(_) => {
                    <PROXY_ADMIN_SEQUENCER_INBOXCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::REI(_) => <REICall as alloy_sol_types::SolCall>::SELECTOR,
                Self::REPLENISH_RATE_IN_BASIS(_) => {
                    <REPLENISH_RATE_IN_BASISCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::SECONDS_PER_SLOT(_) => {
                    <SECONDS_PER_SLOTCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::SEQ_INBOX(_) => {
                    <SEQ_INBOXCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::SMALLSTEP_LEAF_SIZE(_) => {
                    <SMALLSTEP_LEAF_SIZECall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::STAKE_AMOUNT(_) => {
                    <STAKE_AMOUNTCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::STAKE_TOKEN(_) => {
                    <STAKE_TOKENCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::THRESHOLD(_) => {
                    <THRESHOLDCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::VALIDATOR_AFK_BLOCKS(_) => {
                    <VALIDATOR_AFK_BLOCKSCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::expectedRollupAddress(_) => {
                    <expectedRollupAddressCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::perform(_) => <performCall as alloy_sol_types::SolCall>::SELECTOR,
                Self::validateRollupDeployedAtAddress(_) => {
                    <validateRollupDeployedAtAddressCall as alloy_sol_types::SolCall>::SELECTOR
                }
            }
        }
        #[inline]
        fn selector_at(i: usize) -> ::core::option::Option<[u8; 4]> {
            Self::SELECTORS.get(i).copied()
        }
        #[inline]
        fn valid_selector(selector: [u8; 4]) -> bool {
            Self::SELECTORS.binary_search(&selector).is_ok()
        }
        #[inline]
        #[allow(non_snake_case)]
        fn abi_decode_raw(
            selector: [u8; 4],
            data: &[u8],
            validate: bool,
        ) -> alloy_sol_types::Result<Self> {
            static DECODE_SHIMS: &[fn(
                &[u8],
                bool,
            ) -> alloy_sol_types::Result<BOLDUpgradeActionCalls>] = &[
                {
                    fn MINIMUM_ASSERTION_PERIOD(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<BOLDUpgradeActionCalls> {
                        <MINIMUM_ASSERTION_PERIODCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(BOLDUpgradeActionCalls::MINIMUM_ASSERTION_PERIOD)
                    }
                    MINIMUM_ASSERTION_PERIOD
                },
                {
                    fn IMPL_NEW_ROLLUP_ADMIN(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<BOLDUpgradeActionCalls> {
                        <IMPL_NEW_ROLLUP_ADMINCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(BOLDUpgradeActionCalls::IMPL_NEW_ROLLUP_ADMIN)
                    }
                    IMPL_NEW_ROLLUP_ADMIN
                },
                {
                    fn PROXY_ADMIN_OUTBOX(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<BOLDUpgradeActionCalls> {
                        <PROXY_ADMIN_OUTBOXCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(BOLDUpgradeActionCalls::PROXY_ADMIN_OUTBOX)
                    }
                    PROXY_ADMIN_OUTBOX
                },
                {
                    fn PROXY_ADMIN_BRIDGE(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<BOLDUpgradeActionCalls> {
                        <PROXY_ADMIN_BRIDGECall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(BOLDUpgradeActionCalls::PROXY_ADMIN_BRIDGE)
                    }
                    PROXY_ADMIN_BRIDGE
                },
                {
                    fn CONFIRM_PERIOD_BLOCKS(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<BOLDUpgradeActionCalls> {
                        <CONFIRM_PERIOD_BLOCKSCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(BOLDUpgradeActionCalls::CONFIRM_PERIOD_BLOCKS)
                    }
                    CONFIRM_PERIOD_BLOCKS
                },
                {
                    fn IMPL_CHALLENGE_MANAGER(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<BOLDUpgradeActionCalls> {
                        <IMPL_CHALLENGE_MANAGERCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(BOLDUpgradeActionCalls::IMPL_CHALLENGE_MANAGER)
                    }
                    IMPL_CHALLENGE_MANAGER
                },
                {
                    fn OUTBOX(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<BOLDUpgradeActionCalls> {
                        <OUTBOXCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(BOLDUpgradeActionCalls::OUTBOX)
                    }
                    OUTBOX
                },
                {
                    fn STAKE_TOKEN(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<BOLDUpgradeActionCalls> {
                        <STAKE_TOKENCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(BOLDUpgradeActionCalls::STAKE_TOKEN)
                    }
                    STAKE_TOKEN
                },
                {
                    fn BIGSTEP_LEAF_SIZE(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<BOLDUpgradeActionCalls> {
                        <BIGSTEP_LEAF_SIZECall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(BOLDUpgradeActionCalls::BIGSTEP_LEAF_SIZE)
                    }
                    BIGSTEP_LEAF_SIZE
                },
                {
                    fn expectedRollupAddress(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<BOLDUpgradeActionCalls> {
                        <expectedRollupAddressCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(BOLDUpgradeActionCalls::expectedRollupAddress)
                    }
                    expectedRollupAddress
                },
                {
                    fn PROXY_ADMIN_SEQUENCER_INBOX(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<BOLDUpgradeActionCalls> {
                        <PROXY_ADMIN_SEQUENCER_INBOXCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(BOLDUpgradeActionCalls::PROXY_ADMIN_SEQUENCER_INBOX)
                    }
                    PROXY_ADMIN_SEQUENCER_INBOX
                },
                {
                    fn SECONDS_PER_SLOT(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<BOLDUpgradeActionCalls> {
                        <SECONDS_PER_SLOTCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(BOLDUpgradeActionCalls::SECONDS_PER_SLOT)
                    }
                    SECONDS_PER_SLOT
                },
                {
                    fn PROXY_ADMIN_REI(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<BOLDUpgradeActionCalls> {
                        <PROXY_ADMIN_REICall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(BOLDUpgradeActionCalls::PROXY_ADMIN_REI)
                    }
                    PROXY_ADMIN_REI
                },
                {
                    fn IMPL_NEW_ROLLUP_USER(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<BOLDUpgradeActionCalls> {
                        <IMPL_NEW_ROLLUP_USERCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(BOLDUpgradeActionCalls::IMPL_NEW_ROLLUP_USER)
                    }
                    IMPL_NEW_ROLLUP_USER
                },
                {
                    fn PROXY_ADMIN_INBOX(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<BOLDUpgradeActionCalls> {
                        <PROXY_ADMIN_INBOXCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(BOLDUpgradeActionCalls::PROXY_ADMIN_INBOX)
                    }
                    PROXY_ADMIN_INBOX
                },
                {
                    fn VALIDATOR_AFK_BLOCKS(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<BOLDUpgradeActionCalls> {
                        <VALIDATOR_AFK_BLOCKSCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(BOLDUpgradeActionCalls::VALIDATOR_AFK_BLOCKS)
                    }
                    VALIDATOR_AFK_BLOCKS
                },
                {
                    fn NUM_BIGSTEP_LEVEL(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<BOLDUpgradeActionCalls> {
                        <NUM_BIGSTEP_LEVELCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(BOLDUpgradeActionCalls::NUM_BIGSTEP_LEVEL)
                    }
                    NUM_BIGSTEP_LEVEL
                },
                {
                    fn BLOCK_LEAF_SIZE(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<BOLDUpgradeActionCalls> {
                        <BLOCK_LEAF_SIZECall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(BOLDUpgradeActionCalls::BLOCK_LEAF_SIZE)
                    }
                    BLOCK_LEAF_SIZE
                },
                {
                    fn EXCESS_STAKE_RECEIVER(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<BOLDUpgradeActionCalls> {
                        <EXCESS_STAKE_RECEIVERCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(BOLDUpgradeActionCalls::EXCESS_STAKE_RECEIVER)
                    }
                    EXCESS_STAKE_RECEIVER
                },
                {
                    fn THRESHOLD(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<BOLDUpgradeActionCalls> {
                        <THRESHOLDCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(BOLDUpgradeActionCalls::THRESHOLD)
                    }
                    THRESHOLD
                },
                {
                    fn IMPL_INBOX(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<BOLDUpgradeActionCalls> {
                        <IMPL_INBOXCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(BOLDUpgradeActionCalls::IMPL_INBOX)
                    }
                    IMPL_INBOX
                },
                {
                    fn CHAIN_ID(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<BOLDUpgradeActionCalls> {
                        <CHAIN_IDCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(BOLDUpgradeActionCalls::CHAIN_ID)
                    }
                    CHAIN_ID
                },
                {
                    fn OLD_ROLLUP(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<BOLDUpgradeActionCalls> {
                        <OLD_ROLLUPCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(BOLDUpgradeActionCalls::OLD_ROLLUP)
                    }
                    OLD_ROLLUP
                },
                {
                    fn CHALLENGE_PERIOD_BLOCKS(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<BOLDUpgradeActionCalls> {
                        <CHALLENGE_PERIOD_BLOCKSCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(BOLDUpgradeActionCalls::CHALLENGE_PERIOD_BLOCKS)
                    }
                    CHALLENGE_PERIOD_BLOCKS
                },
                {
                    fn validateRollupDeployedAtAddress(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<BOLDUpgradeActionCalls> {
                        <validateRollupDeployedAtAddressCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(BOLDUpgradeActionCalls::validateRollupDeployedAtAddress)
                    }
                    validateRollupDeployedAtAddress
                },
                {
                    fn OSP(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<BOLDUpgradeActionCalls> {
                        <OSPCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(BOLDUpgradeActionCalls::OSP)
                    }
                    OSP
                },
                {
                    fn DISABLE_VALIDATOR_WHITELIST(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<BOLDUpgradeActionCalls> {
                        <DISABLE_VALIDATOR_WHITELISTCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(BOLDUpgradeActionCalls::DISABLE_VALIDATOR_WHITELIST)
                    }
                    DISABLE_VALIDATOR_WHITELIST
                },
                {
                    fn MINI_STAKE_AMOUNTS_STORAGE(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<BOLDUpgradeActionCalls> {
                        <MINI_STAKE_AMOUNTS_STORAGECall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(BOLDUpgradeActionCalls::MINI_STAKE_AMOUNTS_STORAGE)
                    }
                    MINI_STAKE_AMOUNTS_STORAGE
                },
                {
                    fn INBOX(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<BOLDUpgradeActionCalls> {
                        <INBOXCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(BOLDUpgradeActionCalls::INBOX)
                    }
                    INBOX
                },
                {
                    fn REI(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<BOLDUpgradeActionCalls> {
                        <REICall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(BOLDUpgradeActionCalls::REI)
                    }
                    REI
                },
                {
                    fn IMPL_REI(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<BOLDUpgradeActionCalls> {
                        <IMPL_REICall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(BOLDUpgradeActionCalls::IMPL_REI)
                    }
                    IMPL_REI
                },
                {
                    fn IMPL_SEQUENCER_INBOX(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<BOLDUpgradeActionCalls> {
                        <IMPL_SEQUENCER_INBOXCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(BOLDUpgradeActionCalls::IMPL_SEQUENCER_INBOX)
                    }
                    IMPL_SEQUENCER_INBOX
                },
                {
                    fn IMPL_OUTBOX(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<BOLDUpgradeActionCalls> {
                        <IMPL_OUTBOXCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(BOLDUpgradeActionCalls::IMPL_OUTBOX)
                    }
                    IMPL_OUTBOX
                },
                {
                    fn PREIMAGE_LOOKUP(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<BOLDUpgradeActionCalls> {
                        <PREIMAGE_LOOKUPCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(BOLDUpgradeActionCalls::PREIMAGE_LOOKUP)
                    }
                    PREIMAGE_LOOKUP
                },
                {
                    fn SEQ_INBOX(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<BOLDUpgradeActionCalls> {
                        <SEQ_INBOXCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(BOLDUpgradeActionCalls::SEQ_INBOX)
                    }
                    SEQ_INBOX
                },
                {
                    fn MAX(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<BOLDUpgradeActionCalls> {
                        <MAXCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(BOLDUpgradeActionCalls::MAX)
                    }
                    MAX
                },
                {
                    fn IMPL_BRIDGE(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<BOLDUpgradeActionCalls> {
                        <IMPL_BRIDGECall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(BOLDUpgradeActionCalls::IMPL_BRIDGE)
                    }
                    IMPL_BRIDGE
                },
                {
                    fn IS_DELAY_BUFFERABLE(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<BOLDUpgradeActionCalls> {
                        <IS_DELAY_BUFFERABLECall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(BOLDUpgradeActionCalls::IS_DELAY_BUFFERABLE)
                    }
                    IS_DELAY_BUFFERABLE
                },
                {
                    fn REPLENISH_RATE_IN_BASIS(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<BOLDUpgradeActionCalls> {
                        <REPLENISH_RATE_IN_BASISCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(BOLDUpgradeActionCalls::REPLENISH_RATE_IN_BASIS)
                    }
                    REPLENISH_RATE_IN_BASIS
                },
                {
                    fn perform(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<BOLDUpgradeActionCalls> {
                        <performCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(BOLDUpgradeActionCalls::perform)
                    }
                    perform
                },
                {
                    fn CHALLENGE_GRACE_PERIOD_BLOCKS(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<BOLDUpgradeActionCalls> {
                        <CHALLENGE_GRACE_PERIOD_BLOCKSCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(BOLDUpgradeActionCalls::CHALLENGE_GRACE_PERIOD_BLOCKS)
                    }
                    CHALLENGE_GRACE_PERIOD_BLOCKS
                },
                {
                    fn BRIDGE(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<BOLDUpgradeActionCalls> {
                        <BRIDGECall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(BOLDUpgradeActionCalls::BRIDGE)
                    }
                    BRIDGE
                },
                {
                    fn SMALLSTEP_LEAF_SIZE(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<BOLDUpgradeActionCalls> {
                        <SMALLSTEP_LEAF_SIZECall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(BOLDUpgradeActionCalls::SMALLSTEP_LEAF_SIZE)
                    }
                    SMALLSTEP_LEAF_SIZE
                },
                {
                    fn STAKE_AMOUNT(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<BOLDUpgradeActionCalls> {
                        <STAKE_AMOUNTCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(BOLDUpgradeActionCalls::STAKE_AMOUNT)
                    }
                    STAKE_AMOUNT
                },
            ];
            let Ok(idx) = Self::SELECTORS.binary_search(&selector) else {
                return Err(
                    alloy_sol_types::Error::unknown_selector(
                        <Self as alloy_sol_types::SolInterface>::NAME,
                        selector,
                    ),
                );
            };
            DECODE_SHIMS[idx](data, validate)
        }
        #[inline]
        fn abi_encoded_size(&self) -> usize {
            match self {
                Self::BIGSTEP_LEAF_SIZE(inner) => {
                    <BIGSTEP_LEAF_SIZECall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::BLOCK_LEAF_SIZE(inner) => {
                    <BLOCK_LEAF_SIZECall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::BRIDGE(inner) => {
                    <BRIDGECall as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::CHAIN_ID(inner) => {
                    <CHAIN_IDCall as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::CHALLENGE_GRACE_PERIOD_BLOCKS(inner) => {
                    <CHALLENGE_GRACE_PERIOD_BLOCKSCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::CHALLENGE_PERIOD_BLOCKS(inner) => {
                    <CHALLENGE_PERIOD_BLOCKSCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::CONFIRM_PERIOD_BLOCKS(inner) => {
                    <CONFIRM_PERIOD_BLOCKSCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::DISABLE_VALIDATOR_WHITELIST(inner) => {
                    <DISABLE_VALIDATOR_WHITELISTCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::EXCESS_STAKE_RECEIVER(inner) => {
                    <EXCESS_STAKE_RECEIVERCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::IMPL_BRIDGE(inner) => {
                    <IMPL_BRIDGECall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::IMPL_CHALLENGE_MANAGER(inner) => {
                    <IMPL_CHALLENGE_MANAGERCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::IMPL_INBOX(inner) => {
                    <IMPL_INBOXCall as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::IMPL_NEW_ROLLUP_ADMIN(inner) => {
                    <IMPL_NEW_ROLLUP_ADMINCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::IMPL_NEW_ROLLUP_USER(inner) => {
                    <IMPL_NEW_ROLLUP_USERCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::IMPL_OUTBOX(inner) => {
                    <IMPL_OUTBOXCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::IMPL_REI(inner) => {
                    <IMPL_REICall as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::IMPL_SEQUENCER_INBOX(inner) => {
                    <IMPL_SEQUENCER_INBOXCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::INBOX(inner) => {
                    <INBOXCall as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::IS_DELAY_BUFFERABLE(inner) => {
                    <IS_DELAY_BUFFERABLECall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::MAX(inner) => {
                    <MAXCall as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::MINIMUM_ASSERTION_PERIOD(inner) => {
                    <MINIMUM_ASSERTION_PERIODCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::MINI_STAKE_AMOUNTS_STORAGE(inner) => {
                    <MINI_STAKE_AMOUNTS_STORAGECall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::NUM_BIGSTEP_LEVEL(inner) => {
                    <NUM_BIGSTEP_LEVELCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::OLD_ROLLUP(inner) => {
                    <OLD_ROLLUPCall as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::OSP(inner) => {
                    <OSPCall as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::OUTBOX(inner) => {
                    <OUTBOXCall as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::PREIMAGE_LOOKUP(inner) => {
                    <PREIMAGE_LOOKUPCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::PROXY_ADMIN_BRIDGE(inner) => {
                    <PROXY_ADMIN_BRIDGECall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::PROXY_ADMIN_INBOX(inner) => {
                    <PROXY_ADMIN_INBOXCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::PROXY_ADMIN_OUTBOX(inner) => {
                    <PROXY_ADMIN_OUTBOXCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::PROXY_ADMIN_REI(inner) => {
                    <PROXY_ADMIN_REICall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::PROXY_ADMIN_SEQUENCER_INBOX(inner) => {
                    <PROXY_ADMIN_SEQUENCER_INBOXCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::REI(inner) => {
                    <REICall as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::REPLENISH_RATE_IN_BASIS(inner) => {
                    <REPLENISH_RATE_IN_BASISCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::SECONDS_PER_SLOT(inner) => {
                    <SECONDS_PER_SLOTCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::SEQ_INBOX(inner) => {
                    <SEQ_INBOXCall as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::SMALLSTEP_LEAF_SIZE(inner) => {
                    <SMALLSTEP_LEAF_SIZECall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::STAKE_AMOUNT(inner) => {
                    <STAKE_AMOUNTCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::STAKE_TOKEN(inner) => {
                    <STAKE_TOKENCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::THRESHOLD(inner) => {
                    <THRESHOLDCall as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::VALIDATOR_AFK_BLOCKS(inner) => {
                    <VALIDATOR_AFK_BLOCKSCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::expectedRollupAddress(inner) => {
                    <expectedRollupAddressCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::perform(inner) => {
                    <performCall as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::validateRollupDeployedAtAddress(inner) => {
                    <validateRollupDeployedAtAddressCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
            }
        }
        #[inline]
        fn abi_encode_raw(&self, out: &mut alloy_sol_types::private::Vec<u8>) {
            match self {
                Self::BIGSTEP_LEAF_SIZE(inner) => {
                    <BIGSTEP_LEAF_SIZECall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::BLOCK_LEAF_SIZE(inner) => {
                    <BLOCK_LEAF_SIZECall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::BRIDGE(inner) => {
                    <BRIDGECall as alloy_sol_types::SolCall>::abi_encode_raw(inner, out)
                }
                Self::CHAIN_ID(inner) => {
                    <CHAIN_IDCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::CHALLENGE_GRACE_PERIOD_BLOCKS(inner) => {
                    <CHALLENGE_GRACE_PERIOD_BLOCKSCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::CHALLENGE_PERIOD_BLOCKS(inner) => {
                    <CHALLENGE_PERIOD_BLOCKSCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::CONFIRM_PERIOD_BLOCKS(inner) => {
                    <CONFIRM_PERIOD_BLOCKSCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::DISABLE_VALIDATOR_WHITELIST(inner) => {
                    <DISABLE_VALIDATOR_WHITELISTCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::EXCESS_STAKE_RECEIVER(inner) => {
                    <EXCESS_STAKE_RECEIVERCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::IMPL_BRIDGE(inner) => {
                    <IMPL_BRIDGECall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::IMPL_CHALLENGE_MANAGER(inner) => {
                    <IMPL_CHALLENGE_MANAGERCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::IMPL_INBOX(inner) => {
                    <IMPL_INBOXCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::IMPL_NEW_ROLLUP_ADMIN(inner) => {
                    <IMPL_NEW_ROLLUP_ADMINCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::IMPL_NEW_ROLLUP_USER(inner) => {
                    <IMPL_NEW_ROLLUP_USERCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::IMPL_OUTBOX(inner) => {
                    <IMPL_OUTBOXCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::IMPL_REI(inner) => {
                    <IMPL_REICall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::IMPL_SEQUENCER_INBOX(inner) => {
                    <IMPL_SEQUENCER_INBOXCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::INBOX(inner) => {
                    <INBOXCall as alloy_sol_types::SolCall>::abi_encode_raw(inner, out)
                }
                Self::IS_DELAY_BUFFERABLE(inner) => {
                    <IS_DELAY_BUFFERABLECall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::MAX(inner) => {
                    <MAXCall as alloy_sol_types::SolCall>::abi_encode_raw(inner, out)
                }
                Self::MINIMUM_ASSERTION_PERIOD(inner) => {
                    <MINIMUM_ASSERTION_PERIODCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::MINI_STAKE_AMOUNTS_STORAGE(inner) => {
                    <MINI_STAKE_AMOUNTS_STORAGECall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::NUM_BIGSTEP_LEVEL(inner) => {
                    <NUM_BIGSTEP_LEVELCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::OLD_ROLLUP(inner) => {
                    <OLD_ROLLUPCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::OSP(inner) => {
                    <OSPCall as alloy_sol_types::SolCall>::abi_encode_raw(inner, out)
                }
                Self::OUTBOX(inner) => {
                    <OUTBOXCall as alloy_sol_types::SolCall>::abi_encode_raw(inner, out)
                }
                Self::PREIMAGE_LOOKUP(inner) => {
                    <PREIMAGE_LOOKUPCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::PROXY_ADMIN_BRIDGE(inner) => {
                    <PROXY_ADMIN_BRIDGECall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::PROXY_ADMIN_INBOX(inner) => {
                    <PROXY_ADMIN_INBOXCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::PROXY_ADMIN_OUTBOX(inner) => {
                    <PROXY_ADMIN_OUTBOXCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::PROXY_ADMIN_REI(inner) => {
                    <PROXY_ADMIN_REICall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::PROXY_ADMIN_SEQUENCER_INBOX(inner) => {
                    <PROXY_ADMIN_SEQUENCER_INBOXCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::REI(inner) => {
                    <REICall as alloy_sol_types::SolCall>::abi_encode_raw(inner, out)
                }
                Self::REPLENISH_RATE_IN_BASIS(inner) => {
                    <REPLENISH_RATE_IN_BASISCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::SECONDS_PER_SLOT(inner) => {
                    <SECONDS_PER_SLOTCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::SEQ_INBOX(inner) => {
                    <SEQ_INBOXCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::SMALLSTEP_LEAF_SIZE(inner) => {
                    <SMALLSTEP_LEAF_SIZECall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::STAKE_AMOUNT(inner) => {
                    <STAKE_AMOUNTCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::STAKE_TOKEN(inner) => {
                    <STAKE_TOKENCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::THRESHOLD(inner) => {
                    <THRESHOLDCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::VALIDATOR_AFK_BLOCKS(inner) => {
                    <VALIDATOR_AFK_BLOCKSCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::expectedRollupAddress(inner) => {
                    <expectedRollupAddressCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::perform(inner) => {
                    <performCall as alloy_sol_types::SolCall>::abi_encode_raw(inner, out)
                }
                Self::validateRollupDeployedAtAddress(inner) => {
                    <validateRollupDeployedAtAddressCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
            }
        }
    }
    ///Container for all the [`BOLDUpgradeAction`](self) events.
    pub enum BOLDUpgradeActionEvents {
        #[allow(missing_docs)]
        RollupMigrated(RollupMigrated),
    }
    #[automatically_derived]
    impl BOLDUpgradeActionEvents {
        /// All the selectors of this enum.
        ///
        /// Note that the selectors might not be in the same order as the variants.
        /// No guarantees are made about the order of the selectors.
        ///
        /// Prefer using `SolInterface` methods instead.
        pub const SELECTORS: &'static [[u8; 32usize]] = &[
            [
                126u8,
                92u8,
                197u8,
                195u8,
                252u8,
                224u8,
                70u8,
                216u8,
                104u8,
                213u8,
                145u8,
                133u8,
                72u8,
                223u8,
                141u8,
                62u8,
                142u8,
                249u8,
                240u8,
                158u8,
                111u8,
                179u8,
                10u8,
                104u8,
                8u8,
                31u8,
                31u8,
                19u8,
                72u8,
                205u8,
                3u8,
                20u8,
            ],
        ];
    }
    #[automatically_derived]
    impl alloy_sol_types::SolEventInterface for BOLDUpgradeActionEvents {
        const NAME: &'static str = "BOLDUpgradeActionEvents";
        const COUNT: usize = 1usize;
        fn decode_raw_log(
            topics: &[alloy_sol_types::Word],
            data: &[u8],
            validate: bool,
        ) -> alloy_sol_types::Result<Self> {
            match topics.first().copied() {
                Some(<RollupMigrated as alloy_sol_types::SolEvent>::SIGNATURE_HASH) => {
                    <RollupMigrated as alloy_sol_types::SolEvent>::decode_raw_log(
                            topics,
                            data,
                            validate,
                        )
                        .map(Self::RollupMigrated)
                }
                _ => {
                    alloy_sol_types::private::Err(alloy_sol_types::Error::InvalidLog {
                        name: <Self as alloy_sol_types::SolEventInterface>::NAME,
                        log: alloy_sol_types::private::Box::new(
                            alloy_sol_types::private::LogData::new_unchecked(
                                topics.to_vec(),
                                data.to_vec().into(),
                            ),
                        ),
                    })
                }
            }
        }
    }
    #[automatically_derived]
    impl alloy_sol_types::private::IntoLogData for BOLDUpgradeActionEvents {
        fn to_log_data(&self) -> alloy_sol_types::private::LogData {
            match self {
                Self::RollupMigrated(inner) => {
                    alloy_sol_types::private::IntoLogData::to_log_data(inner)
                }
            }
        }
        fn into_log_data(self) -> alloy_sol_types::private::LogData {
            match self {
                Self::RollupMigrated(inner) => {
                    alloy_sol_types::private::IntoLogData::into_log_data(inner)
                }
            }
        }
    }
    use alloy::contract as alloy_contract;
    /**Creates a new wrapper around an on-chain [`BOLDUpgradeAction`](self) contract instance.

See the [wrapper's documentation](`BOLDUpgradeActionInstance`) for more details.*/
    #[inline]
    pub const fn new<
        T: alloy_contract::private::Transport + ::core::clone::Clone,
        P: alloy_contract::private::Provider<T, N>,
        N: alloy_contract::private::Network,
    >(
        address: alloy_sol_types::private::Address,
        provider: P,
    ) -> BOLDUpgradeActionInstance<T, P, N> {
        BOLDUpgradeActionInstance::<T, P, N>::new(address, provider)
    }
    /**Deploys this contract using the given `provider` and constructor arguments, if any.

Returns a new instance of the contract, if the deployment was successful.

For more fine-grained control over the deployment process, use [`deploy_builder`] instead.*/
    #[inline]
    pub fn deploy<
        T: alloy_contract::private::Transport + ::core::clone::Clone,
        P: alloy_contract::private::Provider<T, N>,
        N: alloy_contract::private::Network,
    >(
        provider: P,
        contracts: <Contracts as alloy::sol_types::SolType>::RustType,
        proxyAdmins: <ProxyAdmins as alloy::sol_types::SolType>::RustType,
        implementations: <Implementations as alloy::sol_types::SolType>::RustType,
        settings: <Settings as alloy::sol_types::SolType>::RustType,
    ) -> impl ::core::future::Future<
        Output = alloy_contract::Result<BOLDUpgradeActionInstance<T, P, N>>,
    > {
        BOLDUpgradeActionInstance::<
            T,
            P,
            N,
        >::deploy(provider, contracts, proxyAdmins, implementations, settings)
    }
    /**Creates a `RawCallBuilder` for deploying this contract using the given `provider`
and constructor arguments, if any.

This is a simple wrapper around creating a `RawCallBuilder` with the data set to
the bytecode concatenated with the constructor's ABI-encoded arguments.*/
    #[inline]
    pub fn deploy_builder<
        T: alloy_contract::private::Transport + ::core::clone::Clone,
        P: alloy_contract::private::Provider<T, N>,
        N: alloy_contract::private::Network,
    >(
        provider: P,
        contracts: <Contracts as alloy::sol_types::SolType>::RustType,
        proxyAdmins: <ProxyAdmins as alloy::sol_types::SolType>::RustType,
        implementations: <Implementations as alloy::sol_types::SolType>::RustType,
        settings: <Settings as alloy::sol_types::SolType>::RustType,
    ) -> alloy_contract::RawCallBuilder<T, P, N> {
        BOLDUpgradeActionInstance::<
            T,
            P,
            N,
        >::deploy_builder(provider, contracts, proxyAdmins, implementations, settings)
    }
    /**A [`BOLDUpgradeAction`](self) instance.

Contains type-safe methods for interacting with an on-chain instance of the
[`BOLDUpgradeAction`](self) contract located at a given `address`, using a given
provider `P`.

If the contract bytecode is available (see the [`sol!`](alloy_sol_types::sol!)
documentation on how to provide it), the `deploy` and `deploy_builder` methods can
be used to deploy a new instance of the contract.

See the [module-level documentation](self) for all the available methods.*/
    #[derive(Clone)]
    pub struct BOLDUpgradeActionInstance<T, P, N = alloy_contract::private::Ethereum> {
        address: alloy_sol_types::private::Address,
        provider: P,
        _network_transport: ::core::marker::PhantomData<(N, T)>,
    }
    #[automatically_derived]
    impl<T, P, N> ::core::fmt::Debug for BOLDUpgradeActionInstance<T, P, N> {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
            f.debug_tuple("BOLDUpgradeActionInstance").field(&self.address).finish()
        }
    }
    /// Instantiation and getters/setters.
    #[automatically_derived]
    impl<
        T: alloy_contract::private::Transport + ::core::clone::Clone,
        P: alloy_contract::private::Provider<T, N>,
        N: alloy_contract::private::Network,
    > BOLDUpgradeActionInstance<T, P, N> {
        /**Creates a new wrapper around an on-chain [`BOLDUpgradeAction`](self) contract instance.

See the [wrapper's documentation](`BOLDUpgradeActionInstance`) for more details.*/
        #[inline]
        pub const fn new(
            address: alloy_sol_types::private::Address,
            provider: P,
        ) -> Self {
            Self {
                address,
                provider,
                _network_transport: ::core::marker::PhantomData,
            }
        }
        /**Deploys this contract using the given `provider` and constructor arguments, if any.

Returns a new instance of the contract, if the deployment was successful.

For more fine-grained control over the deployment process, use [`deploy_builder`] instead.*/
        #[inline]
        pub async fn deploy(
            provider: P,
            contracts: <Contracts as alloy::sol_types::SolType>::RustType,
            proxyAdmins: <ProxyAdmins as alloy::sol_types::SolType>::RustType,
            implementations: <Implementations as alloy::sol_types::SolType>::RustType,
            settings: <Settings as alloy::sol_types::SolType>::RustType,
        ) -> alloy_contract::Result<BOLDUpgradeActionInstance<T, P, N>> {
            let call_builder = Self::deploy_builder(
                provider,
                contracts,
                proxyAdmins,
                implementations,
                settings,
            );
            let contract_address = call_builder.deploy().await?;
            Ok(Self::new(contract_address, call_builder.provider))
        }
        /**Creates a `RawCallBuilder` for deploying this contract using the given `provider`
and constructor arguments, if any.

This is a simple wrapper around creating a `RawCallBuilder` with the data set to
the bytecode concatenated with the constructor's ABI-encoded arguments.*/
        #[inline]
        pub fn deploy_builder(
            provider: P,
            contracts: <Contracts as alloy::sol_types::SolType>::RustType,
            proxyAdmins: <ProxyAdmins as alloy::sol_types::SolType>::RustType,
            implementations: <Implementations as alloy::sol_types::SolType>::RustType,
            settings: <Settings as alloy::sol_types::SolType>::RustType,
        ) -> alloy_contract::RawCallBuilder<T, P, N> {
            alloy_contract::RawCallBuilder::new_raw_deploy(
                provider,
                [
                    &BYTECODE[..],
                    &alloy_sol_types::SolConstructor::abi_encode(
                        &constructorCall {
                            contracts,
                            proxyAdmins,
                            implementations,
                            settings,
                        },
                    )[..],
                ]
                    .concat()
                    .into(),
            )
        }
        /// Returns a reference to the address.
        #[inline]
        pub const fn address(&self) -> &alloy_sol_types::private::Address {
            &self.address
        }
        /// Sets the address.
        #[inline]
        pub fn set_address(&mut self, address: alloy_sol_types::private::Address) {
            self.address = address;
        }
        /// Sets the address and returns `self`.
        pub fn at(mut self, address: alloy_sol_types::private::Address) -> Self {
            self.set_address(address);
            self
        }
        /// Returns a reference to the provider.
        #[inline]
        pub const fn provider(&self) -> &P {
            &self.provider
        }
    }
    impl<T, P: ::core::clone::Clone, N> BOLDUpgradeActionInstance<T, &P, N> {
        /// Clones the provider and returns a new instance with the cloned provider.
        #[inline]
        pub fn with_cloned_provider(self) -> BOLDUpgradeActionInstance<T, P, N> {
            BOLDUpgradeActionInstance {
                address: self.address,
                provider: ::core::clone::Clone::clone(&self.provider),
                _network_transport: ::core::marker::PhantomData,
            }
        }
    }
    /// Function calls.
    #[automatically_derived]
    impl<
        T: alloy_contract::private::Transport + ::core::clone::Clone,
        P: alloy_contract::private::Provider<T, N>,
        N: alloy_contract::private::Network,
    > BOLDUpgradeActionInstance<T, P, N> {
        /// Creates a new call builder using this contract instance's provider and address.
        ///
        /// Note that the call can be any function call, not just those defined in this
        /// contract. Prefer using the other methods for building type-safe contract calls.
        pub fn call_builder<C: alloy_sol_types::SolCall>(
            &self,
            call: &C,
        ) -> alloy_contract::SolCallBuilder<T, &P, C, N> {
            alloy_contract::SolCallBuilder::new_sol(&self.provider, &self.address, call)
        }
        ///Creates a new call builder for the [`BIGSTEP_LEAF_SIZE`] function.
        pub fn BIGSTEP_LEAF_SIZE(
            &self,
        ) -> alloy_contract::SolCallBuilder<T, &P, BIGSTEP_LEAF_SIZECall, N> {
            self.call_builder(&BIGSTEP_LEAF_SIZECall {})
        }
        ///Creates a new call builder for the [`BLOCK_LEAF_SIZE`] function.
        pub fn BLOCK_LEAF_SIZE(
            &self,
        ) -> alloy_contract::SolCallBuilder<T, &P, BLOCK_LEAF_SIZECall, N> {
            self.call_builder(&BLOCK_LEAF_SIZECall {})
        }
        ///Creates a new call builder for the [`BRIDGE`] function.
        pub fn BRIDGE(&self) -> alloy_contract::SolCallBuilder<T, &P, BRIDGECall, N> {
            self.call_builder(&BRIDGECall {})
        }
        ///Creates a new call builder for the [`CHAIN_ID`] function.
        pub fn CHAIN_ID(
            &self,
        ) -> alloy_contract::SolCallBuilder<T, &P, CHAIN_IDCall, N> {
            self.call_builder(&CHAIN_IDCall {})
        }
        ///Creates a new call builder for the [`CHALLENGE_GRACE_PERIOD_BLOCKS`] function.
        pub fn CHALLENGE_GRACE_PERIOD_BLOCKS(
            &self,
        ) -> alloy_contract::SolCallBuilder<
            T,
            &P,
            CHALLENGE_GRACE_PERIOD_BLOCKSCall,
            N,
        > {
            self.call_builder(
                &CHALLENGE_GRACE_PERIOD_BLOCKSCall {
                },
            )
        }
        ///Creates a new call builder for the [`CHALLENGE_PERIOD_BLOCKS`] function.
        pub fn CHALLENGE_PERIOD_BLOCKS(
            &self,
        ) -> alloy_contract::SolCallBuilder<T, &P, CHALLENGE_PERIOD_BLOCKSCall, N> {
            self.call_builder(&CHALLENGE_PERIOD_BLOCKSCall {})
        }
        ///Creates a new call builder for the [`CONFIRM_PERIOD_BLOCKS`] function.
        pub fn CONFIRM_PERIOD_BLOCKS(
            &self,
        ) -> alloy_contract::SolCallBuilder<T, &P, CONFIRM_PERIOD_BLOCKSCall, N> {
            self.call_builder(&CONFIRM_PERIOD_BLOCKSCall {})
        }
        ///Creates a new call builder for the [`DISABLE_VALIDATOR_WHITELIST`] function.
        pub fn DISABLE_VALIDATOR_WHITELIST(
            &self,
        ) -> alloy_contract::SolCallBuilder<T, &P, DISABLE_VALIDATOR_WHITELISTCall, N> {
            self.call_builder(&DISABLE_VALIDATOR_WHITELISTCall {})
        }
        ///Creates a new call builder for the [`EXCESS_STAKE_RECEIVER`] function.
        pub fn EXCESS_STAKE_RECEIVER(
            &self,
        ) -> alloy_contract::SolCallBuilder<T, &P, EXCESS_STAKE_RECEIVERCall, N> {
            self.call_builder(&EXCESS_STAKE_RECEIVERCall {})
        }
        ///Creates a new call builder for the [`IMPL_BRIDGE`] function.
        pub fn IMPL_BRIDGE(
            &self,
        ) -> alloy_contract::SolCallBuilder<T, &P, IMPL_BRIDGECall, N> {
            self.call_builder(&IMPL_BRIDGECall {})
        }
        ///Creates a new call builder for the [`IMPL_CHALLENGE_MANAGER`] function.
        pub fn IMPL_CHALLENGE_MANAGER(
            &self,
        ) -> alloy_contract::SolCallBuilder<T, &P, IMPL_CHALLENGE_MANAGERCall, N> {
            self.call_builder(&IMPL_CHALLENGE_MANAGERCall {})
        }
        ///Creates a new call builder for the [`IMPL_INBOX`] function.
        pub fn IMPL_INBOX(
            &self,
        ) -> alloy_contract::SolCallBuilder<T, &P, IMPL_INBOXCall, N> {
            self.call_builder(&IMPL_INBOXCall {})
        }
        ///Creates a new call builder for the [`IMPL_NEW_ROLLUP_ADMIN`] function.
        pub fn IMPL_NEW_ROLLUP_ADMIN(
            &self,
        ) -> alloy_contract::SolCallBuilder<T, &P, IMPL_NEW_ROLLUP_ADMINCall, N> {
            self.call_builder(&IMPL_NEW_ROLLUP_ADMINCall {})
        }
        ///Creates a new call builder for the [`IMPL_NEW_ROLLUP_USER`] function.
        pub fn IMPL_NEW_ROLLUP_USER(
            &self,
        ) -> alloy_contract::SolCallBuilder<T, &P, IMPL_NEW_ROLLUP_USERCall, N> {
            self.call_builder(&IMPL_NEW_ROLLUP_USERCall {})
        }
        ///Creates a new call builder for the [`IMPL_OUTBOX`] function.
        pub fn IMPL_OUTBOX(
            &self,
        ) -> alloy_contract::SolCallBuilder<T, &P, IMPL_OUTBOXCall, N> {
            self.call_builder(&IMPL_OUTBOXCall {})
        }
        ///Creates a new call builder for the [`IMPL_REI`] function.
        pub fn IMPL_REI(
            &self,
        ) -> alloy_contract::SolCallBuilder<T, &P, IMPL_REICall, N> {
            self.call_builder(&IMPL_REICall {})
        }
        ///Creates a new call builder for the [`IMPL_SEQUENCER_INBOX`] function.
        pub fn IMPL_SEQUENCER_INBOX(
            &self,
        ) -> alloy_contract::SolCallBuilder<T, &P, IMPL_SEQUENCER_INBOXCall, N> {
            self.call_builder(&IMPL_SEQUENCER_INBOXCall {})
        }
        ///Creates a new call builder for the [`INBOX`] function.
        pub fn INBOX(&self) -> alloy_contract::SolCallBuilder<T, &P, INBOXCall, N> {
            self.call_builder(&INBOXCall {})
        }
        ///Creates a new call builder for the [`IS_DELAY_BUFFERABLE`] function.
        pub fn IS_DELAY_BUFFERABLE(
            &self,
        ) -> alloy_contract::SolCallBuilder<T, &P, IS_DELAY_BUFFERABLECall, N> {
            self.call_builder(&IS_DELAY_BUFFERABLECall {})
        }
        ///Creates a new call builder for the [`MAX`] function.
        pub fn MAX(&self) -> alloy_contract::SolCallBuilder<T, &P, MAXCall, N> {
            self.call_builder(&MAXCall {})
        }
        ///Creates a new call builder for the [`MINIMUM_ASSERTION_PERIOD`] function.
        pub fn MINIMUM_ASSERTION_PERIOD(
            &self,
        ) -> alloy_contract::SolCallBuilder<T, &P, MINIMUM_ASSERTION_PERIODCall, N> {
            self.call_builder(&MINIMUM_ASSERTION_PERIODCall {})
        }
        ///Creates a new call builder for the [`MINI_STAKE_AMOUNTS_STORAGE`] function.
        pub fn MINI_STAKE_AMOUNTS_STORAGE(
            &self,
        ) -> alloy_contract::SolCallBuilder<T, &P, MINI_STAKE_AMOUNTS_STORAGECall, N> {
            self.call_builder(&MINI_STAKE_AMOUNTS_STORAGECall {})
        }
        ///Creates a new call builder for the [`NUM_BIGSTEP_LEVEL`] function.
        pub fn NUM_BIGSTEP_LEVEL(
            &self,
        ) -> alloy_contract::SolCallBuilder<T, &P, NUM_BIGSTEP_LEVELCall, N> {
            self.call_builder(&NUM_BIGSTEP_LEVELCall {})
        }
        ///Creates a new call builder for the [`OLD_ROLLUP`] function.
        pub fn OLD_ROLLUP(
            &self,
        ) -> alloy_contract::SolCallBuilder<T, &P, OLD_ROLLUPCall, N> {
            self.call_builder(&OLD_ROLLUPCall {})
        }
        ///Creates a new call builder for the [`OSP`] function.
        pub fn OSP(&self) -> alloy_contract::SolCallBuilder<T, &P, OSPCall, N> {
            self.call_builder(&OSPCall {})
        }
        ///Creates a new call builder for the [`OUTBOX`] function.
        pub fn OUTBOX(&self) -> alloy_contract::SolCallBuilder<T, &P, OUTBOXCall, N> {
            self.call_builder(&OUTBOXCall {})
        }
        ///Creates a new call builder for the [`PREIMAGE_LOOKUP`] function.
        pub fn PREIMAGE_LOOKUP(
            &self,
        ) -> alloy_contract::SolCallBuilder<T, &P, PREIMAGE_LOOKUPCall, N> {
            self.call_builder(&PREIMAGE_LOOKUPCall {})
        }
        ///Creates a new call builder for the [`PROXY_ADMIN_BRIDGE`] function.
        pub fn PROXY_ADMIN_BRIDGE(
            &self,
        ) -> alloy_contract::SolCallBuilder<T, &P, PROXY_ADMIN_BRIDGECall, N> {
            self.call_builder(&PROXY_ADMIN_BRIDGECall {})
        }
        ///Creates a new call builder for the [`PROXY_ADMIN_INBOX`] function.
        pub fn PROXY_ADMIN_INBOX(
            &self,
        ) -> alloy_contract::SolCallBuilder<T, &P, PROXY_ADMIN_INBOXCall, N> {
            self.call_builder(&PROXY_ADMIN_INBOXCall {})
        }
        ///Creates a new call builder for the [`PROXY_ADMIN_OUTBOX`] function.
        pub fn PROXY_ADMIN_OUTBOX(
            &self,
        ) -> alloy_contract::SolCallBuilder<T, &P, PROXY_ADMIN_OUTBOXCall, N> {
            self.call_builder(&PROXY_ADMIN_OUTBOXCall {})
        }
        ///Creates a new call builder for the [`PROXY_ADMIN_REI`] function.
        pub fn PROXY_ADMIN_REI(
            &self,
        ) -> alloy_contract::SolCallBuilder<T, &P, PROXY_ADMIN_REICall, N> {
            self.call_builder(&PROXY_ADMIN_REICall {})
        }
        ///Creates a new call builder for the [`PROXY_ADMIN_SEQUENCER_INBOX`] function.
        pub fn PROXY_ADMIN_SEQUENCER_INBOX(
            &self,
        ) -> alloy_contract::SolCallBuilder<T, &P, PROXY_ADMIN_SEQUENCER_INBOXCall, N> {
            self.call_builder(&PROXY_ADMIN_SEQUENCER_INBOXCall {})
        }
        ///Creates a new call builder for the [`REI`] function.
        pub fn REI(&self) -> alloy_contract::SolCallBuilder<T, &P, REICall, N> {
            self.call_builder(&REICall {})
        }
        ///Creates a new call builder for the [`REPLENISH_RATE_IN_BASIS`] function.
        pub fn REPLENISH_RATE_IN_BASIS(
            &self,
        ) -> alloy_contract::SolCallBuilder<T, &P, REPLENISH_RATE_IN_BASISCall, N> {
            self.call_builder(&REPLENISH_RATE_IN_BASISCall {})
        }
        ///Creates a new call builder for the [`SECONDS_PER_SLOT`] function.
        pub fn SECONDS_PER_SLOT(
            &self,
        ) -> alloy_contract::SolCallBuilder<T, &P, SECONDS_PER_SLOTCall, N> {
            self.call_builder(&SECONDS_PER_SLOTCall {})
        }
        ///Creates a new call builder for the [`SEQ_INBOX`] function.
        pub fn SEQ_INBOX(
            &self,
        ) -> alloy_contract::SolCallBuilder<T, &P, SEQ_INBOXCall, N> {
            self.call_builder(&SEQ_INBOXCall {})
        }
        ///Creates a new call builder for the [`SMALLSTEP_LEAF_SIZE`] function.
        pub fn SMALLSTEP_LEAF_SIZE(
            &self,
        ) -> alloy_contract::SolCallBuilder<T, &P, SMALLSTEP_LEAF_SIZECall, N> {
            self.call_builder(&SMALLSTEP_LEAF_SIZECall {})
        }
        ///Creates a new call builder for the [`STAKE_AMOUNT`] function.
        pub fn STAKE_AMOUNT(
            &self,
        ) -> alloy_contract::SolCallBuilder<T, &P, STAKE_AMOUNTCall, N> {
            self.call_builder(&STAKE_AMOUNTCall {})
        }
        ///Creates a new call builder for the [`STAKE_TOKEN`] function.
        pub fn STAKE_TOKEN(
            &self,
        ) -> alloy_contract::SolCallBuilder<T, &P, STAKE_TOKENCall, N> {
            self.call_builder(&STAKE_TOKENCall {})
        }
        ///Creates a new call builder for the [`THRESHOLD`] function.
        pub fn THRESHOLD(
            &self,
        ) -> alloy_contract::SolCallBuilder<T, &P, THRESHOLDCall, N> {
            self.call_builder(&THRESHOLDCall {})
        }
        ///Creates a new call builder for the [`VALIDATOR_AFK_BLOCKS`] function.
        pub fn VALIDATOR_AFK_BLOCKS(
            &self,
        ) -> alloy_contract::SolCallBuilder<T, &P, VALIDATOR_AFK_BLOCKSCall, N> {
            self.call_builder(&VALIDATOR_AFK_BLOCKSCall {})
        }
        ///Creates a new call builder for the [`expectedRollupAddress`] function.
        pub fn expectedRollupAddress(
            &self,
            deployer: alloy::sol_types::private::Address,
            chainId: alloy::sol_types::private::primitives::aliases::U256,
        ) -> alloy_contract::SolCallBuilder<T, &P, expectedRollupAddressCall, N> {
            self.call_builder(
                &expectedRollupAddressCall {
                    deployer,
                    chainId,
                },
            )
        }
        ///Creates a new call builder for the [`perform`] function.
        pub fn perform(
            &self,
            validators: alloy::sol_types::private::Vec<
                alloy::sol_types::private::Address,
            >,
        ) -> alloy_contract::SolCallBuilder<T, &P, performCall, N> {
            self.call_builder(&performCall { validators })
        }
        ///Creates a new call builder for the [`validateRollupDeployedAtAddress`] function.
        pub fn validateRollupDeployedAtAddress(
            &self,
            rollupAddress: alloy::sol_types::private::Address,
            deployer: alloy::sol_types::private::Address,
            chainId: alloy::sol_types::private::primitives::aliases::U256,
        ) -> alloy_contract::SolCallBuilder<
            T,
            &P,
            validateRollupDeployedAtAddressCall,
            N,
        > {
            self.call_builder(
                &validateRollupDeployedAtAddressCall {
                    rollupAddress,
                    deployer,
                    chainId,
                },
            )
        }
    }
    /// Event filters.
    #[automatically_derived]
    impl<
        T: alloy_contract::private::Transport + ::core::clone::Clone,
        P: alloy_contract::private::Provider<T, N>,
        N: alloy_contract::private::Network,
    > BOLDUpgradeActionInstance<T, P, N> {
        /// Creates a new event filter using this contract instance's provider and address.
        ///
        /// Note that the type can be any event, not just those defined in this contract.
        /// Prefer using the other methods for building type-safe event filters.
        pub fn event_filter<E: alloy_sol_types::SolEvent>(
            &self,
        ) -> alloy_contract::Event<T, &P, E, N> {
            alloy_contract::Event::new_sol(&self.provider, &self.address)
        }
        ///Creates a new event filter for the [`RollupMigrated`] event.
        pub fn RollupMigrated_filter(
            &self,
        ) -> alloy_contract::Event<T, &P, RollupMigrated, N> {
            self.event_filter::<RollupMigrated>()
        }
    }
}
