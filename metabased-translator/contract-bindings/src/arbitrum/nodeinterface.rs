/**

Generated by the following Solidity interface...
```solidity
interface NodeInterface {
    function blockL1Num(uint64 l2BlockNum) external view returns (uint64 l1BlockNum);
    function constructOutboxProof(uint64 size, uint64 leaf) external view returns (bytes32 send, bytes32 root, bytes32[] memory proof);
    function estimateRetryableTicket(address sender, uint256 deposit, address to, uint256 l2CallValue, address excessFeeRefundAddress, address callValueRefundAddress, bytes memory data) external;
    function findBatchContainingBlock(uint64 blockNum) external view returns (uint64 batch);
    function gasEstimateComponents(address to, bool contractCreation, bytes memory data) external payable returns (uint64 gasEstimate, uint64 gasEstimateForL1, uint256 baseFee, uint256 l1BaseFeeEstimate);
    function gasEstimateL1Component(address to, bool contractCreation, bytes memory data) external payable returns (uint64 gasEstimateForL1, uint256 baseFee, uint256 l1BaseFeeEstimate);
    function getL1Confirmations(bytes32 blockHash) external view returns (uint64 confirmations);
    function l2BlockRangeForL1(uint64 blockNum) external view returns (uint64 firstBlock, uint64 lastBlock);
    function legacyLookupMessageBatchProof(uint256 batchNum, uint64 index) external view returns (bytes32[] memory proof, uint256 path, address l2Sender, address l1Dest, uint256 l2Block, uint256 l1Block, uint256 timestamp, uint256 amount, bytes memory calldataForL1);
    function nitroGenesisBlock() external pure returns (uint256 number);
}
```

...which was generated by the following JSON ABI:
```json
[
  {
    "type": "function",
    "name": "blockL1Num",
    "inputs": [
      {
        "name": "l2BlockNum",
        "type": "uint64",
        "internalType": "uint64"
      }
    ],
    "outputs": [
      {
        "name": "l1BlockNum",
        "type": "uint64",
        "internalType": "uint64"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "constructOutboxProof",
    "inputs": [
      {
        "name": "size",
        "type": "uint64",
        "internalType": "uint64"
      },
      {
        "name": "leaf",
        "type": "uint64",
        "internalType": "uint64"
      }
    ],
    "outputs": [
      {
        "name": "send",
        "type": "bytes32",
        "internalType": "bytes32"
      },
      {
        "name": "root",
        "type": "bytes32",
        "internalType": "bytes32"
      },
      {
        "name": "proof",
        "type": "bytes32[]",
        "internalType": "bytes32[]"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "estimateRetryableTicket",
    "inputs": [
      {
        "name": "sender",
        "type": "address",
        "internalType": "address"
      },
      {
        "name": "deposit",
        "type": "uint256",
        "internalType": "uint256"
      },
      {
        "name": "to",
        "type": "address",
        "internalType": "address"
      },
      {
        "name": "l2CallValue",
        "type": "uint256",
        "internalType": "uint256"
      },
      {
        "name": "excessFeeRefundAddress",
        "type": "address",
        "internalType": "address"
      },
      {
        "name": "callValueRefundAddress",
        "type": "address",
        "internalType": "address"
      },
      {
        "name": "data",
        "type": "bytes",
        "internalType": "bytes"
      }
    ],
    "outputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "findBatchContainingBlock",
    "inputs": [
      {
        "name": "blockNum",
        "type": "uint64",
        "internalType": "uint64"
      }
    ],
    "outputs": [
      {
        "name": "batch",
        "type": "uint64",
        "internalType": "uint64"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "gasEstimateComponents",
    "inputs": [
      {
        "name": "to",
        "type": "address",
        "internalType": "address"
      },
      {
        "name": "contractCreation",
        "type": "bool",
        "internalType": "bool"
      },
      {
        "name": "data",
        "type": "bytes",
        "internalType": "bytes"
      }
    ],
    "outputs": [
      {
        "name": "gasEstimate",
        "type": "uint64",
        "internalType": "uint64"
      },
      {
        "name": "gasEstimateForL1",
        "type": "uint64",
        "internalType": "uint64"
      },
      {
        "name": "baseFee",
        "type": "uint256",
        "internalType": "uint256"
      },
      {
        "name": "l1BaseFeeEstimate",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "stateMutability": "payable"
  },
  {
    "type": "function",
    "name": "gasEstimateL1Component",
    "inputs": [
      {
        "name": "to",
        "type": "address",
        "internalType": "address"
      },
      {
        "name": "contractCreation",
        "type": "bool",
        "internalType": "bool"
      },
      {
        "name": "data",
        "type": "bytes",
        "internalType": "bytes"
      }
    ],
    "outputs": [
      {
        "name": "gasEstimateForL1",
        "type": "uint64",
        "internalType": "uint64"
      },
      {
        "name": "baseFee",
        "type": "uint256",
        "internalType": "uint256"
      },
      {
        "name": "l1BaseFeeEstimate",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "stateMutability": "payable"
  },
  {
    "type": "function",
    "name": "getL1Confirmations",
    "inputs": [
      {
        "name": "blockHash",
        "type": "bytes32",
        "internalType": "bytes32"
      }
    ],
    "outputs": [
      {
        "name": "confirmations",
        "type": "uint64",
        "internalType": "uint64"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "l2BlockRangeForL1",
    "inputs": [
      {
        "name": "blockNum",
        "type": "uint64",
        "internalType": "uint64"
      }
    ],
    "outputs": [
      {
        "name": "firstBlock",
        "type": "uint64",
        "internalType": "uint64"
      },
      {
        "name": "lastBlock",
        "type": "uint64",
        "internalType": "uint64"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "legacyLookupMessageBatchProof",
    "inputs": [
      {
        "name": "batchNum",
        "type": "uint256",
        "internalType": "uint256"
      },
      {
        "name": "index",
        "type": "uint64",
        "internalType": "uint64"
      }
    ],
    "outputs": [
      {
        "name": "proof",
        "type": "bytes32[]",
        "internalType": "bytes32[]"
      },
      {
        "name": "path",
        "type": "uint256",
        "internalType": "uint256"
      },
      {
        "name": "l2Sender",
        "type": "address",
        "internalType": "address"
      },
      {
        "name": "l1Dest",
        "type": "address",
        "internalType": "address"
      },
      {
        "name": "l2Block",
        "type": "uint256",
        "internalType": "uint256"
      },
      {
        "name": "l1Block",
        "type": "uint256",
        "internalType": "uint256"
      },
      {
        "name": "timestamp",
        "type": "uint256",
        "internalType": "uint256"
      },
      {
        "name": "amount",
        "type": "uint256",
        "internalType": "uint256"
      },
      {
        "name": "calldataForL1",
        "type": "bytes",
        "internalType": "bytes"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "nitroGenesisBlock",
    "inputs": [],
    "outputs": [
      {
        "name": "number",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "stateMutability": "pure"
  }
]
```*/
#[allow(
    non_camel_case_types,
    non_snake_case,
    clippy::pub_underscore_fields,
    clippy::style,
    clippy::empty_structs_with_brackets
)]
pub mod NodeInterface {
    use super::*;
    use alloy::sol_types as alloy_sol_types;
    /// The creation / init bytecode of the contract.
    ///
    /// ```text
    ///0x
    /// ```
    #[rustfmt::skip]
    #[allow(clippy::all)]
    pub static BYTECODE: alloy_sol_types::private::Bytes = alloy_sol_types::private::Bytes::from_static(
        b"",
    );
    /// The runtime bytecode of the contract, as deployed on the network.
    ///
    /// ```text
    ///0x
    /// ```
    #[rustfmt::skip]
    #[allow(clippy::all)]
    pub static DEPLOYED_BYTECODE: alloy_sol_types::private::Bytes = alloy_sol_types::private::Bytes::from_static(
        b"",
    );
    /**Function with signature `blockL1Num(uint64)` and selector `0x6f275ef2`.
```solidity
function blockL1Num(uint64 l2BlockNum) external view returns (uint64 l1BlockNum);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct blockL1NumCall {
        #[allow(missing_docs)]
        pub l2BlockNum: u64,
    }
    ///Container type for the return parameters of the [`blockL1Num(uint64)`](blockL1NumCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct blockL1NumReturn {
        #[allow(missing_docs)]
        pub l1BlockNum: u64,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<64>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (u64,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<blockL1NumCall> for UnderlyingRustTuple<'_> {
                fn from(value: blockL1NumCall) -> Self {
                    (value.l2BlockNum,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for blockL1NumCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { l2BlockNum: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<64>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (u64,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<blockL1NumReturn> for UnderlyingRustTuple<'_> {
                fn from(value: blockL1NumReturn) -> Self {
                    (value.l1BlockNum,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for blockL1NumReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { l1BlockNum: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for blockL1NumCall {
            type Parameters<'a> = (alloy::sol_types::sol_data::Uint<64>,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = blockL1NumReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Uint<64>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "blockL1Num(uint64)";
            const SELECTOR: [u8; 4] = [111u8, 39u8, 94u8, 242u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        64,
                    > as alloy_sol_types::SolType>::tokenize(&self.l2BlockNum),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `constructOutboxProof(uint64,uint64)` and selector `0x42696350`.
```solidity
function constructOutboxProof(uint64 size, uint64 leaf) external view returns (bytes32 send, bytes32 root, bytes32[] memory proof);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct constructOutboxProofCall {
        #[allow(missing_docs)]
        pub size: u64,
        #[allow(missing_docs)]
        pub leaf: u64,
    }
    ///Container type for the return parameters of the [`constructOutboxProof(uint64,uint64)`](constructOutboxProofCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct constructOutboxProofReturn {
        #[allow(missing_docs)]
        pub send: alloy::sol_types::private::FixedBytes<32>,
        #[allow(missing_docs)]
        pub root: alloy::sol_types::private::FixedBytes<32>,
        #[allow(missing_docs)]
        pub proof: alloy::sol_types::private::Vec<
            alloy::sol_types::private::FixedBytes<32>,
        >,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::Uint<64>,
                alloy::sol_types::sol_data::Uint<64>,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (u64, u64);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<constructOutboxProofCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: constructOutboxProofCall) -> Self {
                    (value.size, value.leaf)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for constructOutboxProofCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        size: tuple.0,
                        leaf: tuple.1,
                    }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Array<
                    alloy::sol_types::sol_data::FixedBytes<32>,
                >,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::FixedBytes<32>,
                alloy::sol_types::private::FixedBytes<32>,
                alloy::sol_types::private::Vec<alloy::sol_types::private::FixedBytes<32>>,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<constructOutboxProofReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: constructOutboxProofReturn) -> Self {
                    (value.send, value.root, value.proof)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for constructOutboxProofReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        send: tuple.0,
                        root: tuple.1,
                        proof: tuple.2,
                    }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for constructOutboxProofCall {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::Uint<64>,
                alloy::sol_types::sol_data::Uint<64>,
            );
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = constructOutboxProofReturn;
            type ReturnTuple<'a> = (
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Array<
                    alloy::sol_types::sol_data::FixedBytes<32>,
                >,
            );
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "constructOutboxProof(uint64,uint64)";
            const SELECTOR: [u8; 4] = [66u8, 105u8, 99u8, 80u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        64,
                    > as alloy_sol_types::SolType>::tokenize(&self.size),
                    <alloy::sol_types::sol_data::Uint<
                        64,
                    > as alloy_sol_types::SolType>::tokenize(&self.leaf),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `estimateRetryableTicket(address,uint256,address,uint256,address,address,bytes)` and selector `0xc3dc5879`.
```solidity
function estimateRetryableTicket(address sender, uint256 deposit, address to, uint256 l2CallValue, address excessFeeRefundAddress, address callValueRefundAddress, bytes memory data) external;
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct estimateRetryableTicketCall {
        #[allow(missing_docs)]
        pub sender: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub deposit: alloy::sol_types::private::primitives::aliases::U256,
        #[allow(missing_docs)]
        pub to: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub l2CallValue: alloy::sol_types::private::primitives::aliases::U256,
        #[allow(missing_docs)]
        pub excessFeeRefundAddress: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub callValueRefundAddress: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub data: alloy::sol_types::private::Bytes,
    }
    ///Container type for the return parameters of the [`estimateRetryableTicket(address,uint256,address,uint256,address,address,bytes)`](estimateRetryableTicketCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct estimateRetryableTicketReturn {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Bytes,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::Address,
                alloy::sol_types::private::primitives::aliases::U256,
                alloy::sol_types::private::Address,
                alloy::sol_types::private::primitives::aliases::U256,
                alloy::sol_types::private::Address,
                alloy::sol_types::private::Address,
                alloy::sol_types::private::Bytes,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<estimateRetryableTicketCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: estimateRetryableTicketCall) -> Self {
                    (
                        value.sender,
                        value.deposit,
                        value.to,
                        value.l2CallValue,
                        value.excessFeeRefundAddress,
                        value.callValueRefundAddress,
                        value.data,
                    )
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for estimateRetryableTicketCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        sender: tuple.0,
                        deposit: tuple.1,
                        to: tuple.2,
                        l2CallValue: tuple.3,
                        excessFeeRefundAddress: tuple.4,
                        callValueRefundAddress: tuple.5,
                        data: tuple.6,
                    }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<estimateRetryableTicketReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: estimateRetryableTicketReturn) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for estimateRetryableTicketReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for estimateRetryableTicketCall {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Bytes,
            );
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = estimateRetryableTicketReturn;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "estimateRetryableTicket(address,uint256,address,uint256,address,address,bytes)";
            const SELECTOR: [u8; 4] = [195u8, 220u8, 88u8, 121u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.sender,
                    ),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.deposit),
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.to,
                    ),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.l2CallValue),
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.excessFeeRefundAddress,
                    ),
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.callValueRefundAddress,
                    ),
                    <alloy::sol_types::sol_data::Bytes as alloy_sol_types::SolType>::tokenize(
                        &self.data,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `findBatchContainingBlock(uint64)` and selector `0x81f1adaf`.
```solidity
function findBatchContainingBlock(uint64 blockNum) external view returns (uint64 batch);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct findBatchContainingBlockCall {
        #[allow(missing_docs)]
        pub blockNum: u64,
    }
    ///Container type for the return parameters of the [`findBatchContainingBlock(uint64)`](findBatchContainingBlockCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct findBatchContainingBlockReturn {
        #[allow(missing_docs)]
        pub batch: u64,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<64>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (u64,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<findBatchContainingBlockCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: findBatchContainingBlockCall) -> Self {
                    (value.blockNum,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for findBatchContainingBlockCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { blockNum: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<64>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (u64,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<findBatchContainingBlockReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: findBatchContainingBlockReturn) -> Self {
                    (value.batch,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for findBatchContainingBlockReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { batch: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for findBatchContainingBlockCall {
            type Parameters<'a> = (alloy::sol_types::sol_data::Uint<64>,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = findBatchContainingBlockReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Uint<64>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "findBatchContainingBlock(uint64)";
            const SELECTOR: [u8; 4] = [129u8, 241u8, 173u8, 175u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        64,
                    > as alloy_sol_types::SolType>::tokenize(&self.blockNum),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `gasEstimateComponents(address,bool,bytes)` and selector `0xc94e6eeb`.
```solidity
function gasEstimateComponents(address to, bool contractCreation, bytes memory data) external payable returns (uint64 gasEstimate, uint64 gasEstimateForL1, uint256 baseFee, uint256 l1BaseFeeEstimate);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct gasEstimateComponentsCall {
        #[allow(missing_docs)]
        pub to: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub contractCreation: bool,
        #[allow(missing_docs)]
        pub data: alloy::sol_types::private::Bytes,
    }
    ///Container type for the return parameters of the [`gasEstimateComponents(address,bool,bytes)`](gasEstimateComponentsCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct gasEstimateComponentsReturn {
        #[allow(missing_docs)]
        pub gasEstimate: u64,
        #[allow(missing_docs)]
        pub gasEstimateForL1: u64,
        #[allow(missing_docs)]
        pub baseFee: alloy::sol_types::private::primitives::aliases::U256,
        #[allow(missing_docs)]
        pub l1BaseFeeEstimate: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Bool,
                alloy::sol_types::sol_data::Bytes,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::Address,
                bool,
                alloy::sol_types::private::Bytes,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<gasEstimateComponentsCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: gasEstimateComponentsCall) -> Self {
                    (value.to, value.contractCreation, value.data)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for gasEstimateComponentsCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        to: tuple.0,
                        contractCreation: tuple.1,
                        data: tuple.2,
                    }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::Uint<64>,
                alloy::sol_types::sol_data::Uint<64>,
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Uint<256>,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                u64,
                u64,
                alloy::sol_types::private::primitives::aliases::U256,
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<gasEstimateComponentsReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: gasEstimateComponentsReturn) -> Self {
                    (
                        value.gasEstimate,
                        value.gasEstimateForL1,
                        value.baseFee,
                        value.l1BaseFeeEstimate,
                    )
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for gasEstimateComponentsReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        gasEstimate: tuple.0,
                        gasEstimateForL1: tuple.1,
                        baseFee: tuple.2,
                        l1BaseFeeEstimate: tuple.3,
                    }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for gasEstimateComponentsCall {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Bool,
                alloy::sol_types::sol_data::Bytes,
            );
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = gasEstimateComponentsReturn;
            type ReturnTuple<'a> = (
                alloy::sol_types::sol_data::Uint<64>,
                alloy::sol_types::sol_data::Uint<64>,
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Uint<256>,
            );
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "gasEstimateComponents(address,bool,bytes)";
            const SELECTOR: [u8; 4] = [201u8, 78u8, 110u8, 235u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.to,
                    ),
                    <alloy::sol_types::sol_data::Bool as alloy_sol_types::SolType>::tokenize(
                        &self.contractCreation,
                    ),
                    <alloy::sol_types::sol_data::Bytes as alloy_sol_types::SolType>::tokenize(
                        &self.data,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `gasEstimateL1Component(address,bool,bytes)` and selector `0x77d488a2`.
```solidity
function gasEstimateL1Component(address to, bool contractCreation, bytes memory data) external payable returns (uint64 gasEstimateForL1, uint256 baseFee, uint256 l1BaseFeeEstimate);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct gasEstimateL1ComponentCall {
        #[allow(missing_docs)]
        pub to: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub contractCreation: bool,
        #[allow(missing_docs)]
        pub data: alloy::sol_types::private::Bytes,
    }
    ///Container type for the return parameters of the [`gasEstimateL1Component(address,bool,bytes)`](gasEstimateL1ComponentCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct gasEstimateL1ComponentReturn {
        #[allow(missing_docs)]
        pub gasEstimateForL1: u64,
        #[allow(missing_docs)]
        pub baseFee: alloy::sol_types::private::primitives::aliases::U256,
        #[allow(missing_docs)]
        pub l1BaseFeeEstimate: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Bool,
                alloy::sol_types::sol_data::Bytes,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::Address,
                bool,
                alloy::sol_types::private::Bytes,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<gasEstimateL1ComponentCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: gasEstimateL1ComponentCall) -> Self {
                    (value.to, value.contractCreation, value.data)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for gasEstimateL1ComponentCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        to: tuple.0,
                        contractCreation: tuple.1,
                        data: tuple.2,
                    }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::Uint<64>,
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Uint<256>,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                u64,
                alloy::sol_types::private::primitives::aliases::U256,
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<gasEstimateL1ComponentReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: gasEstimateL1ComponentReturn) -> Self {
                    (value.gasEstimateForL1, value.baseFee, value.l1BaseFeeEstimate)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for gasEstimateL1ComponentReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        gasEstimateForL1: tuple.0,
                        baseFee: tuple.1,
                        l1BaseFeeEstimate: tuple.2,
                    }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for gasEstimateL1ComponentCall {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Bool,
                alloy::sol_types::sol_data::Bytes,
            );
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = gasEstimateL1ComponentReturn;
            type ReturnTuple<'a> = (
                alloy::sol_types::sol_data::Uint<64>,
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Uint<256>,
            );
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "gasEstimateL1Component(address,bool,bytes)";
            const SELECTOR: [u8; 4] = [119u8, 212u8, 136u8, 162u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.to,
                    ),
                    <alloy::sol_types::sol_data::Bool as alloy_sol_types::SolType>::tokenize(
                        &self.contractCreation,
                    ),
                    <alloy::sol_types::sol_data::Bytes as alloy_sol_types::SolType>::tokenize(
                        &self.data,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `getL1Confirmations(bytes32)` and selector `0xe5ca238c`.
```solidity
function getL1Confirmations(bytes32 blockHash) external view returns (uint64 confirmations);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct getL1ConfirmationsCall {
        #[allow(missing_docs)]
        pub blockHash: alloy::sol_types::private::FixedBytes<32>,
    }
    ///Container type for the return parameters of the [`getL1Confirmations(bytes32)`](getL1ConfirmationsCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct getL1ConfirmationsReturn {
        #[allow(missing_docs)]
        pub confirmations: u64,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::FixedBytes<32>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::FixedBytes<32>,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<getL1ConfirmationsCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: getL1ConfirmationsCall) -> Self {
                    (value.blockHash,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for getL1ConfirmationsCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { blockHash: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<64>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (u64,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<getL1ConfirmationsReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: getL1ConfirmationsReturn) -> Self {
                    (value.confirmations,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for getL1ConfirmationsReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { confirmations: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for getL1ConfirmationsCall {
            type Parameters<'a> = (alloy::sol_types::sol_data::FixedBytes<32>,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = getL1ConfirmationsReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Uint<64>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "getL1Confirmations(bytes32)";
            const SELECTOR: [u8; 4] = [229u8, 202u8, 35u8, 140u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.blockHash),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `l2BlockRangeForL1(uint64)` and selector `0x48e7f811`.
```solidity
function l2BlockRangeForL1(uint64 blockNum) external view returns (uint64 firstBlock, uint64 lastBlock);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct l2BlockRangeForL1Call {
        #[allow(missing_docs)]
        pub blockNum: u64,
    }
    ///Container type for the return parameters of the [`l2BlockRangeForL1(uint64)`](l2BlockRangeForL1Call) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct l2BlockRangeForL1Return {
        #[allow(missing_docs)]
        pub firstBlock: u64,
        #[allow(missing_docs)]
        pub lastBlock: u64,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<64>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (u64,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<l2BlockRangeForL1Call>
            for UnderlyingRustTuple<'_> {
                fn from(value: l2BlockRangeForL1Call) -> Self {
                    (value.blockNum,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for l2BlockRangeForL1Call {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { blockNum: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::Uint<64>,
                alloy::sol_types::sol_data::Uint<64>,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (u64, u64);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<l2BlockRangeForL1Return>
            for UnderlyingRustTuple<'_> {
                fn from(value: l2BlockRangeForL1Return) -> Self {
                    (value.firstBlock, value.lastBlock)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for l2BlockRangeForL1Return {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        firstBlock: tuple.0,
                        lastBlock: tuple.1,
                    }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for l2BlockRangeForL1Call {
            type Parameters<'a> = (alloy::sol_types::sol_data::Uint<64>,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = l2BlockRangeForL1Return;
            type ReturnTuple<'a> = (
                alloy::sol_types::sol_data::Uint<64>,
                alloy::sol_types::sol_data::Uint<64>,
            );
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "l2BlockRangeForL1(uint64)";
            const SELECTOR: [u8; 4] = [72u8, 231u8, 248u8, 17u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        64,
                    > as alloy_sol_types::SolType>::tokenize(&self.blockNum),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `legacyLookupMessageBatchProof(uint256,uint64)` and selector `0x89496270`.
```solidity
function legacyLookupMessageBatchProof(uint256 batchNum, uint64 index) external view returns (bytes32[] memory proof, uint256 path, address l2Sender, address l1Dest, uint256 l2Block, uint256 l1Block, uint256 timestamp, uint256 amount, bytes memory calldataForL1);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct legacyLookupMessageBatchProofCall {
        #[allow(missing_docs)]
        pub batchNum: alloy::sol_types::private::primitives::aliases::U256,
        #[allow(missing_docs)]
        pub index: u64,
    }
    ///Container type for the return parameters of the [`legacyLookupMessageBatchProof(uint256,uint64)`](legacyLookupMessageBatchProofCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct legacyLookupMessageBatchProofReturn {
        #[allow(missing_docs)]
        pub proof: alloy::sol_types::private::Vec<
            alloy::sol_types::private::FixedBytes<32>,
        >,
        #[allow(missing_docs)]
        pub path: alloy::sol_types::private::primitives::aliases::U256,
        #[allow(missing_docs)]
        pub l2Sender: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub l1Dest: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub l2Block: alloy::sol_types::private::primitives::aliases::U256,
        #[allow(missing_docs)]
        pub l1Block: alloy::sol_types::private::primitives::aliases::U256,
        #[allow(missing_docs)]
        pub timestamp: alloy::sol_types::private::primitives::aliases::U256,
        #[allow(missing_docs)]
        pub amount: alloy::sol_types::private::primitives::aliases::U256,
        #[allow(missing_docs)]
        pub calldataForL1: alloy::sol_types::private::Bytes,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Uint<64>,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
                u64,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<legacyLookupMessageBatchProofCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: legacyLookupMessageBatchProofCall) -> Self {
                    (value.batchNum, value.index)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for legacyLookupMessageBatchProofCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        batchNum: tuple.0,
                        index: tuple.1,
                    }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::Array<
                    alloy::sol_types::sol_data::FixedBytes<32>,
                >,
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Bytes,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::Vec<
                    alloy::sol_types::private::FixedBytes<32>,
                >,
                alloy::sol_types::private::primitives::aliases::U256,
                alloy::sol_types::private::Address,
                alloy::sol_types::private::Address,
                alloy::sol_types::private::primitives::aliases::U256,
                alloy::sol_types::private::primitives::aliases::U256,
                alloy::sol_types::private::primitives::aliases::U256,
                alloy::sol_types::private::primitives::aliases::U256,
                alloy::sol_types::private::Bytes,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<legacyLookupMessageBatchProofReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: legacyLookupMessageBatchProofReturn) -> Self {
                    (
                        value.proof,
                        value.path,
                        value.l2Sender,
                        value.l1Dest,
                        value.l2Block,
                        value.l1Block,
                        value.timestamp,
                        value.amount,
                        value.calldataForL1,
                    )
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for legacyLookupMessageBatchProofReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        proof: tuple.0,
                        path: tuple.1,
                        l2Sender: tuple.2,
                        l1Dest: tuple.3,
                        l2Block: tuple.4,
                        l1Block: tuple.5,
                        timestamp: tuple.6,
                        amount: tuple.7,
                        calldataForL1: tuple.8,
                    }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for legacyLookupMessageBatchProofCall {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Uint<64>,
            );
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = legacyLookupMessageBatchProofReturn;
            type ReturnTuple<'a> = (
                alloy::sol_types::sol_data::Array<
                    alloy::sol_types::sol_data::FixedBytes<32>,
                >,
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Bytes,
            );
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "legacyLookupMessageBatchProof(uint256,uint64)";
            const SELECTOR: [u8; 4] = [137u8, 73u8, 98u8, 112u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.batchNum),
                    <alloy::sol_types::sol_data::Uint<
                        64,
                    > as alloy_sol_types::SolType>::tokenize(&self.index),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `nitroGenesisBlock()` and selector `0x93a2fe21`.
```solidity
function nitroGenesisBlock() external pure returns (uint256 number);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct nitroGenesisBlockCall {}
    ///Container type for the return parameters of the [`nitroGenesisBlock()`](nitroGenesisBlockCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct nitroGenesisBlockReturn {
        #[allow(missing_docs)]
        pub number: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<nitroGenesisBlockCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: nitroGenesisBlockCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for nitroGenesisBlockCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<nitroGenesisBlockReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: nitroGenesisBlockReturn) -> Self {
                    (value.number,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for nitroGenesisBlockReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { number: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for nitroGenesisBlockCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = nitroGenesisBlockReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "nitroGenesisBlock()";
            const SELECTOR: [u8; 4] = [147u8, 162u8, 254u8, 33u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    ///Container for all the [`NodeInterface`](self) function calls.
    pub enum NodeInterfaceCalls {
        #[allow(missing_docs)]
        blockL1Num(blockL1NumCall),
        #[allow(missing_docs)]
        constructOutboxProof(constructOutboxProofCall),
        #[allow(missing_docs)]
        estimateRetryableTicket(estimateRetryableTicketCall),
        #[allow(missing_docs)]
        findBatchContainingBlock(findBatchContainingBlockCall),
        #[allow(missing_docs)]
        gasEstimateComponents(gasEstimateComponentsCall),
        #[allow(missing_docs)]
        gasEstimateL1Component(gasEstimateL1ComponentCall),
        #[allow(missing_docs)]
        getL1Confirmations(getL1ConfirmationsCall),
        #[allow(missing_docs)]
        l2BlockRangeForL1(l2BlockRangeForL1Call),
        #[allow(missing_docs)]
        legacyLookupMessageBatchProof(legacyLookupMessageBatchProofCall),
        #[allow(missing_docs)]
        nitroGenesisBlock(nitroGenesisBlockCall),
    }
    #[automatically_derived]
    impl NodeInterfaceCalls {
        /// All the selectors of this enum.
        ///
        /// Note that the selectors might not be in the same order as the variants.
        /// No guarantees are made about the order of the selectors.
        ///
        /// Prefer using `SolInterface` methods instead.
        pub const SELECTORS: &'static [[u8; 4usize]] = &[
            [66u8, 105u8, 99u8, 80u8],
            [72u8, 231u8, 248u8, 17u8],
            [111u8, 39u8, 94u8, 242u8],
            [119u8, 212u8, 136u8, 162u8],
            [129u8, 241u8, 173u8, 175u8],
            [137u8, 73u8, 98u8, 112u8],
            [147u8, 162u8, 254u8, 33u8],
            [195u8, 220u8, 88u8, 121u8],
            [201u8, 78u8, 110u8, 235u8],
            [229u8, 202u8, 35u8, 140u8],
        ];
    }
    #[automatically_derived]
    impl alloy_sol_types::SolInterface for NodeInterfaceCalls {
        const NAME: &'static str = "NodeInterfaceCalls";
        const MIN_DATA_LENGTH: usize = 0usize;
        const COUNT: usize = 10usize;
        #[inline]
        fn selector(&self) -> [u8; 4] {
            match self {
                Self::blockL1Num(_) => {
                    <blockL1NumCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::constructOutboxProof(_) => {
                    <constructOutboxProofCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::estimateRetryableTicket(_) => {
                    <estimateRetryableTicketCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::findBatchContainingBlock(_) => {
                    <findBatchContainingBlockCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::gasEstimateComponents(_) => {
                    <gasEstimateComponentsCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::gasEstimateL1Component(_) => {
                    <gasEstimateL1ComponentCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::getL1Confirmations(_) => {
                    <getL1ConfirmationsCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::l2BlockRangeForL1(_) => {
                    <l2BlockRangeForL1Call as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::legacyLookupMessageBatchProof(_) => {
                    <legacyLookupMessageBatchProofCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::nitroGenesisBlock(_) => {
                    <nitroGenesisBlockCall as alloy_sol_types::SolCall>::SELECTOR
                }
            }
        }
        #[inline]
        fn selector_at(i: usize) -> ::core::option::Option<[u8; 4]> {
            Self::SELECTORS.get(i).copied()
        }
        #[inline]
        fn valid_selector(selector: [u8; 4]) -> bool {
            Self::SELECTORS.binary_search(&selector).is_ok()
        }
        #[inline]
        #[allow(non_snake_case)]
        fn abi_decode_raw(
            selector: [u8; 4],
            data: &[u8],
            validate: bool,
        ) -> alloy_sol_types::Result<Self> {
            static DECODE_SHIMS: &[fn(
                &[u8],
                bool,
            ) -> alloy_sol_types::Result<NodeInterfaceCalls>] = &[
                {
                    fn constructOutboxProof(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<NodeInterfaceCalls> {
                        <constructOutboxProofCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(NodeInterfaceCalls::constructOutboxProof)
                    }
                    constructOutboxProof
                },
                {
                    fn l2BlockRangeForL1(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<NodeInterfaceCalls> {
                        <l2BlockRangeForL1Call as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(NodeInterfaceCalls::l2BlockRangeForL1)
                    }
                    l2BlockRangeForL1
                },
                {
                    fn blockL1Num(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<NodeInterfaceCalls> {
                        <blockL1NumCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(NodeInterfaceCalls::blockL1Num)
                    }
                    blockL1Num
                },
                {
                    fn gasEstimateL1Component(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<NodeInterfaceCalls> {
                        <gasEstimateL1ComponentCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(NodeInterfaceCalls::gasEstimateL1Component)
                    }
                    gasEstimateL1Component
                },
                {
                    fn findBatchContainingBlock(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<NodeInterfaceCalls> {
                        <findBatchContainingBlockCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(NodeInterfaceCalls::findBatchContainingBlock)
                    }
                    findBatchContainingBlock
                },
                {
                    fn legacyLookupMessageBatchProof(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<NodeInterfaceCalls> {
                        <legacyLookupMessageBatchProofCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(NodeInterfaceCalls::legacyLookupMessageBatchProof)
                    }
                    legacyLookupMessageBatchProof
                },
                {
                    fn nitroGenesisBlock(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<NodeInterfaceCalls> {
                        <nitroGenesisBlockCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(NodeInterfaceCalls::nitroGenesisBlock)
                    }
                    nitroGenesisBlock
                },
                {
                    fn estimateRetryableTicket(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<NodeInterfaceCalls> {
                        <estimateRetryableTicketCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(NodeInterfaceCalls::estimateRetryableTicket)
                    }
                    estimateRetryableTicket
                },
                {
                    fn gasEstimateComponents(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<NodeInterfaceCalls> {
                        <gasEstimateComponentsCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(NodeInterfaceCalls::gasEstimateComponents)
                    }
                    gasEstimateComponents
                },
                {
                    fn getL1Confirmations(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<NodeInterfaceCalls> {
                        <getL1ConfirmationsCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(NodeInterfaceCalls::getL1Confirmations)
                    }
                    getL1Confirmations
                },
            ];
            let Ok(idx) = Self::SELECTORS.binary_search(&selector) else {
                return Err(
                    alloy_sol_types::Error::unknown_selector(
                        <Self as alloy_sol_types::SolInterface>::NAME,
                        selector,
                    ),
                );
            };
            DECODE_SHIMS[idx](data, validate)
        }
        #[inline]
        fn abi_encoded_size(&self) -> usize {
            match self {
                Self::blockL1Num(inner) => {
                    <blockL1NumCall as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::constructOutboxProof(inner) => {
                    <constructOutboxProofCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::estimateRetryableTicket(inner) => {
                    <estimateRetryableTicketCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::findBatchContainingBlock(inner) => {
                    <findBatchContainingBlockCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::gasEstimateComponents(inner) => {
                    <gasEstimateComponentsCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::gasEstimateL1Component(inner) => {
                    <gasEstimateL1ComponentCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::getL1Confirmations(inner) => {
                    <getL1ConfirmationsCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::l2BlockRangeForL1(inner) => {
                    <l2BlockRangeForL1Call as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::legacyLookupMessageBatchProof(inner) => {
                    <legacyLookupMessageBatchProofCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::nitroGenesisBlock(inner) => {
                    <nitroGenesisBlockCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
            }
        }
        #[inline]
        fn abi_encode_raw(&self, out: &mut alloy_sol_types::private::Vec<u8>) {
            match self {
                Self::blockL1Num(inner) => {
                    <blockL1NumCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::constructOutboxProof(inner) => {
                    <constructOutboxProofCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::estimateRetryableTicket(inner) => {
                    <estimateRetryableTicketCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::findBatchContainingBlock(inner) => {
                    <findBatchContainingBlockCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::gasEstimateComponents(inner) => {
                    <gasEstimateComponentsCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::gasEstimateL1Component(inner) => {
                    <gasEstimateL1ComponentCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::getL1Confirmations(inner) => {
                    <getL1ConfirmationsCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::l2BlockRangeForL1(inner) => {
                    <l2BlockRangeForL1Call as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::legacyLookupMessageBatchProof(inner) => {
                    <legacyLookupMessageBatchProofCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::nitroGenesisBlock(inner) => {
                    <nitroGenesisBlockCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
            }
        }
    }
    use alloy::contract as alloy_contract;
    /**Creates a new wrapper around an on-chain [`NodeInterface`](self) contract instance.

See the [wrapper's documentation](`NodeInterfaceInstance`) for more details.*/
    #[inline]
    pub const fn new<
        T: alloy_contract::private::Transport + ::core::clone::Clone,
        P: alloy_contract::private::Provider<T, N>,
        N: alloy_contract::private::Network,
    >(
        address: alloy_sol_types::private::Address,
        provider: P,
    ) -> NodeInterfaceInstance<T, P, N> {
        NodeInterfaceInstance::<T, P, N>::new(address, provider)
    }
    /**Deploys this contract using the given `provider` and constructor arguments, if any.

Returns a new instance of the contract, if the deployment was successful.

For more fine-grained control over the deployment process, use [`deploy_builder`] instead.*/
    #[inline]
    pub fn deploy<
        T: alloy_contract::private::Transport + ::core::clone::Clone,
        P: alloy_contract::private::Provider<T, N>,
        N: alloy_contract::private::Network,
    >(
        provider: P,
    ) -> impl ::core::future::Future<
        Output = alloy_contract::Result<NodeInterfaceInstance<T, P, N>>,
    > {
        NodeInterfaceInstance::<T, P, N>::deploy(provider)
    }
    /**Creates a `RawCallBuilder` for deploying this contract using the given `provider`
and constructor arguments, if any.

This is a simple wrapper around creating a `RawCallBuilder` with the data set to
the bytecode concatenated with the constructor's ABI-encoded arguments.*/
    #[inline]
    pub fn deploy_builder<
        T: alloy_contract::private::Transport + ::core::clone::Clone,
        P: alloy_contract::private::Provider<T, N>,
        N: alloy_contract::private::Network,
    >(provider: P) -> alloy_contract::RawCallBuilder<T, P, N> {
        NodeInterfaceInstance::<T, P, N>::deploy_builder(provider)
    }
    /**A [`NodeInterface`](self) instance.

Contains type-safe methods for interacting with an on-chain instance of the
[`NodeInterface`](self) contract located at a given `address`, using a given
provider `P`.

If the contract bytecode is available (see the [`sol!`](alloy_sol_types::sol!)
documentation on how to provide it), the `deploy` and `deploy_builder` methods can
be used to deploy a new instance of the contract.

See the [module-level documentation](self) for all the available methods.*/
    #[derive(Clone)]
    pub struct NodeInterfaceInstance<T, P, N = alloy_contract::private::Ethereum> {
        address: alloy_sol_types::private::Address,
        provider: P,
        _network_transport: ::core::marker::PhantomData<(N, T)>,
    }
    #[automatically_derived]
    impl<T, P, N> ::core::fmt::Debug for NodeInterfaceInstance<T, P, N> {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
            f.debug_tuple("NodeInterfaceInstance").field(&self.address).finish()
        }
    }
    /// Instantiation and getters/setters.
    #[automatically_derived]
    impl<
        T: alloy_contract::private::Transport + ::core::clone::Clone,
        P: alloy_contract::private::Provider<T, N>,
        N: alloy_contract::private::Network,
    > NodeInterfaceInstance<T, P, N> {
        /**Creates a new wrapper around an on-chain [`NodeInterface`](self) contract instance.

See the [wrapper's documentation](`NodeInterfaceInstance`) for more details.*/
        #[inline]
        pub const fn new(
            address: alloy_sol_types::private::Address,
            provider: P,
        ) -> Self {
            Self {
                address,
                provider,
                _network_transport: ::core::marker::PhantomData,
            }
        }
        /**Deploys this contract using the given `provider` and constructor arguments, if any.

Returns a new instance of the contract, if the deployment was successful.

For more fine-grained control over the deployment process, use [`deploy_builder`] instead.*/
        #[inline]
        pub async fn deploy(
            provider: P,
        ) -> alloy_contract::Result<NodeInterfaceInstance<T, P, N>> {
            let call_builder = Self::deploy_builder(provider);
            let contract_address = call_builder.deploy().await?;
            Ok(Self::new(contract_address, call_builder.provider))
        }
        /**Creates a `RawCallBuilder` for deploying this contract using the given `provider`
and constructor arguments, if any.

This is a simple wrapper around creating a `RawCallBuilder` with the data set to
the bytecode concatenated with the constructor's ABI-encoded arguments.*/
        #[inline]
        pub fn deploy_builder(provider: P) -> alloy_contract::RawCallBuilder<T, P, N> {
            alloy_contract::RawCallBuilder::new_raw_deploy(
                provider,
                ::core::clone::Clone::clone(&BYTECODE),
            )
        }
        /// Returns a reference to the address.
        #[inline]
        pub const fn address(&self) -> &alloy_sol_types::private::Address {
            &self.address
        }
        /// Sets the address.
        #[inline]
        pub fn set_address(&mut self, address: alloy_sol_types::private::Address) {
            self.address = address;
        }
        /// Sets the address and returns `self`.
        pub fn at(mut self, address: alloy_sol_types::private::Address) -> Self {
            self.set_address(address);
            self
        }
        /// Returns a reference to the provider.
        #[inline]
        pub const fn provider(&self) -> &P {
            &self.provider
        }
    }
    impl<T, P: ::core::clone::Clone, N> NodeInterfaceInstance<T, &P, N> {
        /// Clones the provider and returns a new instance with the cloned provider.
        #[inline]
        pub fn with_cloned_provider(self) -> NodeInterfaceInstance<T, P, N> {
            NodeInterfaceInstance {
                address: self.address,
                provider: ::core::clone::Clone::clone(&self.provider),
                _network_transport: ::core::marker::PhantomData,
            }
        }
    }
    /// Function calls.
    #[automatically_derived]
    impl<
        T: alloy_contract::private::Transport + ::core::clone::Clone,
        P: alloy_contract::private::Provider<T, N>,
        N: alloy_contract::private::Network,
    > NodeInterfaceInstance<T, P, N> {
        /// Creates a new call builder using this contract instance's provider and address.
        ///
        /// Note that the call can be any function call, not just those defined in this
        /// contract. Prefer using the other methods for building type-safe contract calls.
        pub fn call_builder<C: alloy_sol_types::SolCall>(
            &self,
            call: &C,
        ) -> alloy_contract::SolCallBuilder<T, &P, C, N> {
            alloy_contract::SolCallBuilder::new_sol(&self.provider, &self.address, call)
        }
        ///Creates a new call builder for the [`blockL1Num`] function.
        pub fn blockL1Num(
            &self,
            l2BlockNum: u64,
        ) -> alloy_contract::SolCallBuilder<T, &P, blockL1NumCall, N> {
            self.call_builder(&blockL1NumCall { l2BlockNum })
        }
        ///Creates a new call builder for the [`constructOutboxProof`] function.
        pub fn constructOutboxProof(
            &self,
            size: u64,
            leaf: u64,
        ) -> alloy_contract::SolCallBuilder<T, &P, constructOutboxProofCall, N> {
            self.call_builder(
                &constructOutboxProofCall {
                    size,
                    leaf,
                },
            )
        }
        ///Creates a new call builder for the [`estimateRetryableTicket`] function.
        pub fn estimateRetryableTicket(
            &self,
            sender: alloy::sol_types::private::Address,
            deposit: alloy::sol_types::private::primitives::aliases::U256,
            to: alloy::sol_types::private::Address,
            l2CallValue: alloy::sol_types::private::primitives::aliases::U256,
            excessFeeRefundAddress: alloy::sol_types::private::Address,
            callValueRefundAddress: alloy::sol_types::private::Address,
            data: alloy::sol_types::private::Bytes,
        ) -> alloy_contract::SolCallBuilder<T, &P, estimateRetryableTicketCall, N> {
            self.call_builder(
                &estimateRetryableTicketCall {
                    sender,
                    deposit,
                    to,
                    l2CallValue,
                    excessFeeRefundAddress,
                    callValueRefundAddress,
                    data,
                },
            )
        }
        ///Creates a new call builder for the [`findBatchContainingBlock`] function.
        pub fn findBatchContainingBlock(
            &self,
            blockNum: u64,
        ) -> alloy_contract::SolCallBuilder<T, &P, findBatchContainingBlockCall, N> {
            self.call_builder(
                &findBatchContainingBlockCall {
                    blockNum,
                },
            )
        }
        ///Creates a new call builder for the [`gasEstimateComponents`] function.
        pub fn gasEstimateComponents(
            &self,
            to: alloy::sol_types::private::Address,
            contractCreation: bool,
            data: alloy::sol_types::private::Bytes,
        ) -> alloy_contract::SolCallBuilder<T, &P, gasEstimateComponentsCall, N> {
            self.call_builder(
                &gasEstimateComponentsCall {
                    to,
                    contractCreation,
                    data,
                },
            )
        }
        ///Creates a new call builder for the [`gasEstimateL1Component`] function.
        pub fn gasEstimateL1Component(
            &self,
            to: alloy::sol_types::private::Address,
            contractCreation: bool,
            data: alloy::sol_types::private::Bytes,
        ) -> alloy_contract::SolCallBuilder<T, &P, gasEstimateL1ComponentCall, N> {
            self.call_builder(
                &gasEstimateL1ComponentCall {
                    to,
                    contractCreation,
                    data,
                },
            )
        }
        ///Creates a new call builder for the [`getL1Confirmations`] function.
        pub fn getL1Confirmations(
            &self,
            blockHash: alloy::sol_types::private::FixedBytes<32>,
        ) -> alloy_contract::SolCallBuilder<T, &P, getL1ConfirmationsCall, N> {
            self.call_builder(
                &getL1ConfirmationsCall {
                    blockHash,
                },
            )
        }
        ///Creates a new call builder for the [`l2BlockRangeForL1`] function.
        pub fn l2BlockRangeForL1(
            &self,
            blockNum: u64,
        ) -> alloy_contract::SolCallBuilder<T, &P, l2BlockRangeForL1Call, N> {
            self.call_builder(&l2BlockRangeForL1Call { blockNum })
        }
        ///Creates a new call builder for the [`legacyLookupMessageBatchProof`] function.
        pub fn legacyLookupMessageBatchProof(
            &self,
            batchNum: alloy::sol_types::private::primitives::aliases::U256,
            index: u64,
        ) -> alloy_contract::SolCallBuilder<
            T,
            &P,
            legacyLookupMessageBatchProofCall,
            N,
        > {
            self.call_builder(
                &legacyLookupMessageBatchProofCall {
                    batchNum,
                    index,
                },
            )
        }
        ///Creates a new call builder for the [`nitroGenesisBlock`] function.
        pub fn nitroGenesisBlock(
            &self,
        ) -> alloy_contract::SolCallBuilder<T, &P, nitroGenesisBlockCall, N> {
            self.call_builder(&nitroGenesisBlockCall {})
        }
    }
    /// Event filters.
    #[automatically_derived]
    impl<
        T: alloy_contract::private::Transport + ::core::clone::Clone,
        P: alloy_contract::private::Provider<T, N>,
        N: alloy_contract::private::Network,
    > NodeInterfaceInstance<T, P, N> {
        /// Creates a new event filter using this contract instance's provider and address.
        ///
        /// Note that the type can be any event, not just those defined in this contract.
        /// Prefer using the other methods for building type-safe event filters.
        pub fn event_filter<E: alloy_sol_types::SolEvent>(
            &self,
        ) -> alloy_contract::Event<T, &P, E, N> {
            alloy_contract::Event::new_sol(&self.provider, &self.address)
        }
    }
}
