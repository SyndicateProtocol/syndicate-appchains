//! Types module for metabased-translator

use alloy::primitives::Address;
use serde::de::{self, Deserializer};
use serde::Deserialize;
use strum_macros::Display;

#[derive(Clone, Debug)]
/// **`BlockAndReceipts`**: Contains both a `Block` and the associated list of `Receipt` objects.
pub struct BlockAndReceipts {
    /// The block data.
    pub block: Block,
    /// The transaction receipts for the block.
    pub receipts: Vec<Receipt>,
}

#[derive(Deserialize, Debug, Clone)]
/// **`Block`**: Represents an Ethereum block, including details like its hash, number, timestamp, and the transactions it contains.
pub struct Block {
    /// The hash of the block.
    pub hash: String,
    /// The block number.
    #[serde(deserialize_with = "deserialize_hex_to_u64")]
    pub number: u64,
    /// The hash of the parent block.
    #[serde(rename = "parentHash")]
    pub parent_hash: String,
    /// The logs bloom filter for the block.
    #[serde(rename = "logsBloom")]
    pub logs_bloom: String,
    /// The root hash of the transactions trie.
    #[serde(rename = "transactionsRoot")]
    pub transactions_root: String,
    /// The root hash of the final state trie.
    #[serde(rename = "stateRoot")]
    pub state_root: String,
    /// The root hash of the receipts trie.
    #[serde(rename = "receiptsRoot")]
    pub receipts_root: String,
    /// The timestamp when the block was mined, in Unix time.
    #[serde(deserialize_with = "deserialize_hex_to_u64")]
    pub timestamp: u64,
    /// The transactions included in the block.
    pub transactions: Vec<Transaction>,
}

#[derive(Deserialize, Debug, Clone)]
/// **`Transaction`**: Represents a single transaction within a block, including fields such as the transaction hash, sender/recipient addresses, value, and input data.
pub struct Transaction {
    /// The hash of the block containing this transaction, or `null` if pending.
    #[serde(rename = "blockHash")]
    pub block_hash: String,
    /// The number of the block containing this transaction, or `null` if pending.
    #[serde(rename = "blockNumber", deserialize_with = "deserialize_hex_to_u64")]
    pub block_number: u64,
    /// The sender's address.
    #[serde(deserialize_with = "deserialize_address")]
    pub from: Address,
    /// The transaction hash.
    pub hash: String,
    /// The data payload of the transaction.
    pub input: String,
    /// The number of transactions sent by the sender.
    pub nonce: String,
    /// The recipient's address, or `null` if the transaction creates a contract.
    pub to: Option<String>,
    /// The index of this transaction in the block, or `null` if pending.
    #[serde(rename = "transactionIndex")]
    pub transaction_index: String,
    /// The amount of Wei transferred.
    pub value: String,
}

#[derive(Deserialize, Debug, Clone)]
/// **`Receipt`**: Contains the result of a transaction, including fields like status, logs, and potentially a contract address if one was created.
pub struct Receipt {
    /// The hash of the block containing the transaction.
    #[serde(rename = "blockHash")]
    pub block_hash: String,
    /// The number of the block containing the transaction.
    #[serde(rename = "blockNumber", deserialize_with = "deserialize_hex_to_u64")]
    pub block_number: u64,
    /// The sender's address.
    #[serde(deserialize_with = "deserialize_address")]
    pub from: Address,
    /// The recipient's address.
    #[serde(deserialize_with = "deserialize_optional_address")]
    pub to: Option<Address>,
    /// The address of the contract created by the transaction, if applicable.
    #[serde(
        rename = "contractAddress",
        deserialize_with = "deserialize_optional_address"
    )]
    pub contract_address: Option<Address>,
    /// The logs generated by the transaction.
    pub logs: Vec<Log>,
    /// The logs bloom filter for the transaction.
    #[serde(rename = "logsBloom")]
    pub logs_bloom: String,
    /// The transaction's execution status.
    pub status: String,
    /// The receipt type, if available.
    #[serde(rename = "type")]
    pub receipt_type: Option<String>,
}

#[derive(Deserialize, Debug, Clone)]
/// *`Log`**: Represents an individual log entry emitted by a smart contract during a transaction, containing information such as topics, data, and whether it was removed due to a reorganization.
pub struct Log {
    /// The hash of the block containing the log, or `null` if pending.
    #[serde(rename = "blockHash")]
    pub block_hash: String,
    /// The number of the block containing the log, or `null` if pending.
    #[serde(rename = "blockNumber", deserialize_with = "deserialize_hex_to_u64")]
    pub block_number: u64,
    /// The index of the transaction that generated the log, or `null` if pending.
    pub transaction_index: Option<String>,
    /// The address from which the log originated.
    #[serde(deserialize_with = "deserialize_address")]
    pub address: Address,
    /// The index of the log entry, or `null` if pending.
    #[serde(rename = "logIndex")]
    pub log_index: Option<String>,
    /// The data associated with the log.
    pub data: String,
    /// A flag indicating if the log was removed due to a chain reorganization.
    pub removed: bool,
    /// The topics associated with the log.
    pub topics: Vec<String>,
    /// The hash of the transaction that generated the log, or `null` if pending.
    #[serde(rename = "transactionHash")]
    pub transaction_hash: Option<String>,
}

#[allow(missing_docs)] // self-explanatory
#[derive(Debug, Clone, Copy, PartialEq, Eq, Display)]
#[strum(serialize_all = "lowercase")]
pub enum Chain {
    Sequencing,
    Settlement,
}

/// The state of a slot describing its finality
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub enum SlotState {
    /// A slot that is considered final and cannot rollback (we don't expect any underlying chains to reorg this far)
    Finalized,
    /// A slot that is considered final according to the source L2s finality guarantees (it can only be rolled back if a L1 reorg happens)
    Safe,
    /// A slot that we don't expect to fit more blocks into. It should be considered cannonical unless a reorg happens
    Unsafe,
    /// A slot to which incoming blocks might still be added
    Open,
}

/// A `Slot` is a collection of source chain blocks  to be sent to the block builder
#[derive(Debug, Clone)]
pub struct Slot {
    /// the number of the slot - `slot_number` == `MetaChain`'s block number
    pub slot_number: u64,
    /// the timestamp of the slot
    pub timestamp: u64,
    /// the blocks from the sequencing chain to be included in the slot
    pub sequencing_chain_blocks: Vec<BlockAndReceipts>,
    /// the blocks from the settlement chain to be included in the slot
    pub settlement_chain_blocks: Vec<BlockAndReceipts>,
    /// the finality state of the slot
    pub state: SlotState,
}

impl Slot {
    /// Creates a new slot
    pub const fn new(number: u64, timestamp: u64) -> Self {
        Self {
            slot_number: number,
            timestamp,
            sequencing_chain_blocks: Vec::new(),
            settlement_chain_blocks: Vec::new(),
            state: SlotState::Open,
        }
    }

    /// Checks if the slot is empty (does not include any blocks)
    pub fn is_empty(&self) -> bool {
        self.sequencing_chain_blocks.is_empty() && self.settlement_chain_blocks.is_empty()
    }

    /// Adds a block to the slot's chain-specific block list
    pub fn push_block(&mut self, block: BlockAndReceipts, chain: Chain) {
        match chain {
            Chain::Sequencing => self.sequencing_chain_blocks.push(block),
            Chain::Settlement => self.settlement_chain_blocks.push(block),
        }
    }
}

fn deserialize_address<'de, D>(deserializer: D) -> Result<Address, D::Error>
where
    D: Deserializer<'de>,
{
    let address_str: String = Deserialize::deserialize(deserializer)?;
    let address: Address = address_str
        .parse()
        .map_err(|err| de::Error::custom(format!("Failed to parse address: {err}")))?;
    Ok(address)
}

fn deserialize_optional_address<'de, D>(deserializer: D) -> Result<Option<Address>, D::Error>
where
    D: Deserializer<'de>,
{
    let opt: Option<String> = Option::deserialize(deserializer)?;
    if let Some(address_str) = opt {
        let address: Address = address_str
            .parse()
            .map_err(|err| de::Error::custom(format!("Failed to parse address: {err}")))?;
        Ok(Some(address))
    } else {
        Ok(None)
    }
}

fn deserialize_hex_to_u64<'de, D>(deserializer: D) -> Result<u64, D::Error>
where
    D: Deserializer<'de>,
{
    let hex_str: String = Deserialize::deserialize(deserializer)?;
    // Remove "0x" prefix if present, then parse as hexadecimal.
    u64::from_str_radix(hex_str.trim_start_matches("0x"), 16)
        .map_err(|err| de::Error::custom(format!("Failed to parse hex to u64: {}", err)))
}
