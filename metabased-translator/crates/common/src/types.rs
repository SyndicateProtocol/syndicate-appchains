//! Types module for metabased-translator

use alloy::{
    hex,
    primitives::{Address, Bytes, B256},
};
use serde::{
    de::{self, Deserializer},
    Deserialize, Serialize,
};
use std::fmt;
use strum_macros::Display;

#[derive(Clone, Debug, Serialize, Deserialize, PartialEq, Eq, Default)]
/// **`BlockAndReceipts`**: Contains both a `Block` and the associated list of `Receipt` objects.
pub struct BlockAndReceipts {
    /// The block data.
    pub block: Block,
    /// The transaction receipts for the block.
    pub receipts: Vec<Receipt>,
}

#[derive(Serialize, Deserialize, Debug, Clone, PartialEq, Eq, Default)]
#[serde(rename_all = "camelCase")]
/// **`Block`**: Represents an Ethereum block, including details like its hash, number, timestamp,
/// and the transactions it contains.
pub struct Block {
    /// The hash of the block.
    #[serde(deserialize_with = "deserialize_b256", serialize_with = "serialize_b256")]
    pub hash: B256,
    /// The block number.
    #[serde(deserialize_with = "deserialize_hex_to_u64", serialize_with = "serialize_hex_u64")]
    pub number: u64,
    /// The hash of the parent block.
    #[serde(deserialize_with = "deserialize_b256", serialize_with = "serialize_b256")]
    pub parent_hash: B256,
    /// The logs bloom filter for the block.
    pub logs_bloom: String,
    /// The root hash of the transactions trie.
    pub transactions_root: String,
    /// The root hash of the final state trie.
    pub state_root: String,
    /// The root hash of the receipts trie.
    pub receipts_root: String,
    /// The timestamp when the block was mined, in Unix time.
    #[serde(deserialize_with = "deserialize_hex_to_u64", serialize_with = "serialize_hex_u64")]
    pub timestamp: u64,
    /// The transactions included in the block.
    pub transactions: Vec<Transaction>,
}

#[derive(Serialize, Deserialize, Debug, Clone, PartialEq, Eq, Default)]
#[serde(rename_all = "camelCase")]
/// **`Transaction`**: Represents a single transaction within a block, including fields such as the
/// transaction hash, sender/recipient addresses, value, and input data.
pub struct Transaction {
    /// The hash of the block containing this transaction, or `null` if pending.
    #[serde(deserialize_with = "deserialize_b256", serialize_with = "serialize_b256")]
    pub block_hash: B256,
    /// The number of the block containing this transaction, or `null` if pending.
    #[serde(deserialize_with = "deserialize_hex_to_u64", serialize_with = "serialize_hex_u64")]
    pub block_number: u64,
    /// The sender's address.
    #[serde(deserialize_with = "deserialize_address", serialize_with = "serialize_address")]
    pub from: Address,
    /// The transaction hash.
    #[serde(deserialize_with = "deserialize_b256", serialize_with = "serialize_b256")]
    pub hash: B256,
    /// The data payload of the transaction.
    #[serde(deserialize_with = "deserialize_bytes", serialize_with = "serialize_bytes")]
    pub input: Bytes,
    /// The number of transactions sent by the sender.
    #[serde(deserialize_with = "deserialize_hex_to_u64", serialize_with = "serialize_hex_u64")]
    pub nonce: u64,
    /// The recipient's address, or `null` if the transaction creates a contract.
    #[serde(
        deserialize_with = "deserialize_optional_address",
        serialize_with = "serialize_optional_address"
    )]
    pub to: Option<Address>,
    /// The index of this transaction in the block.
    pub transaction_index: String,
    /// The amount of Wei transferred.
    pub value: String,
}

#[derive(Serialize, Deserialize, Debug, Clone, PartialEq, Eq, Default)]
#[serde(rename_all = "camelCase")]
/// **`Receipt`**: Contains the result of a transaction, including fields like status, logs, and
/// potentially a contract address if one was created.
pub struct Receipt {
    /// The hash of the block containing the transaction.
    #[serde(deserialize_with = "deserialize_b256", serialize_with = "serialize_b256")]
    pub block_hash: B256,
    /// The number of the block containing the transaction.
    #[serde(deserialize_with = "deserialize_hex_to_u64", serialize_with = "serialize_hex_u64")]
    pub block_number: u64,
    /// The sender's address.
    #[serde(deserialize_with = "deserialize_address", serialize_with = "serialize_address")]
    pub from: Address,
    /// The recipient's address.
    #[serde(
        deserialize_with = "deserialize_optional_address",
        serialize_with = "serialize_optional_address"
    )]
    pub to: Option<Address>,
    /// The address of the contract created by the transaction, if applicable.
    #[serde(
        deserialize_with = "deserialize_optional_address",
        serialize_with = "serialize_optional_address"
    )]
    pub contract_address: Option<Address>,
    /// The logs generated by the transaction.
    pub logs: Vec<Log>,
    /// The logs bloom filter for the transaction.
    pub logs_bloom: String,
    /// The transaction's execution status.
    pub status: String,
    /// The receipt type, if available.
    #[serde(rename = "type")]
    pub receipt_type: String,
}

#[derive(Serialize, Deserialize, Debug, Clone, PartialEq, Eq, Default)]
#[serde(rename_all = "camelCase")]
/// *`Log`**: Represents an individual log entry emitted by a smart contract during a transaction,
/// containing information such as topics, data, and whether it was removed due to a reorganization.
pub struct Log {
    /// The hash of the block containing the log, or `null` if pending.
    #[serde(deserialize_with = "deserialize_b256", serialize_with = "serialize_b256")]
    pub block_hash: B256,
    /// The number of the block containing the log, or `null` if pending.
    #[serde(deserialize_with = "deserialize_hex_to_u64", serialize_with = "serialize_hex_u64")]
    pub block_number: u64,
    /// The index of the transaction that generated the log
    #[serde(deserialize_with = "deserialize_hex_to_u64", serialize_with = "serialize_hex_u64")]
    pub transaction_index: u64,
    /// The address from which the log originated.
    #[serde(deserialize_with = "deserialize_address", serialize_with = "serialize_address")]
    pub address: Address,
    /// The index of the log entry
    #[serde(deserialize_with = "deserialize_hex_to_u64", serialize_with = "serialize_hex_u64")]
    pub log_index: u64,
    /// The data associated with the log.
    #[serde(deserialize_with = "deserialize_bytes", serialize_with = "serialize_bytes")]
    pub data: Bytes,
    /// A flag indicating if the log was removed due to a chain reorganization.
    pub removed: bool,
    /// The topics associated with the log.
    #[serde(deserialize_with = "deserialize_b256_vec", serialize_with = "serialize_b256_vec")]
    pub topics: Vec<B256>,
    /// The hash of the transaction that generated the log
    #[serde(deserialize_with = "deserialize_b256", serialize_with = "serialize_b256")]
    pub transaction_hash: B256,
}

#[allow(missing_docs)] // self-explanatory
#[derive(Debug, Clone, Copy, PartialEq, Eq, Display)]
#[strum(serialize_all = "lowercase")]
pub enum Chain {
    Sequencing,
    Settlement,
}

impl From<Chain> for &'static str {
    fn from(chain: Chain) -> &'static str {
        match chain {
            Chain::Sequencing => "sequencing",
            Chain::Settlement => "settlement",
        }
    }
}
/// The state of a slot describing its finality
#[derive(Debug, Clone, Copy, PartialEq, Eq, Display, Serialize, Deserialize, Default)]
#[strum(serialize_all = "lowercase")]
pub enum SlotState {
    /// A slot that is considered final and cannot rollback (blocks that are more than
    /// `MAX_WAIT_MS` old)
    Safe,
    /// A slot that we don't expect to fit more blocks into. It should be considered cannonical
    /// unless a reorg happens
    Unsafe,
    /// A slot to which incoming blocks might still be added
    #[default]
    Open,
}

/// A `Slot` is a collection of source chain blocks  to be sent to the block builder
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq, Eq, Default)]
pub struct Slot {
    /// the number of the slot - `slot_number` == `MetaChain`'s block number
    pub number: u64,
    /// the timestamp of the slot in seconds
    pub timestamp: u64,
    /// the blocks from the sequencing chain to be included in the slot
    pub sequencing_chain_blocks: Vec<BlockAndReceipts>,
    /// the blocks from the settlement chain to be included in the slot
    pub settlement_chain_blocks: Vec<BlockAndReceipts>,
    /// the finality state of the slot
    pub state: SlotState,
}

impl Slot {
    /// Creates a new slot
    pub const fn new(number: u64, timestamp: u64) -> Self {
        Self {
            number,
            timestamp,
            sequencing_chain_blocks: Vec::new(),
            settlement_chain_blocks: Vec::new(),
            state: SlotState::Open,
        }
    }

    /// Checks if the slot is empty (does not include any blocks)
    pub fn is_empty(&self) -> bool {
        self.sequencing_chain_blocks.is_empty() && self.settlement_chain_blocks.is_empty()
    }

    /// Adds a block to the slot's chain-specific block list
    pub fn push_block(&mut self, block: BlockAndReceipts, chain: Chain) {
        match chain {
            Chain::Sequencing => self.sequencing_chain_blocks.push(block),
            Chain::Settlement => self.settlement_chain_blocks.push(block),
        }
    }

    /// Returns the total number of blocks across both the sequencing and settlement chains
    pub fn get_total_blocks(&self) -> usize {
        self.sequencing_chain_blocks.len() + self.settlement_chain_blocks.len()
    }
}

impl fmt::Display for Slot {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        write!(
            f,
            "Slot #{} [ts: {}, state: {}, blocks: {} seq + {} settle],  Sequencing blocks: {},  Settlement blocks: {}",
            self.number,
            self.timestamp,
            self.state,
            self.sequencing_chain_blocks.len(),
            self.settlement_chain_blocks.len(),
            format_blocks(&self.sequencing_chain_blocks),
            format_blocks(&self.settlement_chain_blocks),
        )
    }
}

fn format_blocks(blocks: &[BlockAndReceipts]) -> String {
    if blocks.is_empty() {
        return "none".to_string();
    }
    blocks
        .iter()
        .map(|b| format!("#{} ({})", b.block.number, b.block.hash))
        .collect::<Vec<_>>()
        .join(", ")
}

/// A reference to a block containing just its number and timestamp
#[derive(Debug, Serialize, Deserialize, Eq, PartialEq)]
pub struct BlockRef {
    /// The block number
    pub number: u64,
    /// The block timestamp
    pub timestamp: u64,
    /// The block hash
    pub hash: B256,
}

impl BlockRef {
    /// Creates a new `BlockRef` from a `Block`
    pub const fn new(block: &Block) -> Self {
        Self { number: block.number, timestamp: block.timestamp, hash: block.hash }
    }
}

impl fmt::Display for BlockRef {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        write!(f, "number: {}, ts: {}, hash: {}", self.number, self.timestamp, self.hash)
    }
}

fn deserialize_address<'de, D>(deserializer: D) -> Result<Address, D::Error>
where
    D: Deserializer<'de>,
{
    let address_str: String = Deserialize::deserialize(deserializer)?;
    let address: Address = address_str
        .parse()
        .map_err(|err| de::Error::custom(format!("Failed to parse address: {err}")))?;
    Ok(address)
}

fn deserialize_optional_address<'de, D>(deserializer: D) -> Result<Option<Address>, D::Error>
where
    D: Deserializer<'de>,
{
    let opt: Option<String> = Option::deserialize(deserializer)?;
    if let Some(address_str) = opt {
        let address: Address = address_str
            .parse()
            .map_err(|err| de::Error::custom(format!("Failed to parse address: {err}")))?;
        Ok(Some(address))
    } else {
        Ok(None)
    }
}

fn deserialize_hex_to_u64<'de, D>(deserializer: D) -> Result<u64, D::Error>
where
    D: Deserializer<'de>,
{
    let hex_str: String = Deserialize::deserialize(deserializer)?;

    // Remove "0x" prefix if present, then parse as hexadecimal.
    u64::from_str_radix(hex_str.trim_start_matches("0x"), 16)
        .map_err(|err| de::Error::custom(format!("Failed to parse hex to u64: {}", err)))
}

fn deserialize_b256<'de, D>(deserializer: D) -> Result<B256, D::Error>
where
    D: Deserializer<'de>,
{
    let hex_str: String = Deserialize::deserialize(deserializer)?;

    let decoded = hex::decode(hex_str.trim_start_matches("0x"))
        .map_err(|err| de::Error::custom(format!("Failed to decode hex string: {err}")))?;

    let array: [u8; 32] = decoded
        .try_into()
        .map_err(|_| de::Error::custom("Failed to convert to a 32-byte array"))?;

    Ok(B256::from(array))
}

fn deserialize_b256_vec<'de, D>(deserializer: D) -> Result<Vec<B256>, D::Error>
where
    D: Deserializer<'de>,
{
    let vec: Vec<String> = Deserialize::deserialize(deserializer)?;
    vec.into_iter()
        .map(|s| {
            let decoded = hex::decode(s.trim_start_matches("0x"))
                .map_err(|err| de::Error::custom(format!("Failed to decode hex string: {err}")))?;

            let array: [u8; 32] = decoded
                .try_into()
                .map_err(|_| de::Error::custom("Failed to convert to a 32-byte array"))?;

            Ok(B256::from(array))
        })
        .collect()
}

fn deserialize_bytes<'de, D>(deserializer: D) -> Result<Bytes, D::Error>
where
    D: Deserializer<'de>,
{
    let hex_str: String = Deserialize::deserialize(deserializer)?;
    hex::decode(hex_str.trim_start_matches("0x"))
        .map(Bytes::from)
        .map_err(|err| de::Error::custom(format!("Failed to decode hex string: {err}")))
}

fn serialize_b256<S>(b256: &B256, serializer: S) -> Result<S::Ok, S::Error>
where
    S: serde::Serializer,
{
    serializer.serialize_str(&format!("0x{}", hex::encode(b256.as_slice())))
}

fn serialize_b256_vec<S>(vec: &[B256], serializer: S) -> Result<S::Ok, S::Error>
where
    S: serde::Serializer,
{
    use serde::ser::SerializeSeq;
    let mut seq = serializer.serialize_seq(Some(vec.len()))?;
    for b256 in vec {
        seq.serialize_element(&format!("0x{}", hex::encode(b256.as_slice())))?;
    }
    seq.end()
}

fn serialize_address<S>(addr: &Address, serializer: S) -> Result<S::Ok, S::Error>
where
    S: serde::Serializer,
{
    serializer.serialize_str(&format!("0x{}", hex::encode(addr.as_slice())))
}

fn serialize_optional_address<S>(opt: &Option<Address>, serializer: S) -> Result<S::Ok, S::Error>
where
    S: serde::Serializer,
{
    match opt {
        Some(addr) => serializer.serialize_str(&format!("0x{}", hex::encode(addr.as_slice()))),
        None => serializer.serialize_none(),
    }
}

fn serialize_bytes<S>(bytes: &Bytes, serializer: S) -> Result<S::Ok, S::Error>
where
    S: serde::Serializer,
{
    serializer.serialize_str(&format!("0x{}", hex::encode(bytes)))
}

fn serialize_hex_u64<S>(num: &u64, serializer: S) -> Result<S::Ok, S::Error>
where
    S: serde::Serializer,
{
    serializer.serialize_str(&format!("0x{:x}", num))
}

/// Block tags
#[derive(Debug, PartialEq, Eq)]
pub enum BlockTag {
    /// The most recent block in the canonical chain observed by the client, this block may be
    /// re-orged out of the canonical chain even under healthy/normal conditions.
    Latest,
    /// The lowest numbered block the client has available. Intuitively, you can think of this as
    /// the first block created.
    Earliest,
    /// A sample next block built by the client on top of latest and containing the set of
    /// transactions usually taken from local mempool. Intuitively, you can think of these as
    /// blocks that have not been mined yet.
    Pending,
    /// The most recent crypto-economically secure block, cannot be re-orged outside of manual
    /// intervention driven by community coordination. Intuitively, this block is “unlikely” to be
    /// re-orged.
    Safe,
    /// The most recent crypto-economically secure block, that has been accepted by >2/3 of
    /// validators. Cannot be re-orged outside of manual intervention driven by community
    /// coordination. Intuitively, this block is very unlikely to be re-orged.
    Finalized,
    /// Block number
    Number(u64),
}

impl BlockTag {
    /// Converts a `BlockTag` to a valid rpc parameter
    pub fn to_rpc_param(&self) -> String {
        match self {
            Self::Latest => "latest".to_string(),
            Self::Earliest => "earliest".to_string(),
            Self::Pending => "pending".to_string(),
            Self::Safe => "safe".to_string(),
            Self::Finalized => "finalized".to_string(),
            Self::Number(num) => format!("0x{:x}", num),
        }
    }
}

#[cfg(test)]
mod test {
    use super::*;
    use alloy::{hex::FromHex, primitives::B256};

    fn create_test_slot() -> Slot {
        let mut slot = Slot::new(1, 1000);

        // Add sequencing chain block with transaction and receipt
        slot.sequencing_chain_blocks.push(BlockAndReceipts {
            block: Block {
                hash: B256::from_hex(
                    "0x1234567890123456789012345678901234567890123456789012345678901234",
                )
                .unwrap(),
                number: 100,
                parent_hash: B256::ZERO,
                logs_bloom: "0x01".to_string(),
                transactions_root: "0x02".to_string(),
                state_root: "0x03".to_string(),
                receipts_root: "0x04".to_string(),
                timestamp: 1000,
                transactions: vec![Transaction {
                    block_hash: B256::from_hex(
                        "0x1234567890123456789012345678901234567890123456789012345678901234",
                    )
                    .unwrap(),
                    block_number: 100,
                    from: Address::from_hex("0x1234567890123456789012345678901234567890").unwrap(),
                    hash: B256::from_hex(
                        "0xabcd567890123456789012345678901234567890123456789012345678901234",
                    )
                    .unwrap(),
                    input: hex::decode("0x123456").unwrap().into(),
                    nonce: 1,
                    to: Some(
                        Address::from_hex("0x9876543210987654321098765432109876543210").unwrap(),
                    ),
                    transaction_index: "0x0".to_string(),
                    value: "0x0".to_string(),
                }],
            },
            receipts: vec![Receipt {
                block_hash: B256::from_hex(
                    "0x1234567890123456789012345678901234567890123456789012345678901234",
                )
                .unwrap(),
                block_number: 100,
                from: Address::from_hex("0x1234567890123456789012345678901234567890").unwrap(),
                to: Some(Address::from_hex("0x9876543210987654321098765432109876543210").unwrap()),
                contract_address: None,
                logs: vec![Log {
                    block_hash: B256::from_hex(
                        "0x1234567890123456789012345678901234567890123456789012345678901234",
                    )
                    .unwrap(),
                    block_number: 100,
                    transaction_index: 0,
                    address: Address::from_hex("0x1234567890123456789012345678901234567890")
                        .unwrap(),
                    log_index: 0,
                    data: Bytes::from_hex("0xdeadbeef").unwrap(),
                    removed: false,
                    topics: vec![B256::from_hex(
                        "0xddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef",
                    )
                    .unwrap()],
                    transaction_hash: B256::from_hex(
                        "0xabcd567890123456789012345678901234567890123456789012345678901234",
                    )
                    .unwrap(),
                }],
                logs_bloom: "0x0".to_string(),
                status: "0x1".to_string(),
                receipt_type: "0x0".to_string(),
            }],
        });

        // Add settlement chain block
        slot.settlement_chain_blocks.push(BlockAndReceipts {
            block: Block {
                hash: B256::from_hex(
                    "0x5678901234567890123456789012345678901234567890123456789012345678",
                )
                .unwrap(),
                number: 200,
                parent_hash: B256::from_hex(
                    "0x1111111111111111111111111111111111111111111111111111111111111111",
                )
                .unwrap(),
                logs_bloom: "0x05".to_string(),
                transactions_root: "0x06".to_string(),
                state_root: "0x07".to_string(),
                receipts_root: "0x08".to_string(),
                timestamp: 1100,
                transactions: vec![],
            },
            receipts: vec![],
        });

        slot
    }

    #[test]
    #[ignore] // NOTE: binary serialization fails. the current way we define the serialization/deserialization
              // logic is only for JSON and there is no way to use the same objects for bincode.
    fn test_bincode_serialization() {
        let slot = create_test_slot();
        let encoded = bincode::serialize(&slot).unwrap();
        let decoded: Slot = bincode::deserialize(&encoded).unwrap();
        assert_eq!(decoded, slot);
    }

    #[test]
    fn test_json_serialization() {
        let slot = create_test_slot();
        let json = serde_json::to_string(&slot).unwrap();
        println!("{}", json);
        let decoded: Slot = serde_json::from_str(&json).unwrap();
        assert_eq!(decoded, slot);
    }
}
