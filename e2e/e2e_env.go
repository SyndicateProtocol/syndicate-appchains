//nolint:mnd // lots of "magic numbers" for testing in this file
package e2e_test

import (
	"context"
	"crypto/ecdsa"
	_ "embed"
	"encoding/hex"
	"encoding/json"
	"fmt"
	"math/big"
	"os"
	"testing"
	"time"

	"github.com/SyndicateProtocol/metabased-rollup/op-translator/mocks"
	"github.com/SyndicateProtocol/metabased-rollup/op-translator/pkg/rpc-clients"
	"github.com/SyndicateProtocol/metabased-rollup/op-translator/pkg/translator"
	altda "github.com/ethereum-optimism/optimism/op-alt-da"
	"github.com/ethereum-optimism/optimism/op-chain-ops/foundry"
	"github.com/ethereum-optimism/optimism/op-chain-ops/genesis"
	"github.com/ethereum-optimism/optimism/op-e2e/actions/helpers"
	"github.com/ethereum-optimism/optimism/op-e2e/config"
	"github.com/ethereum-optimism/optimism/op-e2e/e2eutils"
	"github.com/ethereum-optimism/optimism/op-e2e/e2eutils/geth"
	"github.com/ethereum-optimism/optimism/op-node/rollup"
	op_service_client "github.com/ethereum-optimism/optimism/op-service/client"
	"github.com/ethereum-optimism/optimism/op-service/eth"
	"github.com/ethereum-optimism/optimism/op-service/sources"
	"github.com/ethereum-optimism/optimism/op-service/testlog"
	"github.com/ethereum/go-ethereum"
	"github.com/ethereum/go-ethereum/common"
	"github.com/ethereum/go-ethereum/common/hexutil"
	"github.com/ethereum/go-ethereum/core"
	"github.com/ethereum/go-ethereum/core/types"
	"github.com/ethereum/go-ethereum/crypto"
	tracelogger "github.com/ethereum/go-ethereum/eth/tracers/logger"
	"github.com/ethereum/go-ethereum/ethclient"
	gethlog "github.com/ethereum/go-ethereum/log"
	"github.com/ethereum/go-ethereum/params"
	geth_rpc "github.com/ethereum/go-ethereum/rpc"
	"github.com/stretchr/testify/require"
)

func TestMain(m *testing.M) {
	// TODO parse env
	os.Exit(m.Run())
}

type fakeChain struct {
	t       helpers.StatefulTesting
	genesis *core.Genesis
	miner   *helpers.L1Miner
	log     gethlog.Logger
}

var _ SourceChain = (*fakeChain)(nil)

func newFakeChain(t helpers.StatefulTesting, deployParams *e2eutils.DeployParams, log gethlog.Logger, chainID *big.Int) *fakeChain {
	chainGenesis, err := genesis.BuildL1DeveloperGenesis(
		deployParams.DeployConfig.Copy(),
		config.L1Allocs(deployParams.AllocType),
		config.L1Deployments(deployParams.AllocType),
	)
	require.NoError(t, err, "failed to create genesis")

	// override the default with a random chain ID
	chainGenesis.Config.ChainID = chainID

	// NOTE: we're setting up the L2 chains as "L1s" here - doesn't particularly matter, we just want to be able to emulate the behavior of a chain
	miner := helpers.NewL1Miner(t, log, chainGenesis)

	chain := &fakeChain{
		t:       t,
		genesis: chainGenesis,
		miner:   miner,
		log:     log,
	}

	// mine the blocks until the L3 start block number
	for i := 0; i < settlementChainL3StartBlockNumber; i++ {
		chain.MineBlock(1)
	}

	// TODO this is just producing blocks ad-infinitum, but we can expand the logic to be able to stop/resume block production for certain test cases
	go func() {
		for {
			if t.Ctx().Err() != nil {
				return
			}
			// a new block is produced every 200ms with a 1s time increment in timestamp
			chain.MineBlock(1)
			time.Sleep(200 * time.Millisecond)
		}
	}()

	return chain
}

func (c *fakeChain) Client() *ethclient.Client {
	return c.miner.EthClient()
}

func (c *fakeChain) RPCHTTPEndpoint() string {
	return c.miner.HTTPEndpoint()
}

func (c *fakeChain) Signer() types.Signer {
	return types.LatestSigner(c.genesis.Config)
}

func (c *fakeChain) MineBlock(timeDelta uint64) {
	c.miner.ActL1StartBlock(timeDelta)(c.t) // TODO right now we have a 1s block time, but we can make this configurable / variable on command
	// include all pending txs
	runnableTxs, _ := c.miner.Eth.TxPool().Content()
	for _, txs := range runnableTxs {
		for _, tx := range txs {
			c.miner.ActL1IncludeTxByHash(tx.Hash())(c.t)
		}
	}
	b := c.miner.ActL1EndBlock(c.t)
	c.log.Info("new block mined", "number", b.NumberU64(), "timestamp", b.Time(), "hash", b.Hash().Hex())
	c.miner.ActL1SafeNext(c.t)
	c.miner.ActL1FinalizeNext(c.t)
}

/// ------------------------------------------------------------------------------------------------

// SourceChain is a generic interface for a chain that can be used as a source of transactions
// it is meant to be filled with either a fake miner, or a real chain connection
type SourceChain interface {
	Client() *ethclient.Client
	RPCHTTPEndpoint() string
	Signer() types.Signer
}

// NOTE: these files are generated by running "forge build" in the metabased-contracts dir
// read contract artifacts
var (
	MetabasedFactoryArtifact        = MustParseFoundryArtifact("../metabased-contracts/out/MetabasedFactory.sol/MetabasedFactory.json")
	AlwaysAllowModuleArtifact       = MustParseFoundryArtifact("../metabased-contracts/out/AlwaysAllowedModule.sol/AlwaysAllowedModule.json")
	MetabasedSequencerChainArtifact = MustParseFoundryArtifact("../metabased-contracts/out/MetabasedSequencerChain.sol/MetabasedSequencerChain.json")
)

type MetabasedChainTestEnv struct {
	T helpers.StatefulTesting

	SequencingChain SourceChain
	SettlementChain SourceChain
	log             gethlog.Logger
	translator      *translator.OPTranslator

	L3Client *ethclient.Client
	L3Signer types.Signer

	MetabasedFactoryContractAddress    common.Address
	AlwaysAllowedModuleContractAddress common.Address
	L3SequencingContractAddress        common.Address
	BatcherInboxAddress                common.Address

	Secrets   *e2eutils.Secrets
	Addresses *e2eutils.Addresses

	SequencingChainID *big.Int
	SettlementChainID *big.Int
	L3ChainID         *big.Int
}

// TODO if we set this to 0, the translator will return errors because it can't find sequencing blocks to fit the time window
const settlementChainL3StartBlockNumber = 2

func NewMetabasedChainTestEnv(gt *testing.T) *MetabasedChainTestEnv { //nolint:thelper // t is named gt and wrapped into a helpers.StatefulTesting object which is named t
	gt.Helper()
	t := helpers.NewDefaultTesting(gt)
	s := &MetabasedChainTestEnv{
		SettlementChainID: big.NewInt(900), // NOTE: must be 900 this is what the L2 allocs expect
		SequencingChainID: big.NewInt(1000),
		L3ChainID:         big.NewInt(2000),
	}
	s.T = t
	s.log = testlog.Logger(t, gethlog.LvlDebug)

	alwaysAllowModuleJSON, err := os.ReadFile("../metabased-contracts/out/AlwaysAllowedModule.sol/AlwaysAllowedModule.json")
	require.NoError(t, err, "failed to read  alwaysAllowModule json")
	require.NoError(t, json.Unmarshal(alwaysAllowModuleJSON, &AlwaysAllowModuleArtifact), "failed to unmarshal alwaysAllowModule json")

	// TODO swap for real chains here if configured (Note: and real wallets)
	s.Secrets = must(e2eutils.DefaultMnemonicConfig.Secrets())
	s.Addresses = s.Secrets.Addresses()

	testParams := &e2eutils.TestParams{
		MaxSequencerDrift:   40,
		SequencerWindowSize: 120,
		ChannelTimeout:      120,
		L1BlockTime:         2, // 2s block time for the source chains
		UseAltDA:            false,
		AllocType:           config.AllocTypeStandard,
	}
	deployParams := e2eutils.MakeDeployParams(t, testParams)
	s.BatcherInboxAddress = deployParams.DeployConfig.BatchInboxAddress

	sequencingChain := newFakeChain(t, deployParams, s.log.New("role", "sequencing-chain-miner"), s.SequencingChainID)
	settlementChain := newFakeChain(t, deployParams, s.log.New("role", "settlement-chain-miner"), s.SettlementChainID)
	s.SequencingChain = sequencingChain
	s.SettlementChain = settlementChain

	//
	// deploy the metabased chain
	s.deployNewMetabasedChain()

	// TODO deploy rollup contrants on the settlement layer

	// assert non-zero balance for all test actors on the source chains
	s.AssertNonZeroBalance(s.SequencingChain.Client(), s.Addresses.Alice)
	s.AssertNonZeroBalance(s.SequencingChain.Client(), s.Addresses.Bob)
	s.AssertNonZeroBalance(s.SequencingChain.Client(), s.Addresses.Mallory)

	s.AssertNonZeroBalance(s.SettlementChain.Client(), s.Addresses.Alice)
	s.AssertNonZeroBalance(s.SettlementChain.Client(), s.Addresses.Bob)
	s.AssertNonZeroBalance(s.SettlementChain.Client(), s.Addresses.Mallory)

	//
	// init op-translator

	batchProvider := translator.NewMetaBasedBatchProvider(
		rpc.NewRPCClient(s.SettlementChain.Client(), s.SettlementChain.Client().Client(), rpc.NewReceiptFetcher(s.SettlementChain.Client().Client())),
		rpc.NewRPCClient(s.SequencingChain.Client(), s.SequencingChain.Client().Client(), rpc.NewReceiptFetcher(s.SequencingChain.Client().Client())),
		s.L3SequencingContractAddress,
		settlementChainL3StartBlockNumber,
		1, // TODO parameterize this, or remove it if we decide to support variable block time settlement chains
		mocks.NewMockMetrics(),
		s.log.New("role", "batch-provider"),
	)

	s.translator = translator.NewOPTranslator(
		rpc.NewRPCClient(s.SettlementChain.Client(), s.SettlementChain.Client().Client(), rpc.NewReceiptFetcher(s.SettlementChain.Client().Client())),
		batchProvider,
		mocks.NewMockBackfillProvider(),
		must(translator.NewSigner(hex.EncodeToString(crypto.FromECDSA(s.Secrets.Batcher)), s.SettlementChainID)),
		&s.BatcherInboxAddress,
		mocks.NewMockMetrics(),
		s.log.New("role", "translator"),
	)

	// TODO: if we would want to swap the consumer from op-stack for arb, here would be the place to do it
	s.initOpStackL3(deployParams)

	return s
}

func (s *MetabasedChainTestEnv) AssertNonZeroBalance(client *ethclient.Client, addr common.Address) {
	bal, err := client.BalanceAt(s.T.Ctx(), s.Addresses.Alice, nil)
	require.NoError(s.T, err, "failed to get alice balance")
	require.True(s.T, bal.Cmp(e2eutils.Ether(0)) > 0, "alice balance is too low")
}

func (s *MetabasedChainTestEnv) deployNewMetabasedChain() {
	seqClient := s.SequencingChain.Client()

	// TODO skip if factory contract is already provided
	//
	// deploy the metabased factory
	{
		tx := BuildGenericDataTx(
			s.T.Ctx(),
			seqClient,
			s.SequencingChain.Signer(),
			s.Secrets.Alice,
			must(GenerateContractDeploymentCallData(MetabasedFactoryArtifact)),
		)
		receipt := s.sendTxWaitReceipt(seqClient, tx)
		require.Equal(s.T, receipt.Status, types.ReceiptStatusSuccessful)
		s.MetabasedFactoryContractAddress = receipt.ContractAddress
	}

	// TODO skip if a sequencing module address is already provided

	//
	// deploy the always allowed module
	{
		tx := BuildGenericDataTx(
			s.T.Ctx(),
			seqClient,
			s.SequencingChain.Signer(),
			s.Secrets.Alice,
			must(GenerateContractDeploymentCallData(AlwaysAllowModuleArtifact)),
		)
		receipt := s.sendTxWaitReceipt(seqClient, tx)
		require.Equal(s.T, receipt.Status, types.ReceiptStatusSuccessful)
		s.AlwaysAllowedModuleContractAddress = receipt.ContractAddress
	}

	// NOTE: for now, we're assuming all tests will be performed on a freshly minted metabased chain.
	// it should be possible to run tests on a chain that has already been deployed, but the sequencer keys would have to be provided.
	//
	// create the metabased chain
	{
		tx := types.MustSignNewTx(s.Secrets.Alice, s.SequencingChain.Signer(), &types.DynamicFeeTx{
			ChainID:   must(seqClient.ChainID(s.T.Ctx())),
			Nonce:     must(seqClient.PendingNonceAt(s.T.Ctx(), s.Addresses.Alice)),
			GasFeeCap: new(big.Int).Add(must(seqClient.HeaderByNumber(s.T.Ctx(), nil)).BaseFee, big.NewInt(2*params.GWei)),
			Gas:       10_000_000,
			Value:     e2eutils.Ether(0),
			To:        &s.MetabasedFactoryContractAddress,
			Data:      must(MetabasedFactoryArtifact.ABI.Pack("createMetabasedSequencerChain", s.L3ChainID, s.Addresses.Alice, s.AlwaysAllowedModuleContractAddress)),
		})
		receipt := s.sendTxWaitReceipt(seqClient, tx)
		require.Equal(s.T, receipt.Status, types.ReceiptStatusSuccessful)

		event := MetabasedFactoryArtifact.ABI.Events["MetabasedSequencerChainCreated"]
		argIndex := -1
		for i := 0; i < len(event.Inputs); i++ {
			if event.Inputs[i].Name == "metabasedSequencerChainAddress" {
				argIndex = i
				break
			}
		}
		require.NotEqual(s.T, argIndex, -1, "metabasedSequencerChainAddress argument not found")

		for _, log := range receipt.Logs {
			if log.Topics[0] == event.ID {
				s.L3SequencingContractAddress = common.BytesToAddress(log.Topics[argIndex+1].Bytes())
				break
			}
		}
		require.NotEqual(s.T, s.L3SequencingContractAddress, (common.Address{}), "MetabasedSequencerChainCreated event not found")

		// sanity check
		code, err := seqClient.CodeAt(s.T.Ctx(), s.L3SequencingContractAddress, nil)
		require.NoError(s.T, err, "failed to get code")
		require.NotEqual(s.T, len(code), 0, "sequencing contract not deployed")
	}
}

func (s *MetabasedChainTestEnv) sendTxWaitReceipt(client *ethclient.Client, tx *types.Transaction) *types.Receipt {
	err := client.SendTransaction(context.Background(), tx)
	require.NoError(s.T, err, "failed to send tx")
	receipt, err := geth.WaitForTransaction(tx.Hash(), client, 5*time.Second) // TODO make this timeout configurable
	require.NoError(s.T, err, "failed to get receipt")
	return receipt
}

func (s *MetabasedChainTestEnv) initOpStackL3(deployParams *e2eutils.DeployParams) {
	// use the op deriver to obtain L3 state from the translator output

	//
	// generate the L3 genesis and rollup config
	settlementLayerBlock := must(s.SequencingChain.Client().BlockByNumber(s.T.Ctx(), nil))

	deployConf := deployParams.DeployConfig.Copy()
	// deployConf.L1ChainID = s.SettlementChainID.Uint64()
	// deployConf.L2ChainID = s.L3ChainID.Uint64()
	deployConf.L2BlockTime = 2

	allocsMode := e2eutils.GetL2AllocsMode(deployConf, settlementLayerBlock.Time())
	l3Allocs := config.L2Allocs(deployParams.AllocType, allocsMode)
	l3Genesis, err := genesis.BuildL2Genesis(deployConf, l3Allocs, settlementLayerBlock.Header())
	require.NoError(s.T, err)
	l3Genesis.Config.ChainID = s.L3ChainID // override the chainID

	var pcfg *rollup.AltDAConfig
	if deployConf.UseAltDA {
		pcfg = &rollup.AltDAConfig{
			DAChallengeAddress: config.L1Deployments(deployParams.AllocType).DataAvailabilityChallengeProxy,
			DAChallengeWindow:  deployConf.DAChallengeWindow,
			DAResolveWindow:    deployConf.DAResolveWindow,
			CommitmentType:     altda.KeccakCommitmentString,
		}
	}

	settlementStartBlock := must(s.SettlementChain.Client().BlockByNumber(s.T.Ctx(), big.NewInt(settlementChainL3StartBlockNumber)))
	deployConf.L1GenesisBlockTimestamp = hexutil.Uint64(settlementStartBlock.Time())

	rollupConfig := &rollup.Config{
		Genesis: rollup.Genesis{
			L1: eth.BlockID{
				Hash:   settlementStartBlock.Hash(),
				Number: settlementChainL3StartBlockNumber,
			},
			L2: eth.BlockID{
				Hash:   l3Genesis.ToBlock().Hash(),
				Number: 0,
			},
			L2Time:       uint64(deployConf.L1GenesisBlockTimestamp),
			SystemConfig: e2eutils.SystemConfigFromDeployConfig(deployConf),
		},
		BlockTime:              deployConf.L2BlockTime,
		MaxSequencerDrift:      deployConf.MaxSequencerDrift,
		SeqWindowSize:          deployConf.SequencerWindowSize,
		ChannelTimeoutBedrock:  deployConf.ChannelTimeoutBedrock,
		L1ChainID:              new(big.Int).SetUint64(deployConf.L1ChainID),
		L2ChainID:              new(big.Int).SetUint64(deployConf.L2ChainID),
		BatchInboxAddress:      deployConf.BatchInboxAddress,
		DepositContractAddress: deployConf.OptimismPortalProxy,
		L1SystemConfigAddress:  deployConf.SystemConfigProxy,
		RegolithTime:           deployConf.RegolithTime(uint64(deployConf.L1GenesisBlockTimestamp)),
		CanyonTime:             deployConf.CanyonTime(uint64(deployConf.L1GenesisBlockTimestamp)),
		DeltaTime:              deployConf.DeltaTime(uint64(deployConf.L1GenesisBlockTimestamp)),
		// disable ecotone upgrade (we do this so we don't need a beacon chain/client)
		EcotoneTime:  nil, // deployConf.EcotoneTime(uint64(deployConf.L1GenesisBlockTimestamp)),
		FjordTime:    nil, // deployConf.FjordTime(uint64(deployConf.L1GenesisBlockTimestamp)),
		GraniteTime:  nil, // deployConf.GraniteTime(uint64(deployConf.L1GenesisBlockTimestamp)),
		HoloceneTime: nil, // deployConf.HoloceneTime(uint64(deployConf.L1GenesisBlockTimestamp)),
		InteropTime:  nil, // deployConf.InteropTime(uint64(deployConf.L1GenesisBlockTimestamp)),
		AltDAConfig:  pcfg,
	}
	require.NoError(s.T, rollupConfig.Check())

	//
	// init L3 components
	l1FConfig := sources.L1ClientDefaultConfig(rollupConfig, false, sources.RPCKindStandard)
	l1FConfig.TrustRPC = true // must set `trustRPC` to true, otherwise the engine will fail when verifying op-translator blocks // TODO delete if we can fix this behavior
	l1F, err := sources.NewL1Client(
		newRPCInterceptor(s.SettlementChain.Client(), s.translator),
		s.log.New("component", "l3-settlement-chain-fetcher"),
		nil,
		l1FConfig,
	)
	require.NoError(s.T, err)
	jwtPath := e2eutils.WriteDefaultJWT(s.T)
	engine := helpers.NewL2Engine(s.T, s.log.New("component", "l3-engine"), l3Genesis, jwtPath, helpers.EngineWithP2P())
	engineClientConfig := sources.EngineClientDefaultConfig(rollupConfig)
	engineClientConfig.TrustRPC = true // must set `trustRPC` to true, otherwise the engine will fail when verifying op-translator blocks // TODO delete if we can fix this behavior
	engineClient, err := sources.NewEngineClient(
		engine.RPCClient(),
		s.log.New("component", "l3-engine-client"),
		nil,
		engineClientConfig,
	)
	require.NoError(s.T, err)

	// cfg := &helpers.SequencerCfg{VerifierCfg: *helpers.DefaultVerifierCfg()}

	sequencer := helpers.NewL2Sequencer(
		s.T,
		s.log.New("role", "l3-sequencer"),
		l1F,
		nil,            // TODO is this okay? maybe a noopFetcher will be required here //miner.BlobStore(),
		altda.Disabled, // TODO if we want to integrate altDA in these tests, we'll need to provide a valid altDAFetcher
		engineClient,
		rollupConfig,
		0,
		nil, // TODO is this okay? // cfg.InteropBackend,
	)
	sequencer.ActL2PipelineFull(s.T) // TODO not sure if needed

	go func() {
		// for {
		if s.T.Ctx().Err() != nil {
			return
		}
		// TODO not sure if needed
		// Build an empty block on L2
		// sequencer.ActL2StartBlock(s.T)
		// sequencer.ActL2EndBlock(s.T)

		// Instruct the sequencer to derive the L2 chain from the data on L1
		// sequencer.ActL1HeadSignal(s.T) //TODO not sure if needed
		sequencer.ActL2PipelineFull(s.T)
		sequencer.ActL1FinalizedSignal(s.T)
		time.Sleep(100 * time.Millisecond)
		// }
	}()

	// batcher := helpers.NewL2Batcher(s.log.New("component", "l3-batcher"), rollupConfig, helpers.DefaultBatcherCfg(deployParams),
	// 	l3.RollupClient(), s.SequencingChain.Client(), engine.EthClient(), engineClient)

	s.L3Client = engine.EthClient()
	s.L3Signer = types.LatestSigner(l3Genesis.Config)
}

// ------------------------------------------------------------------------------------------------
// public methods

func (s *MetabasedChainTestEnv) SequenceL3TransactionRaw(sender *ecdsa.PrivateKey, data []byte) {
	seqClient := s.SequencingChain.Client()
	txData, err := MetabasedSequencerChainArtifact.ABI.Pack("processTransactionRaw", data)
	require.NoError(s.T, err, "failed to pack tx data")
	tx := BuildGenericDataTx(s.T.Ctx(), seqClient, s.SequencingChain.Signer(), sender, txData, s.L3SequencingContractAddress)
	receipt := s.sendTxWaitReceipt(seqClient, tx)
	require.Equal(s.T, receipt.Status, types.ReceiptStatusSuccessful)
}

// ------------------------------------------------------------------------------------------------
// rpc interceptor

type rpcInterceptor struct {
	settlementChainRPC *geth_rpc.Client
	opTranslator       *translator.OPTranslator
}

// Note: this RPC is used in op e2e tests to wrap an RPC client and be able to fake errors (to test the handling of said errors). (example: https://github.com/ethereum-optimism/optimism/blob/develop/op-service/testutils/rpc_err_faker.go )
// In our case we're not interested in faking errors, but we do need to implement this interface to be able to use the RPC client in the tests.
// this interceptor client has the same high level functionality as the `internal/server` package of op-translator
var _ op_service_client.RPC = (*rpcInterceptor)(nil)

func newRPCInterceptor(settlementChainRPC *ethclient.Client, opTranslator *translator.OPTranslator) *rpcInterceptor {
	return &rpcInterceptor{
		settlementChainRPC: settlementChainRPC.Client(),
		opTranslator:       opTranslator,
	}
}

func (r *rpcInterceptor) interceptMethod(ctx context.Context, method string, args ...any) (any, error) {
	switch method {
	case "eth_getBlockByHash":
		return r.opTranslator.GetBlockByHash(ctx, args[0].(common.Hash), args[1].(bool)) //nolint:errcheck // safe to ignore
	case "eth_getBlockByNumber":
		return r.opTranslator.GetBlockByNumber(ctx, args[0].(string), args[1].(bool)) //nolint:errcheck // safe to ignore
	case "eth_getBlockReceipts":
		return r.opTranslator.GetBlockReceipts(ctx, args[0].(common.Hash)) //nolint:errcheck // safe to ignore
	}
	return nil, nil
}

func (r *rpcInterceptor) CallContext(ctx context.Context, result any, method string, args ...any) error {
	interceptResult, err := r.interceptMethod(ctx, method, args...)
	if err != nil {
		return err
	}
	if result != nil {
		jsonBytes, err := json.Marshal(interceptResult)
		if err != nil {
			panic("failed to marshal result")
		}
		return json.Unmarshal(jsonBytes, result)
	}
	return r.settlementChainRPC.CallContext(ctx, result, method, args...)
}

func (r *rpcInterceptor) BatchCallContext(ctx context.Context, b []geth_rpc.BatchElem) error {
	panic("this is not expected to be called")
}

func (r *rpcInterceptor) EthSubscribe(ctx context.Context, channel any, args ...any) (ethereum.Subscription, error) {
	panic("this is not expected to be called")
}

func (r *rpcInterceptor) Close() {
	r.settlementChainRPC.Close()
}

// ------------------------------------------------------------------------------------------------
// utils

func must[T any](v T, err error) T {
	if err != nil {
		panic(err)
	}
	return v
}

func GenerateContractDeploymentCallData(contractArtifact *foundry.Artifact, args ...any) ([]byte, error) {
	constructorArgs, err := contractArtifact.ABI.Pack("", args...)
	if err != nil {
		return nil, err
	}
	data := []byte{}
	data = append(data, contractArtifact.Bytecode.Object...)
	data = append(data, constructorArgs...)
	return data, nil
}

func MustParseFoundryArtifact(path string) *foundry.Artifact {
	jsonContent, err := os.ReadFile(path)
	if err != nil {
		panic(fmt.Errorf("failed to read metabased factory json: %w", err))
	}
	var artifact foundry.Artifact
	err = json.Unmarshal(jsonContent, &artifact)
	if err != nil {
		panic(fmt.Errorf("failed to unmarshal metabased factory json: %w", err))
	}
	return &artifact
}

func BuildGenericDataTx(ctx context.Context, client *ethclient.Client, signer types.Signer, sender *ecdsa.PrivateKey, data []byte, to ...common.Address) *types.Transaction {
	var txTo *common.Address
	if len(to) > 0 {
		txTo = &to[0]
	}
	return types.MustSignNewTx(sender, signer, &types.DynamicFeeTx{
		ChainID:   must(client.ChainID(ctx)),
		Nonce:     must(client.PendingNonceAt(ctx, crypto.PubkeyToAddress(sender.PublicKey))),
		GasFeeCap: must(client.HeaderByNumber(ctx, nil)).BaseFee,
		Gas:       10_000_000,
		Value:     e2eutils.Ether(0),
		Data:      data,
		To:        txTo,
	})
}

type traceConfig struct {
	*tracelogger.Config
	Tracer  string  `json:"tracer"`
	Timeout *string `json:"timeout"`
	// Config specific to given tracer. Note struct logger
	// config are historically embedded in main object.
	TracerConfig json.RawMessage
}

// TraceTransaction is just an useful debugging tool
func TraceTransaction(client *ethclient.Client, txHash common.Hash) {
	var result json.RawMessage
	err := client.Client().CallContext(context.Background(), &result, "debug_traceTransaction", txHash, traceConfig{
		Config: &tracelogger.Config{
			EnableMemory:     true,
			DisableStack:     true,
			DisableStorage:   true,
			EnableReturnData: false,
			Debug:            true,
			Limit:            0,
			Overrides:        nil,
		},
		Tracer:       "callTracer",
		Timeout:      nil,
		TracerConfig: nil,
	})
	if err != nil {
		panic(err)
	}
	println(string(result))
}
